{"repo": "PySnooper", "commit": "f1194be092cb224a4b1d43e12b9323230dc0cbe3", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex b9d2300..56165d3 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -293,6 +293,7 @@ class Tracer:\n     def __enter__(self):\n         if DISABLED:\n             return\n+        thread_global.__dict__.setdefault('depth', -1)\n         calling_frame = inspect.currentframe().f_back\n         if not self._is_internal_frame(calling_frame):\n             calling_frame.f_trace = self.trace\n@@ -362,7 +363,6 @@ class Tracer:\n                 else:\n                     return None\n \n-        thread_global.__dict__.setdefault('depth', -1)\n         if event == 'call':\n             thread_global.depth += 1\n         indent = ' ' * 4 * thread_global.depth\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex fdf650c..882b5ea 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -1894,5 +1894,10 @@ def test_exception():\n     )\n \n \n+def test_exception_on_entry():\n+    @pysnooper.snoop()\n+    def f(x):\n+        pass\n \n-\n+    with pytest.raises(TypeError):\n+        f()\n"}
{"repo": "PySnooper", "commit": "473bb37a769fbbab0672585f2afe5d948a2beeb8", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 4b4ac05..b9d2300 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -492,7 +492,7 @@ class Tracer:\n             exception = '\\n'.join(traceback.format_exception_only(*arg[:2])).strip()\n             if self.max_variable_length:\n                 exception = utils.truncate(exception, self.max_variable_length)\n-            self.write('{indent}{exception}'.\n+            self.write('{indent}Exception:..... {exception}'.\n                        format(**locals()))\n \n         return self.trace\ndiff --git a/tests/test_chinese.py b/tests/test_chinese.py\nindex 90e52aa..9964957 100644\n--- a/tests/test_chinese.py\n+++ b/tests/test_chinese.py\n@@ -16,7 +16,8 @@ from pysnooper import pycompat\n from pysnooper.variables import needs_parentheses\n from .utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ReturnValueEntry, ExceptionEntry, ExceptionValueEntry,\n+                    SourcePathEntry, CallEndedByExceptionEntry,\n                     ElapsedTimeEntry)\n from . import mini_toolbox\n \ndiff --git a/tests/test_multiple_files/test_multiple_files.py b/tests/test_multiple_files/test_multiple_files.py\nindex e217ce4..9f78d1b 100644\n--- a/tests/test_multiple_files/test_multiple_files.py\n+++ b/tests/test_multiple_files/test_multiple_files.py\n@@ -15,7 +15,8 @@ import pysnooper\n from pysnooper.variables import needs_parentheses\n from ..utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ReturnValueEntry, ExceptionEntry, ExceptionValueEntry,\n+                    SourcePathEntry, CallEndedByExceptionEntry,\n                     ElapsedTimeEntry)\n from .. import mini_toolbox\n from .multiple_files import foo\ndiff --git a/tests/test_not_implemented.py b/tests/test_not_implemented.py\nindex 65b2645..e392dbf 100644\n--- a/tests/test_not_implemented.py\n+++ b/tests/test_not_implemented.py\n@@ -17,7 +17,9 @@ from pysnooper.variables import needs_parentheses\n from pysnooper import pycompat\n from .utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry)\n+                    ReturnValueEntry, ExceptionEntry, ExceptionValueEntry,\n+                    SourcePathEntry, CallEndedByExceptionEntry,\n+                    ElapsedTimeEntry)\n from . import mini_toolbox\n \n \ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 2623f35..fdf650c 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -16,7 +16,8 @@ import pysnooper\n from pysnooper.variables import needs_parentheses\n from .utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ReturnValueEntry, ExceptionEntry, ExceptionValueEntry,\n+                    SourcePathEntry, CallEndedByExceptionEntry,\n                     ElapsedTimeEntry)\n from . import mini_toolbox\n \n@@ -1864,3 +1865,34 @@ def test_normalize_thread_info():\n \n     with pytest.raises(NotImplementedError):\n         add()\n+\n+\n+def test_exception():\n+    string_io = io.StringIO()\n+    @pysnooper.snoop(string_io)\n+    def f():\n+        x = 8\n+        raise MemoryError\n+\n+    with pytest.raises(MemoryError):\n+        f()\n+\n+    output = string_io.getvalue()\n+    assert_output(\n+        output,\n+        (\n+            SourcePathEntry(),\n+            CallEntry(),\n+            LineEntry(),\n+            VariableEntry(),\n+            LineEntry(),\n+            ExceptionEntry(),\n+            ExceptionValueEntry('MemoryError'),\n+            CallEndedByExceptionEntry(),\n+            ElapsedTimeEntry(),\n+        )\n+    )\n+\n+\n+\n+\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 10fd249..6260cdc 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -101,6 +101,19 @@ class ElapsedTimeEntry(_BaseEntry):\n \n \n \n+class CallEndedByExceptionEntry(_BaseEntry):\n+    # Todo: Looking at this class, we could rework the hierarchy.\n+    def __init__(self, prefix=''):\n+        _BaseEntry.__init__(self, prefix=prefix)\n+\n+    def check(self, s):\n+        return re.match(\n+            r'''(?P<indent>(?: {4})*)Call ended by exception''',\n+            s\n+        )\n+\n+\n+\n class VariableEntry(_BaseValueEntry):\n     def __init__(self, name=None, value=None, stage=None, prefix='',\n                  name_regex=None, value_regex=None):\n@@ -165,7 +178,7 @@ class VariableEntry(_BaseValueEntry):\n             return stage == self.stage\n \n \n-class ReturnValueEntry(_BaseValueEntry):\n+class _BaseSimpleValueEntry(_BaseValueEntry):\n     def __init__(self, value=None, value_regex=None, prefix=''):\n         _BaseValueEntry.__init__(self, prefix=prefix)\n         if value is not None:\n@@ -175,10 +188,6 @@ class ReturnValueEntry(_BaseValueEntry):\n         self.value_regex = (None if value_regex is None else\n                             re.compile(value_regex))\n \n-    _preamble_pattern = re.compile(\n-        r\"\"\"^Return value$\"\"\"\n-    )\n-\n     def _check_preamble(self, preamble):\n         return bool(self._preamble_pattern.match(preamble))\n \n@@ -193,6 +202,16 @@ class ReturnValueEntry(_BaseValueEntry):\n         else:\n             return True\n \n+class ReturnValueEntry(_BaseSimpleValueEntry):\n+    _preamble_pattern = re.compile(\n+        r\"\"\"^Return value$\"\"\"\n+    )\n+\n+class ExceptionValueEntry(_BaseSimpleValueEntry):\n+    _preamble_pattern = re.compile(\n+        r\"\"\"^Exception$\"\"\"\n+    )\n+\n class SourcePathEntry(_BaseValueEntry):\n     def __init__(self, source_path=None, source_path_regex=None, prefix=''):\n         _BaseValueEntry.__init__(self, prefix=prefix)\n@@ -315,6 +334,8 @@ def verify_normalize(lines, prefix):\n \n def assert_output(output, expected_entries, prefix=None, normalize=False):\n     lines = tuple(filter(None, output.split('\\n')))\n+    if expected_entries and not lines:\n+        raise OutputFailure(\"Output is empty\")\n \n     if prefix is not None:\n         for line in lines:\n"}
{"repo": "PySnooper", "commit": "a602866ce10d0f45f56d20fc70107faff75965e2", "diff": "diff --git a/tests/mini_toolbox/__init__.py b/tests/mini_toolbox/__init__.py\nindex 97d6f57..3184e37 100644\n--- a/tests/mini_toolbox/__init__.py\n+++ b/tests/mini_toolbox/__init__.py\n@@ -213,7 +213,6 @@ class OutputCapturer(object):\n         # Not doing exception swallowing anywhere here.\n         self._stderr_temp_setter.__exit__(exc_type, exc_value, exc_traceback)\n         self._stdout_temp_setter.__exit__(exc_type, exc_value, exc_traceback)\n-        return self\n \n     output = property(lambda self: self.string_io.getvalue(),\n                       doc='''The string of output that was captured.''')\ndiff --git a/tests/test_mini_toolbox.py b/tests/test_mini_toolbox.py\nnew file mode 100644\nindex 0000000..7074e07\n--- /dev/null\n+++ b/tests/test_mini_toolbox.py\n@@ -0,0 +1,12 @@\n+# Copyright 2019 Ram Rachum and collaborators.\n+# This program is distributed under the MIT license.\n+\n+import pytest\n+\n+from . import mini_toolbox\n+\n+\n+def test_output_capturer_doesnt_swallow_exceptions():\n+    with pytest.raises(ZeroDivisionError):\n+        with mini_toolbox.OutputCapturer():\n+            1 / 0\n"}
{"repo": "PySnooper", "commit": "48cc9d94cdb102064fb6b3248c1d2b8f288cb96f", "diff": "diff --git a/pysnooper/pycompat.py b/pysnooper/pycompat.py\nindex c6b23b3..fedb3a5 100644\n--- a/pysnooper/pycompat.py\n+++ b/pysnooper/pycompat.py\n@@ -90,6 +90,6 @@ else:\n         return datetime_module.time(hour, minute, second, microsecond)\n \n \n-def timedelta_isoformat(timedelta):\n+def timedelta_isoformat(timedelta, timespec='microseconds'):\n     time = (datetime_module.datetime.min + timedelta).time()\n-    return time_isoformat(time)\n+    return time_isoformat(time, timespec)\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex e6a4a65..7a56d3b 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -374,7 +374,7 @@ class Tracer:\n                 start_time = self.start_times[frame]\n             duration = datetime_module.datetime.now() - start_time\n             now_string = pycompat.timedelta_isoformat(\n-                duration) if not self.normalize else ' ' * 15\n+                duration, timespec='microseconds') if not self.normalize else ' ' * 15\n         else:\n             now = datetime_module.datetime.now().time()\n             now_string = pycompat.time_isoformat(now, timespec='microseconds') if not self.normalize else ' ' * 15\n"}
{"repo": "PySnooper", "commit": "0cb6df1f7b5bab9ca98b6afd5442dd9306328282", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 1c9103b..e6a4a65 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -217,7 +217,7 @@ class Tracer:\n              for v in utils.ensure_tuple(watch_explode)\n         ]\n         self.frame_to_local_reprs = {}\n-        self.start_times = []\n+        self.start_times = {}\n         self.depth = depth\n         self.prefix = prefix\n         self.thread_info = thread_info\n@@ -303,7 +303,7 @@ class Tracer:\n             'original_trace_functions', []\n         )\n         stack.append(sys.gettrace())\n-        self.start_times.append(datetime_module.datetime.now())\n+        self.start_times[calling_frame] = datetime_module.datetime.now()\n         sys.settrace(self.trace)\n \n     def __exit__(self, exc_type, exc_value, exc_traceback):\n@@ -315,12 +315,14 @@ class Tracer:\n         self.target_frames.discard(calling_frame)\n         self.frame_to_local_reprs.pop(calling_frame, None)\n \n-        start_time = self.start_times.pop(-1)\n-        duration = datetime_module.datetime.now() - start_time\n-        now_string = pycompat.timedelta_isoformat(duration)\n-        indent = ' ' * 4 * (thread_global.depth + 1)\n-        self.write('{indent}Total elapsed time: {now_string}'.format(\n-            **locals()))\n+        start_time = self.start_times.pop(calling_frame, None)\n+        # TODO(Fix case of start_time is None)\n+        if start_time:\n+            duration = datetime_module.datetime.now() - start_time\n+            now_string = pycompat.timedelta_isoformat(duration)\n+            indent = ' ' * 4 * (thread_global.depth + 1)\n+            self.write('{indent}Total elapsed time: {now_string}'.format(\n+                **locals()))\n \n     def _is_internal_frame(self, frame):\n         return frame.f_code.co_filename == Tracer.__enter__.__code__.co_filename\n@@ -366,7 +368,11 @@ class Tracer:\n         ### Finished checking whether we should trace this line. ##############\n \n         if self.elapsed_time:\n-            duration = datetime_module.datetime.now() - self.start_times[-1]\n+            if frame not in self.start_times:\n+                self.start_times[frame] = start_time = datetime_module.datetime.now()\n+            else:\n+                start_time = self.start_times[frame]\n+            duration = datetime_module.datetime.now() - start_time\n             now_string = pycompat.timedelta_isoformat(\n                 duration) if not self.normalize else ' ' * 15\n         else:\n@@ -458,6 +464,8 @@ class Tracer:\n \n         if event == 'return':\n             del self.frame_to_local_reprs[frame]\n+            if self.elapsed_time:\n+                del self.start_times[frame]\n             thread_global.depth -= 1\n \n             if not ended_by_exception:\n"}
{"repo": "PySnooper", "commit": "0c018d868e60949592b360519e6ca2be2d34883d", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex cf957b7..887277e 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -217,7 +217,7 @@ class Tracer:\n              for v in utils.ensure_tuple(watch_explode)\n         ]\n         self.frame_to_local_reprs = {}\n-        self.start_times = {}\n+        self.start_times = []\n         self.depth = depth\n         self.prefix = prefix\n         self.thread_info = thread_info\n@@ -303,7 +303,7 @@ class Tracer:\n             'original_trace_functions', []\n         )\n         stack.append(sys.gettrace())\n-        self.start_times[id(calling_frame)] = datetime_module.datetime.now()\n+        self.start_times.append(datetime_module.datetime.now())\n         sys.settrace(self.trace)\n \n     def __exit__(self, exc_type, exc_value, exc_traceback):\n@@ -315,7 +315,7 @@ class Tracer:\n         self.target_frames.discard(calling_frame)\n         self.frame_to_local_reprs.pop(calling_frame, None)\n \n-        start_time = self.start_times.pop(id(calling_frame))\n+        start_time = self.start_times.pop(-1)\n         duration = datetime_module.datetime.now() - start_time\n         now_string = pycompat.timedelta_isoformat(duration, timespec='microseconds')\n         indent = ' ' * 4 * (thread_global.depth + 1)\n@@ -332,7 +332,6 @@ class Tracer:\n         return thread_info.ljust(self.thread_info_padding)\n \n     def trace(self, frame, event, arg):\n-\n         ### Checking whether we should trace this line: #######################\n         #                                                                     #\n         # We should trace this line either if it's in the decorated function,\n@@ -367,9 +366,7 @@ class Tracer:\n         ### Finished checking whether we should trace this line. ##############\n \n         if self.elapsed_time:\n-            calling_frame = frame.f_back\n-            duration = datetime_module.datetime.now() - self.start_times[\n-                id(calling_frame)]\n+            duration = datetime_module.datetime.now() - self.start_times[-1]\n             now_string = pycompat.timedelta_isoformat(\n                 duration, timespec='microseconds') if not self.normalize else ' ' * 15\n         else:\n"}
{"repo": "PySnooper", "commit": "2ac382f8563452ce982665a39c8abd99106cc9ac", "diff": "diff --git a/tests/samples/indentation.py b/tests/samples/indentation.py\nindex 65cb7b4..60f073b 100644\n--- a/tests/samples/indentation.py\n+++ b/tests/samples/indentation.py\n@@ -38,6 +38,7 @@ Source path:... Whatever\n             Return value:.. None\n         21:10:42.299509 return      19     f5()\n         Return value:.. None\n+        Total elapsed time: 00:00:00.000134\n     21:10:42.299577 return      10     f3()\n     Return value:.. None\n 21:10:42.299627 return       6     f2()\ndiff --git a/tests/samples/recursion.py b/tests/samples/recursion.py\nindex 7edbaac..f1529ed 100644\n--- a/tests/samples/recursion.py\n+++ b/tests/samples/recursion.py\n@@ -18,46 +18,49 @@ def main():\n expected_output = '''\n Source path:... Whatever\n Starting var:.. x = 4\n-20:28:17.875295 call         5 def factorial(x):\n-20:28:17.875509 line         6     if x <= 1:\n-20:28:17.875550 line         8     return mul(x, factorial(x - 1))\n+09:31:32.691599 call         5 def factorial(x):\n+09:31:32.691722 line         6     if x <= 1:\n+09:31:32.691746 line         8     return mul(x, factorial(x - 1))\n     Starting var:.. x = 3\n-    20:28:17.875624 call         5 def factorial(x):\n-    20:28:17.875668 line         6     if x <= 1:\n-    20:28:17.875703 line         8     return mul(x, factorial(x - 1))\n+    09:31:32.691781 call         5 def factorial(x):\n+    09:31:32.691806 line         6     if x <= 1:\n+    09:31:32.691823 line         8     return mul(x, factorial(x - 1))\n         Starting var:.. x = 2\n-        20:28:17.875771 call         5 def factorial(x):\n-        20:28:17.875813 line         6     if x <= 1:\n-        20:28:17.875849 line         8     return mul(x, factorial(x - 1))\n+        09:31:32.691852 call         5 def factorial(x):\n+        09:31:32.691875 line         6     if x <= 1:\n+        09:31:32.691892 line         8     return mul(x, factorial(x - 1))\n             Starting var:.. x = 1\n-            20:28:17.875913 call         5 def factorial(x):\n-            20:28:17.875953 line         6     if x <= 1:\n-            20:28:17.875987 line         7         return 1\n-            20:28:17.876021 return       7         return 1\n+            09:31:32.691918 call         5 def factorial(x):\n+            09:31:32.691941 line         6     if x <= 1:\n+            09:31:32.691961 line         7         return 1\n+            09:31:32.691978 return       7         return 1\n             Return value:.. 1\n+            Total elapsed time: 00:00:00.000092\n             Starting var:.. a = 2\n             Starting var:.. b = 1\n-            20:28:17.876111 call        11 def mul(a, b):\n-            20:28:17.876151 line        12     return a * b\n-            20:28:17.876190 return      12     return a * b\n+            09:31:32.692025 call        11 def mul(a, b):\n+            09:31:32.692055 line        12     return a * b\n+            09:31:32.692075 return      12     return a * b\n             Return value:.. 2\n-        20:28:17.876235 return       8     return mul(x, factorial(x - 1))\n+        09:31:32.692102 return       8     return mul(x, factorial(x - 1))\n         Return value:.. 2\n+        Total elapsed time: 00:00:00.000283\n         Starting var:.. a = 3\n         Starting var:.. b = 2\n-        20:28:17.876320 call        11 def mul(a, b):\n-        20:28:17.876359 line        12     return a * b\n-        20:28:17.876397 return      12     return a * b\n+        09:31:32.692147 call        11 def mul(a, b):\n+        09:31:32.692174 line        12     return a * b\n+        09:31:32.692193 return      12     return a * b\n         Return value:.. 6\n-    20:28:17.876442 return       8     return mul(x, factorial(x - 1))\n+    09:31:32.692216 return       8     return mul(x, factorial(x - 1))\n     Return value:.. 6\n+    Total elapsed time: 00:00:00.000468\n     Starting var:.. a = 4\n     Starting var:.. b = 6\n-    20:28:17.876525 call        11 def mul(a, b):\n-    20:28:17.876563 line        12     return a * b\n-    20:28:17.876601 return      12     return a * b\n+    09:31:32.692259 call        11 def mul(a, b):\n+    09:31:32.692285 line        12     return a * b\n+    09:31:32.692304 return      12     return a * b\n     Return value:.. 24\n-20:28:17.876646 return       8     return mul(x, factorial(x - 1))\n+09:31:32.692326 return       8     return mul(x, factorial(x - 1))\n Return value:.. 24\n-Total elapsed time: 00:00:00.000651\n+Total elapsed time: 00:00:00.000760\n '''\ndiff --git a/tests/test_multiple_files/test_multiple_files.py b/tests/test_multiple_files/test_multiple_files.py\nindex 5bd233a..e217ce4 100644\n--- a/tests/test_multiple_files/test_multiple_files.py\n+++ b/tests/test_multiple_files/test_multiple_files.py\n@@ -15,7 +15,8 @@ import pysnooper\n from pysnooper.variables import needs_parentheses\n from ..utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry)\n+                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ElapsedTimeEntry)\n from .. import mini_toolbox\n from .multiple_files import foo\n \n@@ -45,6 +46,7 @@ def test_multiple_files():\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry(),\n+            ElapsedTimeEntry(),\n         )\n     )\n \ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 2140ca5..d4dd5f4 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -1544,6 +1544,7 @@ def test_class_with_decorated_method_and_snoop_applied_to_method(normalize):\n             LineEntry('return y + self.x'),\n             ReturnEntry('return y + self.x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n             VariableEntry('result', '15'),\n             LineEntry('return result'),\n             ReturnEntry('return result'),\n"}
{"repo": "PySnooper", "commit": "57cec2b9af96b9234bdfdf9fe0f07a1df6bb525d", "diff": "diff --git a/tests/samples/exception.py b/tests/samples/exception.py\nindex aa663de..87642c8 100644\n--- a/tests/samples/exception.py\n+++ b/tests/samples/exception.py\n@@ -46,4 +46,5 @@ TypeError: bad\n 12:18:08.018787 line        21         pass\n 12:18:08.018813 return      21         pass\n Return value:.. None\n+Total elapsed time: 00:00:00.000885\n '''\ndiff --git a/tests/samples/indentation.py b/tests/samples/indentation.py\nindex 9ea0318..65cb7b4 100644\n--- a/tests/samples/indentation.py\n+++ b/tests/samples/indentation.py\n@@ -42,4 +42,5 @@ Source path:... Whatever\n     Return value:.. None\n 21:10:42.299627 return       6     f2()\n Return value:.. None\n+Total elapsed time: 00:00:00.000885\n '''\ndiff --git a/tests/samples/recursion.py b/tests/samples/recursion.py\nindex 1570d1a..7edbaac 100644\n--- a/tests/samples/recursion.py\n+++ b/tests/samples/recursion.py\n@@ -59,4 +59,5 @@ Starting var:.. x = 4\n     Return value:.. 24\n 20:28:17.876646 return       8     return mul(x, factorial(x - 1))\n Return value:.. 24\n+Total elapsed time: 00:00:00.000651\n '''\ndiff --git a/tests/test_chinese.py b/tests/test_chinese.py\nindex 828ad1c..90e52aa 100644\n--- a/tests/test_chinese.py\n+++ b/tests/test_chinese.py\n@@ -16,7 +16,8 @@ from pysnooper import pycompat\n from pysnooper.variables import needs_parentheses\n from .utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry)\n+                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ElapsedTimeEntry)\n from . import mini_toolbox\n \n \n@@ -44,6 +45,7 @@ def test_chinese():\n                 VariableEntry(u'x', (u\"'\u00e5\u00a4\u00b1\u00e8\u00b4\u00a5'\" if pycompat.PY3 else None)),\n                 LineEntry(),\n                 ReturnEntry(),\n-                ReturnValueEntry('7')\n+                ReturnValueEntry('7'),\n+                ElapsedTimeEntry(),\n             ),\n         )\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 44852f4..b321d95 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -15,7 +15,8 @@ import pysnooper\n from pysnooper.variables import needs_parentheses\n from .utils import (assert_output, assert_sample_output, VariableEntry,\n                     CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n-                    ReturnValueEntry, ExceptionEntry, SourcePathEntry)\n+                    ReturnValueEntry, ExceptionEntry, SourcePathEntry,\n+                    ElapsedTimeEntry)\n from . import mini_toolbox\n \n \n@@ -44,6 +45,7 @@ def test_string_io():\n             LineEntry('return y + x'),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         )\n     )\n \n@@ -74,6 +76,7 @@ def test_thread_info():\n             LineEntry('return y + x'),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         )\n     )\n \n@@ -125,6 +128,7 @@ def test_multi_thread_info():\n                           name=\"MainThread\")),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n             VariableEntry('foo', value_regex=\"u?'bubu'\"),\n             CallEntry('def my_function(foo):',\n                       thread_info_regex=thread_info_regex.format(\n@@ -142,6 +146,7 @@ def test_multi_thread_info():\n                           name=\"test123\")),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n             VariableEntry('foo', value_regex=\"u?'bibi'\"),\n             CallEntry('def my_function(foo):',\n                       thread_info_regex=thread_info_regex.format(name='bibi')),\n@@ -155,6 +160,7 @@ def test_multi_thread_info():\n                       thread_info_regex=thread_info_regex.format(name='bibi')),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         )\n     )\n \n@@ -188,6 +194,7 @@ def test_callable(normalize):\n             LineEntry('return y + x'),\n             ReturnEntry('return y + x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -240,7 +247,8 @@ def test_watch(normalize):\n             VariableEntry('len(foo.__dict__[\"x\"] * \"abc\")', '48'),\n             LineEntry(),\n             ReturnEntry(),\n-            ReturnValueEntry('None')\n+            ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -291,7 +299,8 @@ def test_watch_explode(normalize):\n             VariableEntry('(lst + [])[3]', '10'),\n             VariableEntry('lst + []'),\n             ReturnEntry(),\n-            ReturnValueEntry('None')\n+            ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -342,7 +351,8 @@ def test_variables_classes(normalize):\n             VariableEntry('_lst[998]', '998'),\n             VariableEntry('_lst[999]', '999'),\n             ReturnEntry(),\n-            ReturnValueEntry('None')\n+            ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -384,7 +394,8 @@ def test_single_watch_no_comma(normalize):\n             LineEntry(),\n             LineEntry(),\n             ReturnEntry(),\n-            ReturnValueEntry('None')\n+            ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -412,7 +423,8 @@ def test_long_variable(normalize):\n             VariableEntry('foo', value_regex=regex),\n             LineEntry(),\n             ReturnEntry(),\n-            ReturnValueEntry(value_regex=regex)\n+            ReturnValueEntry(value_regex=regex),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -440,7 +452,8 @@ def test_long_variable_with_custom_max_variable_length(normalize):\n             VariableEntry('foo', value_regex=regex),\n             LineEntry(),\n             ReturnEntry(),\n-            ReturnValueEntry(value_regex=regex)\n+            ReturnValueEntry(value_regex=regex),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -468,7 +481,8 @@ def test_long_variable_with_infinite_max_variable_length(normalize):\n             VariableEntry('foo', value_regex=regex),\n             LineEntry(),\n             ReturnEntry(),\n-            ReturnValueEntry(value_regex=regex)\n+            ReturnValueEntry(value_regex=regex),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -498,7 +512,8 @@ def test_repr_exception(normalize):\n             LineEntry('bad = Bad()'),\n             VariableEntry('bad', value='REPR FAILED'),\n             ReturnEntry(),\n-            ReturnValueEntry('None')\n+            ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -561,6 +576,7 @@ def test_depth(normalize):\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('20'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -600,6 +616,7 @@ def test_method_and_prefix(normalize):\n             LineEntry(prefix='ZZZ'),\n             ReturnEntry(prefix='ZZZ'),\n             ReturnValueEntry(prefix='ZZZ'),\n+            ElapsedTimeEntry(prefix='ZZZ'),\n         ),\n         prefix='ZZZ',\n         normalize=normalize,\n@@ -634,6 +651,7 @@ def test_file_output(normalize):\n                 LineEntry('return y + x'),\n                 ReturnEntry('return y + x'),\n                 ReturnValueEntry('15'),\n+                ElapsedTimeEntry(),\n             ),\n             normalize=normalize,\n         )\n@@ -679,6 +697,7 @@ def test_confusing_decorator_lines(normalize):\n             # back in my_function\n             ReturnEntry(),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -700,6 +719,7 @@ def test_lambda(normalize):\n             LineEntry(source_regex='^my_function = pysnooper.*'),\n             ReturnEntry(source_regex='^my_function = pysnooper.*'),\n             ReturnValueEntry('49'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -734,6 +754,7 @@ def test_unavailable_source():\n                 LineEntry('SOURCE IS UNAVAILABLE'),\n                 ReturnEntry('SOURCE IS UNAVAILABLE'),\n                 ReturnValueEntry('7'),\n+                ElapsedTimeEntry(),\n             )\n         )\n \n@@ -767,6 +788,7 @@ def test_no_overwrite_by_default():\n                 LineEntry('return y + x'),\n                 ReturnEntry('return y + x'),\n                 ReturnValueEntry('15'),\n+                ElapsedTimeEntry(),\n             )\n         )\n \n@@ -800,6 +822,7 @@ def test_overwrite():\n                 LineEntry('return y + x'),\n                 ReturnEntry('return y + x'),\n                 ReturnValueEntry('15'),\n+                ElapsedTimeEntry(),\n \n                 VariableEntry('foo', value_regex=\"u?'baba'\"),\n                 CallEntry('def my_function(foo):'),\n@@ -810,6 +833,7 @@ def test_overwrite():\n                 LineEntry('return y + x'),\n                 ReturnEntry('return y + x'),\n                 ReturnValueEntry('15'),\n+                ElapsedTimeEntry(),\n             )\n         )\n \n@@ -914,6 +938,7 @@ def test_with_block(normalize):\n             LineEntry('qux()'),\n             ReturnEntry('qux()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # In with in recursive call\n             LineEntry('bar2(x)'),\n@@ -925,9 +950,11 @@ def test_with_block(normalize):\n             LineEntry('qux()'),\n             ReturnEntry('qux()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # In with in recursive call\n             LineEntry('qux()'),\n+            ElapsedTimeEntry(),\n \n             # Call to bar3 from after with\n             VariableEntry('_x', '9'),\n@@ -936,6 +963,7 @@ def test_with_block(normalize):\n             LineEntry('qux()'),\n             ReturnEntry('qux()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # -- Similar to previous few sections,\n             # -- but from first call to foo\n@@ -950,9 +978,11 @@ def test_with_block(normalize):\n             LineEntry('qux()'),\n             ReturnEntry('qux()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # In with in first call\n             LineEntry('qux()'),\n+            ElapsedTimeEntry(),\n \n             # Call to bar3 from after with\n             VariableEntry('_x', '9'),\n@@ -961,6 +991,7 @@ def test_with_block(normalize):\n             LineEntry('qux()'),\n             ReturnEntry('qux()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1020,6 +1051,7 @@ def test_with_block_depth(normalize):\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('20'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1086,6 +1118,7 @@ def test_cellvars(normalize):\n             ReturnValueEntry(),\n             ReturnEntry(),\n             ReturnValueEntry(),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1133,6 +1166,7 @@ def test_var_order(normalize):\n             VariableEntry(\"seven\", \"7\"),\n             ReturnEntry(),\n             ReturnValueEntry(),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1207,6 +1241,7 @@ def test_generator():\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('0'),\n+            ElapsedTimeEntry(),\n \n             # Pause and resume:\n \n@@ -1223,6 +1258,7 @@ def test_generator():\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('2'),\n+            ElapsedTimeEntry(),\n \n             # Pause and resume:\n \n@@ -1238,7 +1274,7 @@ def test_generator():\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry(None),\n-\n+            ElapsedTimeEntry(),\n         )\n     )\n \n@@ -1285,6 +1321,7 @@ def test_custom_repr(normalize):\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('49995000'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1313,6 +1350,7 @@ def test_custom_repr_single(normalize):\n             LineEntry(),\n             ReturnEntry(),\n             ReturnValueEntry('7'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1363,6 +1401,7 @@ def test_class(normalize):\n             LineEntry('self.x = 7'),\n             ReturnEntry('self.x = 7'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n             VariableEntry('self', value_regex=\"u?.+MyClass object\"),\n             VariableEntry('foo', value_regex=\"u?'baba'\"),\n             CallEntry('def my_method(self, foo):'),\n@@ -1371,6 +1410,7 @@ def test_class(normalize):\n             LineEntry('return y + self.x'),\n             ReturnEntry('return y + self.x'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1409,6 +1449,7 @@ def test_class_with_decorated_method(normalize):\n             LineEntry('self.x = 7'),\n             ReturnEntry('self.x = 7'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n             VariableEntry('args', value_regex=r\"\\(<.+>, 'baba'\\)\"),\n             VariableEntry('kwargs', value_regex=r\"\\{\\}\"),\n             VariableEntry('function', value_regex=\"u?.+my_method\"),\n@@ -1418,6 +1459,7 @@ def test_class_with_decorated_method(normalize):\n             LineEntry('return result'),\n             ReturnEntry('return result'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1457,6 +1499,7 @@ def test_class_with_decorated_method_and_snoop_applied_to_method(normalize):\n             LineEntry('self.x = 7'),\n             ReturnEntry('self.x = 7'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n             VariableEntry('args', value_regex=r\"u?\\(<.+>, 'baba'\\)\"),\n             VariableEntry('kwargs', value_regex=r\"u?\\{\\}\"),\n             VariableEntry('function', value_regex=\"u?.*my_method\"),\n@@ -1475,6 +1518,7 @@ def test_class_with_decorated_method_and_snoop_applied_to_method(normalize):\n             LineEntry('return result'),\n             ReturnEntry('return result'),\n             ReturnValueEntry('15'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1531,6 +1575,7 @@ def test_class_with_property(normalize):\n             LineEntry('self._x = 0'),\n             ReturnEntry('self._x = 0'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # Called from getter\n             VariableEntry('self', value_regex=\"u?.*MyClass object\"),\n@@ -1538,6 +1583,7 @@ def test_class_with_property(normalize):\n             LineEntry('pass'),\n             ReturnEntry('pass'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # Called from setter\n             VariableEntry('self', value_regex=\"u?.*MyClass object\"),\n@@ -1545,6 +1591,7 @@ def test_class_with_property(normalize):\n             LineEntry('pass'),\n             ReturnEntry('pass'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n \n             # Called from deleter\n             VariableEntry('self', value_regex=\"u?.*MyClass object\"),\n@@ -1552,6 +1599,7 @@ def test_class_with_property(normalize):\n             LineEntry('pass'),\n             ReturnEntry('pass'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1589,6 +1637,7 @@ def test_snooping_on_class_does_not_cause_base_class_to_be_snooped(normalize):\n             LineEntry('self.method_on_base_class()'),\n             ReturnEntry('self.method_on_base_class()'),\n             ReturnValueEntry('None'),\n+            ElapsedTimeEntry(),\n         ),\n         normalize=normalize,\n     )\n@@ -1625,6 +1674,7 @@ def test_normalize():\n                 LineEntry('return res'),\n                 ReturnEntry('return res'),\n                 ReturnValueEntry('41'),\n+                ElapsedTimeEntry(),\n             )\n     )\n \n@@ -1661,6 +1711,7 @@ def test_normalize_prefix():\n                 LineEntry('return res', prefix=_prefix),\n                 ReturnEntry('return res', prefix=_prefix),\n                 ReturnValueEntry('41', prefix=_prefix),\n+                ElapsedTimeEntry(prefix=_prefix),\n             )\n     )\n \n"}
{"repo": "PySnooper", "commit": "c0bf4bd0067d8d7618e40d27b2626e6f3cba4fce", "diff": "diff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 500c959..24b0868 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -86,6 +86,9 @@ def test_multi_thread_info():\n         y = 8\n         return y + x\n \n+    def parse_call_content(line):\n+        return line.split('{event:9} '.format(event='call'))[-1]\n+\n     with mini_toolbox.OutputCapturer(stdout=False,\n                                      stderr=True) as output_capturer:\n         my_function('baba')\n@@ -98,11 +101,8 @@ def test_multi_thread_info():\n     output = output_capturer.string_io.getvalue()\n     calls = [line for line in output.split(\"\\n\") if \"call\" in line]\n     main_thread = calls[0]\n-    assert len(main_thread) == len(calls[1])\n-    assert len(main_thread) == len(calls[2])\n-    main_thread_call_str = main_thread.find(\"call\")\n-    assert main_thread_call_str == calls[1].find(\"call\")\n-    assert main_thread_call_str == calls[2].find(\"call\")\n+    assert parse_call_content(main_thread) == parse_call_content(calls[1])\n+    assert parse_call_content(main_thread) == parse_call_content(calls[2])\n     thread_info_regex = '([0-9]+-{name}+[ ]+)'\n     assert_output(\n         output,\n"}
{"repo": "PySnooper", "commit": "337b6f20db884f78389c064e21a45e4457ac62a5", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 6d76685..f9625c3 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -234,6 +234,11 @@ class Tracer:\n \n     def _wrap_class(self, cls):\n         for attr_name, attr in cls.__dict__.items():\n+            # Coroutines are functions, but snooping them is not supported\n+            # at the moment\n+            if pycompat.iscoroutinefunction(attr):\n+                continue\n+\n             if inspect.isfunction(attr):\n                 setattr(cls, attr_name, self._wrap_function(attr))\n         return cls\n"}
{"repo": "PySnooper", "commit": "5ed81cb8483f41f132628b5604851ca18d4c54c3", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 0844c59..6584d94 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -223,9 +223,23 @@ class Tracer:\n         self.custom_repr = custom_repr\n         self.last_source_path = None\n \n-    def __call__(self, function):\n+    def __call__(self, function_or_class):\n         if DISABLED:\n             return function\n+\n+        if inspect.isclass(function_or_class):\n+            return self._wrap_class(function_or_class)\n+        else:\n+            return self._wrap_function(function_or_class)\n+\n+    def _wrap_class(self, cls):\n+        for attr_name in dir(cls):\n+            attr = getattr(cls, attr_name)\n+            if inspect.isfunction(attr):\n+                setattr(cls, attr_name, self._wrap_function(attr))\n+        return cls\n+\n+    def _wrap_function(self, function):\n         self.target_codes.add(function.__code__)\n \n         @functools.wraps(function)\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex b6f03e1..65f1d7b 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -48,6 +48,43 @@ def test_string_io():\n     )\n \n \n+def test_class():\n+    string_io = io.StringIO()\n+\n+    @pysnooper.snoop(string_io)\n+    class MyClass(object):\n+        def __init__(self):\n+            self.x = 7\n+\n+        def my_method(self, foo):\n+            y = 8\n+            return y + self.x\n+\n+    instance = MyClass()\n+    result = instance.my_method('baba')\n+    assert result == 15\n+    output = string_io.getvalue()\n+    assert_output(\n+        output,\n+        (\n+            SourcePathEntry(),\n+            VariableEntry('self', value_regex=\"u?.*<locals>.MyClass object at\"),\n+            CallEntry('def __init__(self):'),\n+            LineEntry('self.x = 7'),\n+            ReturnEntry('self.x = 7'),\n+            ReturnValueEntry('None'),\n+            VariableEntry('self', value_regex=\"u?.*<locals>.MyClass object at\"),\n+            VariableEntry('foo', value_regex=\"u?'baba'\"),\n+            CallEntry('def my_method(self, foo):'),\n+            LineEntry('y = 8'),\n+            VariableEntry('y', '8'),\n+            LineEntry('return y + self.x'),\n+            ReturnEntry('return y + self.x'),\n+            ReturnValueEntry('15'),\n+        )\n+    )\n+\n+\n def test_thread_info():\n \n     @pysnooper.snoop(thread_info=True)\n"}
{"repo": "PySnooper", "commit": "a1517196e146ae0c40f3e7aee804a4089c612b73", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 9b090a8..0844c59 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -80,7 +80,9 @@ def get_path_and_source_from_frame(frame):\n                     source = fp.read().splitlines()\n             except utils.file_reading_errors:\n                 pass\n-    if source is None:\n+    if not source:\n+        # We used to check `if source is None` but I found a rare bug where it\n+        # was empty, but not `None`, so now we check `if not source`.\n         source = UnavailableSource()\n \n     # If we just read the source from a file, or if the loader did not\n"}
{"repo": "PySnooper", "commit": "814abc34a098c1b98cb327105ac396f985d2413e", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 5d91aeb..fb6eddc 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -214,6 +214,9 @@ class Tracer:\n         self.target_codes = set()\n         self.target_frames = set()\n         self.thread_local = threading.local()\n+        if len(custom_repr) == 2 and not all(isinstance(x,\n+                      pycompat.collections_abc.Iterable) for x in custom_repr):\n+            custom_repr = (custom_repr,)\n         self.custom_repr = custom_repr\n \n     def __call__(self, function):\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 0b93845..930dd5d 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -1174,6 +1174,30 @@ def test_custom_repr():\n         )\n     )\n \n+def test_custom_repr_single():\n+    string_io = io.StringIO()\n+\n+    @pysnooper.snoop(string_io, custom_repr=(list, lambda l: 'foofoo!'))\n+    def sum_to_x(x):\n+        l = list(range(x))\n+        return 7\n+\n+    result = sum_to_x(10000)\n+\n+    output = string_io.getvalue()\n+    assert_output(\n+        output,\n+        (\n+            VariableEntry('x', '10000'),\n+            CallEntry(),\n+            LineEntry(),\n+            VariableEntry('l', 'foofoo!'),\n+            LineEntry(),\n+            ReturnEntry(),\n+            ReturnValueEntry('7'),\n+        )\n+    )\n+\n \n def test_disable():\n     string_io = io.StringIO()\n"}
{"repo": "PySnooper", "commit": "d7d3a80c16ec98345645e575046b9affad93a76c", "diff": "diff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex e451caf..52b8a2e 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -1183,11 +1183,11 @@ def test_activate_deactivate_snoop():\n         y = 8\n         return x + y\n \n-    os.environ['PYSNOOPER_DISABLED'] = '1'\n-    with pysnooper.snoop():\n+    pysnooper.tracer.DISABLED = '1'\n+    with pysnooper.snoop(string_io):\n         result = my_function('baba')\n     output = string_io.getvalue()\n     assert output == \"\"\n \n-    os.environ['PYSNOOPER_DISABLED'] = ''\n+    pysnooper.tracer.DISABLED = ''\n     test_string_io()\n"}
{"repo": "PySnooper", "commit": "7687ee1c2613ab5c095e992dd1bb736c16c41153", "diff": "diff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 7c8ede8..49ab4db 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -55,7 +55,7 @@ def test_thread_info():\n         return y + x\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function('baba')\n     assert result == 15\n     output = output_capturer.string_io.getvalue()\n@@ -84,7 +84,7 @@ def test_multi_thread_info():\n         return y + x\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         my_function('baba')\n         t1 = threading.Thread(target=my_function, name=\"test123\",args=['bubu'])\n         t1.start()\n@@ -207,7 +207,7 @@ def test_watch():\n             foo.square()\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result is None\n     output = output_capturer.string_io.getvalue()\n@@ -253,7 +253,7 @@ def test_watch_explode():\n         lst.append(10)\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result is None\n     output = output_capturer.string_io.getvalue()\n@@ -307,7 +307,7 @@ def test_variables_classes():\n         _lst = list(range(1000))\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result is None\n     output = output_capturer.string_io.getvalue()\n@@ -352,7 +352,7 @@ def test_single_watch_no_comma():\n             foo.square()\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result is None\n     output = output_capturer.string_io.getvalue()\n@@ -383,7 +383,7 @@ def test_long_variable():\n         return foo\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result == list(range(1000))\n     output = output_capturer.string_io.getvalue()\n@@ -411,7 +411,7 @@ def test_repr_exception():\n         bad = Bad()\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = my_function()\n     assert result is None\n     output = output_capturer.string_io.getvalue()\n@@ -501,7 +501,7 @@ def test_method_and_prefix():\n     baz = Baz()\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = baz.square()\n     assert result is baz\n     assert result.x == 4\n@@ -630,7 +630,7 @@ def test_unavailable_source():\n         module = __import__(module_name)\n         python_file_path.unlink()\n         with mini_toolbox.OutputCapturer(stdout=False,\n-                                      stderr=True) as output_capturer:\n+                                         stderr=True) as output_capturer:\n             result = getattr(module, 'f')(7)\n         assert result == 7\n         output = output_capturer.output\n@@ -784,7 +784,7 @@ def test_with_block():\n         return 9  # not traced, mustn't show up\n \n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         result = foo(2)\n     assert result == 2\n     output = output_capturer.string_io.getvalue()\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 349ab00..5772f8b 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -271,7 +271,7 @@ def assert_output(output, expected_entries, prefix=None):\n \n def assert_sample_output(module):\n     with mini_toolbox.OutputCapturer(stdout=False,\n-                                  stderr=True) as output_capturer:\n+                                     stderr=True) as output_capturer:\n         module.main()\n \n     time = '21:10:42.298924'\n"}
{"repo": "PySnooper", "commit": "56f22f8ffe1c6b2be4d2cf3ad1987fdb66113da2", "diff": "diff --git a/pysnooper/pycompat.py b/pysnooper/pycompat.py\nindex 63dd3db..de0a472 100644\n--- a/pysnooper/pycompat.py\n+++ b/pysnooper/pycompat.py\n@@ -8,6 +8,7 @@ import inspect\n import sys\n \n PY3 = (sys.version_info[0] == 3)\n+PY2 = not PY3\n \n if hasattr(abc, 'ABC'):\n     ABC = abc.ABC\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 089b817..480d60a 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -14,6 +14,8 @@ import traceback\n \n from .variables import CommonVariable, Exploding, BaseVariable\n from . import utils, pycompat\n+if pycompat.PY2:\n+    from io import open\n \n \n ipython_filename_pattern = re.compile('^<ipython-input-([0-9]+)-.*>$')\n@@ -84,7 +86,7 @@ def get_source_from_frame(frame):\n     # apply tokenize.detect_encoding to decode the source into a\n     # string, then we should do that ourselves.\n     if isinstance(source[0], bytes):\n-        encoding = 'ascii'\n+        encoding = 'utf-8'\n         for line in source[:2]:\n             # File coding may be specified. Match pattern from PEP-263\n             # (https://www.python.org/dev/peps/pep-0263/)\n@@ -130,7 +132,8 @@ class FileWriter(object):\n         self.overwrite = overwrite\n \n     def write(self, s):\n-        with open(self.path, 'w' if self.overwrite else 'a') as output_file:\n+        with open(self.path, 'w' if self.overwrite else 'a',\n+                  encoding='utf-8') as output_file:\n             output_file.write(s)\n         self.overwrite = False\n \ndiff --git a/tests/test_chinese.py b/tests/test_chinese.py\nnew file mode 100644\nindex 0000000..269c8df\n--- /dev/null\n+++ b/tests/test_chinese.py\n@@ -0,0 +1,48 @@\n+# -*- coding: utf-8 -*-\n+# Copyright 2019 Ram Rachum and collaborators.\n+# This program is distributed under the MIT license.\n+\n+import io\n+import textwrap\n+import threading\n+import types\n+import sys\n+\n+from pysnooper.utils import truncate\n+from python_toolbox import sys_tools, temp_file_tools\n+import pytest\n+\n+import pysnooper\n+from pysnooper import pycompat\n+from pysnooper.variables import needs_parentheses\n+from .utils import (assert_output, assert_sample_output, VariableEntry,\n+                    CallEntry, LineEntry, ReturnEntry, OpcodeEntry,\n+                    ReturnValueEntry, ExceptionEntry)\n+\n+\n+\n+def test_chinese():\n+    with temp_file_tools.create_temp_folder(prefix='pysnooper') as folder:\n+        path = folder / 'foo.log'\n+        @pysnooper.snoop(path)\n+        def foo():\n+            a = 1\n+            x = '\u00e5\u00a4\u00b1\u00e8\u00b4\u00a5'\n+            return 7\n+\n+        foo()\n+        with path.open(encoding='utf-8') as file:\n+            output = file.read()\n+        assert_output(\n+            output,\n+            (\n+                CallEntry(),\n+                LineEntry(),\n+                VariableEntry('a'),\n+                LineEntry(u\"x = '\u00e5\u00a4\u00b1\u00e8\u00b4\u00a5'\"),\n+                VariableEntry(u'x', (u\"'\u00e5\u00a4\u00b1\u00e8\u00b4\u00a5'\" if pycompat.PY3 else None)),\n+                LineEntry(),\n+                ReturnEntry(),\n+                ReturnValueEntry('7')\n+            ),\n+        )\ndiff --git a/tests/utils.py b/tests/utils.py\nindex b77e1f6..05185f0 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -254,7 +254,7 @@ def assert_output(output, expected_entries, prefix=None):\n \n     any_mismatch = False\n     result = ''\n-    template = '\\n{line!s:%s}   {expected_entry}  {arrow}' % max(map(len, lines))\n+    template = u'\\n{line!s:%s}   {expected_entry}  {arrow}' % max(map(len, lines))\n     for expected_entry, line in zip_longest(expected_entries, lines, fillvalue=\"\"):\n         mismatch = not (expected_entry and expected_entry.check(line))\n         any_mismatch |= mismatch\n@@ -273,7 +273,7 @@ def assert_sample_output(module):\n     with sys_tools.OutputCapturer(stdout=False,\n                                   stderr=True) as output_capturer:\n         module.main()\n-        \n+\n     time = '21:10:42.298924'\n     time_pattern = re.sub(r'\\d', r'\\\\d', time)\n \n"}
{"repo": "PySnooper", "commit": "90a19465292156e0e2ce0155181065b74b225162", "diff": "diff --git a/tests/samples/exception.py b/tests/samples/exception.py\nindex bf90979..8b36042 100644\n--- a/tests/samples/exception.py\n+++ b/tests/samples/exception.py\n@@ -8,8 +8,8 @@ def foo():\n def bar():\n     try:\n         foo()\n-    except Exception as e:\n-        str(e)\n+    except Exception:\n+        str(1)\n         raise\n \n \n@@ -35,9 +35,8 @@ expected_output = '''\n         Call ended by exception\n     12:18:08.018494 exception   10         foo()\n     TypeError: bad\n-    12:18:08.018545 line        11     except Exception as e:\n-    New var:....... e = TypeError('bad',)\n-    12:18:08.018597 line        12         str(e)\n+    12:26:33.942623 line        11     except Exception:\n+    12:26:33.942674 line        12         str(1)\n     12:18:08.018655 line        13         raise\n     Call ended by exception\n 12:18:08.018718 exception   19         bar()\n"}
{"repo": "PySnooper", "commit": "dea100b9290fb2d88cce3d7c0bfb14d625b5a7b2", "diff": "diff --git a/tests/samples/exception.py b/tests/samples/exception.py\nnew file mode 100644\nindex 0000000..bf90979\n--- /dev/null\n+++ b/tests/samples/exception.py\n@@ -0,0 +1,49 @@\n+import pysnooper\n+\n+\n+def foo():\n+    raise TypeError('bad')\n+\n+\n+def bar():\n+    try:\n+        foo()\n+    except Exception as e:\n+        str(e)\n+        raise\n+\n+\n+@pysnooper.snoop(depth=3)\n+def main():\n+    try:\n+        bar()\n+    except:\n+        pass\n+\n+\n+expected_output = '''\n+12:18:08.017782 call        17 def main():\n+12:18:08.018142 line        18     try:\n+12:18:08.018181 line        19         bar()\n+    12:18:08.018223 call         8 def bar():\n+    12:18:08.018260 line         9     try:\n+    12:18:08.018293 line        10         foo()\n+        12:18:08.018329 call         4 def foo():\n+        12:18:08.018364 line         5     raise TypeError('bad')\n+        12:18:08.018396 exception    5     raise TypeError('bad')\n+        TypeError: bad\n+        Call ended by exception\n+    12:18:08.018494 exception   10         foo()\n+    TypeError: bad\n+    12:18:08.018545 line        11     except Exception as e:\n+    New var:....... e = TypeError('bad',)\n+    12:18:08.018597 line        12         str(e)\n+    12:18:08.018655 line        13         raise\n+    Call ended by exception\n+12:18:08.018718 exception   19         bar()\n+TypeError: bad\n+12:18:08.018761 line        20     except:\n+12:18:08.018787 line        21         pass\n+12:18:08.018813 return      21         pass\n+Return value:.. None\n+'''\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 5f266c4..18f27ca 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -938,3 +938,8 @@ def test_indentation():\n     from .samples import indentation, recursion\n     assert_sample_output(indentation)\n     assert_sample_output(recursion)\n+\n+\n+def test_exception():\n+    from .samples import exception\n+    assert_sample_output(exception)\n"}
{"repo": "PySnooper", "commit": "f6001ce3b1d2d0f6bb7f8c27f8ff829eedeb385b", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 6907069..d484bcb 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -339,10 +339,13 @@ class Tracer:\n         # If a call ends due to an exception, we still get a 'return' event\n         # with arg = None. This seems to be the only way to tell the difference\n         # https://stackoverflow.com/a/12800909/2482744\n+        code_byte = frame.f_code.co_code[frame.f_lasti]\n+        if not isinstance(code_byte, int):\n+            code_byte = ord(code_byte)\n         ended_by_exception = (\n                 event == 'return'\n                 and arg is None\n-                and (opcode.opname[frame.f_code.co_code[frame.f_lasti]]\n+                and (opcode.opname[code_byte]\n                      not in ('RETURN_VALUE', 'YIELD_VALUE'))\n         )\n \n"}
{"repo": "PySnooper", "commit": "d24f9e38469be216b8be913791132453c17e3bd7", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex a6cd301..6907069 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -3,12 +3,14 @@\n \n import functools\n import inspect\n+import opcode\n import sys\n import re\n import collections\n import datetime as datetime_module\n import itertools\n import threading\n+import traceback\n \n from .variables import CommonVariable, Exploding, BaseVariable\n from .third_party import six\n@@ -334,14 +336,36 @@ class Tracer:\n         #                                                                     #\n         ### Finished dealing with misplaced function definition. ##############\n \n-        self.write(u'{indent}{now_string} {thread_info}{event:9} '\n-                   u'{line_no:4} {source_line}'.format(**locals()))\n+        # If a call ends due to an exception, we still get a 'return' event\n+        # with arg = None. This seems to be the only way to tell the difference\n+        # https://stackoverflow.com/a/12800909/2482744\n+        ended_by_exception = (\n+                event == 'return'\n+                and arg is None\n+                and (opcode.opname[frame.f_code.co_code[frame.f_lasti]]\n+                     not in ('RETURN_VALUE', 'YIELD_VALUE'))\n+        )\n+\n+        if ended_by_exception:\n+            self.write('{indent}Call ended by exception'.\n+                       format(**locals()))\n+        else:\n+            self.write(u'{indent}{now_string} {thread_info}{event:9} '\n+                       u'{line_no:4} {source_line}'.format(**locals()))\n \n         if event == 'return':\n-            return_value_repr = utils.get_shortish_repr(arg)\n-            self.write('{indent}Return value:.. {return_value_repr}'.\n-                                                            format(**locals()))\n             del self.frame_to_local_reprs[frame]\n             thread_global.depth -= 1\n \n+            if not ended_by_exception:\n+                return_value_repr = utils.get_shortish_repr(arg)\n+                self.write('{indent}Return value:.. {return_value_repr}'.\n+                           format(**locals()))\n+\n+        if event == 'exception':\n+            exception = '\\n'.join(traceback.format_exception_only(*arg[:2])).strip()\n+            exception = utils.truncate(exception, utils.MAX_EXCEPTION_LENGTH)\n+            self.write('{indent}{exception}'.\n+                       format(**locals()))\n+\n         return self.trace\ndiff --git a/pysnooper/utils.py b/pysnooper/utils.py\nindex 458d602..605e34a 100644\n--- a/pysnooper/utils.py\n+++ b/pysnooper/utils.py\n@@ -7,6 +7,7 @@ from .pycompat import ABC\n from .third_party import six\n \n MAX_VARIABLE_LENGTH = 100\n+MAX_EXCEPTION_LENGTH = 200\n \n def _check_methods(C, *methods):\n     mro = C.__mro__\n"}
{"repo": "PySnooper", "commit": "313b22f30c261f8900a0f3250640b631127fb653", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 95f9b74..6da1d32 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -29,24 +29,19 @@ class UnavailableSource(object):\n         return u'SOURCE IS UNAVAILABLE'\n \n \n-source_cache_by_module_name = {}\n-source_cache_by_file_name = {}\n+source_cache = {}\n \n \n def get_source_from_frame(frame):\n-    module_name = (frame.f_globals or {}).get('__name__') or ''\n-    if module_name:\n-        try:\n-            return source_cache_by_module_name[module_name]\n-        except KeyError:\n-            pass\n+    globs = frame.f_globals or {}\n+    module_name = globs.get('__name__')\n     file_name = frame.f_code.co_filename\n-    if file_name:\n-        try:\n-            return source_cache_by_file_name[file_name]\n-        except KeyError:\n-            pass\n-    loader = (frame.f_globals or {}).get('__loader__')\n+    cache_key = (module_name, file_name)\n+    try:\n+        return source_cache[cache_key]\n+    except KeyError:\n+        pass\n+    loader = globs.get('__loader__')\n \n     source = None\n     if hasattr(loader, 'get_source'):\n@@ -92,10 +87,7 @@ def get_source_from_frame(frame):\n         source = [six.text_type(sline, encoding, 'replace') for sline in\n                   source]\n \n-    if module_name:\n-        source_cache_by_module_name[module_name] = source\n-    if file_name:\n-        source_cache_by_file_name[file_name] = source\n+    source_cache[cache_key] = source\n     return source\n \n \n"}
{"repo": "PySnooper", "commit": "7e845b8f493d82c9e6f6f4d200136bb8a956dcfc", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex ef8dfef..4049c67 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -1,5 +1,20 @@\n # Copyright 2019 Ram Rachum and collaborators.\n # This program is distributed under the MIT license.\n+\"\"\"PySnooper - Never use print for debugging again\n+\n+Usage:\n+\n+    import pysnooper\n+\n+    @pysnooper.snoop()\n+    def number_to_bits(number):\n+        ...\n+\n+A log will be written to stderr showing the lines executed and variables\n+changed in the decorated function.\n+\n+For more information, see https://github.com/cool-RR/PySnooper\n+\"\"\"\n \n from .pysnooper import snoop\n from .variables import Attrs, Exploding, Indices, Keys\n"}
{"repo": "PySnooper", "commit": "a9d884a5797764c2212992eb3a59003f0c7d74a4", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex 4944847..26e76f8 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -8,7 +8,7 @@ import collections\n __VersionInfo = collections.namedtuple('VersionInfo',\n                                        ('major', 'minor', 'micro'))\n \n-__version__ = '0.0.28'\n+__version__ = '0.0.29'\n __version_info__ = __VersionInfo(*(map(int, __version__.split('.'))))\n \n del collections, __VersionInfo # Avoid polluting the namespace\n"}
{"repo": "PySnooper", "commit": "600dedcc1ace263ce513d48663784a6b8b62040a", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex 05156d3..4944847 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -8,7 +8,7 @@ import collections\n __VersionInfo = collections.namedtuple('VersionInfo',\n                                        ('major', 'minor', 'micro'))\n \n-__version__ = '0.0.27'\n+__version__ = '0.0.28'\n __version_info__ = __VersionInfo(*(map(int, __version__.split('.'))))\n \n del collections, __VersionInfo # Avoid polluting the namespace\ndiff --git a/pysnooper/pysnooper.py b/pysnooper/pysnooper.py\nindex cebfd51..94625e6 100644\n--- a/pysnooper/pysnooper.py\n+++ b/pysnooper/pysnooper.py\n@@ -61,7 +61,7 @@ def snoop(output=None, watch=(), watch_explode=(), depth=1,\n \n     Expand values to see all their attributes or items of lists/dictionaries:\n \n-        @pysnooper.snoop(exploding_variables=('foo', 'self'))\n+        @pysnooper.snoop(watch_explode=('foo', 'self'))\n \n     (see Advanced Usage in the README for more control)\n \n"}
{"repo": "PySnooper", "commit": "e4b244736a53014b2bd38a9ffa5ef44348263681", "diff": "diff --git a/pysnooper/variables.py b/pysnooper/variables.py\nindex d233d60..a5a0a6f 100644\n--- a/pysnooper/variables.py\n+++ b/pysnooper/variables.py\n@@ -21,7 +21,7 @@ class BaseVariable(ABC):\n \n     @abstractmethod\n     def _items(self, key):\n-        raise NotImplementedError()\n+        raise NotImplementedError\n \n \n class CommonVariable(BaseVariable):\n@@ -51,10 +51,10 @@ class CommonVariable(BaseVariable):\n         return ()\n \n     def _format_key(self, key):\n-        raise NotImplementedError()\n+        raise NotImplementedError\n \n     def _get_value(self, main_value, key):\n-        raise NotImplementedError()\n+        raise NotImplementedError\n \n \n class Attrs(CommonVariable):\n"}
{"repo": "PySnooper", "commit": "5f34219df7226f4cd18ef9c46838ef97830032ae", "diff": "diff --git a/pysnooper/variables.py b/pysnooper/variables.py\nindex b0486bb..8e5d091 100644\n--- a/pysnooper/variables.py\n+++ b/pysnooper/variables.py\n@@ -26,9 +26,9 @@ class CommonVariable(BaseVariable):\n     def _items(self, main_value):\n         result = [(self.source, get_shortish_repr(main_value))]\n         for key in self._safe_keys(main_value):\n-            if key in self.exclude:\n-                continue\n             try:\n+                if key in self.exclude:\n+                    continue\n                 value = self._get_value(main_value, key)\n             except Exception:\n                 continue\n"}
{"repo": "PySnooper", "commit": "b8dec67a4f968b02e9ebfd771a27f5168444d501", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex 2135595..bf8590a 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -7,7 +7,7 @@ import collections\n __VersionInfo = collections.namedtuple('VersionInfo',\n                                        ('major', 'minor', 'micro'))\n \n-__version__ = '0.0.24'\n+__version__ = '0.0.25'\n __version_info__ = __VersionInfo(*(map(int, __version__.split('.'))))\n \n del collections, __VersionInfo # Avoid polluting the namespace\ndiff --git a/pysnooper/pysnooper.py b/pysnooper/pysnooper.py\nindex ad6e689..bc17403 100644\n--- a/pysnooper/pysnooper.py\n+++ b/pysnooper/pysnooper.py\n@@ -14,7 +14,11 @@ def get_write_and_truncate_functions(output):\n     if output is None:\n         def write(s):\n             stderr = sys.stderr\n-            stderr.write(s)\n+            try:\n+                stderr.write(s)\n+            except UnicodeEncodeError:\n+                 # God damn Python 2\n+                stderr.write(utils.shitcode(s))\n         truncate = None\n     elif isinstance(output, (pycompat.PathLike, str)):\n         def write(s):\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex c4f4407..f029535 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -251,8 +251,8 @@ class Tracer:\n         #                                                                     #\n         ### Finished dealing with misplaced function definition. ##############\n \n-        self.write('{indent}{now_string} {event:9} '\n-                   '{line_no:4} {source_line}'.format(**locals()))\n+        self.write(u'{indent}{now_string} {event:9} '\n+                   u'{line_no:4} {source_line}'.format(**locals()))\n \n         if event == 'return':\n             return_value_repr = get_shortish_repr(arg)\ndiff --git a/pysnooper/utils.py b/pysnooper/utils.py\nindex 07d8814..2de6948 100644\n--- a/pysnooper/utils.py\n+++ b/pysnooper/utils.py\n@@ -36,3 +36,9 @@ file_reading_errors = (\n     OSError,\n     ValueError # IronPython weirdness.\n )\n+\n+\n+def shitcode(s):\n+    return ''.join(\n+        (c if (0 < ord(c) < 256) else '?') for c in s\n+    )\n"}
{"repo": "PySnooper", "commit": "59d3a9d1787bbc49c6e0592c2a7c77d697b72735", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex a7e0464..2135595 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -7,7 +7,7 @@ import collections\n __VersionInfo = collections.namedtuple('VersionInfo',\n                                        ('major', 'minor', 'micro'))\n \n-__version__ = '0.0.23'\n+__version__ = '0.0.24'\n __version_info__ = __VersionInfo(*(map(int, __version__.split('.'))))\n \n del collections, __VersionInfo # Avoid polluting the namespace\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex bc4dbd0..c4f4407 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -14,6 +14,7 @@ except ImportError:\n     import __builtin__ as builtins\n \n from .third_party import six\n+from . import utils\n \n ipython_filename_pattern = re.compile('^<ipython-input-([0-9]+)-.*>$')\n \n@@ -109,7 +110,7 @@ def get_source_from_frame(frame):\n             try:\n                 with open(file_name, 'rb') as fp:\n                     source = fp.read().splitlines()\n-            except (OSError, IOError):\n+            except utils.file_reading_errors:\n                 pass\n     if source is None:\n         source = UnavailableSource()\ndiff --git a/pysnooper/utils.py b/pysnooper/utils.py\nindex fc6a89c..07d8814 100644\n--- a/pysnooper/utils.py\n+++ b/pysnooper/utils.py\n@@ -30,3 +30,9 @@ class WritableStream(ABC):\n             return _check_methods(C, 'write')\n         return NotImplemented\n \n+\n+file_reading_errors = (\n+    IOError,\n+    OSError,\n+    ValueError # IronPython weirdness.\n+)\n"}
{"repo": "PySnooper", "commit": "fb5b7eabbc5cd8f872bf5dbc4a1bdbd0b5d6abae", "diff": "diff --git a/pysnooper/__init__.py b/pysnooper/__init__.py\nindex a5ea960..a7e0464 100644\n--- a/pysnooper/__init__.py\n+++ b/pysnooper/__init__.py\n@@ -7,7 +7,7 @@ import collections\n __VersionInfo = collections.namedtuple('VersionInfo',\n                                        ('major', 'minor', 'micro'))\n \n-__version__ = '0.0.22'\n+__version__ = '0.0.23'\n __version_info__ = __VersionInfo(*(map(int, __version__.split('.'))))\n \n del collections, __VersionInfo # Avoid polluting the namespace\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 048d798..bc4dbd0 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -54,7 +54,7 @@ def get_local_reprs(frame, variables=()):\n     for variable in variables:\n         try:\n             result[variable] = get_shortish_repr(\n-                eval(variable, frame.f_globals, frame.f_locals)\n+                eval(variable, (frame.f_globals or {}), frame.f_locals)\n             )\n         except Exception:\n             pass\n@@ -71,7 +71,7 @@ source_cache_by_file_name = {}\n \n \n def get_source_from_frame(frame):\n-    module_name = frame.f_globals.get('__name__') or ''\n+    module_name = (frame.f_globals or {}).get('__name__') or ''\n     if module_name:\n         try:\n             return source_cache_by_module_name[module_name]\n@@ -83,7 +83,7 @@ def get_source_from_frame(frame):\n             return source_cache_by_file_name[file_name]\n         except KeyError:\n             pass\n-    loader = frame.f_globals.get('__loader__')\n+    loader = (frame.f_globals or {}).get('__loader__')\n \n     source = None\n     if hasattr(loader, 'get_source'):\n"}
{"repo": "PySnooper", "commit": "9a81a2e76c98c54c6ac44a7a872fdd6c573cb82e", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 87e9ffa..048d798 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -8,28 +8,30 @@ import datetime as datetime_module\n import itertools\n try:\n     import reprlib\n+    import builtins\n except ImportError:\n     import repr as reprlib\n+    import __builtin__ as builtins\n \n from .third_party import six\n \n ipython_filename_pattern = re.compile('^<ipython-input-([0-9]+)-.*>$')\n \n \n-class MyRepr(reprlib.Repr):\n+class Repr(reprlib.Repr, object):  # reprlib.Repr is old-style in Python 2\n     def __init__(self):\n-        super(MyRepr, self).__init__()\n+        super(Repr, self).__init__()\n         self.maxother = 100\n \n     def repr(self, x):\n         try:\n-            return super(MyRepr, self).repr(x)\n+            return super(Repr, self).repr(x)\n         except Exception as e:\n             return '<{} instance at {:#x} (__repr__ raised {})>'.format(\n                 x.__class__.__name__, id(x), e.__class__.__name__)\n \n     def repr_instance(self, x, level):\n-        s = reprlib.builtins.repr(x)\n+        s = builtins.repr(x)\n         if len(s) > self.maxother:\n             i = max(0, (self.maxother - 3) // 2)\n             j = max(0, self.maxother - 3 - i)\n@@ -37,7 +39,7 @@ class MyRepr(reprlib.Repr):\n         return s\n \n \n-repr_instance = MyRepr()\n+repr_instance = Repr()\n \n \n def get_shortish_repr(item):\n"}
{"repo": "PySnooper", "commit": "0322982875c03d9b44ba3e5ef38863f26d8eef01", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex bd0ec77..87e9ffa 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -15,12 +15,33 @@ from .third_party import six\n \n ipython_filename_pattern = re.compile('^<ipython-input-([0-9]+)-.*>$')\n \n-repr_instance = reprlib.Repr()\n-repr_instance.maxother = 100\n+\n+class MyRepr(reprlib.Repr):\n+    def __init__(self):\n+        super(MyRepr, self).__init__()\n+        self.maxother = 100\n+\n+    def repr(self, x):\n+        try:\n+            return super(MyRepr, self).repr(x)\n+        except Exception as e:\n+            return '<{} instance at {:#x} (__repr__ raised {})>'.format(\n+                x.__class__.__name__, id(x), e.__class__.__name__)\n+\n+    def repr_instance(self, x, level):\n+        s = reprlib.builtins.repr(x)\n+        if len(s) > self.maxother:\n+            i = max(0, (self.maxother - 3) // 2)\n+            j = max(0, self.maxother - 3 - i)\n+            s = s[:i] + '...' + s[len(s) - j:]\n+        return s\n+\n+\n+repr_instance = MyRepr()\n \n \n def get_shortish_repr(item):\n-    r = reprlib.repr(item)\n+    r = repr_instance.repr(item)\n     r = r.replace('\\r', '').replace('\\n', '')\n     return r\n \ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 8f25373..03567c5 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -158,6 +158,33 @@ def test_long_variable():\n     )\n \n \n+def test_repr_exception():\n+    class Bad(object):\n+        def __repr__(self):\n+            1 / 0\n+\n+    @pysnooper.snoop()\n+    def my_function():\n+        bad = Bad()\n+\n+    with sys_tools.OutputCapturer(stdout=False,\n+                                  stderr=True) as output_capturer:\n+        result = my_function()\n+    assert result is None\n+    output = output_capturer.string_io.getvalue()\n+    assert_output(\n+        output,\n+        (\n+            VariableEntry('Bad'),\n+            CallEntry('def my_function():'),\n+            LineEntry('bad = Bad()'),\n+            VariableEntry('bad', value_regex=r'<Bad instance at 0x\\w+ \\(__repr__ raised ZeroDivisionError\\)>'),\n+            ReturnEntry(),\n+            ReturnValueEntry('None')\n+        )\n+    )\n+\n+\n def test_depth():\n     string_io = io.StringIO()\n \n"}
{"repo": "PySnooper", "commit": "a5e420a3aba44da3c1f33277a6ef6bee8521ae5a", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex e0cb0aa..ea59552 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -13,18 +13,12 @@ except ImportError:\n \n from .third_party import six\n \n-MAX_VARIABLE_LENGTH = 100\n ipython_filename_pattern = re.compile('^<ipython-input-([0-9]+)-.*>$')\n \n \n def get_shortish_repr(item):\n-    try:\n-        r = reprlib.repr(item)\n-    except Exception:\n-        r = 'REPR FAILED'\n+    r = reprlib.repr(item)\n     r = r.replace('\\r', '').replace('\\n', '')\n-    if len(r) > MAX_VARIABLE_LENGTH:\n-        r = '{truncated_r}...'.format(truncated_r=r[:MAX_VARIABLE_LENGTH])\n     return r\n \n \n"}
{"repo": "PySnooper", "commit": "36b3271f0a184592025a32d032ca3cb551f45470", "diff": "diff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 81f7102..b32fe92 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -150,7 +150,7 @@ def test_method_and_prefix():\n         def __init__(self):\n             self.x = 2\n \n-        @pysnooper.snoop(variables=('self.x'), prefix='ZZZ')\n+        @pysnooper.snoop(variables=('self.x',), prefix='ZZZ')\n         def square(self):\n             foo = 7\n             self.x **= 2\n@@ -167,11 +167,13 @@ def test_method_and_prefix():\n     assert_output(\n         output,\n         (\n-            VariableEntry(prefix='ZZZ'),\n+            VariableEntry('self', prefix='ZZZ'),\n+            VariableEntry('self.x', '2', prefix='ZZZ'),\n             CallEntry('def square(self):', prefix='ZZZ'),\n             LineEntry('foo = 7', prefix='ZZZ'),\n             VariableEntry('foo', '7', prefix='ZZZ'),\n             LineEntry('self.x **= 2', prefix='ZZZ'),\n+            VariableEntry('self.x', '4', prefix='ZZZ'),\n             LineEntry(prefix='ZZZ'),\n             ReturnEntry(prefix='ZZZ'),\n             ReturnValueEntry(prefix='ZZZ'),\n"}
{"repo": "PySnooper", "commit": "93edf6fcedb5afe2c909752b61055047f5e5d43a", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex 6303083..db349ec 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -139,9 +139,7 @@ class Tracer:\n         if self.overwrite and not self._did_overwrite:\n             self.truncate()\n             self._did_overwrite = True\n-        s = '{self.prefix}{s}\\n'.format(**locals())\n-        if isinstance(s, bytes): # Python 2 compatibility\n-            s = s.decode()\n+        s = u'{self.prefix}{s}\\n'.format(**locals())\n         self._write(s)\n \n     def __enter__(self):\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 195926e..81f7102 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -275,13 +275,11 @@ def test_unavailable_source():\n             sys_tools.TempSysPathAdder(str(folder)):\n         module_name = 'iaerojajsijf'\n         python_file_path = folder / ('%s.py' % (module_name,))\n-        content = ('import pysnooper\\n'\n+        content = (u'import pysnooper\\n'\n                    '\\n'\n                    '@pysnooper.snoop()\\n'\n                    'def f(x):\\n'\n                    '    return x\\n')\n-        if six.PY2:\n-            content = content.decode()\n         with python_file_path.open('w') as python_file:\n             python_file.write(content)\n         module = __import__(module_name)\n"}
{"repo": "PySnooper", "commit": "30e57891779f5a5e8d673308685b541b9dc2724c", "diff": "diff --git a/misc/generate_authors.py b/misc/generate_authors.py\nindex 51c9694..6ce76ea 100644\n--- a/misc/generate_authors.py\n+++ b/misc/generate_authors.py\n@@ -3,7 +3,7 @@\n # This program is distributed under the MIT license.\n \n \n-\"\"\"\n+'''\n Generate an AUTHORS file for your Git repo.\n \n This will list the authors by chronological order, from their first\n@@ -13,7 +13,7 @@ You probably want to run it this way:\n \n     ./generate_authors > AUTHORS\n \n-\"\"\"\n+'''\n \n \n import subprocess\ndiff --git a/pysnooper/pysnooper.py b/pysnooper/pysnooper.py\nindex b70c932..ad6e689 100644\n--- a/pysnooper/pysnooper.py\n+++ b/pysnooper/pysnooper.py\n@@ -2,12 +2,6 @@\n # This program is distributed under the MIT license.\n \n import sys\n-import os\n-import inspect\n-import types\n-import datetime as datetime_module\n-import re\n-import collections\n \n from .third_party import decorator\n \n@@ -38,7 +32,6 @@ def get_write_and_truncate_functions(output):\n     return (write, truncate)\n \n \n-\n def snoop(output=None, variables=(), depth=1, prefix='', overwrite=False):\n     '''\n     Snoop on the function, writing everything it's doing to stderr.\n@@ -83,5 +76,3 @@ def snoop(output=None, variables=(), depth=1, prefix='', overwrite=False):\n         return decorator.decorate(function, inner)\n \n     return decorate\n-\n-\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex cc75fd5..6303083 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -1,7 +1,6 @@\n # Copyright 2019 Ram Rachum and collaborators.\n # This program is distributed under the MIT license.\n \n-import types\n import sys\n import re\n import collections\n@@ -28,6 +27,7 @@ def get_shortish_repr(item):\n         r = '{truncated_r}...'.format(truncated_r=r[:MAX_VARIABLE_LENGTH])\n     return r\n \n+\n def get_local_reprs(frame, variables=()):\n     result = {key: get_shortish_repr(value) for key, value\n                                                      in frame.f_locals.items()}\n@@ -52,6 +52,8 @@ class UnavailableSource(object):\n \n source_cache_by_module_name = {}\n source_cache_by_file_name = {}\n+\n+\n def get_source_from_frame(frame):\n     module_name = frame.f_globals.get('__name__') or ''\n     if module_name:\n@@ -65,7 +67,6 @@ def get_source_from_frame(frame):\n             return source_cache_by_file_name[file_name]\n         except KeyError:\n             pass\n-    function = frame.f_code.co_name\n     loader = frame.f_globals.get('__loader__')\n \n     source = None\n@@ -118,6 +119,7 @@ def get_source_from_frame(frame):\n         source_cache_by_file_name[file_name] = source\n     return source\n \n+\n class Tracer:\n     def __init__(self, target_code_object, write, truncate, variables=(),\n                  depth=1, prefix='', overwrite=False):\n@@ -149,7 +151,6 @@ class Tracer:\n     def __exit__(self, exc_type, exc_value, exc_traceback):\n         sys.settrace(self.original_trace_function)\n \n-\n     def trace(self, frame, event, arg):\n \n         ### Checking whether we should trace this line: #######################\n@@ -242,5 +243,3 @@ class Tracer:\n                                                             format(**locals()))\n \n         return self.trace\n-\n-\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 3cb7df5..195926e 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -2,28 +2,27 @@\n # This program is distributed under the MIT license.\n \n import io\n-import re\n-import abc\n \n-from python_toolbox import caching\n from python_toolbox import sys_tools\n from python_toolbox import temp_file_tools\n from pysnooper.third_party import six\n import pytest\n \n import pysnooper\n-\n+from pysnooper.third_party import six\n from .utils import (assert_output, VariableEntry, CallEntry, LineEntry,\n                     ReturnEntry, OpcodeEntry, ReturnValueEntry, ExceptionEntry)\n \n \n def test_string_io():\n     string_io = io.StringIO()\n+\n     @pysnooper.snoop(string_io)\n     def my_function(foo):\n         x = 7\n         y = 8\n         return y + x\n+\n     result = my_function('baba')\n     assert result == 15\n     output = string_io.getvalue()\n@@ -42,6 +41,7 @@ def test_string_io():\n         )\n     )\n \n+\n def test_variables():\n \n     class Foo(object):\n@@ -51,7 +51,7 @@ def test_variables():\n         def square(self):\n             self.x **= 2\n \n-    @pysnooper.snoop(variables=('foo.x', 're'))\n+    @pysnooper.snoop(variables=('foo.x', 'io'))\n     def my_function():\n         foo = Foo()\n         for i in range(2):\n@@ -85,6 +85,7 @@ def test_variables():\n         )\n     )\n \n+\n def test_depth():\n     string_io = io.StringIO()\n \n@@ -145,7 +146,6 @@ def test_depth():\n \n \n def test_method_and_prefix():\n-\n     class Baz(object):\n         def __init__(self):\n             self.x = 2\n@@ -179,14 +179,17 @@ def test_method_and_prefix():\n         prefix='ZZZ'\n     )\n \n+\n def test_file_output():\n     with temp_file_tools.create_temp_folder(prefix='pysnooper') as folder:\n         path = folder / 'foo.log'\n+\n         @pysnooper.snoop(str(path))\n-        def my_function(foo):\n+        def my_function(_foo):\n             x = 7\n             y = 8\n             return y + x\n+\n         result = my_function('baba')\n         assert result == 15\n         with path.open() as output_file:\n@@ -194,8 +197,8 @@ def test_file_output():\n         assert_output(\n             output,\n             (\n-                VariableEntry('foo', value_regex=\"u?'baba'\"),\n-                CallEntry('def my_function(foo):'),\n+                VariableEntry('_foo', value_regex=\"u?'baba'\"),\n+                CallEntry('def my_function(_foo):'),\n                 LineEntry('x = 7'),\n                 VariableEntry('x', '7'),\n                 LineEntry('y = 8'),\n@@ -206,20 +209,23 @@ def test_file_output():\n             )\n         )\n \n+\n def test_confusing_decorator_lines():\n     string_io = io.StringIO()\n \n     def empty_decorator(function):\n         return function\n+\n     @empty_decorator\n     @pysnooper.snoop(string_io,\n-                     depth=2) # Multi-line decorator for extra confusion!\n+                     depth=2)  # Multi-line decorator for extra confusion!\n     @empty_decorator\n     @empty_decorator\n     def my_function(foo):\n         x = lambda bar: 7\n         y = 8\n         return y + x(foo)\n+\n     result = my_function('baba')\n     assert result == 15\n     output = string_io.getvalue()\n@@ -263,9 +269,10 @@ def test_lambda():\n         )\n     )\n \n+\n def test_unavailable_source():\n     with temp_file_tools.create_temp_folder(prefix='pysnooper') as folder, \\\n-                                       sys_tools.TempSysPathAdder(str(folder)):\n+            sys_tools.TempSysPathAdder(str(folder)):\n         module_name = 'iaerojajsijf'\n         python_file_path = folder / ('%s.py' % (module_name,))\n         content = ('import pysnooper\\n'\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 5c26e5f..191d1dc 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -30,6 +30,7 @@ class _BaseEntry(pysnooper.pycompat.ABC):\n     def check(self, s):\n         pass\n \n+\n class _BaseValueEntry(_BaseEntry):\n     def __init__(self, prefix=''):\n         _BaseEntry.__init__(self, prefix=prefix)\n@@ -68,7 +69,6 @@ class _BaseValueEntry(_BaseEntry):\n         )\n \n \n-\n class VariableEntry(_BaseValueEntry):\n     def __init__(self, name=None, value=None, stage=None, prefix='',\n                  name_regex=None, value_regex=None, ):\n@@ -98,7 +98,6 @@ class VariableEntry(_BaseValueEntry):\n         stage = match.group('stage')\n         return self._check_stage(stage)\n \n-\n     _content_pattern = re.compile(\n         r\"\"\"^(?P<name>[^ ]+) = (?P<value>.+)$\"\"\"\n     )\n@@ -133,6 +132,7 @@ class VariableEntry(_BaseValueEntry):\n         else:\n             return stage == self.stage\n \n+\n class ReturnValueEntry(_BaseValueEntry):\n     def __init__(self, value=None, value_regex=None, prefix=''):\n         _BaseValueEntry.__init__(self, prefix=prefix)\n@@ -150,7 +150,6 @@ class ReturnValueEntry(_BaseValueEntry):\n     def _check_preamble(self, preamble):\n         return bool(self._preamble_pattern.match(preamble))\n \n-\n     def _check_content(self, content):\n         return self._check_value(content)\n \n@@ -162,6 +161,7 @@ class ReturnValueEntry(_BaseValueEntry):\n         else:\n             return True\n \n+\n class _BaseEventEntry(_BaseEntry):\n     def __init__(self, source=None, source_regex=None, prefix=''):\n         _BaseEntry.__init__(self, prefix=prefix)\n@@ -179,7 +179,6 @@ class _BaseEventEntry(_BaseEntry):\n         self.source_regex = (None if source_regex is None else\n                              re.compile(source_regex))\n \n-\n     @caching.CachedProperty\n     def event_name(self):\n         return re.match('^[A-Z][a-z_]*', type(self).__name__).group(0).lower()\n@@ -201,22 +200,26 @@ class _BaseEventEntry(_BaseEntry):\n                 self._check_source(source))\n \n \n-\n class CallEntry(_BaseEventEntry):\n     pass\n \n+\n class LineEntry(_BaseEventEntry):\n     pass\n \n+\n class ReturnEntry(_BaseEventEntry):\n     pass\n \n+\n class ExceptionEntry(_BaseEventEntry):\n     pass\n \n+\n class OpcodeEntry(_BaseEventEntry):\n     pass\n \n+\n class OutputFailure(Exception):\n     pass\n \n"}
{"repo": "PySnooper", "commit": "08aea68d6a824282f9502fccc53e6be568dfb570", "diff": "diff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 28f0289..8578fb3 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -189,7 +189,8 @@ def test_file_output():\n             return y + x\n         result = my_function('baba')\n         assert result == 15\n-        output = path.open().read()\n+        with path.open() as output_file:\n+            output = output_file.read()\n         assert_output(\n             output,\n             (\n"}
{"repo": "PySnooper", "commit": "fbb2dbdd9d5f2b6585e91c5a76710881c59a7ca5", "diff": "diff --git a/tests/utils.py b/tests/utils.py\nindex b7dc1c1..5c26e5f 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -131,7 +131,7 @@ class VariableEntry(_BaseValueEntry):\n         if self.stage is None:\n             return stage in ('starting', 'new', 'modified')\n         else:\n-            return stage == self.value\n+            return stage == self.stage\n \n class ReturnValueEntry(_BaseValueEntry):\n     def __init__(self, value=None, value_regex=None, prefix=''):\n"}
{"repo": "PySnooper", "commit": "e4483bc31021d1e9a25dac151d9508ed644df17b", "diff": "diff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex b9ed9d1..760e16c 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -12,7 +12,7 @@ import six\n def get_shortish_repr(item):\n     r = repr(item)\n     if len(r) > 100:\n-        r = '{r[:97]}...'.format(**locals())\n+        r = '{truncated_r}...'.format(truncated_r=r[:97])\n     return r\n \n def get_local_reprs(frame, variables=()):\n"}
{"repo": "PySnooper", "commit": "15555ed760000b049aff8fecc79d29339c1224c3", "diff": "diff --git a/pysnooper/pysnooper.py b/pysnooper/pysnooper.py\nindex 8d0c6a7..19139d3 100644\n--- a/pysnooper/pysnooper.py\n+++ b/pysnooper/pysnooper.py\n@@ -23,7 +23,7 @@ def get_write_function(output):\n             stderr.write(s)\n     elif isinstance(output, (pycompat.PathLike, str)):\n         def write(s):\n-            with open(output_path, 'a') as output_file:\n+            with open(output, 'a') as output_file:\n                 output_file.write(s)\n     else:\n         assert isinstance(output, utils.WritableStream)\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 13f0401..27af77d 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -7,6 +7,7 @@ import abc\n \n from python_toolbox import caching\n from python_toolbox import sys_tools\n+from python_toolbox import temp_file_tools\n \n import pysnooper\n \n@@ -169,3 +170,30 @@ def test_method_and_prefix():\n         ),\n         prefix='ZZZ'\n     )\n+\n+def test_file_output():\n+\n+    with temp_file_tools.create_temp_folder(prefix='pysnooper') as folder:\n+        path = folder / 'foo.log'\n+        @pysnooper.snoop(str(path))\n+        def my_function(foo):\n+            x = 7\n+            y = 8\n+            return y + x\n+        result = my_function('baba')\n+        assert result == 15\n+        output = path.open().read()\n+        assert_output(\n+            output,\n+            (\n+                VariableEntry('foo', value_regex=\"u?'baba'\"),\n+                CallEntry(),\n+                LineEntry('x = 7'),\n+                VariableEntry('x', '7'),\n+                LineEntry('y = 8'),\n+                VariableEntry('y', '8'),\n+                LineEntry('return y + x'),\n+                ReturnEntry('return y + x'),\n+            )\n+        )\n+\n"}
{"repo": "PySnooper", "commit": "28a8b2449485bfeb8741e7c232b8e1c7b8f8134d", "diff": "diff --git a/pysnooper/pysnooper.py b/pysnooper/pysnooper.py\nindex 917fe00..73c5cb6 100644\n--- a/pysnooper/pysnooper.py\n+++ b/pysnooper/pysnooper.py\n@@ -21,38 +21,29 @@ from .tracer import Tracer\n def get_write_function(output):\n     if output is None:\n         def write(s):\n-            s += '\\n'\n-            if isinstance(s, bytes): # Python 2 compatibility\n-                s = s.decode('utf-8')\n             stderr = sys.stderr\n             stderr.write(s)\n     elif isinstance(output, (pycompat.PathLike, str)):\n         def write(s):\n-            s += '\\n'\n-            if isinstance(s, bytes): # Python 2 compatibility\n-                s = s.decode('utf-8')\n             with open(output_path, 'a') as output_file:\n                 output_file.write(s)\n     else:\n         assert isinstance(output, utils.WritableStream)\n         def write(s):\n-            s += '\\n'\n-            if isinstance(s, bytes): # Python 2 compatibility\n-                s = s.decode('utf-8')\n             output.write(s)\n             \n     return write\n     \n     \n \n-def snoop(output=None, variables=(), depth=1):\n+def snoop(output=None, variables=(), depth=1, prefix=''):\n     write = get_write_function(output)\n     @decorator.decorator\n     def decorate(function, *args, **kwargs):\n         target_code_object = function.__code__\n         with Tracer(target_code_object=target_code_object,\n                     write=write, variables=variables,\n-                    depth=depth):\n+                    depth=depth, prefix=prefix):\n             return function(*args, **kwargs)\n     \n     return decorate\ndiff --git a/pysnooper/tracer.py b/pysnooper/tracer.py\nindex e693ee0..c66d9f2 100644\n--- a/pysnooper/tracer.py\n+++ b/pysnooper/tracer.py\n@@ -96,14 +96,22 @@ def get_source_from_frame(frame):\n     return source\n \n class Tracer:\n-    def __init__(self, target_code_object, write, variables=(), depth=1):\n+    def __init__(self, target_code_object, write, variables=(), depth=1,\n+                 prefix=''):\n         self.target_code_object = target_code_object\n-        self.write = write\n+        self._write = write\n         self.variables = variables\n         self.frame_to_old_local_reprs = collections.defaultdict(lambda: {})\n         self.frame_to_local_reprs = collections.defaultdict(lambda: {})\n         self.depth = depth\n+        self.prefix = prefix\n         assert self.depth >= 1\n+        \n+    def write(self, s):\n+        s = '{self.prefix}{s}\\n'.format(**locals())\n+        if isinstance(s, bytes): # Python 2 compatibility\n+            s = s.decode()\n+        self._write(s)\n \n     def __enter__(self):\n         self.original_trace_function = sys.gettrace()\ndiff --git a/tests/test_pysnooper.py b/tests/test_pysnooper.py\nindex 5de04aa..5c7f7b3 100644\n--- a/tests/test_pysnooper.py\n+++ b/tests/test_pysnooper.py\n@@ -135,3 +135,37 @@ def test_depth():\n         )\n     )\n \n+\n+def test_method_and_prefix():\n+\n+    class Baz(object):\n+        def __init__(self):\n+            self.x = 2\n+            \n+        @pysnooper.snoop(variables=('self.x'), prefix='ZZZ')\n+        def square(self):\n+            foo = 7\n+            self.x **= 2\n+            return self\n+\n+    baz = Baz()\n+\n+    with sys_tools.OutputCapturer(stdout=False,\n+                                  stderr=True) as output_capturer:\n+        result = baz.square()\n+    assert result is baz\n+    assert result.x == 4\n+    output = output_capturer.string_io.getvalue()\n+    assert_output(\n+        output,\n+        (\n+            VariableEntry(),\n+            CallEntry(),\n+            LineEntry('foo = 7'), \n+            VariableEntry('foo', '7'),\n+            LineEntry('self.x **= 2'), \n+            LineEntry(), \n+            ReturnEntry(), \n+        ),\n+        prefix='ZZZ'\n+    )\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 638a098..6ecd24c 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -16,7 +16,8 @@ class _BaseEntry(pysnooper.pycompat.ABC):\n     \n class VariableEntry(_BaseEntry):\n     line_pattern = re.compile(\n-        r\"\"\"^(?P<indent>(?: {4})*)(?P<stage>New|Modified|Starting) var:\"\"\"\n+        r\"\"\"^(?P<prefix>.*?)(?P<indent>(?: {4})*)\"\"\"\n+        r\"\"\"(?P<stage>New|Modified|Starting) var:\"\"\"\n         r\"\"\"\\.{2,7} (?P<name>[^ ]+) = (?P<value>.+)$\"\"\"\n     )\n     def __init__(self, name=None, value=None, stage=None,\n@@ -62,7 +63,7 @@ class VariableEntry(_BaseEntry):\n         match = self.line_pattern.match(s)\n         if not match:\n             return False\n-        indent, stage, name, value = match.groups()\n+        _, _, stage, name, value = match.groups()\n         return (self._check_name(name) and self._check_value(value) and\n                 self._check_stage(stage))\n \n@@ -79,8 +80,9 @@ class _BaseEventEntry(_BaseEntry):\n                              re.compile(source_regex))\n \n     line_pattern = re.compile(\n-        (r\"\"\"^(?P<indent>(?: {4})*)[0-9:.]{15} (?P<event_name>[a-z]*) +\"\"\"\n-         r\"\"\"(?P<line_number>[0-9]*) +(?P<source>.*)$\"\"\")\n+        (r\"\"\"^(?P<prefix>.*?)(?P<indent>(?: {4})*)[0-9:.]{15} \"\"\"\n+         r\"\"\"(?P<event_name>[a-z]*) +(?P<line_number>[0-9]*) \"\"\"\n+         r\"\"\"+(?P<source>.*)$\"\"\")\n     )\n \n     @caching.CachedProperty\n@@ -99,7 +101,7 @@ class _BaseEventEntry(_BaseEntry):\n         match = self.line_pattern.match(s)\n         if not match:\n             return False\n-        indent, event_name, _, source = match.groups()\n+        _, _, event_name, _, source = match.groups()\n         return event_name == self.event_name and self._check_source(source)\n \n \n@@ -124,13 +126,18 @@ class OutputFailure(Exception):\n     pass\n         \n \n-def assert_output(output, expected_entries):\n+def assert_output(output, expected_entries, prefix=None):\n     lines = tuple(filter(None, output.split('\\n')))\n     if len(lines) != len(expected_entries):\n         raise OutputFailure(\n             'Output has {len(lines)} lines, while we expect '\n             '{len(expected_entries)} lines.'.format(**locals())\n         )\n+    if prefix is not None:\n+        for line in lines:\n+            if not line.startswith(prefix):\n+                raise OutputFailure(line)\n+                \n     for expected_entry, line in zip(expected_entries, lines):\n         if not expected_entry.check(line):\n             raise OutputFailure(line)\n"}
{"repo": "drgn", "commit": "bc3bfbdf4c7ebe8b1596c8354364f4b7fa3ebc55", "diff": "diff --git a/drgn/helpers/experimental/kmodify.py b/drgn/helpers/experimental/kmodify.py\nindex 196234c1..a28099e4 100644\n--- a/drgn/helpers/experimental/kmodify.py\n+++ b/drgn/helpers/experimental/kmodify.py\n@@ -427,8 +427,23 @@ class _ReturnIfLastReturnValueNonZero(NamedTuple):\n     value: _Integer\n \n \n+class _AtomicSetBit(NamedTuple):\n+    nr: int\n+    address: _Integer\n+\n+\n+class _AtomicClearBit(NamedTuple):\n+    nr: int\n+    address: _Integer\n+\n+\n _FunctionBodyNode = Union[\n-    _Call, _StoreReturnValue, _Return, _ReturnIfLastReturnValueNonZero\n+    _Call,\n+    _StoreReturnValue,\n+    _Return,\n+    _ReturnIfLastReturnValueNonZero,\n+    _AtomicSetBit,\n+    _AtomicClearBit,\n ]\n \n \n@@ -675,6 +690,20 @@ class _CodeGen_x86_64:\n         # The destination needs to be fixed up later.\n         self._epilogue_jumps.append(len(self.code))\n \n+    def atomic_set_bit(self, nr: int, address: _Integer) -> None:\n+        # mov $address, %rax\n+        self._mov_imm(address, self._rax)\n+        # lock; orb $(1 << nr), (%rax)\n+        self.code.extend(b\"\\xf0\\x80\\x08\")\n+        self.code.append(1 << nr)\n+\n+    def atomic_clear_bit(self, nr: int, address: _Integer) -> None:\n+        # mov $address, %rax\n+        self._mov_imm(address, self._rax)\n+        # lock; andb $~(1 << nr), (%rax)\n+        self.code.extend(b\"\\xf0\\x80\\x20\")\n+        self.code.append(0xFF ^ (1 << nr))\n+\n \n class _Arch_X86_64:\n     ELF_MACHINE = 62  # EM_X86_64\n@@ -715,6 +744,10 @@ class _Arch_X86_64:\n                 code_gen.return_(node.value, last=i == len(func.body) - 1)\n             elif isinstance(node, _ReturnIfLastReturnValueNonZero):\n                 code_gen.return_if_last_return_value_nonzero(node.value)\n+            elif isinstance(node, _AtomicSetBit):\n+                code_gen.atomic_set_bit(node.nr, node.address)\n+            elif isinstance(node, _AtomicClearBit):\n+                code_gen.atomic_clear_bit(node.nr, node.address)\n             else:\n                 assert_never(node)\n \n@@ -965,6 +998,19 @@ class _Kmodify:\n                 return 0\n \n \n+_COPY_TO_FROM_KERNEL_NOFAULT_NAMES = (\n+    # Names used since Linux kernel commit fe557319aa06 (\"maccess: rename\n+    # probe_kernel_{read,write} to copy_{from,to}_kernel_nofault\") (in\n+    # v5.8-rc2).\n+    (\"copy_to_kernel_nofault\", \"copy_from_kernel_nofault\"),\n+    # Names used before Linux kernel commit 48c49c0e5f31 (\"maccess: remove\n+    # various unused weak aliases\") (in v5.8-rc1).\n+    (\"__probe_kernel_write\", \"__probe_kernel_read\"),\n+    # Names briefly used between those two commits.\n+    (\"probe_kernel_write\", \"probe_kernel_read\"),\n+)\n+\n+\n @takes_program_or_default\n def write_memory(prog: Program, address: IntegerLike, value: bytes) -> None:\n     \"\"\"\n@@ -989,17 +1035,10 @@ def write_memory(prog: Program, address: IntegerLike, value: bytes) -> None:\n     \"\"\"\n     copy_to_kernel_nofault_address = None\n     copy_from_kernel_nofault_address = None\n-    for copy_to_kernel_nofault, copy_from_kernel_nofault in (\n-        # Names used since Linux kernel commit fe557319aa06 (\"maccess: rename\n-        # probe_kernel_{read,write} to copy_{from,to}_kernel_nofault\") (in\n-        # v5.8-rc2).\n-        (\"copy_to_kernel_nofault\", \"copy_from_kernel_nofault\"),\n-        # Names used before Linux kernel commit 48c49c0e5f31 (\"maccess: remove\n-        # various unused weak aliases\") (in v5.8-rc1).\n-        (\"__probe_kernel_write\", \"__probe_kernel_read\"),\n-        # Names briefly used between those two commits.\n-        (\"probe_kernel_write\", \"probe_kernel_read\"),\n-    ):\n+    for (\n+        copy_to_kernel_nofault,\n+        copy_from_kernel_nofault,\n+    ) in _COPY_TO_FROM_KERNEL_NOFAULT_NAMES:\n         try:\n             copy_to_kernel_nofault_address = prog[copy_to_kernel_nofault].address_\n             copy_from_kernel_nofault_address = prog[copy_from_kernel_nofault].address_\n@@ -1084,6 +1123,77 @@ def write_memory(prog: Program, address: IntegerLike, value: bytes) -> None:\n             raise ValueError(\"module init did not run\")\n \n \n+def _modify_bit(prog: Program, nr: int, address: int, value: bool) -> None:\n+    # This and the codegen representations are all in terms of bytes.\n+    assert 0 <= nr < 8\n+\n+    copy_from_kernel_nofault_address = None\n+    for _, copy_from_kernel_nofault in _COPY_TO_FROM_KERNEL_NOFAULT_NAMES:\n+        try:\n+            copy_from_kernel_nofault_address = prog[copy_from_kernel_nofault].address_\n+            break\n+        except KeyError:\n+            pass\n+    if copy_from_kernel_nofault_address is None:\n+        raise LookupError(\"copy_from_kernel_nofault not found\")\n+    sizeof_int = sizeof(prog.type(\"int\"))\n+    sizeof_void_p = sizeof(prog.type(\"void *\"))\n+    sizeof_size_t = sizeof(prog.type(\"size_t\"))\n+\n+    kmodify = _Kmodify(prog)\n+    if not kmodify.is_little_endian:\n+        # Big-endian needs different calculations. kmodify only supports\n+        # little-endian architectures at the moment anyways.\n+        raise NotImplementedError(\"_modify_bit() is only implemented for little-endian\")\n+    code, code_relocations = kmodify.arch.code_gen(\n+        _Function(\n+            [\n+                _Call(\n+                    # Catch invalid addresses instead of crashing. Note that\n+                    # this won't catch read-only addresses, unfortunately.\n+                    _Symbol(copy_from_kernel_nofault),\n+                    [\n+                        _Symbol(\".data\", section=True),\n+                        _Integer(sizeof_void_p, address),\n+                        _Integer(sizeof_size_t, 1),\n+                    ],\n+                ),\n+                _ReturnIfLastReturnValueNonZero(\n+                    _Integer(sizeof_int, -errno.EFAULT),\n+                ),\n+                (_AtomicSetBit if value else _AtomicClearBit)(\n+                    nr, _Integer(sizeof_void_p, address)\n+                ),\n+                _Return(_Integer(sizeof_int, -errno.EINPROGRESS)),\n+            ]\n+        )\n+    )\n+    ret = kmodify.insert(\n+        name=\"set_bit\" if value else \"clear_bit\",\n+        code=code,\n+        code_relocations=code_relocations,\n+        data=b\"\\0\",\n+        data_alignment=1,\n+        symbols=[\n+            _ElfSymbol(\n+                name=copy_from_kernel_nofault,\n+                value=copy_from_kernel_nofault_address,\n+                size=0,\n+                type=STT.FUNC,\n+                binding=STB.LOCAL,\n+                section=SHN.ABS,\n+            ),\n+        ],\n+    )\n+    if ret != -errno.EINPROGRESS:\n+        if ret == -errno.EFAULT:\n+            raise FaultError(\"could not write to memory\", address)\n+        elif ret:\n+            raise OSError(-ret, os.strerror(-ret))\n+        else:\n+            raise ValueError(\"module init did not run\")\n+\n+\n def write_object(\n     object: Object, value: Any, *, dereference: Optional[bool] = None\n ) -> None:\n@@ -1096,6 +1206,10 @@ def write_object(\n     >>> os.system(\"uptime -p\")\n     up 3 decades, 1 year, 37 weeks, 1 hour, 59 minutes\n \n+    Bit fields are currently only supported if they are either byte-aligned or\n+    a single bit. Writes to a bit field are atomic with respect to other bit\n+    fields.\n+\n     .. warning::\n         The warnings about :func:`write_memory()` also apply to\n         ``write_object()``.\n@@ -1113,6 +1227,8 @@ def write_object(\n     :raises TypeError: if *object* is a pointer and *dereference* is not given\n     :raises TypeError: if *object* is not a pointer and *dereference* is\n         ``True``\n+    :raises NotImplementedError: if *object* is a bit field that is not\n+        byte-aligned or a single bit\n     \"\"\"\n     type = object.type_\n     if type.unaliased_kind() == TypeKind.POINTER:\n@@ -1129,11 +1245,23 @@ def write_object(\n     address = object.address_\n     if address is None:\n         raise ValueError(\"cannot write to value object\")\n+\n+    bit_field_size = object.bit_field_size_\n     if isinstance(value, Object):\n-        value = implicit_convert(type, value)\n+        value = implicit_convert(type, value, bit_field_size=bit_field_size)\n+    else:\n+        value = Object(object.prog_, type, value, bit_field_size=bit_field_size)\n+\n+    if bit_field_size is None:\n+        bit_field_size = 0\n+    bit_offset: int = object.bit_offset_  # type: ignore[assignment]  # address_ is not None, so bit_offset_ is not, either.\n+\n+    if bit_field_size % 8 == 0 and bit_offset % 8 == 0:\n+        write_memory(object.prog_, address, value.to_bytes_())\n+    elif bit_field_size == 1:\n+        _modify_bit(object.prog_, bit_offset, address, bool(value))\n     else:\n-        value = Object(object.prog_, type, value)\n-    write_memory(object.prog_, address, value.to_bytes_())\n+        raise NotImplementedError(\"only byte-aligned or 1-bit bit fields are supported\")\n \n \n def _default_argument_promotions(obj: Object) -> Object:\ndiff --git a/tests/linux_kernel/helpers/test_kmodify.py b/tests/linux_kernel/helpers/test_kmodify.py\nindex 6c0c183f..db31f595 100644\n--- a/tests/linux_kernel/helpers/test_kmodify.py\n+++ b/tests/linux_kernel/helpers/test_kmodify.py\n@@ -323,3 +323,41 @@ class TestWriteObject(LinuxKernelTestCase):\n             0,\n             dereference=True,\n         )\n+\n+    def test_bit_field_size_1(self):\n+        for i in range(3):\n+            with self.subTest(i=i):\n+                write_object(self.prog[\"drgn_kmodify_test_bit_field\"].bit, i)\n+                self.assertFalse(self.prog[\"drgn_kmodify_test_bit_field\"].expect0_1)\n+                self.assertTrue(self.prog[\"drgn_kmodify_test_bit_field\"].expect1_1)\n+                self.assertEqual(\n+                    self.prog[\"drgn_kmodify_test_bit_field\"].bit.value_(), i % 2\n+                )\n+                self.assertFalse(self.prog[\"drgn_kmodify_test_bit_field\"].expect0_2)\n+                self.assertTrue(self.prog[\"drgn_kmodify_test_bit_field\"].expect1_2)\n+\n+    def test_byte_aligned_bit_field(self):\n+        for i in range(3):\n+            with self.subTest(i=i):\n+                write_object(self.prog[\"drgn_kmodify_test_bit_field\"].byte_aligned, i)\n+                self.assertFalse(self.prog[\"drgn_kmodify_test_bit_field\"].expect0_1)\n+                self.assertTrue(self.prog[\"drgn_kmodify_test_bit_field\"].expect1_1)\n+                self.assertEqual(\n+                    self.prog[\"drgn_kmodify_test_bit_field\"].byte_aligned.value_(), i\n+                )\n+                self.assertFalse(self.prog[\"drgn_kmodify_test_bit_field\"].expect0_2)\n+                self.assertTrue(self.prog[\"drgn_kmodify_test_bit_field\"].expect1_2)\n+\n+    def test_unsupported_bit_field(self):\n+        self.assertRaises(\n+            NotImplementedError,\n+            write_object,\n+            self.prog[\"drgn_kmodify_test_bit_field\"].two_bits,\n+            1,\n+        )\n+        self.assertRaises(\n+            NotImplementedError,\n+            write_object,\n+            self.prog[\"drgn_kmodify_test_bit_field\"].unaligned,\n+            1,\n+        )\n"}
{"repo": "drgn", "commit": "d670ab7399559a2b0446a56792c33736b48e8d2c", "diff": "diff --git a/docs/exts/drgndoc/commands.py b/docs/exts/drgndoc/commands.py\nindex 675f1209..010bc52f 100644\n--- a/docs/exts/drgndoc/commands.py\n+++ b/docs/exts/drgndoc/commands.py\n@@ -392,7 +392,7 @@ class CommandFormatter:\n             dest_node = _get_kwarg(node, \"dest\")\n             if dest_node is None:\n                 if positional:\n-                    arg_names = (option_names[0],)\n+                    arg_names: Sequence[str] = (option_names[0],)\n                 else:\n                     for option_name in option_names:\n                         if option_name.startswith(\"--\"):\n"}
{"repo": "drgn", "commit": "b63a69edccfd7bc8d9c904676ad2a670d97eda43", "diff": "diff --git a/tests/linux_kernel/helpers/test_common.py b/tests/linux_kernel/helpers/test_common.py\nindex e773c2d6..d9b754d2 100644\n--- a/tests/linux_kernel/helpers/test_common.py\n+++ b/tests/linux_kernel/helpers/test_common.py\n@@ -228,13 +228,10 @@ class TestIdentifyAddress(LinuxKernelTestCase):\n     @skip_unless_have_test_kmod\n     def test_identify_unrecognized(self):\n         start_addr = (pfn_to_virt(self.prog[\"min_low_pfn\"])).value_()\n-        end_addr = (pfn_to_virt(self.prog[\"max_pfn\"]) + self.prog[\"PAGE_SIZE\"]).value_()\n-\n         # On s390x, the start address is 0, and identify_address() doesn't\n         # allow a negative address.\n         if start_addr > 0:\n             self.assertIsNone(identify_address(self.prog, start_addr - 1))\n-        self.assertIsNone(identify_address(self.prog, end_addr))\n         self.assertIsNone(identify_address(self.prog, self.prog[\"drgn_test_va\"]))\n \n \n"}
{"repo": "drgn", "commit": "ebd9c4d0108b5509a63427a62bbc41d96ea04e79", "diff": "diff --git a/drgn/commands/_builtin/crash/_kmem.py b/drgn/commands/_builtin/crash/_kmem.py\nindex a42dc601..8ce3d717 100644\n--- a/drgn/commands/_builtin/crash/_kmem.py\n+++ b/drgn/commands/_builtin/crash/_kmem.py\n@@ -1292,11 +1292,20 @@ if cache:\n         code.append(\n             \"\"\"\\\n     objsize = cache.object_size\n-    usage = slab_cache_usage(cache)\n-    allocated = usage.active_objs\n-    total = usage.num_objs\n-    slabs = usage.num_slabs\n-    ssize = prog[\"PAGE_SIZE\"] * slab_cache_pages_per_slab(cache)\n+    try:\n+        usage = slab_cache_usage(cache)\n+    except ValueError:\n+        # SLUB without SLUB_DEBUG and SLOB do not support slab_cache_usage().\n+        pass\n+    else:\n+        allocated = usage.active_objs\n+        total = usage.num_objs\n+        slabs = usage.num_slabs\n+    try:\n+        ssize = prog[\"PAGE_SIZE\"] * slab_cache_pages_per_slab(cache)\n+    except ValueError:\n+        # SLOB does not support slab_cache_pages_per_slab().\n+        pass\n \"\"\"\n         )\n         code.print()\n@@ -1338,17 +1347,34 @@ if cache:\n         else:\n             objsize = cache.object_size.value_()\n             try:\n-                usage = slab_cache_usage(cache)\n-            except (FaultError, ValidationError):\n-                allocated: Any = \"[CORRUPTED]\"\n+                order = slab_cache_order(cache)\n+            except ValueError:\n+                # SLOB doesn't support slab_cache_order() or\n+                # slab_cache_usage().\n+                allocated: Any = \"[UNKNOWN]\"\n                 total: Any = \"\"\n                 slabs: Any = \"\"\n+                ssize: Any = \"\"\n             else:\n-                allocated = usage.active_objs\n-                total = usage.num_objs\n-                slabs = usage.num_slabs\n-            ssize = prog[\"PAGE_SIZE\"].value_() << slab_cache_order(cache)\n-            ssize_cell = CellFormat(f\"{ssize // 1024}k\", \">\")\n+                ssize = CellFormat(\n+                    f\"{(prog['PAGE_SIZE'].value_() << order) // 1024}k\", \">\"\n+                )\n+                # SLUB without SLUB_DEBUG supports slab_cache_order() but not\n+                # slab_cache_usage().\n+                try:\n+                    usage = slab_cache_usage(cache)\n+                except ValueError:\n+                    allocated = \"[UNKNOWN]\"\n+                    total = \"\"\n+                    slabs = \"\"\n+                except (FaultError, ValidationError):\n+                    allocated = \"[CORRUPTED]\"\n+                    total = \"\"\n+                    slabs = \"\"\n+                else:\n+                    allocated = usage.active_objs\n+                    total = usage.num_objs\n+                    slabs = usage.num_slabs\n             rows.append(\n                 (\n                     CellFormat(cache.value_(), \"<x\"),\n@@ -1356,7 +1382,7 @@ if cache:\n                     allocated,\n                     total,\n                     slabs,\n-                    ssize_cell,\n+                    ssize,\n                     escape_ascii_string(cache.name.string_(), escape_backslash=True),\n                 )\n             )\n@@ -1548,9 +1574,15 @@ def _kmem_identify(\n                         print(\n                             f\"kmem: ignoring pre-selected slab caches for address: {address:x}\"\n                         )\n-                    _kmem_slab(\n-                        prog, False, ignore=ignore_slab_caches, identified=identified\n-                    )\n+                    if identified.slab_object_info.address:\n+                        _kmem_slab(\n+                            prog,\n+                            False,\n+                            ignore=ignore_slab_caches,\n+                            identified=identified,\n+                        )\n+                    else:\n+                        print(f\"kmem: address is from SLOB: {address:x}\")\n \n         if not found_vmap and mode == \"vmalloc\":\n             print_divider()\ndiff --git a/tests/linux_kernel/crash_commands/test_kmem.py b/tests/linux_kernel/crash_commands/test_kmem.py\nindex 091a0924..5b747cb1 100644\n--- a/tests/linux_kernel/crash_commands/test_kmem.py\n+++ b/tests/linux_kernel/crash_commands/test_kmem.py\n@@ -5,7 +5,6 @@ import os\n from pathlib import Path\n import re\n import tempfile\n-import unittest\n \n from drgn import Object\n from drgn.commands import CommandArgumentError\n@@ -17,11 +16,8 @@ from tests.linux_kernel.crash_commands import CrashCommandTestCase\n from tests.linux_kernel.helpers.test_slab import fallback_slab_cache_names\n from util import KernelVersion\n \n-skip_unless_kmem_s_supported = unittest.skipUnless(\n-    # Good enough approximation for kmem -s support.\n-    Path(\"/proc/slabinfo\").exists(),\n-    \"kmem -s requires CONFIG_SLUB_DEBUG/!CONFIG_SLOB\",\n-)\n+# Good enough approximation for full kmem -s support.\n+have_full_kmem_s_support = Path(\"/proc/slabinfo\").exists()\n \n \n class TestKmem(CrashCommandTestCase):\n@@ -382,91 +378,92 @@ class TestKmem(CrashCommandTestCase):\n         for variable in (\"mapping\", \"private\", \"_refcount\", \"lru\", \"flags\"):\n             self.assertIsInstance(drgn_option_globals[variable], Object)\n \n-    def _test_s_common(self, cmd):\n+    def check_kmem_s(self, options, check_common=True):\n+        cmd = self.check_crash_command(\"kmem -s \" + options)\n         self.assertEqual(\n             cmd.drgn_option.globals[\"cache\"].type_.type_name(), \"struct kmem_cache *\"\n         )\n-        for variable in (\n-            \"objsize\",\n-            \"usage\",\n-            \"allocated\",\n-            \"total\",\n-            \"slabs\",\n-            \"ssize\",\n-            \"name\",\n-        ):\n-            self.assertIn(variable, cmd.drgn_option.globals)\n+        if check_common:\n+            for variable in (\n+                \"objsize\",\n+                \"name\",\n+            ):\n+                self.assertIn(variable, cmd.drgn_option.globals)\n+            if have_full_kmem_s_support:\n+                for variable in (\n+                    \"usage\",\n+                    \"allocated\",\n+                    \"total\",\n+                    \"slabs\",\n+                    \"ssize\",\n+                    \"name\",\n+                ):\n+                    self.assertIn(variable, cmd.drgn_option.globals)\n+        return cmd\n \n-    @skip_unless_kmem_s_supported\n     def test_s(self):\n-        cmd = self.check_crash_command(\"kmem -s\")\n+        cmd = self.check_kmem_s(\"\")\n \n         for name in fallback_slab_cache_names(self.prog):\n-            self.assertRegex(cmd.stdout, rf\"\\b{re.escape(name.decode())}\\b\")\n+            if have_full_kmem_s_support:\n+                self.assertRegex(cmd.stdout, rf\"[0-9]+k\\s+{re.escape(name.decode())}\\b\")\n+            else:\n+                self.assertRegex(cmd.stdout, rf\"\\b{re.escape(name.decode())}\\b\")\n \n         self.assertIn(\"for_each_slab_cache(\", cmd.drgn_option.stdout)\n-        self._test_s_common(cmd)\n \n-    @skip_unless_kmem_s_supported\n     def test_s_match_one(self):\n         names = sorted(name.decode() for name in fallback_slab_cache_names(self.prog))\n-        cmd = self.check_crash_command(f\"kmem -s {names[0]}\")\n+        cmd = self.check_kmem_s(names[0])\n \n-        self.assertRegex(cmd.stdout, rf\"\\b{re.escape(names[0])}\\b\")\n+        if have_full_kmem_s_support:\n+            self.assertRegex(cmd.stdout, rf\"[0-9]+k\\s+{re.escape(names[0])}\\b\")\n+        else:\n+            self.assertRegex(cmd.stdout, rf\"\\b{re.escape(names[0])}\\b\")\n         self.assertNotRegex(cmd.stdout, rf\"\\b{re.escape(names[1])}\\b\")\n \n         self.assertIn('find_slab_cache(\"', cmd.drgn_option.stdout)\n-        self._test_s_common(cmd)\n \n-    @skip_unless_kmem_s_supported\n     def test_s_match_multiple(self):\n         names = sorted(name.decode() for name in fallback_slab_cache_names(self.prog))\n-        cmd = self.check_crash_command(f\"kmem -s {' '.join(names)}\")\n+        cmd = self.check_kmem_s(\" \".join(names))\n \n         for name in names:\n-            self.assertRegex(cmd.stdout, rf\"\\b{re.escape(name)}\\b\")\n+            if have_full_kmem_s_support:\n+                self.assertRegex(cmd.stdout, rf\"[0-9]+k\\s+{re.escape(name)}\\b\")\n+            else:\n+                self.assertRegex(cmd.stdout, rf\"\\b{re.escape(name)}\\b\")\n \n         self.assertIn(\"find_slab_cache(search_name)\", cmd.drgn_option.stdout)\n-        self._test_s_common(cmd)\n \n-    @skip_unless_kmem_s_supported\n     def test_s_ignore_one(self):\n         ignore = min(fallback_slab_cache_names(self.prog)).decode()\n-        cmd = self.check_crash_command(f\"kmem -s -I {ignore}\")\n+        cmd = self.check_kmem_s(f\"-I {ignore}\")\n \n         self.assertRegex(cmd.stdout, rf\"\\[IGNORED\\].*\\b{re.escape(ignore)}\\b\")\n \n         self.assertIn(\"for_each_slab_cache(\", cmd.drgn_option.stdout)\n         self.assertRegex(cmd.drgn_option.stdout, rf\"== .*\\b{re.escape(ignore)}\\b\")\n-        self._test_s_common(cmd)\n \n-    @skip_unless_kmem_s_supported\n     def test_s_ignore_multiple(self):\n         names = sorted(name.decode() for name in fallback_slab_cache_names(self.prog))\n-        cmd = self.check_crash_command(f\"kmem -s -I {','.join(names)}\")\n+        cmd = self.check_kmem_s(f\"-I {','.join(names)}\", check_common=False)\n \n         for name in names:\n             self.assertRegex(cmd.stdout, rf\"\\[IGNORED\\].*\\b{re.escape(name)}\\b\")\n \n         self.assertIn(\"for_each_slab_cache(\", cmd.drgn_option.stdout)\n         self.assertIn(\" in ignore:\", cmd.drgn_option.stdout)\n-        self.assertEqual(\n-            cmd.drgn_option.globals[\"cache\"].type_.type_name(), \"struct kmem_cache *\"\n-        )\n \n-    @skip_unless_kmem_s_supported\n     def test_s_match_and_ignore(self):\n         names = sorted(name.decode() for name in fallback_slab_cache_names(self.prog))\n-        cmd = self.check_crash_command(f\"kmem -s {names[0]} -I {names[0]}\")\n+        cmd = self.check_kmem_s(f\"{names[0]} -I {names[0]}\", check_common=False)\n \n         self.assertRegex(cmd.stdout, rf\"\\[IGNORED\\].*\\b{re.escape(names[0])}\\b\")\n         self.assertNotRegex(cmd.stdout, rf\"\\b{re.escape(names[1])}\\b\")\n \n         self.assertIn(\"find_slab_cache(\", cmd.drgn_option.stdout)\n         self.assertRegex(cmd.drgn_option.stdout, rf\"== .*\\b{re.escape(names[0])}\\b\")\n-        self.assertEqual(\n-            cmd.drgn_option.globals[\"cache\"].type_.type_name(), \"struct kmem_cache *\"\n-        )\n \n     def test_g_value(self):\n         value = (1 << self.prog[\"PG_locked\"].value_()) | (\n@@ -551,8 +548,13 @@ class TestKmem(CrashCommandTestCase):\n         for option in (\"\", \" -s\"):\n             with self.subTest(option=option):\n                 cmd = self.run_crash_command(f\"kmem{option} {address + 1:x}\")\n-                self.assertIn(\"drgn_test_small\", cmd.stdout)\n-                self.assertIn(f\"[{address:x}]\", cmd.stdout)\n+                if self.prog[\"drgn_test_slob\"]:\n+                    self.assertIn(\n+                        f\"kmem: address is from SLOB: {address + 1:x}\", cmd.stdout\n+                    )\n+                else:\n+                    self.assertIn(\"drgn_test_small\", cmd.stdout)\n+                    self.assertIn(f\"[{address:x}]\", cmd.stdout)\n \n     @skip_unless_have_test_kmod\n     def test_identify_not_slab(self):\n@@ -566,16 +568,22 @@ class TestKmem(CrashCommandTestCase):\n         address = self.prog[\"drgn_test_small_slab_objects\"][0].value_()\n         cmd = self.run_crash_command(f\"kmem -s drgn_test_big {address + 1:x}\")\n         self.assertIn(\"ignoring pre-selected slab caches for address\", cmd.stdout)\n-        self.assertIn(\"drgn_test_small\", cmd.stdout)\n-        self.assertIn(f\"[{address:x}]\", cmd.stdout)\n+        if self.prog[\"drgn_test_slob\"]:\n+            self.assertIn(f\"kmem: address is from SLOB: {address + 1:x}\", cmd.stdout)\n+        else:\n+            self.assertIn(\"drgn_test_small\", cmd.stdout)\n+            self.assertIn(f\"[{address:x}]\", cmd.stdout)\n \n     @skip_unless_have_test_kmod\n     def test_identify_slab_ignored(self):\n         address = self.prog[\"drgn_test_small_slab_objects\"][0].value_()\n         cmd = self.run_crash_command(f\"kmem -s -I drgn_test_small {address + 1:x}\")\n-        self.assertIn(\"drgn_test_small\", cmd.stdout)\n-        self.assertIn(\"[IGNORED]\", cmd.stdout)\n-        self.assertNotIn(f\"[{address:x}]\", cmd.stdout)\n+        if self.prog[\"drgn_test_slob\"]:\n+            self.assertIn(f\"kmem: address is from SLOB: {address + 1:x}\", cmd.stdout)\n+        else:\n+            self.assertIn(\"drgn_test_small\", cmd.stdout)\n+            self.assertIn(\"[IGNORED]\", cmd.stdout)\n+            self.assertNotIn(f\"[{address:x}]\", cmd.stdout)\n \n     @skip_unless_have_test_kmod\n     def test_identify_multiple(self):\n@@ -586,8 +594,9 @@ class TestKmem(CrashCommandTestCase):\n         self.assertIn(\"VMAP_AREA\", cmd.stdout)\n         self.assertIn(f\"{vmalloc_address:x}\", cmd.stdout)\n \n-        self.assertIn(\"drgn_test_small\", cmd.stdout)\n-        self.assertIn(f\"[{slab_address:x}]\", cmd.stdout)\n+        if not self.prog[\"drgn_test_slob\"]:\n+            self.assertIn(\"drgn_test_small\", cmd.stdout)\n+            self.assertIn(f\"[{slab_address:x}]\", cmd.stdout)\n \n         self.assertIn(\"identify_address\", cmd.drgn_option.globals)\n         self.assertTrue(cmd.drgn_option.globals[\"identified\"])\n"}
{"repo": "drgn", "commit": "6e9a68abfce38b7654b62eb74ce274eb6ad5e388", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex ff1da3ae..3b8a08e0 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -295,6 +295,14 @@ class SlabPartialListError(SlabCorruptionError):\n     \"\"\"\n \n \n+# Get the name of a slab cache or fall back to a placeholder.\n+def _slab_cache_name(slab_cache: Object) -> str:\n+    try:\n+        return os.fsdecode(slab_cache.name.string_())\n+    except FaultError:\n+        return \"slab cache\"\n+\n+\n # Between SLUB, SLAB, their respective configuration options, and the\n # differences between kernel versions, there is a lot of state that we need to\n # keep track of to inspect the slab allocator. It isn't pretty, but this class\n@@ -371,7 +379,7 @@ class _SlabCacheHelperSlub(_SlabCacheHelper):\n                         # beginning of the list.\n                         break\n                     e = SlabFreelistCycleError(\n-                        f\"{os.fsdecode(self._slab_cache.name.string_())} {freelist_name()} \"\n+                        f\"{_slab_cache_name(self._slab_cache)} {freelist_name()} \"\n                         \"freelist contains cycle; \"\n                         \"may be corrupted or in the middle of update\"\n                     )\n@@ -478,7 +486,7 @@ class _SlabCacheHelperSlub(_SlabCacheHelper):\n                         # beginning of the list.\n                         break\n                     raise SlabPartialListError(\n-                        f\"{os.fsdecode(self._slab_cache.name.string_())} cpu {cpu} \"\n+                        f\"{_slab_cache_name(self._slab_cache)} cpu {cpu} \"\n                         \"partial slabs count not decreasing; \"\n                         \"may be corrupted or in the middle of update\"\n                     )\n"}
{"repo": "drgn", "commit": "40339982cdec40d2a232a4296cae041126e16df4", "diff": "diff --git a/tests/linux_kernel/helpers/test_fs.py b/tests/linux_kernel/helpers/test_fs.py\nindex 252536b0..daec71fb 100644\n--- a/tests/linux_kernel/helpers/test_fs.py\n+++ b/tests/linux_kernel/helpers/test_fs.py\n@@ -43,10 +43,12 @@ class TestFs(LinuxKernelTestCase):\n         self.assertEqual(d_path(task.fs.pwd.address_of_()), os.fsencode(os.getcwd()))\n \n     def test_d_path_dentry_only(self):\n-        # This test could fail if we are running inside a container or if we are\n-        # in a bind mount.\n-        task = find_task(self.prog, os.getpid())\n-        self.assertEqual(d_path(task.fs.pwd.dentry), os.fsencode(os.getcwd()))\n+        # Since d_path(dentry) picks an arbitrary mount containing the dentry,\n+        # this should be a directory that is unlikely to be bind mounted\n+        # anywhere else.\n+        with tempfile.NamedTemporaryFile(dir=\"/dev/shm\") as f:\n+            dentry = fget(find_task(self.prog, os.getpid()), f.fileno()).f_path.dentry\n+            self.assertEqual(d_path(dentry), os.fsencode(f.name))\n \n     def test_d_path_no_internal_mount(self):\n         if not os.path.isdir(\"/sys/kernel/tracing\"):\n"}
{"repo": "drgn", "commit": "a1bb1e70f50042b500e0afbb572384c6ba778935", "diff": "diff --git a/drgn/helpers/linux/common.py b/drgn/helpers/linux/common.py\nindex 0cc27b9b..112bffb3 100644\n--- a/drgn/helpers/linux/common.py\n+++ b/drgn/helpers/linux/common.py\n@@ -340,6 +340,13 @@ def _identify_kernel_address(\n         direct_map = False\n \n     if direct_map:\n+        if \"vmemmap\" not in prog:\n+            # Without vmemmap, pages are in the direct mapping.\n+            identified = _identify_page(prog, addr, cache)\n+            if identified is not None:\n+                yield identified\n+                return\n+\n         result = _find_containing_slab(prog, addr)\n         if result is not None:\n             slab_cache, page, slab = result\n@@ -367,8 +374,10 @@ def _identify_kernel_address(\n             # address is in a stack.\n             yield from _identify_task_stack(prog, addr, cache)\n     else:\n-        identified = _identify_page(prog, addr, cache)\n-        if identified is not None:\n-            yield identified\n-            return\n+        if \"vmemmap\" in prog:\n+            # With vmemmap, pages are outside of the direct mapping.\n+            identified = _identify_page(prog, addr, cache)\n+            if identified is not None:\n+                yield identified\n+                return\n         yield from _identify_vmap(prog, addr, cache)\n"}
{"repo": "drgn", "commit": "42eba6d2bd764c62528e4bf1efc4ace93c21cf01", "diff": "diff --git a/drgn/commands/_builtin/crash/__init__.py b/drgn/commands/_builtin/crash/__init__.py\nindex 230fb100..4ddab1d1 100644\n--- a/drgn/commands/_builtin/crash/__init__.py\n+++ b/drgn/commands/_builtin/crash/__init__.py\n@@ -7,7 +7,7 @@ from typing import Any, Dict\n \n from drgn import Program\n from drgn.commands import Command, CommandNotFoundError, _write_command_error, argument\n-from drgn.commands._builtin.crash.system import _SysPrinter\n+from drgn.commands._builtin.crash._sys import _SysPrinter\n from drgn.commands.crash import CRASH_COMMAND_NAMESPACE, crash_command\n from drgn.commands.linux import linux_kernel_custom_command\n \ndiff --git a/drgn/commands/_builtin/crash/context.py b/drgn/commands/_builtin/crash/_context.py\nsimilarity index 99%\nrename from drgn/commands/_builtin/crash/context.py\nrename to drgn/commands/_builtin/crash/_context.py\nindex d0e9e59e..b8b26e32 100644\n--- a/drgn/commands/_builtin/crash/context.py\n+++ b/drgn/commands/_builtin/crash/_context.py\n@@ -14,7 +14,7 @@ from drgn.commands import (\n     drgn_argument,\n     mutually_exclusive_group,\n )\n-from drgn.commands._builtin.crash.system import _SysPrinter\n+from drgn.commands._builtin.crash._sys import _SysPrinter\n from drgn.commands.crash import (\n     CrashDrgnCodeBuilder,\n     _crash_get_panic_context,\ndiff --git a/drgn/commands/_builtin/crash/fs.py b/drgn/commands/_builtin/crash/_fs.py\nsimilarity index 100%\nrename from drgn/commands/_builtin/crash/fs.py\nrename to drgn/commands/_builtin/crash/_fs.py\ndiff --git a/drgn/commands/_builtin/crash/structunion.py b/drgn/commands/_builtin/crash/_struct.py\nsimilarity index 100%\nrename from drgn/commands/_builtin/crash/structunion.py\nrename to drgn/commands/_builtin/crash/_struct.py\ndiff --git a/drgn/commands/_builtin/crash/system.py b/drgn/commands/_builtin/crash/_sys.py\nsimilarity index 100%\nrename from drgn/commands/_builtin/crash/system.py\nrename to drgn/commands/_builtin/crash/_sys.py\n"}
{"repo": "drgn", "commit": "a9da25c266524688941691ffef89c0729eed058a", "diff": "diff --git a/drgn/commands/_builtin/crash/_mm.py b/drgn/commands/_builtin/crash/_mm.py\nindex 6331b937..dbdd39ea 100644\n--- a/drgn/commands/_builtin/crash/_mm.py\n+++ b/drgn/commands/_builtin/crash/_mm.py\n@@ -340,10 +340,7 @@ expected_free_pages = nr_free_pages()\n     print(f\"\\nnr_free_pages: {free_pages}  ({verified})\")\n \n \n-def _kmem_info(\n-    prog: Program,\n-    drgn_arg: bool,\n-) -> None:\n+def _kmem_info(prog: Program, drgn_arg: bool) -> None:\n     if drgn_arg:\n         code = CrashDrgnCodeBuilder(prog)\n         code.add_from_import(\"drgn.helpers.linux.block\", \"nr_blockdev_pages\")\n@@ -510,10 +507,7 @@ committed = vm_memory_committed()\n     print_table(rows)\n \n \n-def _kmem_vmalloc(\n-    prog: Program,\n-    drgn_arg: bool,\n-) -> None:\n+def _kmem_vmalloc(prog: Program, drgn_arg: bool) -> None:\n     if drgn_arg:\n         sys.stdout.write(\n             \"\"\"\\\n@@ -923,10 +917,7 @@ if \"memory_subsys\" in prog:  # Check for CONFIG_MEMORY_HOTPLUG.\n         print_table(rows)\n \n \n-def _kmem_per_cpu_offset(\n-    prog: Program,\n-    drgn_arg: bool,\n-) -> None:\n+def _kmem_per_cpu_offset(prog: Program, drgn_arg: bool) -> None:\n     if drgn_arg:\n         sys.stdout.write(\n             \"\"\"\\\n@@ -948,10 +939,7 @@ for cpu in for_each_possible_cpu():\n         print(f\"{cpu_field:>7}: {per_cpu_ptr(nullptr, cpu).value_():x}\")\n \n \n-def _kmem_hstate(\n-    prog: Program,\n-    drgn_arg: bool,\n-) -> None:\n+def _kmem_hstate(prog: Program, drgn_arg: bool) -> None:\n     if drgn_arg:\n         sys.stdout.write(\n             \"\"\"\\\n"}
{"repo": "drgn", "commit": "4e609f8303b9ad0be608dde5565ad7349d67b688", "diff": "diff --git a/drgn/commands/crash.py b/drgn/commands/crash.py\nindex 32b27941..3c9e7446 100644\n--- a/drgn/commands/crash.py\n+++ b/drgn/commands/crash.py\n@@ -213,7 +213,7 @@ def crash_get_context(\n         if arg[0] == \"pid\":\n             task = find_task(prog, arg[1])\n             if not task:\n-                raise LookupError(\"no such process\")\n+                raise LookupError(\"no such process with PID {}\".format(arg[1]))\n             return task\n         else:\n             return Object(prog, \"struct task_struct *\", arg[1])\n"}
{"repo": "drgn", "commit": "01e6c45f00d2e724b12df61cfc2ba39218594a7b", "diff": "diff --git a/drgn/helpers/linux/cgroup.py b/drgn/helpers/linux/cgroup.py\nindex 0f576ec5..e3324b6e 100644\n--- a/drgn/helpers/linux/cgroup.py\n+++ b/drgn/helpers/linux/cgroup.py\n@@ -115,6 +115,8 @@ def css_next_child(pos: Object, parent: Object) -> Object:\n         ):\n             if next_.serial_nr > serial_nr:\n                 break\n+        else:\n+            return NULL(pos.prog_, \"struct cgroup_subsys_state *\")\n \n     if next_.sibling.address_of_() != parent.children.address_of_():\n         return next_\n"}
{"repo": "drgn", "commit": "50f39d67bbbbe11df06ce7d00c531353c4fcb417", "diff": "diff --git a/tests/linux_kernel/crash_commands/test_collections.py b/tests/linux_kernel/crash_commands/test_collections.py\nindex 30b3ebc7..8260fe75 100644\n--- a/tests/linux_kernel/crash_commands/test_collections.py\n+++ b/tests/linux_kernel/crash_commands/test_collections.py\n@@ -446,6 +446,5 @@ b0ba004\n \n     def test_wrong_type(self):\n         cmd = self.run_crash_command(\"tree drgn_test_radix_tree_sparse --drgn\")\n-        print(cmd.stdout)\n         self.assertIn(\"prog.symbol\", cmd.stdout)\n         self.assertIn(\"root = Object\", cmd.stdout)\n"}
{"repo": "drgn", "commit": "3616101426c95db8830c226771402fde67fd85a4", "diff": "diff --git a/tests/linux_kernel/helpers/test_boot.py b/tests/linux_kernel/helpers/test_boot.py\nindex 00393dc5..878be629 100644\n--- a/tests/linux_kernel/helpers/test_boot.py\n+++ b/tests/linux_kernel/helpers/test_boot.py\n@@ -1,19 +1,55 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n+from ctypes import c_int, c_int64, c_size_t, c_void_p\n+import mmap\n import re\n import unittest\n \n from _drgn_util.platform import NORMALIZED_MACHINE_NAME\n from drgn.helpers.linux.boot import pgtable_l5_enabled\n-from tests.linux_kernel import LinuxKernelTestCase\n+from tests.linux_kernel import LinuxKernelTestCase, _c\n+\n+\n+def first_available_slot(size, min_addr):\n+    for line in open(\"/proc/self/maps\"):\n+        start_str, end_str = re.match(r\"([0-9a-f]+)-([0-9a-f]+).*\", line).groups()\n+        start = int(start_str, 16)\n+        end = int(end_str, 16)\n+        if start >= min_addr + size:\n+            break\n+        elif end >= min_addr:\n+            min_addr = end\n+    return min_addr\n+\n+\n+def can_mmap_high_address():\n+    mmap_func = _c.mmap\n+    mmap_func.argtypes = [c_void_p, c_size_t, c_int, c_int, c_int, c_int64]\n+    mmap_func.restype = c_void_p\n+    munmap_func = _c.munmap\n+    munmap_func.argtypes = [c_void_p, c_size_t]\n+    hint_addr = first_available_slot(mmap.PAGESIZE, 1 << 48)\n+\n+    ret = mmap_func(\n+        hint_addr,\n+        mmap.PAGESIZE,\n+        mmap.PROT_READ | mmap.PROT_WRITE,\n+        # Ideally we would use MAP_FIXED, but its value is not exposed by the\n+        # mmap module, and it varies by architecture. Having identified a free\n+        # slot in our memory mappings (and hopefully not changing them since\n+        # then), we can be reasonably confident that we should get the address\n+        # we hinted anyway.\n+        mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS,\n+        -1,\n+        0,\n+    )\n+    if ret != c_void_p(-1).value:\n+        munmap_func(ret, mmap.PAGESIZE)\n+    return ret == hint_addr\n \n \n class TestBoot(LinuxKernelTestCase):\n     @unittest.skipUnless(NORMALIZED_MACHINE_NAME == \"x86_64\", \"machine is not x86_64\")\n     def test_pgtable_l5_enabled(self):\n-        with open(\"/proc/cpuinfo\", \"r\") as f:\n-            self.assertEqual(\n-                pgtable_l5_enabled(self.prog),\n-                bool(re.search(r\"flags\\s*:.*\\bla57\\b\", f.read())),\n-            )\n+        self.assertEqual(pgtable_l5_enabled(self.prog), can_mmap_high_address())\n"}
{"repo": "drgn", "commit": "199713593456f1fe56326ceaaff4de10f6117c5e", "diff": "diff --git a/tests/linux_kernel/crash_commands/test_ptov.py b/tests/linux_kernel/crash_commands/test_ptov.py\nindex 5d915751..92ea13f3 100644\n--- a/tests/linux_kernel/crash_commands/test_ptov.py\n+++ b/tests/linux_kernel/crash_commands/test_ptov.py\n@@ -1,6 +1,8 @@\n # Copyright (c) 2025, Kylin Software, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n+import os\n+\n from drgn import Object\n from drgn.helpers.linux.cpumask import for_each_online_cpu\n from drgn.helpers.linux.mm import phys_to_virt\n@@ -48,7 +50,7 @@ class TestPtov(CrashCommandTestCase):\n     def test_per_cpu_offset_cpu_list(self):\n         \"\"\"Test per-CPU offset conversion for a CPU list.\"\"\"\n         offset = 0x300\n-        cpus = [0, 1, 2]\n+        cpus = sorted(os.sched_getaffinity(0))\n         cmd = self.check_crash_command(f\"ptov {hex(offset)}:{','.join(map(str, cpus))}\")\n \n         self.assertRegex(cmd.stdout, rf\"(?m)^\\s*PER-CPU OFFSET:\\s+{offset:x}\")\n"}
{"repo": "drgn", "commit": "27f069e7740630841f755d5e41323f2fe71616b4", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 7faad9c1..12d60312 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -452,6 +452,8 @@ def kconfig_localversion(arch: Architecture, flavor: KernelFlavor, version: str)\n     # rebuilt, conditionally increment the patch level here.\n     if flavor.name == \"alternative\" and KernelVersion(version) >= KernelVersion(\"6.8\"):\n         patch_level += 1\n+    if KernelVersion(version) < KernelVersion(\"5.10\"):\n+        patch_level += 1\n     if patch_level:\n         vmtest_kernel_version.append(patch_level)\n \ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 88ed22bf..812e5017 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -179,6 +179,14 @@ _PATCHES = (\n             (None, KernelVersion(\"5.4.262\")),\n         ),\n     ),\n+    _Patch(\n+        name=\"kbuild-Only-add-fno-var-tracking-assignments-for-old.patch\",\n+        versions=((KernelVersion(\"5.1\"), KernelVersion(\"5.10\")),),\n+    ),\n+    _Patch(\n+        name=\"4.19-kbuild-Only-add-fno-var-tracking-assignments-for-old.patch\",\n+        versions=((None, KernelVersion(\"5.1\")),),\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "2f840306b7c2239d17394339626035c3fb402fc4", "diff": "diff --git a/tests/linux_kernel/helpers/test_sched.py b/tests/linux_kernel/helpers/test_sched.py\nindex cb3008b2..2196297a 100644\n--- a/tests/linux_kernel/helpers/test_sched.py\n+++ b/tests/linux_kernel/helpers/test_sched.py\n@@ -105,5 +105,12 @@ class TestSched(LinuxKernelTestCase):\n     def test_task_since_last_arrival_ns(self):\n         with fork_and_stop() as pid:\n             time.sleep(0.01)\n+            # Forcing the process to migrate also forces the rq clock to update\n+            # so we can get a reliable reading.\n+            affinity = os.sched_getaffinity(pid)\n+            if len(affinity) > 1:\n+                other_affinity = {affinity.pop()}\n+                os.sched_setaffinity(pid, affinity)\n+                os.sched_setaffinity(pid, other_affinity)\n             task = find_task(self.prog, pid)\n             self.assertGreaterEqual(task_since_last_arrival_ns(task), 10000000)\n"}
{"repo": "drgn", "commit": "1847f91d682aef327b0e0dfccfc1bed3533d2960", "diff": "diff --git a/vmtest/__main__.py b/vmtest/__main__.py\nindex 720f05d8..58920c0d 100644\n--- a/vmtest/__main__.py\n+++ b/vmtest/__main__.py\n@@ -16,6 +16,7 @@ import traceback\n from typing import (\n     TYPE_CHECKING,\n     Callable,\n+    Deque,\n     Dict,\n     List,\n     Optional,\n@@ -129,9 +130,9 @@ class _TestRunner:\n         self._futures: Set[\"concurrent.futures.Future[Callable[[], bool]]\"] = set()\n \n         self._downloader = Downloader(directory)\n-        self._download_queue: \"deque[Union[Compiler, Kernel]]\" = deque()\n+        self._download_queue: Deque[Union[Compiler, Kernel]] = deque()\n \n-        self._test_queue: \"deque[Tuple[str, str, _TestFunction]]\" = deque()\n+        self._test_queue: Deque[Tuple[str, str, _TestFunction]] = deque()\n         self._tests_running: Dict[Tuple[str, str], float] = {}\n         self._tests_passed: Dict[str, List[str]] = {}\n         self._tests_failed: Dict[str, List[str]] = {}\n"}
{"repo": "drgn", "commit": "d027cb6f1246a361c6adfd145cc01c1a9caa7d62", "diff": "diff --git a/tests/linux_kernel/helpers/test_mm.py b/tests/linux_kernel/helpers/test_mm.py\nindex ea6b6cf4..d04e46fe 100644\n--- a/tests/linux_kernel/helpers/test_mm.py\n+++ b/tests/linux_kernel/helpers/test_mm.py\n@@ -472,14 +472,32 @@ class TestMm(LinuxKernelTestCase):\n                 )\n             }\n \n-            # The kernel code uses percpu_counter_read_positive(), but the\n-            # helper uses percpu_counter_sum() for better accuracy. We need to\n-            # account for the deviation.\n-            try:\n-                percpu_counter_batch = self.prog[\"percpu_counter_batch\"].value_()\n-            except ObjectNotFoundError:\n-                percpu_counter_batch = 32\n-            delta = percpu_counter_batch * os.cpu_count()\n+            # Before Linux kernel commit 82241a83cd15 (\"mm: fix the inaccurate\n+            # memory statistics issue for users\") (in v6.16), the RSS counters\n+            # in /proc/pid/meminfo are approximate due to batching, but the\n+            # helpers are exact.\n+            if hasattr(task, \"rss_stat\"):\n+                # Before Linux kernel commit f1a7941243c10 (\"mm: convert mm's\n+                # rss stats into percpu_counter\") (in v6.2), there is a\n+                # per-thread counter that only gets synced to the main counter\n+                # every TASK_RSS_EVENTS_THRESH (64) page faults. Each fault can\n+                # map in multiple pages based on fault_around_bytes. So, the\n+                # maximum error is nr_threads * 64 * (fault_around_bytes / PAGE_SIZE).\n+                delta = (\n+                    len(os.listdir(f\"/proc/{pid}/task\"))\n+                    * 64\n+                    * (self.prog[\"fault_around_bytes\"].value_() // page_size)\n+                )\n+            else:\n+                # Between that and Linux kernel commit 82241a83cd15 (\"mm: fix\n+                # the inaccurate memory statistics issue for users\") (in\n+                # v6.16), the kernel code uses percpu_counter_read_positive(),\n+                # so the maximum error is nr_cpus * percpu_counter_batch.\n+                try:\n+                    percpu_counter_batch = self.prog[\"percpu_counter_batch\"].value_()\n+                except ObjectNotFoundError:\n+                    percpu_counter_batch = 32\n+                delta = percpu_counter_batch * os.cpu_count()\n \n             self.assertAlmostEqual(rss_info.file, stats[\"RssFile\"], delta=delta)\n             self.assertAlmostEqual(rss_info.anon, stats[\"RssAnon\"], delta=delta)\n@@ -487,4 +505,6 @@ class TestMm(LinuxKernelTestCase):\n                 rss_info.shmem, stats.get(\"RssShmem\", 0), delta=delta\n             )\n             self.assertAlmostEqual(rss_info.swap, stats[\"VmSwap\"], delta=delta)\n-            self.assertAlmostEqual(rss_info.total, stats[\"VmRSS\"], delta=delta)\n+            # VmRSS is the sum of three counters, so it has triple the error\n+            # margin.\n+            self.assertAlmostEqual(rss_info.total, stats[\"VmRSS\"], delta=delta * 3)\n"}
{"repo": "drgn", "commit": "0dc3d14b6c04e057d817c2b70e64e0601f77e7b4", "diff": "diff --git a/tests/linux_kernel/__init__.py b/tests/linux_kernel/__init__.py\nindex 2b69b29a..444002eb 100644\n--- a/tests/linux_kernel/__init__.py\n+++ b/tests/linux_kernel/__init__.py\n@@ -171,7 +171,7 @@ def proc_state(pid):\n # Context manager that:\n # 1. Forks a process which optionally calls a function and then stops with\n #    SIGSTOP.\n-# 2. Waits for the child process to stop.\n+# 2. Waits for the child process to stop and unschedule.\n # 3. Returns the PID of the child process, and return value of the function if\n #    provided, from __enter__().\n # 4. Kills the child process in __exit__().\n@@ -197,12 +197,32 @@ def fork_and_stop(fn=None, *args, **kwds):\n                     traceback.print_exc()\n                     sys.stderr.flush()\n                     os._exit(1)\n+\n             if fn:\n                 pipe_w.close()\n                 ret = pickle.load(pipe_r)\n+\n             _, status = os.waitpid(pid, os.WUNTRACED)\n             if not os.WIFSTOPPED(status):\n                 raise Exception(\"child process exited\")\n+            # waitpid() can return as soon as the stopped flag is set on the\n+            # process; see wait_task_stopped() in the Linux kernel source code:\n+            # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/exit.c?h=v6.17-rc5#n1313\n+            # However, the process may still be on the CPU for a short window;\n+            # see do_signal_stop():\n+            # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/signal.c?h=v6.17-rc5#n2617\n+            # So, we need to wait for it to fully unschedule. /proc/pid/syscall\n+            # contains \"running\" unless the process is unscheduled; see\n+            # proc_pid_syscall():\n+            # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/proc/base.c?h=v6.17-rc5#n675\n+            # task_current_syscall():\n+            # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/syscall.c?h=v6.17-rc5#n69\n+            # and wait_task_inactive():\n+            # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/sched/core.c?h=v6.17-rc5#n2257\n+            syscall_path = Path(f\"/proc/{pid}/syscall\")\n+            while syscall_path.read_text() == \"running\\n\":\n+                os.sched_yield()\n+\n             if fn:\n                 yield pid, ret\n             else:\n"}
{"repo": "drgn", "commit": "7a4372cff1d8df37b4bd242c35126d7a56c74bcf", "diff": "diff --git a/vmtest/githubapi.py b/vmtest/githubapi.py\nindex af0a7ace..ddd6de3b 100644\n--- a/vmtest/githubapi.py\n+++ b/vmtest/githubapi.py\n@@ -55,7 +55,7 @@ class _GitHubApiBase:\n             return None\n         try:\n             with open(cache, \"r\") as f:\n-                return json.load(f)  # type: ignore[no-any-return]\n+                return json.load(f)\n         except FileNotFoundError:\n             return None\n \n@@ -69,15 +69,6 @@ class _GitHubApiBase:\n                 return {**self._headers, \"If-Modified-Since\": cached[\"last_modified\"]}\n         return self._headers\n \n-    @staticmethod\n-    def _trust_cache(cached: Any) -> bool:\n-        # If the request was cached and the VMTEST_TRUST_CACHE environment\n-        # variable is non-zero, assume the cache is still valid.\n-        try:\n-            return cached is not None and int(os.getenv(\"VMTEST_TRUST_CACHE\", \"0\")) != 0\n-        except ValueError:\n-            return False\n-\n     def _write_cache(\n         self, cache: _CACHE, body: Any, headers: Mapping[str, str]\n     ) -> None:\n@@ -128,23 +119,25 @@ class GitHubApi(_GitHubApiBase):\n             method=method,\n         )\n         # Work around python/cpython#77842.\n-        if req.has_header(\"Authorization\"):\n-            authorization = req.get_header(\"Authorization\")\n+        authorization = req.get_header(\"Authorization\")\n+        if authorization is not None:\n             req.remove_header(\"Authorization\")\n             req.add_unredirected_header(\"Authorization\", authorization)\n         return urllib.request.urlopen(req)\n \n     def _cached_get_json(self, endpoint: str, cache: _CACHE) -> Any:\n         cached = self._read_cache(cache)\n-        if self._trust_cache(cached):\n+        # If the request was cached and the VMTEST_TRUST_CACHE environment\n+        # variable is set, assume the cache is still valid.\n+        if cached is not None and \"VMTEST_TRUST_CACHE\" in os.environ:\n             return cached[\"body\"]\n         req = urllib.request.Request(\n             self._HOST + \"/\" + endpoint,\n             headers=self._cached_get_headers(cached),\n         )\n         # Work around python/cpython#77842.\n-        if req.has_header(\"Authorization\"):\n-            authorization = req.get_header(\"Authorization\")\n+        authorization = req.get_header(\"Authorization\")\n+        if authorization is not None:\n             req.remove_header(\"Authorization\")\n             req.add_unredirected_header(\"Authorization\", authorization)\n         try:\n@@ -184,7 +177,7 @@ class AioGitHubApi(_GitHubApiBase):\n \n     async def _cached_get_json(self, endpoint: str, cache: _CACHE) -> Any:\n         cached = self._read_cache(cache)\n-        if self._trust_cache(cached):\n+        if cached is not None and \"VMTEST_TRUST_CACHE\" in os.environ:\n             return cached[\"body\"]\n         async with self._session.get(\n             self._HOST + \"/\" + endpoint,\ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 1fd494cf..f0010784 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -209,6 +209,7 @@ async def apply_patches(kernel_dir: Path) -> None:\n             cwd=kernel_dir,\n             stderr=asyncio.subprocess.PIPE,\n         )\n+        assert proc.stderr is not None  # for mypy\n         stderr = await proc.stderr.read()\n         if await proc.wait() != 0:\n             try:\n@@ -514,9 +515,15 @@ MODULE_LICENSE(\"GPL\");\n                 stderr=asyncio.subprocess.PIPE,\n                 env=self._env,\n             )\n+            assert proc.stdout is not None  # for mypy\n+            assert proc.stderr is not None  # for mypy\n             try:\n-                stdout_task = asyncio.create_task(proc.stdout.readline())\n-                stderr_task = asyncio.create_task(proc.stderr.readline())\n+                stdout_task: Optional[asyncio.Task[bytes]] = asyncio.create_task(\n+                    proc.stdout.readline()\n+                )\n+                stderr_task: Optional[asyncio.Task[bytes]] = asyncio.create_task(\n+                    proc.stderr.readline()\n+                )\n                 error = False\n                 while stdout_task is not None or stderr_task is not None:\n                     aws = []\ndiff --git a/vmtest/rootfsbuild.py b/vmtest/rootfsbuild.py\nindex da62ce1c..1684c3c2 100644\n--- a/vmtest/rootfsbuild.py\n+++ b/vmtest/rootfsbuild.py\n@@ -59,7 +59,7 @@ def build_rootfs(\n \n         if btrfs != \"never\":\n             try:\n-                import btrfsutil\n+                import btrfsutil  # type: ignore  # No type hints available.\n \n                 btrfsutil.create_subvolume(tmp_dir / path.name)\n                 snapshot = True\n"}
{"repo": "drgn", "commit": "4748c382611c61b2cecded0b54d19a6fa39df3ce", "diff": "diff --git a/drgn/commands/crash.py b/drgn/commands/crash.py\nindex aee5ca7b..48e7e7a3 100644\n--- a/drgn/commands/crash.py\n+++ b/drgn/commands/crash.py\n@@ -259,7 +259,9 @@ class Cpuspec:\n         elif self.explicit_cpus:\n             possible = set(for_each_possible_cpu(prog))\n             if not self.explicit_cpus.issubset(possible):\n-                raise ValueError(f\"invalid CPUs: {self.explicit_cpus - possible}\")\n+                raise ValueError(\n+                    f\"invalid CPUs: {','.join([str(cpu) for cpu in self.explicit_cpus - possible])}\"\n+                )\n             return sorted(self.explicit_cpus)\n         else:\n             return []\n"}
{"repo": "drgn", "commit": "05e19ec81b4512fcda1589487969932ab47e72cb", "diff": "diff --git a/tools/fsrefs.py b/tools/fsrefs.py\nindex 6db73675..417ea007 100755\n--- a/tools/fsrefs.py\n+++ b/tools/fsrefs.py\n@@ -507,6 +507,7 @@ def visit_uprobes(prog: Program, visitor: \"Visitor\") -> None:\n                         print(\n                             f\"unknown uprobe consumer {consumer.format_(**format_args)}\"\n                         )\n+                    found_consumer = True\n             if not found_consumer:\n                 print(f\"unknown uprobe {uprobe.format_(**format_args)} {match}\")\n \n"}
{"repo": "drgn", "commit": "5265bbecee9417d1d0e3813d42b63976d13d59b4", "diff": "diff --git a/tests/linux_kernel/crash_commands/test_structunion.py b/tests/linux_kernel/crash_commands/test_structunion.py\nindex e8985e24..e3c68c0e 100644\n--- a/tests/linux_kernel/crash_commands/test_structunion.py\n+++ b/tests/linux_kernel/crash_commands/test_structunion.py\n@@ -292,18 +292,26 @@ class TestStruct(CrashCommandTestCase):\n             self.prog[\"drgn_test_list_entries\"][2].value,\n         )\n \n+    @skip_unless_have_test_kmod\n     def test_cpuspec(self):\n-        cmd = self.check_crash_command(\"struct rq runqueues:a\")\n+        cmd = self.check_crash_command(\n+            \"struct drgn_test_percpu_struct drgn_test_percpu_structs:a\"\n+        )\n         cpus = sorted(parse_range_list(POSSIBLE_CPUS_PATH.read_text()))\n         matches = re.findall(\n-            r\"^\\[([0-9]+)\\]: [0-9a-f]+\\n\\(struct rq\\)\\{\", cmd.stdout, flags=re.MULTILINE\n+            r\"^\\[([0-9]+)\\]: [0-9a-f]+\\n\\(struct drgn_test_percpu_struct\\)\\{\",\n+            cmd.stdout,\n+            flags=re.MULTILINE,\n         )\n         self.assertEqual([int(match) for match in matches], cpus)\n         self.assertIn(\"per_cpu(\", cmd.drgn_option.stdout)\n         self.assertEqual(cmd.drgn_option.globals[\"object\"].cpu, max(cpus))\n \n+    @skip_unless_have_test_kmod\n     def test_cpuspec_with_member(self):\n-        cmd = self.check_crash_command(\"struct rq.cpu runqueues:a\")\n+        cmd = self.check_crash_command(\n+            \"struct drgn_test_percpu_struct.cpu drgn_test_percpu_structs:a\"\n+        )\n         cpus = sorted(parse_range_list(POSSIBLE_CPUS_PATH.read_text()))\n         matches = re.findall(r\"cpu = \\([^)]*\\)([0-9]+)\", cmd.stdout, flags=re.MULTILINE)\n         self.assertEqual([int(match) for match in matches], cpus)\n"}
{"repo": "drgn", "commit": "89dfa85ff7daace8215c3eb2b8eb4bfd2d3dbb07", "diff": "diff --git a/drgn/commands/crash.py b/drgn/commands/crash.py\nindex b773bcaa..7ab1f56b 100644\n--- a/drgn/commands/crash.py\n+++ b/drgn/commands/crash.py\n@@ -122,7 +122,9 @@ class _CrashCommandNamespace(CommandNamespace):\n             except CommandNotFoundError as e:\n                 try:\n                     # Smuggle the type into the command function.\n-                    kwargs[\"type\"] = _guess_type(prog, \"*\", command_name)\n+                    kwargs[\"type\"] = _guess_type(\n+                        prog, \"*\", command_name.partition(\".\")[0]\n+                    )\n                 except LookupError:\n                     raise e\n                 else:\ndiff --git a/tests/linux_kernel/crash_commands/test_structunion.py b/tests/linux_kernel/crash_commands/test_structunion.py\nindex 7c8914b4..e8985e24 100644\n--- a/tests/linux_kernel/crash_commands/test_structunion.py\n+++ b/tests/linux_kernel/crash_commands/test_structunion.py\n@@ -490,6 +490,13 @@ class TestImplicit(CrashCommandTestCase):\n             cmd.drgn_option.globals[\"type\"].type_name(), \"drgn_test_anonymous_union\"\n         )\n \n+    def test_member(self):\n+        cmd = self.check_crash_command(\"task_struct.pid init_task\")\n+        self.assertRegex(cmd.stdout, r\"pid = \\([^)]*\\)0\")\n+        self.assertIn(\".pid\", cmd.drgn_option.stdout)\n+        self.assertIdentical(cmd.drgn_option.globals[\"object\"], self.prog[\"init_task\"])\n+        self.assertEqual(cmd.drgn_option.globals[\"pid\"], 0)\n+\n     def test_not_found(self):\n         self.assertRaises(\n             CommandNotFoundError, self.run_crash_command, \"drgn_test_non_existent\"\n"}
{"repo": "drgn", "commit": "c1a40995dedd7bc17642ee407a8cb4df30bd75b1", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 241e13a7..6699806f 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -1501,9 +1501,7 @@ def get_task_rss_info(prog: Program, task: Object) -> TaskRss:\n         filerss = percpu_counter_sum(rss_stat[MM_FILEPAGES].address_of_())\n         anonrss = percpu_counter_sum(rss_stat[MM_ANONPAGES].address_of_())\n         swapents = percpu_counter_sum(rss_stat[MM_SWAPENTS].address_of_())\n-        shmemrss = 0\n-        if MM_SHMEMPAGES >= 0:\n-            shmemrss = percpu_counter_sum(rss_stat[MM_SHMEMPAGES].address_of_())\n+        shmemrss = percpu_counter_sum(rss_stat[MM_SHMEMPAGES].address_of_())\n     else:\n         # Prior to this, the \"rss_stat\" was a structure containing counters that\n         # were cached on each task_struct and periodically updated into the\n@@ -1512,6 +1510,7 @@ def get_task_rss_info(prog: Program, task: Object) -> TaskRss:\n         filerss = rss_stat.count[MM_FILEPAGES].counter.value_()\n         anonrss = rss_stat.count[MM_ANONPAGES].counter.value_()\n         swapents = rss_stat.count[MM_SWAPENTS].counter.value_()\n+        shmemrss = 0\n         if MM_SHMEMPAGES >= 0:\n             shmemrss = rss_stat.count[MM_SHMEMPAGES].counter.value_()\n \n"}
{"repo": "drgn", "commit": "c8966444696c45f0a5e00d3005c20f3ac2a8a86e", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 196e48ba..241e13a7 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -1516,10 +1516,16 @@ def get_task_rss_info(prog: Program, task: Object) -> TaskRss:\n             shmemrss = rss_stat.count[MM_SHMEMPAGES].counter.value_()\n \n         for gtask in for_each_task_in_group(task, include_self=True):\n-            filerss += gtask.rss_stat.count[MM_FILEPAGES].value_()\n-            anonrss += gtask.rss_stat.count[MM_ANONPAGES].value_()\n-            swapents += gtask.rss_stat.count[MM_SWAPENTS].value_()\n+            # Kernel configurations with a small NR_CPUS don't have the\n+            # per-thread cache.\n+            try:\n+                rss_stat = gtask.rss_stat\n+            except AttributeError:\n+                break\n+            filerss += rss_stat.count[MM_FILEPAGES].value_()\n+            anonrss += rss_stat.count[MM_ANONPAGES].value_()\n+            swapents += rss_stat.count[MM_SWAPENTS].value_()\n             if MM_SHMEMPAGES >= 0:\n-                shmemrss += gtask.rss_stat.count[MM_SHMEMPAGES].value_()\n+                shmemrss += rss_stat.count[MM_SHMEMPAGES].value_()\n \n     return TaskRss(filerss, anonrss, shmemrss, swapents)\ndiff --git a/tests/linux_kernel/helpers/test_mm.py b/tests/linux_kernel/helpers/test_mm.py\nindex 80a03efc..ea6b6cf4 100644\n--- a/tests/linux_kernel/helpers/test_mm.py\n+++ b/tests/linux_kernel/helpers/test_mm.py\n@@ -13,7 +13,7 @@ import tempfile\n import unittest\n \n from _drgn_util.platform import NORMALIZED_MACHINE_NAME\n-from drgn import NULL, FaultError\n+from drgn import NULL, FaultError, ObjectNotFoundError\n from drgn.helpers.linux.mm import (\n     PFN_PHYS,\n     PHYS_PFN,\n@@ -475,7 +475,11 @@ class TestMm(LinuxKernelTestCase):\n             # The kernel code uses percpu_counter_read_positive(), but the\n             # helper uses percpu_counter_sum() for better accuracy. We need to\n             # account for the deviation.\n-            delta = self.prog[\"percpu_counter_batch\"].value_() * os.cpu_count()\n+            try:\n+                percpu_counter_batch = self.prog[\"percpu_counter_batch\"].value_()\n+            except ObjectNotFoundError:\n+                percpu_counter_batch = 32\n+            delta = percpu_counter_batch * os.cpu_count()\n \n             self.assertAlmostEqual(rss_info.file, stats[\"RssFile\"], delta=delta)\n             self.assertAlmostEqual(rss_info.anon, stats[\"RssAnon\"], delta=delta)\n"}
{"repo": "drgn", "commit": "7db6b61395a27f95ac92209e0e52655fe8ea8d50", "diff": "diff --git a/drgn/helpers/linux/percpu.py b/drgn/helpers/linux/percpu.py\nindex 01904bd8..d1480f12 100644\n--- a/drgn/helpers/linux/percpu.py\n+++ b/drgn/helpers/linux/percpu.py\n@@ -45,7 +45,12 @@ def percpu_counter_sum(fbc: Object) -> int:\n     :param fbc: ``struct percpu_counter *``\n     \"\"\"\n     ret = fbc.count.value_()\n-    ptr = fbc.counters\n-    for cpu in for_each_online_cpu(fbc.prog_):\n-        ret += per_cpu_ptr(ptr, cpu)[0].value_()\n+    try:\n+        ptr = fbc.counters\n+    except AttributeError:\n+        # On !SMP kernels, there's nothing to sum.\n+        pass\n+    else:\n+        for cpu in for_each_online_cpu(fbc.prog_):\n+            ret += per_cpu_ptr(ptr, cpu)[0].value_()\n     return ret\ndiff --git a/tests/linux_kernel/helpers/test_percpu.py b/tests/linux_kernel/helpers/test_percpu.py\nindex c0a34326..a17b130e 100644\n--- a/tests/linux_kernel/helpers/test_percpu.py\n+++ b/tests/linux_kernel/helpers/test_percpu.py\n@@ -2,7 +2,7 @@\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n from drgn.helpers.linux.cpumask import for_each_possible_cpu\n-from drgn.helpers.linux.percpu import per_cpu, per_cpu_ptr\n+from drgn.helpers.linux.percpu import per_cpu, per_cpu_ptr, percpu_counter_sum\n from tests.linux_kernel import (\n     LinuxKernelTestCase,\n     prng32,\n@@ -37,3 +37,9 @@ class TestPerCpu(LinuxKernelTestCase):\n             self.assertEqual(\n                 per_cpu_ptr(self.prog[\"drgn_test_percpu_dynamic\"], cpu)[0], expected\n             )\n+\n+\n+@skip_unless_have_test_kmod\n+class TestPercpuCounter(LinuxKernelTestCase):\n+    def test_percpu_counter_sum(self):\n+        self.assertEqual(percpu_counter_sum(self.prog[\"drgn_test_percpu_counter\"]), 13)\n"}
{"repo": "drgn", "commit": "5ad6c222987001a5f92cac5dd4d51cf0b8b9d520", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 7ac341ae..4fdff773 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -64,6 +64,7 @@ from _drgn import (\n     NoDefaultProgramError,\n     Object,\n     ObjectAbsentError,\n+    ObjectNotFoundError,\n     OutOfBoundsError,\n     Path,\n     Platform,\n@@ -137,6 +138,7 @@ __all__ = (\n     \"NoDefaultProgramError\",\n     \"Object\",\n     \"ObjectAbsentError\",\n+    \"ObjectNotFoundError\",\n     \"OutOfBoundsError\",\n     \"Path\",\n     \"Platform\",\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex fcdb9891..de586a2c 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -15,6 +15,7 @@ from drgn import (\n     FindObjectFlags,\n     Language,\n     Object,\n+    ObjectNotFoundError,\n     Program,\n     ProgramFlags,\n     Qualifiers,\n@@ -4570,7 +4571,7 @@ class TestObjects(TestCase):\n         )\n         self.assertIdentical(prog.object(\"abs\", FindObjectFlags.FUNCTION), prog[\"abs\"])\n         self.assertRaisesRegex(\n-            LookupError,\n+            ObjectNotFoundError,\n             \"could not find variable\",\n             prog.object,\n             \"abs\",\n@@ -4792,7 +4793,7 @@ class TestObjects(TestCase):\n         )\n         self.assertIdentical(prog.object(\"x\", FindObjectFlags.VARIABLE), prog[\"x\"])\n         self.assertRaisesRegex(\n-            LookupError,\n+            ObjectNotFoundError,\n             \"could not find constant\",\n             prog.object,\n             \"x\",\n@@ -6824,7 +6825,7 @@ class TestObjects(TestCase):\n \n     def test_not_found(self):\n         prog = dwarf_program(int_die)\n-        self.assertRaisesRegex(LookupError, \"could not find\", prog.object, \"y\")\n+        self.assertRaisesRegex(ObjectNotFoundError, \"could not find\", prog.object, \"y\")\n \n \n class TestScopes(TestCase):\ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex 3952c02e..b355d3d6 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -15,6 +15,7 @@ from drgn import (\n     Language,\n     NoDefaultProgramError,\n     Object,\n+    ObjectNotFoundError,\n     Platform,\n     PlatformFlags,\n     Program,\n@@ -105,46 +106,65 @@ class TestProgram(TestCase):\n \n         self.assertEqual(prog.read(ctypes.addressof(buf), len(data)), data)\n \n-    def test_lookup_error(self):\n+    def test_object_not_found_error(self):\n         prog = mock_program()\n-        self.assertRaisesRegex(\n-            LookupError, \"^could not find constant 'foo'$\", prog.constant, \"foo\"\n-        )\n-        self.assertRaisesRegex(\n-            LookupError,\n-            \"^could not find constant 'foo' in 'foo.c'$\",\n-            prog.constant,\n-            \"foo\",\n-            \"foo.c\",\n-        )\n-        self.assertRaisesRegex(\n-            LookupError, \"^could not find function 'foo'$\", prog.function, \"foo\"\n-        )\n-        self.assertRaisesRegex(\n-            LookupError,\n-            \"^could not find function 'foo' in 'foo.c'$\",\n-            prog.function,\n-            \"foo\",\n-            \"foo.c\",\n-        )\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find constant 'foo'$\"\n+        ) as cm:\n+            prog.constant(\"foo\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find constant 'foo' in 'foo.c'$\"\n+        ) as cm:\n+            prog.constant(\"foo\", \"foo.c\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find function 'foo'$\"\n+        ) as cm:\n+            prog.function(\"foo\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find function 'foo' in 'foo.c'$\"\n+        ) as cm:\n+            prog.function(\"foo\", \"foo.c\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find variable 'foo'$\"\n+        ) as cm:\n+            prog.variable(\"foo\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find variable 'foo' in 'foo.c'$\"\n+        ) as cm:\n+            prog.variable(\"foo\", \"foo.c\")\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        with self.assertRaisesRegex(\n+            ObjectNotFoundError, \"^could not find 'foo'$\"\n+        ) as cm:\n+            prog[\"foo\"]\n+        self.assertEqual(cm.exception.name, \"foo\")\n+\n+        # If name isn't a string, prog.object(name) should raise TypeError, and\n+        # prog[name] should raise KeyError (not ObjectNotFoundError).\n+        self.assertRaises(TypeError, prog.object, 9)\n+        with self.assertRaises(KeyError) as cm:\n+            prog[9]\n+        self.assertIs(type(cm.exception), KeyError)\n+\n+    def test_type_lookup_error(self):\n+        prog = mock_program()\n+\n         self.assertRaisesRegex(LookupError, \"^could not find 'foo'$\", prog.type, \"foo\")\n         self.assertRaisesRegex(\n             LookupError, \"^could not find 'foo' in 'foo.c'$\", prog.type, \"foo\", \"foo.c\"\n         )\n-        self.assertRaisesRegex(\n-            LookupError, \"^could not find variable 'foo'$\", prog.variable, \"foo\"\n-        )\n-        self.assertRaisesRegex(\n-            LookupError,\n-            \"^could not find variable 'foo' in 'foo.c'$\",\n-            prog.variable,\n-            \"foo\",\n-            \"foo.c\",\n-        )\n-        # prog[key] should raise KeyError instead of LookupError.\n-        self.assertRaises(KeyError, prog.__getitem__, \"foo\")\n-        # Even for non-strings.\n-        self.assertRaises(KeyError, prog.__getitem__, 9)\n \n     def test_flags(self):\n         self.assertIsInstance(mock_program().flags, ProgramFlags)\n"}
{"repo": "drgn", "commit": "6daaaa9f34f1680800fc93d96e8a9a8bf173abca", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 5b050948..13fa97b3 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -1787,6 +1787,16 @@ class TestGenericOperators(MockProgramTestCase):\n         obj = Object(self.prog, \"int\", value=0)\n         self.assertRaises(TypeError, obj.__getitem__, 0)\n \n+    def test_negative_subscript(self):\n+        arr = Object(self.prog, \"int [4]\", address=0xFFFF0000)\n+        incomplete_arr = Object(self.prog, \"int []\", address=0xFFFF0000)\n+        ptr = Object(self.prog, \"int *\", value=0xFFFF0000)\n+        for obj in [arr, incomplete_arr, ptr]:\n+            self.assertIdentical(obj[-1], Object(self.prog, \"int\", address=0xFFFEFFFC))\n+\n+        obj = arr.read_()\n+        self.assertRaisesRegex(OutOfBoundsError, \"out of bounds\", obj.__getitem__, -1)\n+\n     def test_cast_primitive_value(self):\n         obj = Object(self.prog, \"long\", value=2**32 + 1)\n         self.assertIdentical(cast(\"int\", obj), Object(self.prog, \"int\", value=1))\n"}
{"repo": "drgn", "commit": "7f7529e3f50612cd2726c7bf57b2f0796364f4b6", "diff": "diff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex 57587af6..25cf1622 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -371,8 +371,10 @@ class DrgnCommandDirective(sphinx.util.docutils.SphinxDirective):\n             target[\"ids\"].append(node_id)\n             self.state.document.note_explicit_target(target)\n \n-            std = self.env.domains.standard_domain\n-            std.note_object(\"drgncommand\", name, node_id, location=target)\n+            std = self.env.get_domain(\"std\")\n+            std.note_object(  # type: ignore[attr-defined]\n+                \"drgncommand\", name, node_id, location=target\n+            )\n \n         return nodes\n \n"}
{"repo": "drgn", "commit": "4f41106ef3c07addfda9580a737236e80fe0bf3f", "diff": "diff --git a/docs/exts/drgndoc/commands.py b/docs/exts/drgndoc/commands.py\nindex 87881c58..147677a5 100644\n--- a/docs/exts/drgndoc/commands.py\n+++ b/docs/exts/drgndoc/commands.py\n@@ -271,7 +271,9 @@ class CommandFormatter:\n         raise UnrecognizedInputError(\"option has no names\")\n \n     @staticmethod\n-    def _option_string(node: ast.Call, *, usage: bool) -> str:\n+    def _option_string(\n+        node: ast.Call, *, usage: bool, in_mutually_exclusive_group: bool = False\n+    ) -> str:\n         if usage:\n \n             def format_option_name(s: str) -> str:\n@@ -393,6 +395,20 @@ class CommandFormatter:\n             return arg_name\n \n         arg_str = format_arg_name(arg_name)\n+\n+        if positional and in_mutually_exclusive_group:\n+            # A positional argument in a mutually exclusive group must be\n+            # optional based on nargs, but inside of the mutually exclusive\n+            # group, we want to format it as if it were mandatory.\n+            if nargs == \"?\":\n+                nargs = 1\n+            elif nargs == \"*\":\n+                nargs = \"+\"\n+            else:\n+                raise UnrecognizedInputError(\n+                    f\"unrecognized nargs for positional argument in mutually exclusive group: {nargs!r}\"\n+                )\n+\n         if nargs != 1:\n             if isinstance(nargs, int):\n                 arg_str = \" \".join([arg_str] * nargs)\n@@ -428,11 +444,17 @@ class CommandFormatter:\n         parts_end: List[str] = []\n \n         def append_argument_usage(\n-            type: _ArgumentType, node: ast.Call, nested: bool = False\n+            type: _ArgumentType,\n+            node: ast.Call,\n+            in_mutually_exclusive_group: bool = False,\n         ) -> None:\n             if type == \"drgn.commands.argument\":\n                 try:\n-                    option_string = self._option_string(node, usage=True)\n+                    option_string = self._option_string(\n+                        node,\n+                        usage=True,\n+                        in_mutually_exclusive_group=in_mutually_exclusive_group,\n+                    )\n                     if not option_string:\n                         return\n                 except UnrecognizedInputError as e:\n@@ -440,15 +462,21 @@ class CommandFormatter:\n                     return\n \n                 positional = self._option_is_positional(node)\n-                target = parts_end if positional else parts\n+                # Unlike argparse, we keep positional arguments inside of\n+                # mutually exclusive groups.\n+                target = (\n+                    parts_end\n+                    if not in_mutually_exclusive_group and positional\n+                    else parts\n+                )\n \n                 brackets = (\n-                    not nested\n+                    not in_mutually_exclusive_group\n                     and not positional\n                     and not _get_bool_kwarg(node, \"required\")\n                 )\n \n-                if not nested:\n+                if not in_mutually_exclusive_group:\n                     target.append(\" \")\n                 if brackets:\n                     target.append(\"[\")\n@@ -464,7 +492,7 @@ class CommandFormatter:\n                 for i, (type, node) in enumerate(self._group_arguments(command, node)):\n                     if i != 0:\n                         parts.append(\" | \")\n-                    append_argument_usage(type, node, nested=True)\n+                    append_argument_usage(type, node, in_mutually_exclusive_group=True)\n                 parts.append(\")\" if required else \"]\")\n             else:\n                 assert_never(type)\n"}
{"repo": "drgn", "commit": "9e62d688cda0c872267abee157c98da7dff023e7", "diff": "diff --git a/docs/exts/drgndoc/namespace.py b/docs/exts/drgndoc/namespace.py\nindex 464c470a..fd249cbe 100644\n--- a/docs/exts/drgndoc/namespace.py\n+++ b/docs/exts/drgndoc/namespace.py\n@@ -1,9 +1,17 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n-import dataclasses\n import itertools\n-from typing import Generic, Iterator, List, Mapping, Sequence, TypeVar, Union\n+from typing import (\n+    Generic,\n+    Iterator,\n+    List,\n+    Mapping,\n+    NamedTuple,\n+    Sequence,\n+    TypeVar,\n+    Union,\n+)\n \n from drgndoc.parse import (\n     Class,\n@@ -19,14 +27,12 @@ from drgndoc.parse import (\n NodeT_co = TypeVar(\"NodeT_co\", bound=Node, covariant=True)\n \n \n-@dataclasses.dataclass\n-class BoundNode(Generic[NodeT_co]):\n+class BoundNode(NamedTuple, Generic[NodeT_co]):\n     name: str\n     node: NodeT_co\n \n \n-@dataclasses.dataclass\n-class ResolvedNode(Generic[NodeT_co]):\n+class ResolvedNode(NamedTuple, Generic[NodeT_co]):\n     modules: Sequence[BoundNode[Module]]\n     classes: Sequence[BoundNode[Class]]\n     name: str\n"}
{"repo": "drgn", "commit": "629bea548e7da373a7b8dd59781f9bec04ab4abb", "diff": "diff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex 07273370..57587af6 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -353,7 +353,15 @@ class DrgnCommandDirective(sphinx.util.docutils.SphinxDirective):\n \n         self.env.ref_context[\"std:program\"] = name\n \n-        nodes = self.parse_content_to_nodes(allow_section_headings=True)\n+        # parse_content_to_nodes() was added in Sphinx 7.4. Fall back to an\n+        # equivalent on older versions.\n+        if hasattr(self, \"parse_content_to_nodes\"):\n+            nodes = self.parse_content_to_nodes(allow_section_headings=True)\n+        else:\n+            node = docutils.nodes.Element()\n+            node.document = self.state.document\n+            sphinx.util.nodes.nested_parse_with_titles(self.state, self.content, node)\n+            nodes = node.children\n \n         if nodes:\n             node_id = sphinx.util.nodes.make_id(\n"}
{"repo": "drgn", "commit": "5998092b9dda9279aa61ade06fa931bde59d2d11", "diff": "diff --git a/drgn/helpers/linux/printk.py b/drgn/helpers/linux/printk.py\nindex 71a5e527..4313dfab 100644\n--- a/drgn/helpers/linux/printk.py\n+++ b/drgn/helpers/linux/printk.py\n@@ -299,7 +299,7 @@ def print_dmesg(\n     prog: Program,\n     *,\n     human_readable_time: bool = False,\n-    file: \"Optional[SupportsWrite[str]]\" = None\n+    file: \"Optional[SupportsWrite[str]]\" = None,\n ) -> None:\n     \"\"\"\n     Print the contents of the kernel log buffer.\n"}
{"repo": "drgn", "commit": "49d7f8afef620ce12e31dcc40740aebc63cea35e", "diff": "diff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex af5cc2d6..b72df66f 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -107,6 +107,17 @@ def missing_reference(\n         reftarget = node.get(\"reftarget\")\n         if reftarget and node.get(\"reftype\") == \"class\":\n             resolved = env.drgndoc_namespace.resolve_global_name(reftarget)\n+            if not isinstance(resolved, ResolvedNode):\n+                py_module = node.get(\"py:module\", \"\")\n+                if py_module:\n+                    resolved = env.drgndoc_namespace.resolve_global_name(\n+                        dot_join(py_module, reftarget)\n+                    )\n+                classes = node.get(\"classes\")\n+                if not isinstance(resolved, ResolvedNode) and classes:\n+                    resolved = env.drgndoc_namespace.resolve_global_name(\n+                        dot_join(py_module, *classes, reftarget)\n+                    )\n             if (\n                 isinstance(resolved, ResolvedNode)\n                 and isinstance(resolved.node, Variable)\n"}
{"repo": "drgn", "commit": "ad549815f7a965099d485accbdddc3f2a6140e90", "diff": "diff --git a/tests/linux_kernel/helpers/test_module.py b/tests/linux_kernel/helpers/test_module.py\nindex 9b9dee22..953e511d 100644\n--- a/tests/linux_kernel/helpers/test_module.py\n+++ b/tests/linux_kernel/helpers/test_module.py\n@@ -12,7 +12,8 @@ from tests.linux_kernel import LinuxKernelTestCase, skip_unless_have_test_kmod\n \n class TestListModules(LinuxKernelTestCase):\n     def test_for_each_module(self):\n-        sys_modules = set(line.split(maxsplit=1)[0] for line in open(\"/proc/modules\"))\n+        with open(\"/proc/modules\") as f:\n+            sys_modules = set(line.split(maxsplit=1)[0] for line in f)\n         drgn_modules = set()\n         for module in for_each_module(self.prog):\n             drgn_modules.add(module.name.string_().decode())\n"}
{"repo": "drgn", "commit": "2429f4f4d4a09a63e4104c548dabd1d7aa56e072", "diff": "diff --git a/tests/linux_kernel/helpers/test_pid.py b/tests/linux_kernel/helpers/test_pid.py\nindex 8b2600db..e4623570 100644\n--- a/tests/linux_kernel/helpers/test_pid.py\n+++ b/tests/linux_kernel/helpers/test_pid.py\n@@ -34,11 +34,8 @@ class TestPid(LinuxKernelTestCase):\n         NUM_PROCS = 12\n         barrier = Barrier(NUM_PROCS + 1)\n \n-        def proc_func():\n-            barrier.wait()\n-\n         try:\n-            procs = [Process(target=proc_func) for _ in range(NUM_PROCS)]\n+            procs = [Process(target=barrier.wait) for _ in range(NUM_PROCS)]\n             for proc in procs:\n                 proc.start()\n             pids = {task.pid.value_() for task in for_each_task(self.prog)}\ndiff --git a/tests/linux_kernel/test_threads.py b/tests/linux_kernel/test_threads.py\nindex f363403c..aa778a42 100644\n--- a/tests/linux_kernel/test_threads.py\n+++ b/tests/linux_kernel/test_threads.py\n@@ -13,11 +13,8 @@ class TestThreads(LinuxKernelTestCase):\n         NUM_PROCS = 12\n         barrier = Barrier(NUM_PROCS + 1)\n \n-        def proc_func():\n-            barrier.wait()\n-\n         try:\n-            procs = [Process(target=proc_func) for _ in range(NUM_PROCS)]\n+            procs = [Process(target=barrier.wait) for _ in range(NUM_PROCS)]\n             for proc in procs:\n                 proc.start()\n             pids = {thread.tid for thread in self.prog.threads()}\n"}
{"repo": "drgn", "commit": "9e833f5de6f4bded33d5c721b5a4011e60b18744", "diff": "diff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 443b3b7a..4f3a9f53 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -971,8 +971,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info([crashme_path])\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided path should be used for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1027,8 +1027,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info([crashme_path], main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided path should be used for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1053,8 +1053,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info(main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and set the file for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1168,8 +1168,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info([crashme_dwz_path, crashme_alt_path], main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided paths should be used for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1200,8 +1200,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info(main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and set the files for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1236,8 +1236,8 @@ class TestLoadDebugInfo(TestCase):\n             main=True,\n         )\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided path should be used for the loaded file.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1275,8 +1275,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.assertRaises(MissingDebugInfoError, self.prog.load_debug_info, main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and set the loaded file for the main\n         # module but fail to find the supplementary file.\n         self.assertEqual(\n@@ -1313,8 +1313,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info([crashme_dwz_path], main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided path should be used for the main module.\n         self.assertEqual(\n             self.prog.main_module().loaded_file_path,\n@@ -1381,8 +1381,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info([crashme_alt_path], main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The provided path should be used for the supplementary file.\n         self.assertEqual(\n             self.prog.main_module().supplementary_debug_file_path,\n@@ -1420,8 +1420,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.prog.load_debug_info(main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and set the supplementary file for the\n         # main module.\n         self.assertEqual(\n@@ -1448,8 +1448,8 @@ class TestLoadDebugInfo(TestCase):\n \n         self.assertRaises(MissingDebugInfoError, self.prog.load_debug_info, main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and fail to find the supplementary file\n         # for the main module, but the supplementary file should still be\n         # wanted.\n@@ -1570,8 +1570,8 @@ class TestLoadDebugInfoCoreNoHeaders(TestCase):\n \n         self.prog.load_debug_info(main=True)\n \n-        # Only the main module should be created.\n-        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The main module should be created.\n+        self.assertIn(self.prog.main_module(), list(self.prog.modules()))\n         # The finder should be called and set the files, address range, and\n         # build ID for the main module.\n         self.assertEqual(\n"}
{"repo": "drgn", "commit": "079633bf98dea4131dd5a360a04a0747574c73ce", "diff": "diff --git a/docs/conf.py b/docs/conf.py\nindex 040f1cef..703a2047 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -1,8 +1,8 @@\n import os.path\n import sys\n \n-sys.path.append(os.path.abspath(\"..\"))\n-sys.path.append(os.path.abspath(\"exts\"))\n+sys.path.insert(0, os.path.abspath(\"..\"))\n+sys.path.insert(0, os.path.abspath(\"exts\"))\n \n master_doc = \"index\"\n \n"}
{"repo": "drgn", "commit": "454fefc46e288051cd0fdac62b94c75c5966c492", "diff": "diff --git a/drgn/helpers/linux/net.py b/drgn/helpers/linux/net.py\nindex dabb73a9..c1bd7105 100644\n--- a/drgn/helpers/linux/net.py\n+++ b/drgn/helpers/linux/net.py\n@@ -287,6 +287,9 @@ def is_pp_page(page: Object) -> bool:\n     Check if given page is a page_pool page.\n \n     :param page: ``struct page *``\n+    :raises NotImplementedError: If page_pool pages cannot be identified on\n+        this kernel. This is the case from Linux 4.18 (when page_pool was\n+        introduced) up to and including Linux 5.13.\n     \"\"\"\n     PP_SIGNATURE = _poison_pointer_delta(page.prog_) + 0x40\n     PP_MAGIC_MASK = ~0x3\n@@ -294,4 +297,13 @@ def is_pp_page(page: Object) -> bool:\n     try:\n         return (page.pp_magic & PP_MAGIC_MASK) == PP_SIGNATURE\n     except AttributeError:\n+        pass\n+    # Before Linux kernel commit ff7d6b27f894 (\"page_pool: refurbish version of\n+    # page_pool code\") (in v4.18), page_pool didn't exist.\n+    try:\n+        page.prog_.type(\"struct page_pool\")\n+    except LookupError:\n         return False\n+    # Between that and Linux kernel commit c07aea3ef4d4 (\"mm: add a signature\n+    # in struct page\") (in v5.14), there is no way to identify page_pool pages.\n+    raise NotImplementedError(\"page_pool pages cannot be identified before Linux 5.14\")\n"}
{"repo": "drgn", "commit": "a15b520446f9204f78154fa02baa3e64b8356193", "diff": "diff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex a6360c16..3c8598fb 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -4,8 +4,10 @@\n import itertools\n import lzma\n import tempfile\n+import unittest\n \n from _drgn_util.elf import ET, PT, SHF, SHT, STB, STT\n+import drgn\n from drgn import Program, Symbol, SymbolBinding, SymbolIndex, SymbolKind\n from tests import TestCase\n from tests.dwarfwriter import create_dwarf_file\n@@ -566,6 +568,7 @@ class TestElfSymbol(TestCase):\n         self.assertEqual(prog.symbol(0xFFFF0004), full)\n \n \n+@unittest.skipUnless(drgn._with_lzma, \"built without lzma support\")\n class TestGnuDebugdata(TestCase):\n \n     def assert_all_symbols_found_by_name(self, prog, symbols):\n"}
{"repo": "drgn", "commit": "cf2034250e30e3a60b5022c8416000b1a26a5b4f", "diff": "diff --git a/tests/elfwriter.py b/tests/elfwriter.py\nindex 65d53142..dfb03c9e 100644\n--- a/tests/elfwriter.py\n+++ b/tests/elfwriter.py\n@@ -69,6 +69,11 @@ def _create_symtab(\n     strtab_name = \".dynstr\" if dynamic else \".strtab\"\n     assert not any(section.name in (symtab_name, strtab_name) for section in sections)\n \n+    # An empty symbol name is a placeholder for the implicit 0-index entry in\n+    # the symbol table. It's used to create a valid, but empty symbol table.\n+    if symbols and symbols[0].name == \"\":\n+        symbols = symbols[1:]\n+\n     endian = \"<\" if little_endian else \">\"\n     if bits == 64:\n         symbol_struct = struct.Struct(endian + \"IBBHQQ\")\ndiff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex f6333d09..a6360c16 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -2,6 +2,7 @@\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n import itertools\n+import lzma\n import tempfile\n \n from _drgn_util.elf import ET, PT, SHF, SHT, STB, STT\n@@ -18,22 +19,31 @@ def add_shndx(symbols, shndx):\n     ]\n \n \n-def create_elf_symbol_file(symbols=(), dynamic_symbols=(), dwarf=False):\n+def create_elf_symbol_file(\n+    symbols=(),\n+    dynamic_symbols=(),\n+    gnu_debugdata_symbols=(),\n+    dwarf=False,\n+    loadable=True,\n+):\n     def symbols_start(symbols):\n         return min(symbol.value for symbol in symbols)\n \n     def symbols_end(symbols):\n         return max(symbol.value + max(symbol.size, 1) for symbol in symbols)\n \n-    if symbols and dynamic_symbols:\n-        start = min(symbols_start(symbols), symbols_start(dynamic_symbols))\n-        end = max(symbols_end(symbols), symbols_end(dynamic_symbols))\n-    elif symbols:\n-        start = symbols_start(symbols)\n-        end = symbols_end(symbols)\n-    else:\n-        start = symbols_start(dynamic_symbols)\n-        end = symbols_end(dynamic_symbols)\n+    assert symbols or dynamic_symbols or gnu_debugdata_symbols\n+    start = float(\"inf\")\n+    end = float(\"-inf\")\n+    if symbols:\n+        start = min(start, symbols_start(symbols))\n+        end = max(end, symbols_end(symbols))\n+    if dynamic_symbols:\n+        start = min(start, symbols_start(dynamic_symbols))\n+        end = max(end, symbols_end(dynamic_symbols))\n+    if gnu_debugdata_symbols:\n+        start = min(start, symbols_start(gnu_debugdata_symbols))\n+        end = max(end, symbols_end(gnu_debugdata_symbols))\n \n     start &= ~7\n     end = (end + 7) & ~7\n@@ -47,49 +57,76 @@ def create_elf_symbol_file(symbols=(), dynamic_symbols=(), dwarf=False):\n         ElfSection(\n             name=\".data\",\n             sh_type=SHT.PROGBITS,\n-            sh_flags=SHF.ALLOC,\n+            sh_flags=SHF.ALLOC if loadable else 0,\n             p_type=PT.LOAD,\n             vaddr=start,\n             memsz=size,\n             data=bytes(size),\n         ),\n     ]\n+    symbols = add_shndx(symbols, len(sections))\n+    dynamic_symbols = add_shndx(dynamic_symbols, len(sections))\n+\n+    if gnu_debugdata_symbols:\n+        gds_sections = [\n+            ElfSection(\n+                name=\".data\",\n+                sh_type=SHT.NOBITS,\n+                sh_flags=SHF.ALLOC,\n+                p_type=PT.LOAD,\n+                vaddr=start,\n+                memsz=size,\n+            ),\n+        ]\n+        gds_contents = create_elf_file(\n+            ET.EXEC,\n+            sections=gds_sections,\n+            symbols=add_shndx(gnu_debugdata_symbols, len(gds_sections)),\n+        )\n+        compressor = lzma.LZMACompressor()\n+        gds_compressed = compressor.compress(gds_contents) + compressor.flush()\n+        sections.append(\n+            ElfSection(\n+                name=\".gnu_debugdata\",\n+                sh_type=SHT.PROGBITS,\n+                memsz=len(gds_compressed),\n+                data=gds_compressed,\n+            )\n+        )\n \n     if dwarf:\n         contents = create_dwarf_file(\n             (),\n             sections=sections,\n-            symbols=add_shndx(symbols, len(sections)),\n-            dynamic_symbols=add_shndx(dynamic_symbols, len(sections)),\n+            symbols=symbols,\n+            dynamic_symbols=dynamic_symbols,\n         )\n     else:\n         contents = create_elf_file(\n             ET.EXEC,\n             sections=sections,\n-            symbols=add_shndx(symbols, len(sections)),\n-            dynamic_symbols=add_shndx(dynamic_symbols, len(sections)),\n+            symbols=symbols,\n+            dynamic_symbols=dynamic_symbols,\n         )\n \n     return contents, start, end\n \n \n-def program_add_elf_symbol_file(prog, name, **kwargs):\n+def module_set_elf_symbol_file(module, **kwargs):\n     contents, start, end = create_elf_symbol_file(**kwargs)\n \n     with tempfile.NamedTemporaryFile() as f:\n         f.write(contents)\n         f.flush()\n \n-        module = prog.extra_module(name, create=True)\n-\n         if module.address_range is None:\n-            for other_module in prog.modules():\n+            for other_module in module.prog.modules():\n                 other_address_range = other_module.address_range\n                 if other_address_range is not None:\n                     other_start, other_end = other_address_range\n                     assert (\n                         end <= other_start or start >= other_end\n-                    ), f\"{name} overlaps {other_module.name}\"\n+                    ), f\"{module.name} overlaps {other_module.name}\"\n             module.address_range = (start, end)\n         else:\n             assert (start, end) == module.address_range\n@@ -97,6 +134,11 @@ def program_add_elf_symbol_file(prog, name, **kwargs):\n         module.try_file(f.name, force=True)\n \n \n+def program_add_elf_symbol_file(prog, name, **kwargs):\n+    module = prog.extra_module(name, create=True)\n+    module_set_elf_symbol_file(module, **kwargs)\n+\n+\n def elf_symbol_program(*modules):\n     prog = Program()\n     for i, symbols in enumerate(modules):\n@@ -524,6 +566,201 @@ class TestElfSymbol(TestCase):\n         self.assertEqual(prog.symbol(0xFFFF0004), full)\n \n \n+class TestGnuDebugdata(TestCase):\n+\n+    def assert_all_symbols_found_by_name(self, prog, symbols):\n+        for symbol in symbols:\n+            self.assertEqual(prog.symbol(symbol.name), symbol)\n+\n+    def assert_all_symbols_found_by_address(self, prog, symbols):\n+        for symbol in symbols:\n+            self.assertEqual(prog.symbol(symbol.address), symbol)\n+            self.assertEqual(prog.symbol(symbol.address + symbol.size - 1), symbol)\n+\n+    def assert_all_symbols_returned_by_lookup(self, prog, symbols):\n+        def sort_key(sym):\n+            return (sym.address, sym.name)\n+\n+        expected = sorted(symbols, key=sort_key)\n+        actual = prog.symbols()\n+        actual.sort(key=sort_key)\n+        self.assertEqual(expected, actual)\n+\n+    def test_gnu_debugdata_and_dynamic_lookup(self):\n+        gnu_symbols = [\n+            ElfSymbol(\"first\", 0xFFFF0000, 0x8, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"second\", 0xFFFF0018, 0x8, STT.FUNC, STB.LOCAL),\n+        ]\n+        dynamic_symbols = [\n+            ElfSymbol(\"third\", 0xFFFF0010, 0x8, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"fourth\", 0xFFFF0008, 0x8, STT.FUNC, STB.LOCAL),\n+        ]\n+        prog = Program()\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            dynamic_symbols=dynamic_symbols,\n+            gnu_debugdata_symbols=gnu_symbols,\n+        )\n+        drgn_symbols = [\n+            Symbol(\"first\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+            Symbol(\"second\", 0xFFFF0018, 0x8, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+            Symbol(\"third\", 0xFFFF0010, 0x8, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+            Symbol(\"fourth\", 0xFFFF0008, 0x8, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+        ]\n+        self.assert_all_symbols_found_by_name(prog, drgn_symbols)\n+        self.assert_all_symbols_found_by_address(prog, drgn_symbols)\n+        self.assert_all_symbols_returned_by_lookup(prog, drgn_symbols)\n+\n+    def test_sizeless_symbols_gnu_debugdata(self):\n+        gnu_symbols = [\n+            ElfSymbol(\"zero\", 0xFFFF0000, 0x0, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"two\", 0xFFFF0002, 0x4, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"ten\", 0xFFFF000A, 0x0, STT.FUNC, STB.LOCAL),\n+        ]\n+        dynamic_symbols = [\n+            ElfSymbol(\"four\", 0xFFFF0004, 0x0, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"eight\", 0xFFFF0008, 0x0, STT.FUNC, STB.LOCAL),\n+        ]\n+        drgn_symbols = {\n+            s.name: s\n+            for s in (\n+                Symbol(\"zero\", 0xFFFF0000, 0x0, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+                Symbol(\"two\", 0xFFFF0002, 0x4, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+                Symbol(\"four\", 0xFFFF0004, 0x0, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+                Symbol(\"eight\", 0xFFFF0008, 0x0, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+                Symbol(\"ten\", 0xFFFF000A, 0x0, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+            )\n+        }\n+\n+        for swap in (False, True):\n+            prog = Program()\n+            program_add_elf_symbol_file(\n+                prog,\n+                \"module0\",\n+                dynamic_symbols=gnu_symbols if swap else dynamic_symbols,\n+                gnu_debugdata_symbols=dynamic_symbols if swap else gnu_symbols,\n+            )\n+\n+            self.assert_all_symbols_found_by_name(prog, drgn_symbols.values())\n+            self.assert_all_symbols_returned_by_lookup(prog, drgn_symbols.values())\n+\n+            # Address 9 has a best match in .dynsym, despite other sizeless matches\n+            # in .gnu_debugdata.\n+            self.assertEqual(drgn_symbols[\"eight\"], prog.symbol(0xFFFF0009))\n+\n+            # Address 5 is conained by symbol \"two\" in .gnu_debugdata, despite\n+            # \"four\" being a sizeless match in .dynsym.\n+            self.assertEqual(drgn_symbols[\"two\"], prog.symbol(0xFFFF0005))\n+\n+            # Address 11 has a best sizeless match of \"ten\" in .gnu_debugdata,\n+            # despite having a sizeless match of \"eight\" in .dynsym.\n+            self.assertEqual(drgn_symbols[\"ten\"], prog.symbol(0xFFFF000B))\n+\n+    def test_file_preferences(self):\n+        # We need to be careful to make the address range the same for both\n+        # files: so the minimum and maximum address for gnu + dynamic must be\n+        # the same as for symtab.\n+        # Normally a debug file would contain the same symbols as the loaded\n+        # file, plus more. For testing, give them different names to\n+        # distinguish.\n+        loaded = [\n+            ElfSymbol(\"loaded_lo\", 0xFFFF0000, 0x4, STT.FUNC, STB.LOCAL),\n+            ElfSymbol(\"loaded_hi\", 0xFFFF0004, 0x4, STT.FUNC, STB.LOCAL),\n+        ]\n+        debug = [\n+            ElfSymbol(\"symtab_lo\", 0xFFFF0000, 0x4, STT.OBJECT, STB.LOCAL),\n+            ElfSymbol(\"symtab_hi\", 0xFFFF0004, 0x4, STT.OBJECT, STB.LOCAL),\n+        ]\n+        empty = [ElfSymbol(\"\", 0xFFFF0000, 0, 0, 0, 0, 0)]\n+        loaded_file_symbols = [\n+            Symbol(\"loaded_lo\", 0xFFFF0000, 0x4, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+            Symbol(\"loaded_hi\", 0xFFFF0004, 0x4, SymbolBinding.LOCAL, SymbolKind.FUNC),\n+        ]\n+        debug_file_symbols = [\n+            Symbol(\n+                \"symtab_lo\", 0xFFFF0000, 0x4, SymbolBinding.LOCAL, SymbolKind.OBJECT\n+            ),\n+            Symbol(\n+                \"symtab_hi\", 0xFFFF0004, 0x4, SymbolBinding.LOCAL, SymbolKind.OBJECT\n+            ),\n+        ]\n+        file_choices = {\n+            \"loaded\": (\n+                {\"gnu_debugdata_symbols\": loaded[:1], \"dynamic_symbols\": loaded[1:]},\n+                loaded_file_symbols,\n+            ),\n+            \"loaded_dyn\": (\n+                {\"dynamic_symbols\": loaded},\n+                loaded_file_symbols,\n+            ),\n+            \"loaded_gnu\": (\n+                {\"gnu_debugdata_symbols\": loaded},\n+                loaded_file_symbols,\n+            ),\n+            \"loaded_gnu_dynempty\": (\n+                {\"gnu_debugdata_symbols\": loaded, \"dynamic_symbols\": empty},\n+                loaded_file_symbols,\n+            ),\n+            \"debug\": (\n+                {\"symbols\": debug, \"dwarf\": True, \"loadable\": False},\n+                debug_file_symbols,\n+            ),\n+            \"debug_dyn\": (\n+                {\"dynamic_symbols\": debug, \"dwarf\": True, \"loadable\": False},\n+                debug_file_symbols,\n+            ),\n+        }\n+\n+        # First file, second file, whether or not the symtab should be replaced.\n+        # Combining the symbol table is possible in a corner case (.dynsym from\n+        # the debug file, plus .gnu_debugdata from the loaded, if the loaded\n+        # file has no .dynsym of its own). This really ought not to happen in\n+        # practice, but it's worth ensuring that it's handled safely.\n+        cases = [\n+            (\"loaded\", \"debug\", \"replace\"),\n+            (\"loaded_dyn\", \"debug\", \"replace\"),\n+            (\"loaded_gnu\", \"debug\", \"replace\"),\n+            (\"loaded_gnu_dynempty\", \"debug\", \"replace\"),\n+            (\"debug\", \"loaded\", None),\n+            (\"debug\", \"loaded_dyn\", None),\n+            (\"debug\", \"loaded_gnu\", None),\n+            (\"debug\", \"loaded_gnu_dynempty\", None),\n+            (\"loaded\", \"debug_dyn\", None),\n+            (\"loaded_dyn\", \"debug_dyn\", None),\n+            (\"loaded_gnu\", \"debug_dyn\", \"combine\"),\n+            (\"loaded_gnu_dynempty\", \"debug_dyn\", None),\n+            # We will replace a .dynsym with another .dynsym only if the file\n+            # also has a .gnu_debugdata\n+            (\"debug_dyn\", \"loaded\", \"replace\"),\n+            (\"debug_dyn\", \"loaded_dyn\", None),\n+            (\"debug_dyn\", \"loaded_gnu\", \"combine\"),\n+            (\"debug_dyn\", \"loaded_gnu_dynempty\", \"replace\"),\n+        ]\n+\n+        for first, second, action in cases:\n+            with self.subTest(f\"{first}, {second}\"):\n+                prog = Program()\n+                module = prog.extra_module(\"module0\", create=True)\n+                module_set_elf_symbol_file(module, **file_choices[first][0])\n+                expected = file_choices[first][1]\n+                self.assert_all_symbols_found_by_name(prog, expected)\n+                self.assert_all_symbols_found_by_address(prog, expected)\n+                self.assert_all_symbols_returned_by_lookup(prog, expected)\n+\n+                module_set_elf_symbol_file(module, **file_choices[second][0])\n+                if action == \"replace\":\n+                    expected = file_choices[second][1]\n+                elif action == \"combine\":\n+                    expected = expected + file_choices[second][1]\n+                self.assert_all_symbols_found_by_name(prog, expected)\n+                # We end up with overlapping symbols when tables get combined.\n+                # Don't bother checking address lookup there.\n+                if action != \"combine\":\n+                    self.assert_all_symbols_found_by_address(prog, expected)\n+                self.assert_all_symbols_returned_by_lookup(prog, expected)\n+\n+\n class TestSymbolFinder(TestCase):\n     TEST_SYMS = [\n         Symbol(\"one\", 0xFFFF1000, 16, SymbolBinding.LOCAL, SymbolKind.FUNC),\n"}
{"repo": "drgn", "commit": "f0eda9de7e796079c008ae363b2b4e24f199651e", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 3b0502cd..83f3d319 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -320,26 +320,26 @@ def _load_debugging_symbols(prog: drgn.Program, args: argparse.Namespace) -> Non\n         for option, value in debug_info_options.items():\n             setattr(prog.debug_info_options, option, value)\n \n-    if args.debug_directories is not None:\n-        if args.no_default_debug_directories:\n-            prog.debug_info_options.directories = args.debug_directories\n-        else:\n-            prog.debug_info_options.directories = (\n-                tuple(args.debug_directories) + prog.debug_info_options.directories\n-            )\n-    elif args.no_default_debug_directories:\n-        prog.debug_info_options.directories = ()\n+    def directories_option(arg_name: str, option_name: Optional[str] = None) -> None:\n+        if option_name is None:\n+            option_name = arg_name\n+        arg = getattr(args, arg_name)\n+        no_default = getattr(args, \"no_default_\" + arg_name)\n+        if arg is not None:\n+            if no_default:\n+                setattr(prog.debug_info_options, option_name, arg)\n+            else:\n+                setattr(\n+                    prog.debug_info_options,\n+                    option_name,\n+                    tuple(arg) + getattr(prog.debug_info_options, option_name),\n+                )\n+        elif no_default:\n+            setattr(prog.debug_info_options, option_name, ())\n \n-    if args.kernel_directories is not None:\n-        if args.no_default_kernel_directories:\n-            prog.debug_info_options.kernel_directories = args.kernel_directories\n-        else:\n-            prog.debug_info_options.kernel_directories = (\n-                tuple(args.kernel_directories)\n-                + prog.debug_info_options.kernel_directories\n-            )\n-    elif args.no_default_kernel_directories:\n-        prog.debug_info_options.kernel_directories = ()\n+    directories_option(\"debug_directories\", \"directories\")\n+    directories_option(\"debug_link_directories\")\n+    directories_option(\"kernel_directories\")\n \n     if args.default_symbols is None:\n         args.default_symbols = {\"default\": True, \"main\": True}\n@@ -453,22 +453,40 @@ def _main() -> None:\n         + \"). \"\n         \"This option may be given more than once\",\n     )\n-    symbol_group.add_argument(\n+\n+    directories_group = parser.add_argument_group(\"debugging symbol directories\")\n+    directories_group.add_argument(\n         \"--debug-directory\",\n         dest=\"debug_directories\",\n         metavar=\"PATH\",\n         type=str,\n         action=\"append\",\n-        help=\"search for debugging symbols by build ID and debug link in the given directory. \"\n+        help=\"search for debugging symbols in the given directory. \"\n         \"This option may be given more than once\",\n     )\n-    symbol_group.add_argument(\n+    directories_group.add_argument(\n         \"--no-default-debug-directories\",\n         action=\"store_true\",\n-        help=\"don't search for debugging symbols by build ID and debug link \"\n+        help=\"don't search for debugging symbols \"\n         \"in the standard directories or those added by plugins\",\n     )\n-    symbol_group.add_argument(\n+    directories_group.add_argument(\n+        \"--debug-link-directory\",\n+        dest=\"debug_link_directories\",\n+        metavar=\"PATH\",\n+        type=str,\n+        action=\"append\",\n+        help=\"search for debugging symbols by debug link in the given directory. \"\n+        \"$ORIGIN is replaced with the directory containing the loaded file. \"\n+        \"This option may be given more than once\",\n+    )\n+    directories_group.add_argument(\n+        \"--no-default-debug-link-directories\",\n+        action=\"store_true\",\n+        help=\"don't search for debugging symbols by debug link \"\n+        \"in the standard directories or those added by plugins\",\n+    )\n+    directories_group.add_argument(\n         \"--kernel-directory\",\n         dest=\"kernel_directories\",\n         metavar=\"PATH\",\n@@ -477,7 +495,7 @@ def _main() -> None:\n         help=\"search for the kernel image and loadable kernel modules in the given directory. \"\n         \"This option may be given more than once\",\n     )\n-    symbol_group.add_argument(\n+    directories_group.add_argument(\n         \"--no-default-kernel-directories\",\n         action=\"store_true\",\n         help=\"don't search for the kernel image and loadable kernel modules \"\ndiff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 18039739..443b3b7a 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -565,6 +565,7 @@ class TestLinuxUserspaceCoreDump(TestCase):\n     def setUp(self):\n         self.prog = Program()\n         self.prog.debug_info_options.directories = ()\n+        self.prog.debug_info_options.debug_link_directories = ()\n         self.prog.set_enabled_debug_info_finders([\"standard\"])\n \n     def test_loaded_modules(self):\n@@ -1716,6 +1717,7 @@ class TestStandardDebugInfoFinder(TestCase):\n     def setUp(self):\n         self.prog = Program()\n         self.prog.debug_info_options.directories = ()\n+        self.prog.debug_info_options.debug_link_directories = ()\n         self.prog.set_enabled_debug_info_finders([\"standard\"])\n \n     def test_by_module_name(self):\n@@ -1856,28 +1858,32 @@ class TestStandardDebugInfoFinder(TestCase):\n     def test_by_build_id(self):\n         build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n \n-        with tempfile.TemporaryDirectory(\n-            prefix=\"bin-\"\n-        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n-            bin_dir = Path(bin_dir)\n-            debug_dir = Path(debug_dir)\n-\n-            build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n-            build_id_dir.mkdir(parents=True)\n-            binary_path = build_id_dir / build_id.hex()[2:]\n-            binary_path.write_bytes(\n-                create_dwarf_file((), sections=(ALLOCATED_SECTION,))\n-            )\n+        for i, relative in enumerate((False, True)):\n+            with self.subTest(relative=relative):\n+                with tempfile.TemporaryDirectory(\n+                    prefix=\"bin-\"\n+                ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+                    bin_dir = Path(bin_dir)\n+                    debug_dir = Path(debug_dir)\n+\n+                    build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n+                    build_id_dir.mkdir(parents=True)\n+                    binary_path = build_id_dir / build_id.hex()[2:]\n+                    binary_path.write_bytes(\n+                        create_dwarf_file((), sections=(ALLOCATED_SECTION,))\n+                    )\n \n-            module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n-            module.build_id = build_id\n+                    module = self.prog.extra_module(bin_dir / \"binary\", i, create=True)\n+                    module.build_id = build_id\n \n-            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n-            self.prog.load_module_debug_info(module)\n-            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n-            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n-            self.assertEqual(module.loaded_file_path, str(binary_path))\n-            self.assertEqual(module.debug_file_path, str(binary_path))\n+                    self.prog.debug_info_options.directories = (\n+                        os.path.relpath(debug_dir) if relative else str(debug_dir),\n+                    )\n+                    self.prog.load_module_debug_info(module)\n+                    self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.loaded_file_path, str(binary_path))\n+                    self.assertEqual(module.debug_file_path, str(binary_path))\n \n     def test_by_build_id_separate(self):\n         build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n@@ -1900,7 +1906,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n             module.build_id = build_id\n \n-            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n+            self.prog.debug_info_options.directories = (str(debug_dir),)\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1929,7 +1935,7 @@ class TestStandardDebugInfoFinder(TestCase):\n \n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n \n-            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n+            self.prog.debug_info_options.directories = (str(debug_dir),)\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1957,7 +1963,7 @@ class TestStandardDebugInfoFinder(TestCase):\n \n             self.prog.find_standard_debug_info(\n                 [module],\n-                options=DebugInfoOptions(directories=(\"\", \".debug\", str(debug_dir))),\n+                options=DebugInfoOptions(directories=(str(debug_dir),)),\n             )\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1983,7 +1989,12 @@ class TestStandardDebugInfoFinder(TestCase):\n                 )\n             )\n \n-            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n+            self.prog.debug_info_options.directories = (str(debug_dir),)\n+            self.prog.debug_info_options.debug_link_directories = (\n+                \"$ORIGIN\",\n+                \"$ORIGIN/.debug\",\n+                \"\",\n+            )\n             for i, debug_path in enumerate(\n                 (\n                     bin_dir / \"binary.debug\",\n@@ -2046,6 +2057,111 @@ class TestStandardDebugInfoFinder(TestCase):\n             self.assertEqual(module.loaded_file_path, str(loadable_path))\n             self.assertEqual(module.debug_file_path, str(debug_path))\n \n+    def test_by_gnu_debuglink_origin_with_braces(self):\n+        with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+            bin_dir = Path(bin_dir)\n+\n+            debug_file_contents = create_dwarf_file(())\n+            crc = binascii.crc32(debug_file_contents)\n+            debug_path = bin_dir / \"binary.debug\"\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debuglink=(\"binary.debug\", crc),\n+                )\n+            )\n+\n+            debug_path.parent.mkdir(parents=True, exist_ok=True)\n+            debug_path.write_bytes(debug_file_contents)\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n+\n+            self.prog.debug_info_options.debug_link_directories = (\"${ORIGIN}\",)\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+            self.assertEqual(module.debug_file_path, str(debug_path))\n+\n+    def test_by_gnu_debuglink_not_origin(self):\n+        # Test that strings other than $ORIGIN followed by a word boundary are\n+        # not replaced.\n+        for i, subdir in enumerate((\"$ORIGINAL\", \"$foo\", \"$\")):\n+            with self.subTest(subdir=subdir):\n+                with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+                    bin_dir = Path(bin_dir)\n+                    debug_dir = bin_dir / subdir\n+\n+                    debug_file_contents = create_dwarf_file(())\n+                    crc = binascii.crc32(debug_file_contents)\n+                    debug_path = debug_dir / \"binary.debug\"\n+\n+                    loadable_path = bin_dir / \"binary\"\n+                    loadable_path.write_bytes(\n+                        create_elf_file(\n+                            ET.EXEC,\n+                            sections=(ALLOCATED_SECTION,),\n+                            gnu_debuglink=(\"binary.debug\", crc),\n+                        )\n+                    )\n+\n+                    debug_path.parent.mkdir(parents=True, exist_ok=True)\n+                    debug_path.write_bytes(debug_file_contents)\n+\n+                    module = self.prog.extra_module(bin_dir / \"binary\", i, create=True)\n+\n+                    self.prog.debug_info_options.debug_link_directories = (\n+                        str(debug_dir),\n+                    )\n+                    self.prog.load_module_debug_info(module)\n+                    self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.loaded_file_path, str(loadable_path))\n+                    self.assertEqual(module.debug_file_path, str(debug_path))\n+\n+    def test_by_gnu_debuglink_origin_multiple(self):\n+        # Pathological case combining the cases above.\n+        with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = (\n+                bin_dir\n+                / \"$ORIGINx\"\n+                / (bin_dir.parent / (bin_dir.name + \"x\")).relative_to(\"/\")\n+                / \"$\"\n+                / bin_dir.relative_to(\"/\")\n+                / \"$O\"\n+            )\n+\n+            debug_file_contents = create_dwarf_file(())\n+            crc = binascii.crc32(debug_file_contents)\n+            debug_path = debug_dir / \"binary.debug\"\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debuglink=(\"binary.debug\", crc),\n+                )\n+            )\n+\n+            debug_path.parent.mkdir(parents=True, exist_ok=True)\n+            debug_path.write_bytes(debug_file_contents)\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n+\n+            self.prog.debug_info_options.debug_link_directories = (\n+                str(bin_dir) + \"/$ORIGINx${ORIGIN}x/$$ORIGIN/$O\",\n+            )\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+            self.assertEqual(module.debug_file_path, str(debug_path))\n+\n     def test_by_gnu_debuglink_crc_mismatch(self):\n         with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n             bin_dir = Path(bin_dir)\n@@ -2066,7 +2182,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             debug_path.write_bytes(debug_file_contents)\n \n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)\n-            self.prog.debug_info_options.directories = (\"\",)\n+            self.prog.debug_info_options.debug_link_directories = (\"$ORIGIN\",)\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n \n@@ -2278,7 +2394,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             alt_path.parent.mkdir()\n             alt_path.write_bytes(create_dwarf_file((), build_id=alt_build_id))\n \n-            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n+            self.prog.debug_info_options.directories = (str(debug_dir),)\n             for i, debugaltlink in enumerate(\n                 (\n                     bin_dir / \"debug/.dwz/alt.debug\",\ndiff --git a/tests/test_debug_info_options.py b/tests/test_debug_info_options.py\nindex 87bc168a..00493c7b 100644\n--- a/tests/test_debug_info_options.py\n+++ b/tests/test_debug_info_options.py\n@@ -7,9 +7,7 @@ from tests import TestCase\n \n class TestDebugInfoOptions(TestCase):\n     def test_list_default(self):\n-        self.assertEqual(\n-            DebugInfoOptions().directories, (\"\", \".debug\", \"/usr/lib/debug\")\n-        )\n+        self.assertEqual(DebugInfoOptions().directories, (\"/usr/lib/debug\",))\n \n     def test_list_init(self):\n         self.assertEqual(\n@@ -30,6 +28,10 @@ class TestDebugInfoOptions(TestCase):\n         with self.assertRaises(TypeError):\n             DebugInfoOptions().directories = None\n \n+    def test_directories_empty_string(self):\n+        with self.assertRaises(ValueError):\n+            DebugInfoOptions().directories = (\"\",)\n+\n     def test_bool_default(self):\n         self.assertIs(DebugInfoOptions().try_build_id, True)\n \n"}
{"repo": "drgn", "commit": "c5ebee25633c91dc13cf9cafea3d0af4e4b689d8", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 401150fd..eae96669 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -1218,8 +1218,11 @@ def for_each_vmap_area(prog: Program) -> Iterator[Object]:\n     >>> for va in for_each_vmap_area():\n     ...     caller = \"\"\n     ...     if va.vm:\n-    ...         sym = prog.symbol(va.vm.caller)\n-    ...         if sym:\n+    ...         try:\n+    ...             sym = prog.symbol(va.vm.caller)\n+    ...         except LookupError:\n+    ...             pass\n+    ...         else:\n     ...             caller = f\" {sym.name}\"\n     ...     print(f\"{hex(va.va_start)}-{hex(va.va_end)}{caller}\")\n     ...\n"}
{"repo": "drgn", "commit": "e73a4746fe5edf7e509976989ca2313db6fe7ccb", "diff": "diff --git a/tests/elfwriter.py b/tests/elfwriter.py\nindex 157f6a26..65d53142 100644\n--- a/tests/elfwriter.py\n+++ b/tests/elfwriter.py\n@@ -60,10 +60,14 @@ class ElfSymbol(NamedTuple):\n def _create_symtab(\n     sections: List[ElfSection],\n     symbols: Sequence[ElfSymbol],\n+    *,\n+    dynamic: bool = False,\n     little_endian: bool,\n     bits: int,\n ):\n-    assert not any(section.name in (\".symtab\", \".strtab\") for section in sections)\n+    symtab_name = \".dynsym\" if dynamic else \".symtab\"\n+    strtab_name = \".dynstr\" if dynamic else \".strtab\"\n+    assert not any(section.name in (symtab_name, strtab_name) for section in sections)\n \n     endian = \"<\" if little_endian else \">\"\n     if bits == 64:\n@@ -105,15 +109,15 @@ def _create_symtab(\n \n     sections.append(\n         ElfSection(\n-            name=\".symtab\",\n-            sh_type=SHT.SYMTAB,\n+            name=symtab_name,\n+            sh_type=SHT.DYNSYM if dynamic else SHT.SYMTAB,\n             data=symtab_data,\n             sh_link=sum((1 for section in sections if section.name is not None), 2),\n             sh_info=sh_info,\n             sh_entsize=symbol_struct.size,\n         )\n     )\n-    sections.append(ElfSection(name=\".strtab\", sh_type=SHT.STRTAB, data=strtab_data))\n+    sections.append(ElfSection(name=strtab_name, sh_type=SHT.STRTAB, data=strtab_data))\n \n \n def create_elf_file(\n@@ -121,6 +125,7 @@ def create_elf_file(\n     sections: Sequence[ElfSection] = (),\n     symbols: Sequence[ElfSymbol] = (),\n     *,\n+    dynamic_symbols: Sequence[ElfSymbol] = (),\n     build_id: Optional[bytes] = None,\n     gnu_debuglink: Optional[\n         Tuple[Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"], int]\n@@ -148,6 +153,14 @@ def create_elf_file(\n     nhdr_struct = struct.Struct(endian + \"3I\")\n \n     sections = list(sections)\n+    if dynamic_symbols:\n+        _create_symtab(\n+            sections,\n+            dynamic_symbols,\n+            dynamic=True,\n+            little_endian=little_endian,\n+            bits=bits,\n+        )\n     if symbols:\n         _create_symtab(sections, symbols, little_endian=little_endian, bits=bits)\n     if build_id is not None:\ndiff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex 04e23e19..f6333d09 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -7,15 +7,40 @@ import tempfile\n from _drgn_util.elf import ET, PT, SHF, SHT, STB, STT\n from drgn import Program, Symbol, SymbolBinding, SymbolIndex, SymbolKind\n from tests import TestCase\n+from tests.dwarfwriter import create_dwarf_file\n from tests.elfwriter import ElfSection, ElfSymbol, create_elf_file\n \n \n-def create_elf_symbol_file(symbols):\n+def add_shndx(symbols, shndx):\n+    return [\n+        symbol._replace(shindex=shndx if symbol.shindex is None else symbol.shindex)\n+        for symbol in symbols\n+    ]\n+\n+\n+def create_elf_symbol_file(symbols=(), dynamic_symbols=(), dwarf=False):\n+    def symbols_start(symbols):\n+        return min(symbol.value for symbol in symbols)\n+\n+    def symbols_end(symbols):\n+        return max(symbol.value + max(symbol.size, 1) for symbol in symbols)\n+\n+    if symbols and dynamic_symbols:\n+        start = min(symbols_start(symbols), symbols_start(dynamic_symbols))\n+        end = max(symbols_end(symbols), symbols_end(dynamic_symbols))\n+    elif symbols:\n+        start = symbols_start(symbols)\n+        end = symbols_end(symbols)\n+    else:\n+        start = symbols_start(dynamic_symbols)\n+        end = symbols_end(dynamic_symbols)\n+\n+    start &= ~7\n+    end = (end + 7) & ~7\n+\n     # Create a section for the symbols to reference and the corresponding\n     # segment for address lookups. It must be SHF_ALLOC and must not be\n     # SHT_NOBITS or SHT_NOTE for the file to be loadable.\n-    start = min(symbol.value for symbol in symbols) & ~7\n-    end = (max(symbol.value + max(symbol.size, 1) for symbol in symbols) + 7) & ~7\n     size = end - start\n     assert size <= 4096, \"symbols are too far apart; file would be too large\"\n     sections = [\n@@ -29,31 +54,53 @@ def create_elf_symbol_file(symbols):\n             data=bytes(size),\n         ),\n     ]\n-    symbols = [\n-        symbol._replace(\n-            shindex=len(sections) if symbol.shindex is None else symbol.shindex\n+\n+    if dwarf:\n+        contents = create_dwarf_file(\n+            (),\n+            sections=sections,\n+            symbols=add_shndx(symbols, len(sections)),\n+            dynamic_symbols=add_shndx(dynamic_symbols, len(sections)),\n         )\n-        for symbol in symbols\n-    ]\n-    return create_elf_file(ET.EXEC, sections, symbols), start, end\n+    else:\n+        contents = create_elf_file(\n+            ET.EXEC,\n+            sections=sections,\n+            symbols=add_shndx(symbols, len(sections)),\n+            dynamic_symbols=add_shndx(dynamic_symbols, len(sections)),\n+        )\n+\n+    return contents, start, end\n+\n+\n+def program_add_elf_symbol_file(prog, name, **kwargs):\n+    contents, start, end = create_elf_symbol_file(**kwargs)\n+\n+    with tempfile.NamedTemporaryFile() as f:\n+        f.write(contents)\n+        f.flush()\n+\n+        module = prog.extra_module(name, create=True)\n+\n+        if module.address_range is None:\n+            for other_module in prog.modules():\n+                other_address_range = other_module.address_range\n+                if other_address_range is not None:\n+                    other_start, other_end = other_address_range\n+                    assert (\n+                        end <= other_start or start >= other_end\n+                    ), f\"{name} overlaps {other_module.name}\"\n+            module.address_range = (start, end)\n+        else:\n+            assert (start, end) == module.address_range\n+\n+        module.try_file(f.name, force=True)\n \n \n def elf_symbol_program(*modules):\n     prog = Program()\n-    address_ranges = []\n-    for symbols in modules:\n-        with tempfile.NamedTemporaryFile() as f:\n-            contents, start, end = create_elf_symbol_file(symbols)\n-            f.write(contents)\n-            f.flush()\n-            for i, (other_start, other_end) in enumerate(address_ranges):\n-                assert (\n-                    end <= other_start or start >= other_end\n-                ), f\"module {len(address_ranges)} overlaps module {i}\"\n-            address_ranges.append((start, end))\n-            module = prog.extra_module(f.name, create=True)\n-            module.address_range = (start, end)\n-            module.try_file(f.name, force=True)\n+    for i, symbols in enumerate(modules):\n+        program_add_elf_symbol_file(prog, f\"module{i}\", symbols=symbols)\n     return prog\n \n \n@@ -381,6 +428,101 @@ class TestElfSymbol(TestCase):\n         prog = elf_symbol_program(*elf_syms)\n         self.assert_symbols_equal_unordered(prog.symbols(), syms)\n \n+    def test_dynsym(self):\n+        prog = Program()\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            dynamic_symbols=[\n+                ElfSymbol(\"sym\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+        )\n+\n+        sym = Symbol(\"sym\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.OBJECT)\n+        self.assertEqual(prog.symbol(\"sym\"), sym)\n+        self.assertEqual(prog.symbol(0xFFFF0004), sym)\n+\n+    def test_ignore_dynsym_same_file(self):\n+        # Test that .dynsym is ignored in a file with both .symtab and .dynsym.\n+        prog = Program()\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            # Normally .symtab is a superset of .dynsym, but to test that we\n+            # ignore .dynsym, make them distinct.\n+            symbols=[\n+                ElfSymbol(\"full\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+            dynamic_symbols=[\n+                ElfSymbol(\"partial\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+        )\n+\n+        self.assertRaises(LookupError, prog.symbol, \"partial\")\n+\n+        full = Symbol(\"full\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.OBJECT)\n+        self.assertEqual(prog.symbol(\"full\"), full)\n+        self.assertEqual(prog.symbol(0xFFFF0004), full)\n+\n+    def test_ignore_dynsym_separate_files(self):\n+        # Same as test_ignore_dynsym_same_file(), except .symtab and .dynsym\n+        # are in different files.\n+        prog = Program()\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            dynamic_symbols=[\n+                ElfSymbol(\"partial\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+        )\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            symbols=[\n+                ElfSymbol(\"full\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+            dwarf=True,\n+        )\n+\n+        self.assertRaises(LookupError, prog.symbol, \"partial\")\n+\n+        full = Symbol(\"full\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.OBJECT)\n+        self.assertEqual(prog.symbol(\"full\"), full)\n+        self.assertEqual(prog.symbol(0xFFFF0004), full)\n+\n+    def test_override_dynsym(self):\n+        # Same as test_ignore_dynsym_separate_files(), except we do a lookup in\n+        # .dynsym before we have .symtab.\n+        prog = Program()\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            dynamic_symbols=[\n+                ElfSymbol(\"partial\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+        )\n+\n+        partial = Symbol(\n+            \"partial\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.OBJECT\n+        )\n+        self.assertEqual(prog.symbol(\"partial\"), partial)\n+        self.assertEqual(prog.symbol(0xFFFF0004), partial)\n+\n+        program_add_elf_symbol_file(\n+            prog,\n+            \"module0\",\n+            symbols=[\n+                ElfSymbol(\"full\", 0xFFFF0000, 0x8, STT.OBJECT, STB.LOCAL),\n+            ],\n+            dwarf=True,\n+        )\n+\n+        self.assertRaises(LookupError, prog.symbol, \"partial\")\n+\n+        full = Symbol(\"full\", 0xFFFF0000, 0x8, SymbolBinding.LOCAL, SymbolKind.OBJECT)\n+        self.assertEqual(prog.symbol(\"full\"), full)\n+        self.assertEqual(prog.symbol(0xFFFF0004), full)\n+\n \n class TestSymbolFinder(TestCase):\n     TEST_SYMS = [\n"}
{"repo": "drgn", "commit": "f8bedb963def7436ec8920397c40ffcf915ef52d", "diff": "diff --git a/contrib/pp_leak/guess_leaky_skbs.py b/contrib/pp_leak/guess_leaky_skbs.py\nnew file mode 100755\nindex 00000000..72458d90\n--- /dev/null\n+++ b/contrib/pp_leak/guess_leaky_skbs.py\n@@ -0,0 +1,239 @@\n+#!/usr/bin/env drgn\n+\n+# Copyright (c) 2025 NVIDIA Corporation & Affiliates\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+help=\"\"\"\n+Takes in a virtual address from a page or a `struct page *` and tries to find\n+a SKB that references this page either in the linear part or in skb_frag_info.\n+\n+Endianess is handled by the script.\n+\n+This only works if the kernel was built with CONFIG_PROC_KCORE=y. The\n+script is based on search_kernel_memory.py\n+\"\"\"\n+\n+import argparse\n+import math\n+import sys\n+from drgn import (\n+        Object,\n+        PlatformFlags,\n+        FaultError,\n+        Object,\n+        offsetof,\n+        sizeof,\n+)\n+from drgn.helpers.common.memory import (\n+        identify_address,\n+)\n+from drgn.helpers.linux.list import list_for_each_entry\n+from drgn.helpers.linux.mm import (\n+        for_each_vmap_area,\n+        virt_to_page,\n+        page_to_virt,\n+)\n+from drgn.helpers.linux.net import (\n+    skb_shinfo,\n+)\n+\n+\n+byteorder = \"little\" if prog.platform.flags & PlatformFlags.IS_LITTLE_ENDIAN else \"big\"\n+PAGE_SIZE = prog[\"PAGE_SIZE\"].value_()\n+PAGE_SHIFT = prog[\"PAGE_SHIFT\"].value_()\n+\n+\n+def get_opts():\n+    parser = argparse.ArgumentParser(description=help)\n+    parser.add_argument(\n+        \"bytes\",\n+        nargs=\"?\",\n+        help=\"hexadecimal bytes to read. By default they represent a \"\n+             \"virtual address.\",\n+    )\n+    parser.add_argument(\n+        \"--as-frag\", default=False, action=\"store_true\",\n+        help=\"Interpret address as being skb_shinfo(skb).frag.netmem.\")\n+    parser.add_argument(\n+        \"--virt\", default=False, action=\"store_true\",\n+        help=\"Given address is a virtual addresss in a page.\")\n+    parser.add_argument(\n+        \"--show-skb\", default=False, action=\"store_true\",\n+        help=\"Show matched SKB.\")\n+    parser.add_argument(\n+        \"--verbose\", default=False, action=\"store_true\",\n+        help=\"Print partial matches.\")\n+\n+    return parser.parse_args()\n+\n+\n+def virt_to_vmap_address(prog, addr):\n+    page = virt_to_page(addr)\n+    for va in for_each_vmap_area(prog):\n+        vm = va.vm.read_()\n+        if vm:\n+            for i, va_page in enumerate(\n+                Object(\n+                    prog, prog.array_type(page.type_, vm.nr_pages), address=vm.pages\n+                ).read_()\n+            ):\n+                if va_page == page:\n+                    return (\n+                        va.va_start.value_()\n+                        + (i << prog[\"PAGE_SHIFT\"])\n+                        + (addr & (prog[\"PAGE_SIZE\"].value_() - 1))\n+                    )\n+    return None\n+\n+\n+def search_memory(prog, needle):\n+    KCORE_RAM = prog[\"KCORE_RAM\"]\n+    CHUNK_SIZE = 1024 * 1024\n+\n+    for kc in list_for_each_entry(\n+        \"struct kcore_list\", prog[\"kclist_head\"].address_of_(), \"list\"\n+    ):\n+        if kc.type != KCORE_RAM:\n+            continue\n+        start = kc.addr.value_()\n+        end = start + kc.size.value_()\n+        for addr in range(start, end, CHUNK_SIZE):\n+            buf = prog.read(addr, min(CHUNK_SIZE, end - addr))\n+            i = 0\n+            while i < len(buf):\n+                i = buf.find(needle, i)\n+                if i < 0:\n+                    break\n+\n+                yield addr + i\n+                i += 8\n+\n+\n+def search_page_reference(page):\n+    \"\"\"\n+    Search kernel memory for references to the given page contents\n+    (virtual addresses within the PAGE_SIZE range).\n+\n+    Does page conversion.\n+    \"\"\"\n+\n+    val = page_to_virt(page).value_()\n+\n+    skip_bytes = math.ceil(PAGE_SHIFT / 8)\n+    ptr_size = 8\n+\n+    val_endian = val.to_bytes(ptr_size, byteorder)\n+    if byteorder == \"little\":\n+        big_needle = val_endian[skip_bytes:ptr_size - skip_bytes]\n+    else:\n+        big_needle = val_endian[0:ptr_size - skip_bytes]\n+\n+    small_needle = val >> PAGE_SHIFT\n+\n+    # Search for first 6 bytes:\n+    for addr in search_memory(prog, big_needle):\n+\n+        if byteorder == \"little\":\n+            # Adjust address to skipped bytes:\n+            addr = addr - skip_bytes\n+\n+        mem_bytes = prog.read(addr, ptr_size)\n+        mem_val = int.from_bytes(mem_bytes, byteorder)\n+\n+        if mem_val >> PAGE_SHIFT == small_needle:\n+            yield (addr, mem_val)\n+\n+\n+def search_raw(value):\n+    \"\"\"\n+    Search kernel memory for value respectinv the value pointer.\n+    \"\"\"\n+\n+    ptr_size = 8\n+    needle = value.to_bytes(ptr_size, byteorder)\n+\n+    for addr in search_memory(prog, needle):\n+        mem_bytes = prog.read(addr, ptr_size)\n+        mem_val = int.from_bytes(mem_bytes, byteorder)\n+        yield (addr, mem_val)\n+\n+\n+def guess_skb_is_legit(skb) -> bool:\n+    \"\"\"\n+    Guess if there is a legit SKB at the given address.\n+    \"\"\"\n+\n+    # 2 consecutive pointers that point to the same page indicate that\n+    # this could be skb.head and skb.data.\n+    if virt_to_page(skb.head).value_() != virt_to_page(skb.data).value_():\n+        return False\n+\n+    if skb.end.value_() > PAGE_SIZE or skb.tail.value_() > PAGE_SIZE:\n+        return False\n+\n+    # Many checks could be added here ...\n+    return True\n+\n+\n+def search_skb_with_page_as_linear(page, verbose=False):\n+    \"\"\"\n+    Search SKB for given page.\n+    \"\"\"\n+    for addr, val in search_page_reference(page):\n+\n+        if verbose:\n+            print(f\"Found reference at {hex(addr)}: value {hex(val)}. {identify_address(prog, addr)}\")\n+\n+        skb_addr = addr - offsetof(prog.type(\"struct sk_buff\"), \"head\")\n+        skb = Object(prog, \"struct sk_buff\", address=skb_addr)\n+        if guess_skb_is_legit(skb):\n+            yield skb\n+\n+\n+def search_skb_with_page_as_shinfo_frag(page_ptr, verbose):\n+\n+    for addr, _ in search_raw(page_ptr):\n+\n+        if verbose:\n+            print(f\"Found raw value at addr {hex(addr)}. {identify_address(prog, addr)}\")\n+\n+        page = virt_to_page(addr)\n+        for skb in search_skb_with_page_as_linear(page):\n+\n+            # For shinfo, a match happens for\n+            shinfo = skb_shinfo(skb)\n+            shinfo_start = shinfo.value_()\n+            shinfo_end = shinfo.value_() + sizeof(prog.type(\"struct skb_shared_info\"))\n+            if shinfo_start <= addr and addr < shinfo_end:\n+                yield skb\n+\n+\n+opts = get_opts()\n+\n+# Drop hex prefix.\n+if opts.bytes.startswith(\"0x\"):\n+    opts.bytes = opts.bytes[2:]\n+\n+value = int.from_bytes(bytes.fromhex(opts.bytes))\n+\n+if opts.as_frag:\n+    for skb in search_skb_with_page_as_shinfo_frag(value, opts.verbose):\n+        print(f\"Possible skb match at address {hex(skb.address_of_())}\")\n+        if opts.show_skb:\n+            print(skb)\n+\n+else:\n+    if opts.virt:\n+        try:\n+            page = virt_to_page(value)\n+        except FaultError:\n+            print(\"Given address doesn't seem to be a virtual address or it can't be converted to a page.\")\n+            sys.exit(1)\n+    else:\n+        page = Object(prog, \"struct page\", address=value).address_of_()\n+\n+    for skb in search_skb_with_page_as_linear(page, opts.verbose):\n+        print(f\"Possible skb match at address {hex(skb.address_of_())}\")\n+        if opts.show_skb:\n+            print(skb)\n+\ndiff --git a/contrib/pp_leak/ls_pp_leaks.py b/contrib/pp_leak/ls_pp_leaks.py\nnew file mode 100755\nindex 00000000..3dec540b\n--- /dev/null\n+++ b/contrib/pp_leak/ls_pp_leaks.py\n@@ -0,0 +1,50 @@\n+#!/usr/bin/env drgn\n+\n+# Copyright (c) 2025 NVIDIA Corporation & Affiliates\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+help=\"\"\"\n+Detect leaked page_pool pages by scanning through all the pages.\n+\n+Has options for peeking into the page memory and showing the struct page.\n+\"\"\"\n+\n+\n+import argparse\n+from drgn import FaultError\n+from drgn.helpers.common.memory import (\n+        print_annotated_memory\n+)\n+from drgn.helpers.linux.mm import (\n+    for_each_page,\n+    page_to_virt\n+)\n+from drgn.helpers.linux.net import is_pp_page\n+\n+\n+def get_opts():\n+    parser = argparse.ArgumentParser(description=help)\n+    parser.add_argument(\n+        \"-l\", \"--peek\", default=100, type=int, help=\"Peek into page given amount of bytes.\")\n+    parser.add_argument(\n+        \"-s\", \"--show\", default=False, action=\"store_true\", help=\"Show page struct.\")\n+\n+    args = parser.parse_args()\n+    return args\n+\n+\n+opt = get_opts()\n+\n+for page in for_each_page():\n+        try:\n+            if is_pp_page(page) and page.pp.user.detach_time > 0:\n+                if opt.show:\n+                    print(page)\n+                else:\n+                    print(f\"Leaked page: {hex(page)}\")\n+                if opt.peek > 0:\n+                    print(\"Page content: \")\n+                    print_annotated_memory(page_to_virt(page), opt.peek)\n+        except FaultError:\n+            continue\n+\ndiff --git a/contrib/pp_leak/scan_tcp_socks.py b/contrib/pp_leak/scan_tcp_socks.py\nnew file mode 100755\nindex 00000000..711c2844\n--- /dev/null\n+++ b/contrib/pp_leak/scan_tcp_socks.py\n@@ -0,0 +1,90 @@\n+#!/usr/bin/env drgn\n+\n+# Copyright (c) 2025 NVIDIA Corporation & Affiliates\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+help=\"\"\"\n+Detect leaked page_pool pages by scanning TCP sockets for SKBs from the\n+receive queue that are using such leaked pages.\n+\n+It is a good idea to filter out by interface to reduce the run time\n+of the script.\n+\"\"\"\n+\n+\n+import sys\n+import argparse\n+\n+from drgn import (\n+    Object,\n+    FaultError,\n+)\n+from drgn.helpers.linux import (\n+    hlist_nulls_empty,\n+    sk_nulls_for_each,\n+)\n+from drgn.helpers.linux.mm import virt_to_page\n+from drgn.helpers.linux.net import (\n+    netdev_get_by_name,\n+    skb_shinfo,\n+    is_pp_page\n+)\n+\n+\n+def get_opts():\n+    parser = argparse.ArgumentParser(description=help)\n+    parser.add_argument(\n+        \"-i\", \"--interface\", default=None, type=str, help=\"Filter by interface name.\")\n+\n+    args = parser.parse_args()\n+    return args\n+\n+\n+opts = get_opts()\n+ifindex = -1\n+if opts.interface:\n+    netdev = netdev_get_by_name(opts.interface)\n+    if netdev.value_() == 0:\n+        print(f\"Netdev interface '{opts.interface}' not found.\")\n+        sys.exit(1)\n+\n+    ifindex = netdev.ifindex\n+\n+tcp_hashinfo = prog.object(\"tcp_hashinfo\")\n+\n+for i in range(tcp_hashinfo.ehash_mask + 1):\n+    head = tcp_hashinfo.ehash[i].chain\n+    if hlist_nulls_empty(head):\n+        continue\n+\n+    for sk in sk_nulls_for_each(head):\n+\n+        # Filter by interface:\n+        if ifindex > 0 and sk.sk_rx_dst_ifindex.value_() != ifindex:\n+            continue\n+\n+        first_skb = sk.sk_receive_queue.next\n+        skb = first_skb\n+        while skb != None:\n+\n+            try:\n+                # Check linear part of skb:\n+                page = virt_to_page(skb.data)\n+                if is_pp_page(page) and page.pp.user.detach_time:\n+                    print(f\"Found leaked page {hex(page)} in linear part of  skb: {hex(skb.address_of_())}. sk: {hex(sk)}\")\n+\n+                # Check fragments:\n+                shinfo = skb_shinfo(skb)\n+                for i in range(0, shinfo.nr_frags):\n+                    frag = shinfo.frags[i]\n+                    page = Object(prog, \"struct page\", address=frag.netmem)\n+                    if is_pp_page(page) and page.pp.user.detach_time:\n+                        print(f\"Found leaked page {hex(page.address_of_())} in skb frag {i} of skb: {hex(skb.address_of_())}\")\n+\n+            except FaultError:\n+                continue\n+\n+            # Move to next skb:\n+            skb = skb.next\n+            if skb == first_skb:\n+                break\n"}
{"repo": "drgn", "commit": "20b0ff71f58e2449610e9e72622c36dc0d84c2ec", "diff": "diff --git a/tests/test_cli.py b/tests/test_cli.py\nindex 5e842ca7..91414f16 100644\n--- a/tests/test_cli.py\n+++ b/tests/test_cli.py\n@@ -5,6 +5,7 @@\n import os\n import sys\n import tempfile\n+import traceback\n import types\n \n import drgn.cli\n@@ -20,22 +21,26 @@ class TestCli(TestCase):\n \n         pid = os.fork()\n         if pid == 0:\n-            os.close(stdout_r)\n-            sys.stdout = open(stdout_w, \"w\")\n-            os.close(stderr_r)\n-            sys.stderr = open(stderr_w, \"w\")\n-\n-            if input is not None:\n-                os.close(stdin_w)\n-                sys.stdin = open(stdin_r, \"r\")\n-\n-            sys.argv = [\"drgn\"] + args\n-\n-            drgn.cli._main()\n-\n-            sys.stdout.flush()\n-            sys.stderr.flush()\n-            os._exit(0)\n+            try:\n+                os.close(stdout_r)\n+                sys.stdout = open(stdout_w, \"w\")\n+                os.close(stderr_r)\n+                sys.stderr = open(stderr_w, \"w\")\n+\n+                if input is not None:\n+                    os.close(stdin_w)\n+                    sys.stdin = open(stdin_r, \"r\")\n+\n+                sys.argv = [\"drgn\"] + args\n+\n+                drgn.cli._main()\n+            finally:\n+                exception = sys.exc_info()[1] is not None\n+                if exception:\n+                    traceback.print_exc()\n+                sys.stdout.flush()\n+                sys.stderr.flush()\n+                os._exit(1 if exception else 0)\n \n         os.close(stdout_w)\n         os.close(stderr_w)\n@@ -62,9 +67,9 @@ class TestCli(TestCase):\n                 f\"\"\"\\\n {msg}\n STDOUT:\n-{stdout.decode()}\n+{stdout}\n STDERR:\n-{stderr.decode()}\n+{stderr}\n \"\"\"\n             )\n \n"}
{"repo": "drgn", "commit": "a938677d1cdfae931ab8510595a90e3997172da9", "diff": "diff --git a/docs/conf.py b/docs/conf.py\nindex 8405000b..ded0634c 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -18,6 +18,7 @@ extensions = [\n     \"linuxsrc\",\n     \"setuptools_config\",\n     \"sphinx.ext.extlinks\",\n+    \"sphinx.ext.graphviz\",\n     \"sphinx.ext.intersphinx\",\n ]\n \n"}
{"repo": "drgn", "commit": "4834a956e912ac767724892b2d6abbaccca3688c", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex a7a02ed5..401150fd 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -1424,7 +1424,8 @@ def totalram_pages(prog: Program) -> int:\n @takes_program_or_default\n def in_direct_map(prog: Program, addr: IntegerLike) -> bool:\n     \"\"\"\n-    Return True if an address is within the kernel's direct memory mapping\n+    Return whether an address is within the kernel's direct memory mapping.\n+\n     :param addr: address to check\n     \"\"\"\n     addr = operator.index(addr)\n"}
{"repo": "drgn", "commit": "97a3c5a56a41c242be6ef40f51f7ab54702a1507", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex c29e3d25..58d3db16 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -465,7 +465,8 @@ def _main() -> None:\n     symbol_group.add_argument(\n         \"--no-default-debug-directories\",\n         action=\"store_true\",\n-        help=\"don't search for debugging symbols by build ID and debug link in the standard directories\",\n+        help=\"don't search for debugging symbols by build ID and debug link \"\n+        \"in the standard directories or those added by plugins\",\n     )\n     symbol_group.add_argument(\n         \"--kernel-directory\",\n@@ -479,7 +480,8 @@ def _main() -> None:\n     symbol_group.add_argument(\n         \"--no-default-kernel-directories\",\n         action=\"store_true\",\n-        help=\"don't search for the kernel image and loadable kernel modules in the standard directories\",\n+        help=\"don't search for the kernel image and loadable kernel modules \"\n+        \"in the standard directories or those added by plugins\",\n     )\n \n     advanced_group = parser.add_argument_group(\"advanced\")\n"}
{"repo": "drgn", "commit": "26d6ef8efcddb4469fbc28c812fde38c8b391d0f", "diff": "diff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 28d50760..18039739 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -2427,6 +2427,7 @@ class TestDebuginfodDebugInfoFinder(TestCase):\n         cls.server.socket.shutdown(socket.SHUT_RD)\n         cls.server.shutdown()\n         cls.server_thread.join()\n+        cls.server.server_close()\n \n     def setUp(self):\n         self.prog = Program()\n"}
{"repo": "drgn", "commit": "dcf392a2921cee136e119188fb80face1fd1a06a", "diff": "diff --git a/tests/test_module.py b/tests/test_module.py\nindex e22f1bd4..b47bc55f 100644\n--- a/tests/test_module.py\n+++ b/tests/test_module.py\n@@ -492,6 +492,21 @@ class TestCreatedModules(TestCase):\n         ]\n         self.assertCountEqual(list(prog.modules()), modules)\n \n+    def test_same_name(self):\n+        prog = Program()\n+        modules = [\n+            prog.extra_module(\"foo\", id=0, create=True)[0],\n+            prog.main_module(\"foo\", create=True)[0],\n+        ]\n+        actual = list(prog.modules())\n+        self.assertCountEqual(actual, modules)\n+        self.assertEqual(actual[0], prog.main_module())\n+\n+        modules.append(prog.extra_module(\"foo\", id=1, create=True)[0])\n+        actual = list(prog.modules())\n+        self.assertCountEqual(actual, modules)\n+        self.assertEqual(actual[0], prog.main_module())\n+\n     def test_change_during_iteration(self):\n         prog = Program()\n         prog.extra_module(\"/foo/bar\", create=True)\n"}
{"repo": "drgn", "commit": "d03bbe582160e5c4ad2d93d8fa18ad536f6fdd59", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex be5f2ec0..c2b214e4 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -111,6 +111,8 @@ from _drgn import (\n # isort: split\n from _drgn import (  # noqa: F401\n     _elfutils_version as _elfutils_version,\n+    _enable_dlopen_debuginfod as _enable_dlopen_debuginfod,\n+    _have_debuginfod as _have_debuginfod,\n     _with_libkdumpfile as _with_libkdumpfile,\n )\n from drgn.internal.version import __version__ as __version__  # noqa: F401\ndiff --git a/drgn/cli.py b/drgn/cli.py\nindex 27eb0419..c36aa1f9 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -110,8 +110,11 @@ def version_header() -> str:\n     calling :func:`run_interactive()`.\n     \"\"\"\n     python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+    debuginfod = f'with{\"\" if drgn._have_debuginfod else \"out\"} debuginfod'\n+    if drgn._enable_dlopen_debuginfod:\n+        debuginfod += \" (dlopen)\"\n     libkdumpfile = f'with{\"\" if drgn._with_libkdumpfile else \"out\"} libkdumpfile'\n-    return f\"drgn {drgn.__version__} (using Python {python_version}, elfutils {drgn._elfutils_version}, {libkdumpfile})\"\n+    return f\"drgn {drgn.__version__} (using Python {python_version}, elfutils {drgn._elfutils_version}, {debuginfod}, {libkdumpfile})\"\n \n \n def default_globals(prog: drgn.Program) -> Dict[str, Any]:\n"}
{"repo": "drgn", "commit": "12b789e7b2ce4fea5247763989d2370d91db4c12", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 03a4ac2f..27eb0419 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -52,36 +52,37 @@ def _is_tty(file: IO[Any]) -> bool:\n \n class _LogFormatter(logging.Formatter):\n     _LEVELS = (\n-        (logging.DEBUG, \"debug\", \"36\"),\n-        (logging.INFO, \"info\", \"32\"),\n-        (logging.WARNING, \"warning\", \"33\"),\n-        (logging.ERROR, \"error\", \"31\"),\n-        (logging.CRITICAL, \"critical\", \"31;1\"),\n+        (logging.DEBUG, \"debug\", \"\\033[36m\", \"\\033[m\", \"\"),\n+        (logging.INFO, \"info\", \"\\033[32m\", \"\\033[m\", \"\"),\n+        (logging.WARNING, \"warning\", \"\\033[33m\", \"\\033[m\", \"\"),\n+        (logging.ERROR, \"error\", \"\\033[31m\", \"\\033[m\", \"\"),\n+        (logging.CRITICAL, \"critical\", \"\\033[31;1m\", \"\\033[0;1m\", \"\\033[m\"),\n     )\n \n     def __init__(self, color: bool) -> None:\n         if color:\n-            level_prefixes = {\n-                level: f\"\\033[{level_color}m{level_name}:\\033[0m\"\n-                for level, level_name, level_color in self._LEVELS\n+            levels = {\n+                level: (f\"{level_prefix}{level_name}:{message_prefix}\", message_suffix)\n+                for level, level_name, level_prefix, message_prefix, message_suffix in self._LEVELS\n             }\n         else:\n-            level_prefixes = {\n-                level: f\"{level_name}:\" for level, level_name, _ in self._LEVELS\n+            levels = {\n+                level: (f\"{level_name}:\", \"\")\n+                for level, level_name, _, _, _ in self._LEVELS\n             }\n         default_prefix = \"%(levelname)s:\"\n \n         self._drgn_formatters = {\n-            level: logging.Formatter(f\"{prefix} %(message)s\")\n-            for level, prefix in level_prefixes.items()\n+            level: logging.Formatter(f\"{prefix} %(message)s{suffix}\")\n+            for level, (prefix, suffix) in levels.items()\n         }\n         self._default_drgn_formatter = logging.Formatter(\n             f\"{default_prefix} %(message)s\"\n         )\n \n         self._other_formatters = {\n-            level: logging.Formatter(f\"{prefix}%(name)s: %(message)s\")\n-            for level, prefix in level_prefixes.items()\n+            level: logging.Formatter(f\"{prefix}%(name)s: %(message)s{suffix}\")\n+            for level, (prefix, suffix) in levels.items()\n         }\n         self._default_other_formatter = logging.Formatter(\n             f\"{default_prefix}%(name)s: %(message)s\"\n@@ -270,9 +271,7 @@ class _NoSymbolsByAction(_TrySymbolsByBaseAction):\n     _enable = False\n \n \n-def _load_debugging_symbols(\n-    prog: drgn.Program, args: argparse.Namespace, color: bool\n-) -> None:\n+def _load_debugging_symbols(prog: drgn.Program, args: argparse.Namespace) -> None:\n     enable_debug_info_finders = getattr(args, \"enable_debug_info_finders\", ())\n     disable_debug_info_finders = getattr(args, \"disable_debug_info_finders\", ())\n     if enable_debug_info_finders or disable_debug_info_finders:\n@@ -344,7 +343,17 @@ def _load_debugging_symbols(\n     try:\n         prog.load_debug_info(args.symbols, **args.default_symbols)\n     except drgn.MissingDebugInfoError as e:\n-        logger.warning(\"\\033[1m%s\\033[m\" if color else \"%s\", e)\n+        if args.default_symbols.get(\"main\"):\n+            try:\n+                main_module = prog.main_module()\n+                critical = (\n+                    main_module.wants_debug_file() or main_module.wants_loaded_file()\n+                )\n+            except LookupError:\n+                critical = True\n+        else:\n+            critical = False\n+        logger.log(logging.CRITICAL if critical else logging.WARNING, \"%s\", e)\n \n     if args.extra_symbols:\n         for extra_symbol_path in args.extra_symbols:\n@@ -578,7 +587,7 @@ def _main() -> None:\n         # E.g., \"not an ELF core file\"\n         sys.exit(f\"error: {e}\")\n \n-    _load_debugging_symbols(prog, args, color)\n+    _load_debugging_symbols(prog, args)\n \n     if interactive:\n         run_interactive(prog)\n"}
{"repo": "drgn", "commit": "c5210929e5db1eb7fce852ea64a3153e5953174e", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex dce6b8d7..38a21364 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -190,25 +190,25 @@ def _displayhook(value: Any) -> None:\n     setattr(builtins, \"_\", value)\n \n \n+def _bool_options(value: bool) -> Dict[str, Tuple[str, bool]]:\n+    return {\n+        option: (\"try_\" + option.replace(\"-\", \"_\"), value)\n+        for option in (\n+            \"module-name\",\n+            \"build-id\",\n+            \"debug-link\",\n+            \"procfs\",\n+            \"embedded-vdso\",\n+            \"reuse\",\n+            \"supplementary\",\n+        )\n+    }\n+\n+\n class _TrySymbolsByBaseAction(argparse.Action):\n     _enable: bool\n     _finder = (\"disable_debug_info_finders\", \"enable_debug_info_finders\")\n \n-    @staticmethod\n-    def _bool_options(value: bool) -> Dict[str, Tuple[str, bool]]:\n-        return {\n-            option: (\"try_\" + option.replace(\"-\", \"_\"), value)\n-            for option in (\n-                \"module-name\",\n-                \"build-id\",\n-                \"debug-link\",\n-                \"procfs\",\n-                \"embedded-vdso\",\n-                \"reuse\",\n-                \"supplementary\",\n-            )\n-        }\n-\n     _options = (\n         {\n             **_bool_options(False),\n"}
{"repo": "drgn", "commit": "4a6a9f335994a4e16aea49437d44a59247c58480", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 135627f3..dc2d3bf4 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -146,8 +146,9 @@ def _displayhook(value: Any) -> None:\n     setattr(builtins, \"_\", value)\n \n \n-class _DebugInfoOptionAction(argparse.Action):\n-    _choices: Dict[str, Tuple[str, Any]]\n+class _TrySymbolsByBaseAction(argparse.Action):\n+    _enable: bool\n+    _finder = (\"disable_debug_info_finders\", \"enable_debug_info_finders\")\n \n     @staticmethod\n     def _bool_options(value: bool) -> Dict[str, Tuple[str, bool]]:\n@@ -164,6 +165,24 @@ class _DebugInfoOptionAction(argparse.Action):\n             )\n         }\n \n+    _options = (\n+        {\n+            **_bool_options(False),\n+            \"kmod\": (\"try_kmod\", drgn.KmodSearchMethod.NONE),\n+        },\n+        {\n+            **_bool_options(True),\n+            \"kmod=depmod\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD),\n+            \"kmod=walk\": (\"try_kmod\", drgn.KmodSearchMethod.WALK),\n+            \"kmod=depmod-or-walk\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD_OR_WALK),\n+            \"kmod=depmod-and-walk\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD_AND_WALK),\n+        },\n+    )\n+\n+    def __init__(self, *args: Any, **kwargs: Any) -> None:\n+        kwargs[\"dest\"] = argparse.SUPPRESS\n+        super().__init__(*args, **kwargs)\n+\n     def __call__(\n         self,\n         parser: argparse.ArgumentParser,\n@@ -171,37 +190,117 @@ class _DebugInfoOptionAction(argparse.Action):\n         values: Any,\n         option_string: Optional[str] = None,\n     ) -> None:\n-        dest = getattr(namespace, self.dest, None)\n-        if dest is None:\n-            dest = {}\n-            setattr(namespace, self.dest, dest)\n-\n-        for option in values.split(\",\"):\n+        for value in values.split(\",\"):\n             try:\n-                name, value = self._choices[option]\n+                option_name, option_value = self._options[self._enable][value]\n             except KeyError:\n-                raise argparse.ArgumentError(\n-                    self,\n-                    f\"invalid option: {option!r} (choose from {', '.join(self._choices)})\",\n+                # Raise an error if passed an option meant for the opposite\n+                # argument.\n+                if value in self._options[not self._enable]:\n+                    raise argparse.ArgumentError(self, f\"invalid option: {value!r}\")\n+\n+                if not hasattr(namespace, self._finder[self._enable]):\n+                    setattr(namespace, self._finder[self._enable], {})\n+                getattr(namespace, self._finder[self._enable])[value] = None\n+\n+                if hasattr(namespace, self._finder[not self._enable]):\n+                    getattr(namespace, self._finder[not self._enable]).pop(value, None)\n+            else:\n+                if not hasattr(namespace, \"debug_info_options\"):\n+                    namespace.debug_info_options = {}\n+                namespace.debug_info_options[option_name] = option_value\n+\n+\n+class _TrySymbolsByAction(_TrySymbolsByBaseAction):\n+    _enable = True\n+\n+\n+class _NoSymbolsByAction(_TrySymbolsByBaseAction):\n+    _enable = False\n+\n+\n+def _load_debugging_symbols(\n+    prog: drgn.Program, args: argparse.Namespace, color: bool\n+) -> None:\n+    enable_debug_info_finders = getattr(args, \"enable_debug_info_finders\", ())\n+    disable_debug_info_finders = getattr(args, \"disable_debug_info_finders\", ())\n+    if enable_debug_info_finders or disable_debug_info_finders:\n+        debug_info_finders = prog.enabled_debug_info_finders()\n+        registered_debug_info_finders = prog.registered_debug_info_finders()\n+\n+        unknown_finders = []\n+\n+        for finder in enable_debug_info_finders:\n+            if finder not in debug_info_finders:\n+                if finder in registered_debug_info_finders:\n+                    debug_info_finders.append(finder)\n+                else:\n+                    unknown_finders.append(finder)\n+\n+        for finder in disable_debug_info_finders:\n+            try:\n+                debug_info_finders.remove(finder)\n+            except ValueError:\n+                if finder not in registered_debug_info_finders:\n+                    unknown_finders.append(finder)\n+\n+        if unknown_finders:\n+            if len(unknown_finders) == 1:\n+                unknown_finders_repr = repr(unknown_finders[0])\n+            elif len(unknown_finders) == 2:\n+                unknown_finders_repr = (\n+                    f\"{unknown_finders[0]!r} or {unknown_finders[1]!r}\"\n                 )\n-            dest[name] = value\n+            elif len(unknown_finders) > 2:\n+                unknown_finders = [repr(finder) for finder in unknown_finders]\n+                unknown_finders[-1] = \"or \" + unknown_finders[-1]\n+                unknown_finders_repr = \", \".join(unknown_finders)\n+            logger.warning(\n+                \"no matching debugging information finders or options for %s\",\n+                unknown_finders_repr,\n+            )\n \n+        prog.set_enabled_debug_info_finders(debug_info_finders)\n \n-class _TryDebugInfoOptionAction(_DebugInfoOptionAction):\n-    _choices = {\n-        **_DebugInfoOptionAction._bool_options(True),\n-        \"kmod=depmod\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD),\n-        \"kmod=walk\": (\"try_kmod\", drgn.KmodSearchMethod.WALK),\n-        \"kmod=depmod-or-walk\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD_OR_WALK),\n-        \"kmod=depmod-and-walk\": (\"try_kmod\", drgn.KmodSearchMethod.DEPMOD_AND_WALK),\n-    }\n+    debug_info_options = getattr(args, \"debug_info_options\", None)\n+    if debug_info_options:\n+        for option, value in debug_info_options.items():\n+            setattr(prog.debug_info_options, option, value)\n \n+    if args.debug_directories is not None:\n+        if args.no_default_debug_directories:\n+            prog.debug_info_options.directories = args.debug_directories\n+        else:\n+            prog.debug_info_options.directories = (\n+                tuple(args.debug_directories) + prog.debug_info_options.directories\n+            )\n+    elif args.no_default_debug_directories:\n+        prog.debug_info_options.directories = ()\n \n-class _NoDebugInfoOptionAction(_DebugInfoOptionAction):\n-    _choices = {\n-        **_DebugInfoOptionAction._bool_options(False),\n-        \"kmod\": (\"try_kmod\", drgn.KmodSearchMethod.NONE),\n-    }\n+    if args.kernel_directories is not None:\n+        if args.no_default_kernel_directories:\n+            prog.debug_info_options.kernel_directories = args.kernel_directories\n+        else:\n+            prog.debug_info_options.kernel_directories = (\n+                tuple(args.kernel_directories)\n+                + prog.debug_info_options.kernel_directories\n+            )\n+    elif args.no_default_kernel_directories:\n+        prog.debug_info_options.kernel_directories = ()\n+\n+    if args.default_symbols is None:\n+        args.default_symbols = {\"default\": True, \"main\": True}\n+    try:\n+        prog.load_debug_info(args.symbols, **args.default_symbols)\n+    except drgn.MissingDebugInfoError as e:\n+        logger.warning(\"\\033[1m%s\\033[m\" if color else \"%s\", e)\n+\n+    if args.extra_symbols:\n+        for extra_symbol_path in args.extra_symbols:\n+            extra_symbol_path = os.path.abspath(extra_symbol_path)\n+            module, new = prog.extra_module(extra_symbol_path, create=True)\n+            if new:\n+                module.try_file(extra_symbol_path)\n \n \n def _main() -> None:\n@@ -269,20 +368,26 @@ def _main() -> None:\n     )\n     symbol_group.add_argument(\n         \"--try-symbols-by\",\n-        dest=\"symbols_by\",\n         metavar=\"METHOD[,METHOD...]\",\n-        action=_TryDebugInfoOptionAction,\n+        action=_TrySymbolsByAction,\n         help=\"enable loading debugging symbols using the given methods. \"\n-        \"Choices are \" + \", \".join(_TryDebugInfoOptionAction._choices) + \". \"\n+        \"Choices are debugging information finder names \"\n+        \"(standard, debuginfod, or any added by plugins) \"\n+        \"or debugging information options (\"\n+        + \", \".join(_TrySymbolsByBaseAction._options[True])\n+        + \"). \"\n         \"This option may be given more than once\",\n     )\n     symbol_group.add_argument(\n         \"--no-symbols-by\",\n-        dest=\"symbols_by\",\n         metavar=\"METHOD[,METHOD...]\",\n-        action=_NoDebugInfoOptionAction,\n+        action=_NoSymbolsByAction,\n         help=\"disable loading debugging symbols using the given methods. \"\n-        \"Choices are \" + \", \".join(_NoDebugInfoOptionAction._choices) + \". \"\n+        \"Choices are debugging information finder names \"\n+        \"(standard, debuginfod, or any added by plugins) \"\n+        \"or debugging information options (\"\n+        + \", \".join(_TrySymbolsByBaseAction._options[False])\n+        + \"). \"\n         \"This option may be given more than once\",\n     )\n     symbol_group.add_argument(\n@@ -413,44 +518,7 @@ def _main() -> None:\n         # E.g., \"not an ELF core file\"\n         sys.exit(f\"error: {e}\")\n \n-    if args.symbols_by:\n-        for option, value in args.symbols_by.items():\n-            setattr(prog.debug_info_options, option, value)\n-\n-    if args.debug_directories is not None:\n-        if args.no_default_debug_directories:\n-            prog.debug_info_options.directories = args.debug_directories\n-        else:\n-            prog.debug_info_options.directories = (\n-                tuple(args.debug_directories) + prog.debug_info_options.directories\n-            )\n-    elif args.no_default_debug_directories:\n-        prog.debug_info_options.directories = ()\n-\n-    if args.kernel_directories is not None:\n-        if args.no_default_kernel_directories:\n-            prog.debug_info_options.kernel_directories = args.kernel_directories\n-        else:\n-            prog.debug_info_options.kernel_directories = (\n-                tuple(args.kernel_directories)\n-                + prog.debug_info_options.kernel_directories\n-            )\n-    elif args.no_default_kernel_directories:\n-        prog.debug_info_options.kernel_directories = ()\n-\n-    if args.default_symbols is None:\n-        args.default_symbols = {\"default\": True, \"main\": True}\n-    try:\n-        prog.load_debug_info(args.symbols, **args.default_symbols)\n-    except drgn.MissingDebugInfoError as e:\n-        logger.warning(\"\\033[1m%s\\033[m\" if color else \"%s\", e)\n-\n-    if args.extra_symbols:\n-        for extra_symbol_path in args.extra_symbols:\n-            extra_symbol_path = os.path.abspath(extra_symbol_path)\n-            module, new = prog.extra_module(extra_symbol_path, create=True)\n-            if new:\n-                module.try_file(extra_symbol_path)\n+    _load_debugging_symbols(prog, args, color)\n \n     if args.script:\n         sys.argv = args.script\n"}
{"repo": "drgn", "commit": "53e57ea2d4166aaf3a8c9bd35fcde04fdbefe3a6", "diff": "diff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 3c6592a1..ab3ed5ea 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -551,6 +551,15 @@ class TestModuleTryFile(TestCase):\n         self.assertEqual(module.loaded_file_bias, 0x30000000)\n         self.assertEqual(module.debug_file_bias, 0x30000000)\n \n+    def test_extra_module_empty_address_range(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.address_range = (0, 0)\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.address_range, (0, 0))\n+        self.assertEqual(module.loaded_file_bias, 0)\n+        self.assertEqual(module.debug_file_bias, 0)\n+\n \n class TestLinuxUserspaceCoreDump(TestCase):\n     def setUp(self):\n"}
{"repo": "drgn", "commit": "ca3f004201287b702bae598435817cba105bc0b7", "diff": "diff --git a/tests/test_program.py b/tests/test_program.py\nindex 6b6c4240..18ae3aec 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -407,6 +407,42 @@ class TestMemory(TestCase):\n             8,\n         )\n \n+    def test_python_fault_error(self):\n+        def fault_memory_reader(address, count, offset, physical):\n+            raise FaultError(\"fault from Python\", address)\n+\n+        prog = Program(MOCK_PLATFORM)\n+        prog.add_memory_segment(0xFFFF0000, 8, fault_memory_reader)\n+\n+        with self.assertRaises(FaultError) as cm:\n+            Object(prog, \"int\", address=0xFFFF0004).read_()\n+        self.assertEqual(cm.exception.message, \"fault from Python\")\n+        self.assertEqual(cm.exception.address, 0xFFFF0004)\n+\n+        # If the FaultError from Python is translated to a drgn_error\n+        # correctly, then this shouldn't raise an exception.\n+        str(Object(prog, \"int *\", 0xFFFF0004))\n+\n+    def test_python_fault_error_invalid_message(self):\n+        def fault_memory_reader(address, count, offset, physical):\n+            raise FaultError(None, address)\n+\n+        prog = Program(MOCK_PLATFORM)\n+        prog.add_memory_segment(0xFFFF0000, 8, fault_memory_reader)\n+\n+        # Just test that it doesn't crash.\n+        self.assertRaises(Exception, Object(prog, \"int\", address=0xFFFF0004).read_)\n+\n+    def test_python_fault_error_invalid_address(self):\n+        def fault_memory_reader(address, count, offset, physical):\n+            raise FaultError(\"fault from Python\", None)\n+\n+        prog = Program(MOCK_PLATFORM)\n+        prog.add_memory_segment(0xFFFF0000, 8, fault_memory_reader)\n+\n+        # Just test that it doesn't crash.\n+        self.assertRaises(Exception, Object(prog, \"int\", address=0xFFFF0004).read_)\n+\n \n class TestTypeFinder(TestCase):\n     def test_register(self):\n"}
{"repo": "drgn", "commit": "d171a1d6170999c2075f237fc84a1ee1413dc990", "diff": "diff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex 38efce86..0d3d91e6 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -310,9 +310,9 @@ def create_dwarf_file(\n     compress=None,\n     split=None,\n     sections=(),\n-    build_id=None,\n     little_endian=True,\n     bits=64,\n+    **kwargs,\n ):\n     assert compress in (None, \"zlib-gnu\", \"zlib-gabi\")\n     assert split in (None, \"dwo\")\n@@ -388,7 +388,7 @@ def create_dwarf_file(\n     return create_elf_file(\n         ET.EXEC,\n         sections=[*sections, *dwarf_sections],\n-        build_id=build_id,\n         little_endian=little_endian,\n         bits=bits,\n+        **kwargs,\n     )\ndiff --git a/tests/elfwriter.py b/tests/elfwriter.py\nindex 430432aa..157f6a26 100644\n--- a/tests/elfwriter.py\n+++ b/tests/elfwriter.py\n@@ -1,8 +1,9 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n+import os\n import struct\n-from typing import List, NamedTuple, Optional, Sequence\n+from typing import List, NamedTuple, Optional, Sequence, Tuple, Union\n import zlib\n \n from _drgn_util.elf import ET, PT, SHF, SHN, SHT, STB, STT, STV\n@@ -121,6 +122,12 @@ def create_elf_file(\n     symbols: Sequence[ElfSymbol] = (),\n     *,\n     build_id: Optional[bytes] = None,\n+    gnu_debuglink: Optional[\n+        Tuple[Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"], int]\n+    ] = None,\n+    gnu_debugaltlink: Optional[\n+        Tuple[Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"], bytes]\n+    ] = None,\n     little_endian: bool = True,\n     bits: int = 64,\n ):\n@@ -157,6 +164,32 @@ def create_elf_file(\n         sections.append(\n             ElfSection(name=\".note.gnu.build-id\", sh_type=SHT.NOTE, data=build_id_note)\n         )\n+\n+    if gnu_debuglink is not None:\n+        gnu_debuglink_path, gnu_debuglink_crc = gnu_debuglink\n+        gnu_debuglink_path = os.fsencode(gnu_debuglink_path)\n+        sections.append(\n+            ElfSection(\n+                name=\".gnu_debuglink\",\n+                sh_type=SHT.PROGBITS,\n+                data=gnu_debuglink_path\n+                + bytes(4 - len(gnu_debuglink_path) % 4)\n+                + gnu_debuglink_crc.to_bytes(4, \"little\"),\n+            )\n+        )\n+\n+    if gnu_debugaltlink is not None:\n+        gnu_debugaltlink_path, gnu_debugaltlink_build_id = gnu_debugaltlink\n+        sections.append(\n+            ElfSection(\n+                name=\".gnu_debugaltlink\",\n+                sh_type=SHT.PROGBITS,\n+                data=os.fsencode(gnu_debugaltlink_path)\n+                + b\"\\0\"\n+                + gnu_debugaltlink_build_id,\n+            )\n+        )\n+\n     shnum = 0\n     phnum = 0\n     shstrtab = bytearray(1)\ndiff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 6d652a56..3c6592a1 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -33,24 +33,6 @@ from tests.dwarfwriter import create_dwarf_file\n from tests.elfwriter import ElfSection, create_elf_file\n from tests.resources import get_resource\n \n-\n-def gnu_debuglink_section(path, crc):\n-    path = os.fsencode(path)\n-    return ElfSection(\n-        name=\".gnu_debuglink\",\n-        sh_type=SHT.PROGBITS,\n-        data=path + bytes(4 - len(path) % 4) + crc.to_bytes(4, \"little\"),\n-    )\n-\n-\n-def gnu_debugaltlink_section(path, build_id):\n-    return ElfSection(\n-        name=\".gnu_debugaltlink\",\n-        sh_type=SHT.PROGBITS,\n-        data=os.fsencode(path) + b\"\\0\" + build_id,\n-    )\n-\n-\n ALLOCATED_SECTION = ElfSection(\n     name=\".bss\",\n     sh_type=SHT.PROGBITS,\n@@ -62,14 +44,14 @@ ALLOCATED_SECTION = ElfSection(\n \n \n @contextlib.contextmanager\n-def NamedTemporaryElfFile(*, loadable=True, debug=True, build_id=None, sections=()):\n+def NamedTemporaryElfFile(*, loadable=True, debug=True, sections=(), **kwargs):\n     if loadable:\n         sections = (ALLOCATED_SECTION,) + sections\n     with tempfile.NamedTemporaryFile() as f:\n         if debug:\n-            f.write(create_dwarf_file((), sections=sections, build_id=build_id))\n+            f.write(create_dwarf_file((), sections=sections, **kwargs))\n         else:\n-            f.write(create_elf_file(ET.EXEC, sections=sections, build_id=build_id))\n+            f.write(create_elf_file(ET.EXEC, sections=sections, **kwargs))\n         f.flush()\n         yield f\n \n@@ -378,11 +360,9 @@ class TestModuleTryFile(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(alt_path, alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n                     build_id=build_id,\n+                    gnu_debugaltlink=(alt_path, alt_build_id),\n                 )\n             )\n \n@@ -447,11 +427,9 @@ class TestModuleTryFile(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(alt_path, alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n                     build_id=build_id,\n+                    gnu_debugaltlink=(alt_path, alt_build_id),\n                 )\n             )\n \n@@ -511,8 +489,8 @@ class TestModuleTryFile(TestCase):\n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n             module.build_id = build_id\n             with NamedTemporaryElfFile(\n-                sections=(gnu_debugaltlink_section(alt_path, alt_build_id),),\n                 build_id=build_id,\n+                gnu_debugaltlink=(alt_path, alt_build_id),\n             ) as f1:\n                 module.try_file(f1.name)\n             self.assertEqual(\n@@ -543,8 +521,8 @@ class TestModuleTryFile(TestCase):\n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n             module.build_id = build_id\n             with NamedTemporaryElfFile(\n-                sections=(gnu_debugaltlink_section(alt_path, alt_build_id),),\n                 build_id=build_id,\n+                gnu_debugaltlink=(alt_path, alt_build_id),\n             ) as f:\n                 module.try_file(f.name)\n             self.assertEqual(\n@@ -1816,7 +1794,7 @@ class TestStandardDebugInfoFinder(TestCase):\n         alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n \n         with NamedTemporaryElfFile(\n-            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+            gnu_debugaltlink=(\"alt.debug\", alt_build_id),\n         ) as f:\n             module = self.prog.extra_module(f.name, create=True)[0]\n             module.loaded_file_status = ModuleFileStatus.DONT_WANT\n@@ -1999,10 +1977,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             loadable_path.write_bytes(\n                 create_elf_file(\n                     ET.EXEC,\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debuglink_section(\"binary.debug\", crc),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debuglink=(\"binary.debug\", crc),\n                 )\n             )\n \n@@ -2053,10 +2029,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             loadable_path.write_bytes(\n                 create_elf_file(\n                     ET.EXEC,\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debuglink_section(debug_path, crc),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debuglink=(debug_path, crc),\n                 )\n             )\n \n@@ -2082,10 +2056,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             loadable_path.write_bytes(\n                 create_elf_file(\n                     ET.EXEC,\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debuglink_section(\"binary.debug\", crc ^ 1),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debuglink=(\"binary.debug\", crc ^ 1),\n                 )\n             )\n \n@@ -2136,10 +2108,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(alt_path, alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debugaltlink=(alt_path, alt_build_id),\n                 )\n             )\n \n@@ -2164,10 +2134,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(debug_dir / \"alt.debug\", alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debugaltlink=(debug_dir / \"alt.debug\", alt_build_id),\n                 )\n             )\n \n@@ -2204,10 +2172,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(alt_path, alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debugaltlink=(alt_path, alt_build_id),\n                 )\n             )\n \n@@ -2238,10 +2204,8 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(debug_dir / \"alt.debug\", alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debugaltlink=(debug_dir / \"alt.debug\", alt_build_id),\n                 )\n             )\n \n@@ -2284,11 +2248,10 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(\n-                            Path(os.path.relpath(alt_path, bin_dir)), alt_build_id\n-                        ),\n+                    sections=(ALLOCATED_SECTION,),\n+                    gnu_debugaltlink=(\n+                        Path(os.path.relpath(alt_path, bin_dir)),\n+                        alt_build_id,\n                     ),\n                 )\n             )\n@@ -2326,10 +2289,8 @@ class TestStandardDebugInfoFinder(TestCase):\n                     binary_path.write_bytes(\n                         create_dwarf_file(\n                             (),\n-                            sections=(\n-                                ALLOCATED_SECTION,\n-                                gnu_debugaltlink_section(debugaltlink, alt_build_id),\n-                            ),\n+                            sections=(ALLOCATED_SECTION,),\n+                            gnu_debugaltlink=(debugaltlink, alt_build_id),\n                         )\n                     )\n \n@@ -2360,11 +2321,9 @@ class TestStandardDebugInfoFinder(TestCase):\n             binary_path.write_bytes(\n                 create_dwarf_file(\n                     (),\n-                    sections=(\n-                        ALLOCATED_SECTION,\n-                        gnu_debugaltlink_section(alt_path, alt_build_id),\n-                    ),\n+                    sections=(ALLOCATED_SECTION,),\n                     build_id=build_id,\n+                    gnu_debugaltlink=(alt_path, alt_build_id),\n                 )\n             )\n \n@@ -2572,7 +2531,7 @@ class TestDebuginfodDebugInfoFinder(TestCase):\n             loadable=False,\n             debug=True,\n             build_id=build_id,\n-            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+            gnu_debugaltlink=(\"alt.debug\", alt_build_id),\n         ) as debug_file, NamedTemporaryElfFile(\n             loadable=False, debug=True, build_id=alt_build_id\n         ) as alt_f:\n@@ -2610,7 +2569,7 @@ class TestDebuginfodDebugInfoFinder(TestCase):\n             loadable=False,\n             debug=True,\n             build_id=build_id,\n-            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+            gnu_debugaltlink=(\"alt.debug\", alt_build_id),\n         ) as debug_file:\n             self.server.build_ids[build_id] = {\n                 \"executable\": loadable_file.name,\n@@ -2644,7 +2603,7 @@ class TestDebuginfodDebugInfoFinder(TestCase):\n \n         with NamedTemporaryElfFile(\n             build_id=build_id,\n-            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+            gnu_debugaltlink=(\"alt.debug\", alt_build_id),\n         ) as f, NamedTemporaryElfFile(\n             loadable=False, debug=True, build_id=alt_build_id\n         ) as alt_f:\n@@ -2673,7 +2632,7 @@ class TestDebuginfodDebugInfoFinder(TestCase):\n \n         with NamedTemporaryElfFile(\n             build_id=build_id,\n-            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+            gnu_debugaltlink=(\"alt.debug\", alt_build_id),\n         ) as f:\n             module = self.prog.extra_module(\"foo\", create=True)[0]\n             module.try_file(f.name)\n"}
{"repo": "drgn", "commit": "bdc3212e19e006f2410ac0a813a9ed37a0a6d4e3", "diff": "diff --git a/contrib/negdentdelete.py b/contrib/negdentdelete.py\nindex 889a2ebb..186faa1e 100644\n--- a/contrib/negdentdelete.py\n+++ b/contrib/negdentdelete.py\n@@ -37,7 +37,7 @@ def for_each_child_dentry(dentry: Object) -> Iterator[Object]:\n             dentry.d_children.address_of_(),\n             \"d_sib\",\n         )\n-    except LookupError:\n+    except AttributeError:\n         return list_for_each_entry(\n             \"struct dentry\", dentry.d_subdirs.address_of_(), \"d_child\"\n         )\n"}
{"repo": "drgn", "commit": "af535aa000b04940cc7726a6f2ab7b1bb16d7115", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 7e933377..69c7d341 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -9,6 +9,7 @@ from pathlib import Path\n from typing import Dict, Mapping, NamedTuple, Sequence\n \n from _drgn_util.platform import NORMALIZED_MACHINE_NAME\n+from util import KernelVersion\n \n # Kernel versions that we run tests on and therefore support. Keep this in sync\n # with docs/support_matrix.rst.\ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 16e03f8b..f2039718 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -51,10 +51,6 @@ _PATCHES = (\n         name=\"proc-kcore-allow-enabling-CONFIG_PROC_KCORE-on-ARM.patch\",\n         versions=((None, None),),\n     ),\n-    _Patch(\n-        name=\"9p-fix-slab-cache-name-creation-for-real.patch\",\n-        versions=((KernelVersion(\"6.12\"), None),),\n-    ),\n     _Patch(\n         name=\"filelock-fix-name-of-file_lease-slab-cache.patch\",\n         versions=((KernelVersion(\"6.9\"), KernelVersion(\"6.10\")),),\n"}
{"repo": "drgn", "commit": "792458d68a6d223885fdb244f5a256103589886b", "diff": "diff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex d6f6aebb..8228c52e 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -159,9 +159,6 @@ class TestElfSymbol(TestCase):\n                 self.assertEqual(prog.symbols(0xFFFF0009), [expected])\n \n     def test_by_address_sizeless_subsumed(self):\n-        import unittest.util\n-\n-        unittest.util._MAX_LENGTH = 999999999\n         label = ElfSymbol(\"label\", 0xFFFF0008, 0x0, STT.FUNC, STB.LOCAL)\n         subsume = ElfSymbol(\"subsume\", 0xFFFF0004, 0x8, STT.FUNC, STB.LOCAL)\n         less = ElfSymbol(\"less\", 0xFFFF0000, 0x4, STT.FUNC, STB.LOCAL)\n"}
{"repo": "drgn", "commit": "9de433fe89ef0d60d95d2cedeae821cf06e84855", "diff": "diff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex b496bf2b..d68df48f 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -66,6 +66,7 @@ def _compile_debug_abbrev(units, use_dw_form_indirect):\n \n \n def _compile_debug_info(units, little_endian, bits, version, use_dw_form_indirect):\n+    offset_size = 4  # We only emit the 32-bit format for now.\n     byteorder = \"little\" if little_endian else \"big\"\n     all_labels = set()\n     labels = {}\n@@ -114,6 +115,8 @@ def _compile_debug_info(units, little_endian, bits, version, use_dw_form_indirec\n             elif attrib.form == DW_FORM.block1:\n                 buf.append(len(value))\n                 buf.extend(value)\n+            elif attrib.form == DW_FORM.strp:\n+                buf.extend(value.to_bytes(offset_size, byteorder))\n             elif attrib.form == DW_FORM.string:\n                 buf.extend(value.encode())\n                 buf.append(0)\n@@ -123,7 +126,7 @@ def _compile_debug_info(units, little_endian, bits, version, use_dw_form_indirec\n             elif attrib.form == DW_FORM.ref_sig8:\n                 buf.extend(value.to_bytes(8, byteorder))\n             elif attrib.form == DW_FORM.sec_offset:\n-                buf.extend(b\"\\0\\0\\0\\0\")\n+                buf.extend(bytes(offset_size))\n             elif attrib.form == DW_FORM.flag_present:\n                 pass\n             elif attrib.form == DW_FORM.exprloc:\n@@ -163,7 +166,7 @@ def _compile_debug_info(units, little_endian, bits, version, use_dw_form_indirec\n         if unit.type in (DW_UT.type, DW_UT.split_type):\n             buf.extend(unit.type_signature.to_bytes(8, byteorder))  # type_signature\n             relocations.append((len(buf), unit.type_offset))\n-            buf.extend(b\"\\0\\0\\0\\0\")  # type_offset\n+            buf.extend(bytes(offset_size))  # type_offset\n         else:\n             assert unit.type_signature is None\n             assert unit.type_offset is None\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex f2f0e718..43cf1de0 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -249,6 +249,22 @@ def with_and_without_dw_form_indirect(f):\n     return wrapper\n \n \n+class TestInvalidDwarf(TestCase):\n+    def test_name_out_of_bounds(self):\n+        with self.assertRaisesRegex(Exception, \"name is out of bounds\"):\n+            prog = dwarf_program(\n+                DwarfDie(\n+                    DW_TAG.base_type,\n+                    (\n+                        DwarfAttrib(DW_AT.encoding, DW_FORM.data1, DW_ATE.signed),\n+                        DwarfAttrib(DW_AT.name, DW_FORM.strp, 0xDEADBEEF),\n+                    ),\n+                )\n+            )\n+            # Force indexing.\n+            \"foo\" in prog\n+\n+\n class TestTypes(TestCase):\n     def test_unknown_tag(self):\n         prog = dwarf_program(wrap_test_type_dies(DwarfDie(0x9999, ())))\n"}
{"repo": "drgn", "commit": "f9ab6785c4ed45155ef92819157817191ddc2069", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 68bea6cf..c94b5fd9 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -290,6 +290,20 @@ def _main() -> None:\n         action=\"store_true\",\n         help=\"don't search for debugging symbols by build ID and debug link in the standard locations\",\n     )\n+    symbol_group.add_argument(\n+        \"--kernel-directory\",\n+        dest=\"kernel_directories\",\n+        metavar=\"PATH\",\n+        type=str,\n+        action=\"append\",\n+        help=\"search for the kernel image and loadable kernel modules in the given directory. \"\n+        \"This option may be given more than once\",\n+    )\n+    symbol_group.add_argument(\n+        \"--no-default-kernel-directories\",\n+        action=\"store_true\",\n+        help=\"don't search for the kernel image and loadable kernel modules in the standard locations\",\n+    )\n \n     advanced_group = parser.add_argument_group(\"advanced\")\n     advanced_group.add_argument(\n@@ -404,6 +418,17 @@ def _main() -> None:\n     elif args.no_default_debug_directories:\n         prog.debug_info_options.directories = ()\n \n+    if args.kernel_directories is not None:\n+        if args.no_default_kernel_directories:\n+            prog.debug_info_options.kernel_directories = args.kernel_directories\n+        else:\n+            prog.debug_info_options.kernel_directories = (\n+                tuple(args.kernel_directories)\n+                + prog.debug_info_options.kernel_directories\n+            )\n+    elif args.no_default_kernel_directories:\n+        prog.debug_info_options.kernel_directories = ()\n+\n     if args.default_symbols is None:\n         args.default_symbols = {\"default\": True, \"main\": True}\n     try:\n"}
{"repo": "drgn", "commit": "5e7bec4ef9016db6cbda49c826f89c34d1571994", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 96f922cc..68bea6cf 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -14,7 +14,7 @@ import pkgutil\n import runpy\n import shutil\n import sys\n-from typing import Any, Callable, Dict, Optional\n+from typing import Any, Callable, Dict, Optional, Tuple\n \n import drgn\n from drgn.internal.repl import interact, readline\n@@ -146,6 +146,55 @@ def _displayhook(value: Any) -> None:\n     setattr(builtins, \"_\", value)\n \n \n+class _DebugInfoOptionAction(argparse.Action):\n+    _choices: Dict[str, Tuple[str, Any]]\n+\n+    @staticmethod\n+    def _bool_options(value: bool) -> Dict[str, Tuple[str, bool]]:\n+        return {\n+            option: (\"try_\" + option.replace(\"-\", \"_\"), value)\n+            for option in (\n+                \"module-name\",\n+                \"build-id\",\n+                \"debug-link\",\n+                \"procfs\",\n+                \"embedded-vdso\",\n+                \"reuse\",\n+                \"supplementary\",\n+            )\n+        }\n+\n+    def __call__(\n+        self,\n+        parser: argparse.ArgumentParser,\n+        namespace: argparse.Namespace,\n+        values: Any,\n+        option_string: Optional[str] = None,\n+    ) -> None:\n+        dest = getattr(namespace, self.dest, None)\n+        if dest is None:\n+            dest = {}\n+            setattr(namespace, self.dest, dest)\n+\n+        for option in values.split(\",\"):\n+            try:\n+                name, value = self._choices[option]\n+            except KeyError:\n+                raise argparse.ArgumentError(\n+                    self,\n+                    f\"invalid option: {option!r} (choose from {', '.join(self._choices)})\",\n+                )\n+            dest[name] = value\n+\n+\n+class _TryDebugInfoOptionAction(_DebugInfoOptionAction):\n+    _choices = _DebugInfoOptionAction._bool_options(True)\n+\n+\n+class _NoDebugInfoOptionAction(_DebugInfoOptionAction):\n+    _choices = _DebugInfoOptionAction._bool_options(False)\n+\n+\n def _main() -> None:\n     handler = logging.StreamHandler()\n     color = hasattr(sys.stderr, \"fileno\") and os.isatty(sys.stderr.fileno())\n@@ -209,6 +258,24 @@ def _main() -> None:\n         \"which is assumed not to correspond to a loaded executable, library, or module. \"\n         \"This option may be given more than once\",\n     )\n+    symbol_group.add_argument(\n+        \"--try-symbols-by\",\n+        dest=\"symbols_by\",\n+        metavar=\"METHOD[,METHOD...]\",\n+        action=_TryDebugInfoOptionAction,\n+        help=\"enable loading debugging symbols using the given methods. \"\n+        \"Choices are \" + \", \".join(_TryDebugInfoOptionAction._choices) + \". \"\n+        \"This option may be given more than once\",\n+    )\n+    symbol_group.add_argument(\n+        \"--no-symbols-by\",\n+        dest=\"symbols_by\",\n+        metavar=\"METHOD[,METHOD...]\",\n+        action=_NoDebugInfoOptionAction,\n+        help=\"disable loading debugging symbols using the given methods. \"\n+        \"Choices are \" + \", \".join(_NoDebugInfoOptionAction._choices) + \". \"\n+        \"This option may be given more than once\",\n+    )\n     symbol_group.add_argument(\n         \"--debug-directory\",\n         dest=\"debug_directories\",\n@@ -323,6 +390,10 @@ def _main() -> None:\n         # E.g., \"not an ELF core file\"\n         sys.exit(f\"error: {e}\")\n \n+    if args.symbols_by:\n+        for option, value in args.symbols_by.items():\n+            setattr(prog.debug_info_options, option, value)\n+\n     if args.debug_directories is not None:\n         if args.no_default_debug_directories:\n             prog.debug_info_options.directories = args.debug_directories\ndiff --git a/tests/test_debug_info_options.py b/tests/test_debug_info_options.py\nindex 4a86c445..eb968bee 100644\n--- a/tests/test_debug_info_options.py\n+++ b/tests/test_debug_info_options.py\n@@ -30,6 +30,22 @@ class TestDebugInfoOptions(TestCase):\n         with self.assertRaises(TypeError):\n             DebugInfoOptions().directories = None\n \n+    def test_bool_default(self):\n+        self.assertIs(DebugInfoOptions().try_build_id, True)\n+\n+    def test_bool_init(self):\n+        self.assertIs(DebugInfoOptions(try_build_id=False).try_build_id, False)\n+\n+    def test_bool_copy(self):\n+        self.assertIs(\n+            DebugInfoOptions(DebugInfoOptions(try_build_id=False)).try_build_id, False\n+        )\n+\n+    def test_bool_set(self):\n+        options = DebugInfoOptions()\n+        options.try_build_id = False\n+        self.assertIs(options.try_build_id, False)\n+\n     def test_del(self):\n         with self.assertRaises(AttributeError):\n             del DebugInfoOptions().directories\n"}
{"repo": "drgn", "commit": "2cd7bc69a5733c6f0f049a163e96226349b8eab8", "diff": "diff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex cdb8fe73..69373ed9 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -19,6 +19,7 @@ import unittest.mock\n \n from _drgn_util.elf import ET, PT, SHF, SHT\n from drgn import (\n+    DebugInfoOptions,\n     MainModule,\n     MissingDebugInfoError,\n     ModuleFileStatus,\n@@ -1954,6 +1955,32 @@ class TestStandardDebugInfoFinder(TestCase):\n             self.assertEqual(module.loaded_file_path, str(loadable_path))\n             self.assertEqual(module.debug_file_path, str(debug_path))\n \n+    def test_by_build_id_method(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n+            build_id_dir.mkdir(parents=True)\n+            binary_path = build_id_dir / build_id.hex()[2:]\n+            binary_path.write_bytes(compile_dwarf((), sections=(ALLOCATED_SECTION,)))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+\n+            self.prog.find_standard_debug_info(\n+                [module],\n+                options=DebugInfoOptions(directories=(\"\", \".debug\", str(debug_dir))),\n+            )\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+\n     def test_by_gnu_debuglink(self):\n         with tempfile.TemporaryDirectory(\n             prefix=\"bin-\"\n"}
{"repo": "drgn", "commit": "bb00871601b3c5d7668788664a84938a91de6bac", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 981bef3e..105423ae 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -49,6 +49,7 @@ from typing import Union\n from _drgn import (\n     NULL,\n     Architecture,\n+    DebugInfoOptions,\n     ExtraModule,\n     FaultError,\n     FindObjectFlags,\n@@ -115,6 +116,7 @@ from drgn.internal.version import __version__ as __version__  # noqa: F401\n \n __all__ = (\n     \"Architecture\",\n+    \"DebugInfoOptions\",\n     \"ExtraModule\",\n     \"FaultError\",\n     \"FindObjectFlags\",\ndiff --git a/drgn/cli.py b/drgn/cli.py\nindex 36d6d9f2..96f922cc 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -209,6 +209,20 @@ def _main() -> None:\n         \"which is assumed not to correspond to a loaded executable, library, or module. \"\n         \"This option may be given more than once\",\n     )\n+    symbol_group.add_argument(\n+        \"--debug-directory\",\n+        dest=\"debug_directories\",\n+        metavar=\"PATH\",\n+        type=str,\n+        action=\"append\",\n+        help=\"search for debugging symbols by build ID and debug link in the given directory. \"\n+        \"This option may be given more than once\",\n+    )\n+    symbol_group.add_argument(\n+        \"--no-default-debug-directories\",\n+        action=\"store_true\",\n+        help=\"don't search for debugging symbols by build ID and debug link in the standard locations\",\n+    )\n \n     advanced_group = parser.add_argument_group(\"advanced\")\n     advanced_group.add_argument(\n@@ -309,6 +323,16 @@ def _main() -> None:\n         # E.g., \"not an ELF core file\"\n         sys.exit(f\"error: {e}\")\n \n+    if args.debug_directories is not None:\n+        if args.no_default_debug_directories:\n+            prog.debug_info_options.directories = args.debug_directories\n+        else:\n+            prog.debug_info_options.directories = (\n+                tuple(args.debug_directories) + prog.debug_info_options.directories\n+            )\n+    elif args.no_default_debug_directories:\n+        prog.debug_info_options.directories = ()\n+\n     if args.default_symbols is None:\n         args.default_symbols = {\"default\": True, \"main\": True}\n     try:\ndiff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nindex 8c6f8f73..cdb8fe73 100644\n--- a/tests/test_debug_info.py\n+++ b/tests/test_debug_info.py\n@@ -576,7 +576,7 @@ class TestModuleTryFile(TestCase):\n class TestLinuxUserspaceCoreDump(TestCase):\n     def setUp(self):\n         self.prog = Program()\n-        self.prog.debug_info_path = None\n+        self.prog.debug_info_options.directories = ()\n         self.prog.set_enabled_debug_info_finders([\"standard\"])\n \n     def test_loaded_modules(self):\n@@ -1735,7 +1735,7 @@ class TestLoadModuleDebugInfo(TestCase):\n class TestStandardDebugInfoFinder(TestCase):\n     def setUp(self):\n         self.prog = Program()\n-        self.prog.debug_info_path = None\n+        self.prog.debug_info_options.directories = ()\n         self.prog.set_enabled_debug_info_finders([\"standard\"])\n \n     def test_by_module_name(self):\n@@ -1890,7 +1890,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n             module.build_id = build_id\n \n-            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1918,7 +1918,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n             module.build_id = build_id\n \n-            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1947,7 +1947,7 @@ class TestStandardDebugInfoFinder(TestCase):\n \n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n \n-            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n@@ -1975,7 +1975,7 @@ class TestStandardDebugInfoFinder(TestCase):\n                 )\n             )\n \n-            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n             for i, debug_path in enumerate(\n                 (\n                     bin_dir / \"binary.debug\",\n@@ -2062,7 +2062,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             debug_path.write_bytes(debug_file_contents)\n \n             module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n-            self.prog.debug_info_path = \"\"\n+            self.prog.debug_info_options.directories = (\"\",)\n             self.prog.load_module_debug_info(module)\n             self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n \n@@ -2283,7 +2283,7 @@ class TestStandardDebugInfoFinder(TestCase):\n             alt_path.parent.mkdir()\n             alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n \n-            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.debug_info_options.directories = (\"\", \".debug\", str(debug_dir))\n             for i, debugaltlink in enumerate(\n                 (\n                     bin_dir / \"debug/.dwz/alt.debug\",\ndiff --git a/tests/test_debug_info_options.py b/tests/test_debug_info_options.py\nnew file mode 100644\nindex 00000000..4a86c445\n--- /dev/null\n+++ b/tests/test_debug_info_options.py\n@@ -0,0 +1,56 @@\n+# Copyright (c) Meta Platforms, Inc. and affiliates.\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+from drgn import DebugInfoOptions, Program\n+from tests import TestCase\n+\n+\n+class TestDebugInfoOptions(TestCase):\n+    def test_list_default(self):\n+        self.assertEqual(\n+            DebugInfoOptions().directories, (\"\", \".debug\", \"/usr/lib/debug\")\n+        )\n+\n+    def test_list_init(self):\n+        self.assertEqual(\n+            DebugInfoOptions(directories=[\"foo\", \"bar\"]).directories, (\"foo\", \"bar\")\n+        )\n+        self.assertRaises(TypeError, DebugInfoOptions, directories=None)\n+\n+    def test_list_copy(self):\n+        self.assertEqual(\n+            DebugInfoOptions(DebugInfoOptions(directories=[\"foo\", \"bar\"])).directories,\n+            (\"foo\", \"bar\"),\n+        )\n+\n+    def test_list_set(self):\n+        options = DebugInfoOptions()\n+        options.directories = (\"foo\", \"bar\")\n+        self.assertEqual(options.directories, (\"foo\", \"bar\"))\n+        with self.assertRaises(TypeError):\n+            DebugInfoOptions().directories = None\n+\n+    def test_del(self):\n+        with self.assertRaises(AttributeError):\n+            del DebugInfoOptions().directories\n+\n+    def test_repr(self):\n+        self.assertIn(\"directories=()\", repr(DebugInfoOptions(directories=())))\n+\n+\n+class TestProgramDebugInfoOptions(TestCase):\n+    def test_default(self):\n+        self.assertEqual(\n+            Program().debug_info_options.directories, DebugInfoOptions().directories\n+        )\n+\n+    def test_assign(self):\n+        prog = Program()\n+        prog.debug_info_options.directories = (\"foo\", \"bar\")\n+        prog.debug_info_options = DebugInfoOptions(directories=(\"bar\", \"baz\"))\n+        self.assertEqual(prog.debug_info_options.directories, (\"bar\", \"baz\"))\n+\n+    def test_assign_list(self):\n+        prog = Program()\n+        prog.debug_info_options.directories = (\"bar\", \"foo\")\n+        self.assertEqual(prog.debug_info_options.directories, (\"bar\", \"foo\"))\n"}
{"repo": "drgn", "commit": "45c4a228ac3e3c58603f16f46939b4e4e727d903", "diff": "diff --git a/tests/linux_kernel/test_debug_info.py b/tests/linux_kernel/test_debug_info.py\nindex f50afbdf..db712e68 100644\n--- a/tests/linux_kernel/test_debug_info.py\n+++ b/tests/linux_kernel/test_debug_info.py\n@@ -3,7 +3,7 @@\n \n import os\n \n-from drgn import Program, RelocatableModule\n+from drgn import MainModule, Program, RelocatableModule\n from drgn.helpers.linux.module import find_module\n from tests import modifyenv\n from tests.linux_kernel import LinuxKernelTestCase, skip_unless_have_test_kmod\n@@ -20,6 +20,23 @@ def iter_proc_modules():\n             yield tokens[0], int(tokens[5], 16)\n \n \n+class TestLoadDebugInfo(LinuxKernelTestCase):\n+    def test_no_build_id(self):\n+        prog = Program()\n+        prog.set_kernel()\n+        prog.set_enabled_debug_info_finders([])\n+        for module, _ in prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.build_id = None\n+                break\n+        else:\n+            self.fail(\"main module not found\")\n+        prog.load_debug_info([self.prog.main_module().debug_file_path])\n+        self.assertEqual(\n+            prog.main_module().debug_file_path, self.prog.main_module().debug_file_path\n+        )\n+\n+\n class TestModule(LinuxKernelTestCase):\n     def test_loaded_modules(self):\n         expected = [(\"kernel\", None), *iter_proc_modules()]\n"}
{"repo": "drgn", "commit": "4738ddfa5c01dda14e42f6696a8294804faa32e4", "diff": "diff --git a/tests/test_module.py b/tests/test_module.py\nindex 2ff5c1c8..e22f1bd4 100644\n--- a/tests/test_module.py\n+++ b/tests/test_module.py\n@@ -351,6 +351,11 @@ class TestModule(TestCase):\n         with self.assertRaisesRegex(ValueError, \"invalid module address range\"):\n             module.address_range = (2**64 - 1, 2**64 - 1)\n \n+    def test_address_range_del(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+        with self.assertRaises(AttributeError):\n+            del module.address_range\n+\n     def test_build_id(self):\n         module = Program().extra_module(\"/foo/bar\", create=True)[0]\n \n@@ -376,6 +381,11 @@ class TestModule(TestCase):\n         with self.assertRaisesRegex(ValueError, \"build ID cannot be empty\"):\n             module.build_id = b\"\"\n \n+    def test_build_id_del(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+        with self.assertRaises(AttributeError):\n+            del module.build_id\n+\n     def test_find_by_address(self):\n         prog = Program()\n         module1 = prog.extra_module(\"/foo/bar\", create=True)[0]\n@@ -456,6 +466,8 @@ class TestModule(TestCase):\n         setattr(module, status_attr, ModuleFileStatus.WANT)\n         self.assertEqual(getattr(module, status_attr), ModuleFileStatus.WANT)\n \n+        self.assertRaises(AttributeError, delattr, module, status_attr)\n+\n     def test_loaded_file_status(self):\n         self._test_file_status(\"loaded\")\n \ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex b3b22483..6b6c4240 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -162,6 +162,10 @@ class TestProgram(TestCase):\n             TypeError, \"language must be Language\", setattr, prog, \"language\", \"CPP\"\n         )\n \n+    def test_language_del(self):\n+        with self.assertRaises(AttributeError):\n+            del Program().language\n+\n \n class TestMemory(TestCase):\n     def test_simple_read(self):\n"}
{"repo": "drgn", "commit": "5ee2dfd612c5d5278c8c4f9b959c01b4745396ed", "diff": "diff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex 91fac06a..d6f6aebb 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -47,7 +47,6 @@ def elf_symbol_program(*modules):\n             module = prog.extra_module(f.name, create=True)[0]\n             module.address_range = (start, end)\n             module.try_file(f.name, force=True)\n-            print(module.loaded_file_path)\n     return prog\n \n \n"}
{"repo": "drgn", "commit": "4e83130008e9c28c3d775a0ab40075f2f9123720", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 5a03f5a3..981bef3e 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -49,11 +49,15 @@ from typing import Union\n from _drgn import (\n     NULL,\n     Architecture,\n+    ExtraModule,\n     FaultError,\n     FindObjectFlags,\n     IntegerLike,\n     Language,\n+    MainModule,\n     MissingDebugInfoError,\n+    Module,\n+    ModuleFileStatus,\n     NoDefaultProgramError,\n     Object,\n     ObjectAbsentError,\n@@ -66,8 +70,11 @@ from _drgn import (\n     ProgramFlags,\n     Qualifiers,\n     Register,\n+    RelocatableModule,\n+    SharedLibraryModule,\n     StackFrame,\n     StackTrace,\n+    SupplementaryFileKind,\n     Symbol,\n     SymbolBinding,\n     SymbolIndex,\n@@ -80,6 +87,8 @@ from _drgn import (\n     TypeMember,\n     TypeParameter,\n     TypeTemplateParameter,\n+    VdsoModule,\n+    WantedSupplementaryFile,\n     alignof,\n     cast,\n     container_of,\n@@ -106,11 +115,15 @@ from drgn.internal.version import __version__ as __version__  # noqa: F401\n \n __all__ = (\n     \"Architecture\",\n+    \"ExtraModule\",\n     \"FaultError\",\n     \"FindObjectFlags\",\n     \"IntegerLike\",\n     \"Language\",\n+    \"MainModule\",\n     \"MissingDebugInfoError\",\n+    \"Module\",\n+    \"ModuleFileStatus\",\n     \"NULL\",\n     \"NoDefaultProgramError\",\n     \"Object\",\n@@ -124,8 +137,11 @@ __all__ = (\n     \"ProgramFlags\",\n     \"Qualifiers\",\n     \"Register\",\n+    \"RelocatableModule\",\n+    \"SharedLibraryModule\",\n     \"StackFrame\",\n     \"StackTrace\",\n+    \"SupplementaryFileKind\",\n     \"Symbol\",\n     \"SymbolBinding\",\n     \"SymbolIndex\",\n@@ -138,6 +154,8 @@ __all__ = (\n     \"TypeMember\",\n     \"TypeParameter\",\n     \"TypeTemplateParameter\",\n+    \"VdsoModule\",\n+    \"WantedSupplementaryFile\",\n     \"alignof\",\n     \"cast\",\n     \"container_of\",\ndiff --git a/drgn/cli.py b/drgn/cli.py\nindex 8d349758..36d6d9f2 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -89,19 +89,6 @@ def version_header() -> str:\n     return f\"drgn {drgn.__version__} (using Python {python_version}, elfutils {drgn._elfutils_version}, {libkdumpfile})\"\n \n \n-class _QuietAction(argparse.Action):\n-    def __init__(\n-        self, option_strings: Any, dest: Any, nargs: Any = 0, **kwds: Any\n-    ) -> None:\n-        super().__init__(option_strings, dest, nargs=nargs, **kwds)\n-\n-    def __call__(\n-        self, parser: Any, namespace: Any, values: Any, option_string: Any = None\n-    ) -> None:\n-        setattr(namespace, self.dest, True)\n-        namespace.log_level = \"none\"\n-\n-\n def _identify_script(path: str) -> str:\n     EI_NIDENT = 16\n     SIZEOF_E_TYPE = 2\n@@ -161,9 +148,8 @@ def _displayhook(value: Any) -> None:\n \n def _main() -> None:\n     handler = logging.StreamHandler()\n-    handler.setFormatter(\n-        _LogFormatter(hasattr(sys.stderr, \"fileno\") and os.isatty(sys.stderr.fileno()))\n-    )\n+    color = hasattr(sys.stderr, \"fileno\") and os.isatty(sys.stderr.fileno())\n+    handler.setFormatter(_LogFormatter(color))\n     logging.getLogger().addHandler(handler)\n \n     version = version_header()\n@@ -193,7 +179,9 @@ def _main() -> None:\n         metavar=\"PATH\",\n         type=str,\n         action=\"append\",\n-        help=\"load additional debugging symbols from the given file; this option may be given more than once\",\n+        help=\"load debugging symbols from the given file. \"\n+        \"If the file does not correspond to a loaded executable, library, or module, \"\n+        \"then it is ignored. This option may be given more than once\",\n     )\n     default_symbols_group = symbol_group.add_mutually_exclusive_group()\n     default_symbols_group.add_argument(\n@@ -201,15 +189,25 @@ def _main() -> None:\n         dest=\"default_symbols\",\n         action=\"store_const\",\n         const={\"main\": True},\n-        help=\"only load debugging symbols for the main executable and those added with -s; \"\n-        \"for userspace programs, this is currently equivalent to --no-default-symbols\",\n+        help=\"only load debugging symbols for the main executable \"\n+        \"and those added with -s or --extra-symbols\",\n     )\n     default_symbols_group.add_argument(\n         \"--no-default-symbols\",\n         dest=\"default_symbols\",\n         action=\"store_const\",\n         const={},\n-        help=\"don't load any debugging symbols that were not explicitly added with -s\",\n+        help=\"don't load any debugging symbols that were not explicitly added \"\n+        \"with -s or --extra-symbols\",\n+    )\n+    symbol_group.add_argument(\n+        \"--extra-symbols\",\n+        metavar=\"PATH\",\n+        type=str,\n+        action=\"append\",\n+        help=\"load additional debugging symbols from the given file, \"\n+        \"which is assumed not to correspond to a loaded executable, library, or module. \"\n+        \"This option may be given more than once\",\n     )\n \n     advanced_group = parser.add_argument_group(\"advanced\")\n@@ -235,7 +233,9 @@ def _main() -> None:\n     parser.add_argument(\n         \"-q\",\n         \"--quiet\",\n-        action=_QuietAction,\n+        dest=\"log_level\",\n+        action=\"store_const\",\n+        const=\"none\",\n         help=\"don't print any logs or download progress\",\n     )\n     parser.add_argument(\n@@ -268,8 +268,6 @@ def _main() -> None:\n     else:\n         print(version, file=sys.stderr, flush=True)\n \n-    if not args.quiet:\n-        os.environ[\"DEBUGINFOD_PROGRESS\"] = \"1\"\n     if args.log_level == \"none\":\n         logger.setLevel(logging.CRITICAL + 1)\n     else:\n@@ -316,7 +314,14 @@ def _main() -> None:\n     try:\n         prog.load_debug_info(args.symbols, **args.default_symbols)\n     except drgn.MissingDebugInfoError as e:\n-        logger.warning(\"%s\", e)\n+        logger.warning(\"\\033[1m%s\\033[m\" if color else \"%s\", e)\n+\n+    if args.extra_symbols:\n+        for extra_symbol_path in args.extra_symbols:\n+            extra_symbol_path = os.path.abspath(extra_symbol_path)\n+            module, new = prog.extra_module(extra_symbol_path, create=True)\n+            if new:\n+                module.try_file(extra_symbol_path)\n \n     if args.script:\n         sys.argv = args.script\ndiff --git a/libdrgn/build-aux/gen_constants.py b/libdrgn/build-aux/gen_constants.py\nindex 8e2180b1..c6999292 100644\n--- a/libdrgn/build-aux/gen_constants.py\n+++ b/libdrgn/build-aux/gen_constants.py\n@@ -16,6 +16,7 @@ class ConstantClass(NamedTuple):\n CONSTANTS = (\n     ConstantClass(\"Architecture\", \"Enum\", r\"DRGN_ARCH_([a-zA-Z0-9_]+)\"),\n     ConstantClass(\"FindObjectFlags\", \"Flag\", r\"DRGN_FIND_OBJECT_([a-zA-Z0-9_]+)\"),\n+    ConstantClass(\"ModuleFileStatus\", \"Enum\", r\"DRGN_MODULE_FILE_([a-zA-Z0-9_]+)\"),\n     ConstantClass(\n         \"PlatformFlags\",\n         \"Flag\",\n@@ -28,6 +29,11 @@ CONSTANTS = (\n     ConstantClass(\n         \"Qualifiers\", \"Flag\", r\"DRGN_QUALIFIER_([a-zA-Z0-9_]+)\", [(\"NONE\", \"0\")]\n     ),\n+    ConstantClass(\n+        \"SupplementaryFileKind\",\n+        \"Enum\",\n+        r\"DRGN_SUPPLEMENTARY_FILE_([a-z-A-Z0-9_]+)(?<!DRGN_SUPPLEMENTARY_FILE_NONE)\",\n+    ),\n     ConstantClass(\"SymbolBinding\", \"Enum\", r\"DRGN_SYMBOL_BINDING_([a-z-A-Z0-9_]+)\"),\n     ConstantClass(\"SymbolKind\", \"Enum\", r\"DRGN_SYMBOL_KIND_([a-z-A-Z0-9_]+)\"),\n     ConstantClass(\"TypeKind\", \"Enum\", r\"DRGN_TYPE_([a-zA-Z0-9_]+)\"),\ndiff --git a/libdrgn/build-aux/gen_elf_sections.py b/libdrgn/build-aux/gen_elf_sections.py\nindex 56fa3ab6..47c54c80 100755\n--- a/libdrgn/build-aux/gen_elf_sections.py\n+++ b/libdrgn/build-aux/gen_elf_sections.py\n@@ -28,6 +28,8 @@ CACHED_SECTIONS = (\n UNCACHED_SECTIONS = (\n     \".text\",\n     \".got\",\n+    \".gnu_debuglink\",\n+    \".gnu_debugaltlink\",\n )\n \n \n@@ -54,15 +56,15 @@ enum drgn_section_index {\n         out_file.write(f\"\\t{section_enumerator_name(section_name)},\\n\")\n     out_file.write(\n         \"\"\"\\\n-\t/** Indices less than this are cached when the module is loaded. */\n-\tDRGN_SECTION_INDEX_NUM_PRECACHE,\n+\t/** Indices less than this are used by the DWARF index. */\n+\tDRGN_SECTION_INDEX_NUM_DWARF_INDEX,\n \"\"\"\n     )\n \n     for i, section_name in enumerate(CACHED_SECTIONS):\n         if i == 0:\n             out_file.write(\n-                f\"\\t{section_enumerator_name(section_name)} = DRGN_SECTION_INDEX_NUM_PRECACHE,\\n\"\n+                f\"\\t{section_enumerator_name(section_name)} = DRGN_SECTION_INDEX_NUM_DWARF_INDEX,\\n\"\n             )\n         else:\n             out_file.write(f\"\\t{section_enumerator_name(section_name)},\\n\")\ndiff --git a/tests/linux_kernel/test_debug_info.py b/tests/linux_kernel/test_debug_info.py\nindex 75ccabf5..f50afbdf 100644\n--- a/tests/linux_kernel/test_debug_info.py\n+++ b/tests/linux_kernel/test_debug_info.py\n@@ -2,49 +2,89 @@\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n import os\n-from pathlib import Path\n-import unittest\n \n-from drgn import Program\n+from drgn import Program, RelocatableModule\n+from drgn.helpers.linux.module import find_module\n from tests import modifyenv\n from tests.linux_kernel import LinuxKernelTestCase, skip_unless_have_test_kmod\n \n-KALLSYMS_PATH = Path(\"/proc/kallsyms\")\n-\n-\n-@unittest.skipUnless(\n-    KALLSYMS_PATH.exists(), \"kernel does not have kallsyms (CONFIG_KALLSYMS)\"\n-)\n-@skip_unless_have_test_kmod\n-class TestModuleDebugInfo(LinuxKernelTestCase):\n-    # Arbitrary symbol that we can use to check that the module debug info was\n-    # loaded.\n-    SYMBOL = \"drgn_test_function\"\n-\n-    def setUp(self):\n-        super().setUp()\n-        with KALLSYMS_PATH.open() as f:\n-            for line in f:\n-                tokens = line.split()\n-                if tokens[2] == self.SYMBOL:\n-                    self.symbol_address = int(tokens[0], 16)\n-                    break\n-            else:\n-                self.fail(f\"{self.SYMBOL!r} symbol not found\")\n \n-    def _test_module_debug_info(self, use_sys_module):\n-        old_use_sys_module = int(os.environ.get(\"DRGN_USE_SYS_MODULE\", \"1\")) != 0\n-        with modifyenv({\"DRGN_USE_SYS_MODULE\": \"1\" if use_sys_module else \"0\"}):\n-            if old_use_sys_module == use_sys_module:\n-                prog = self.prog\n+def iter_proc_modules():\n+    try:\n+        f = open(\"/proc/modules\", \"r\")\n+    except FileNotFoundError:\n+        return\n+    with f:\n+        for line in f:\n+            tokens = line.split()\n+            yield tokens[0], int(tokens[5], 16)\n+\n+\n+class TestModule(LinuxKernelTestCase):\n+    def test_loaded_modules(self):\n+        expected = [(\"kernel\", None), *iter_proc_modules()]\n+\n+        loaded_modules = []\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, RelocatableModule):\n+                loaded_modules.append((module.name, module.address))\n             else:\n-                prog = Program()\n-                prog.set_kernel()\n-                self._load_debug_info(prog)\n-            self.assertEqual(prog.symbol(self.SYMBOL).address, self.symbol_address)\n+                loaded_modules.append((module.name, None))\n+\n+        self.assertCountEqual(loaded_modules, expected)\n+\n+    @skip_unless_have_test_kmod\n+    def test_find(self):\n+        self.assertEqual(self.prog.main_module().name, \"kernel\")\n+        for name, address in iter_proc_modules():\n+            if name == \"drgn_test\":\n+                self.assertEqual(\n+                    self.prog.relocatable_module(name, address).name, \"drgn_test\"\n+                )\n+                break\n+        else:\n+            self.fail(\"test module not found\")\n+\n+    @skip_unless_have_test_kmod\n+    def test_find_by_obj(self):\n+        for module in self.prog.modules():\n+            if module.name == \"drgn_test\":\n+                break\n+        else:\n+            self.fail(\"test module not found\")\n \n-    def test_module_debug_info_use_proc_and_sys(self):\n-        self._test_module_debug_info(True)\n+        module_obj = find_module(self.prog, \"drgn_test\")\n+        self.assertEqual(self.prog.linux_kernel_loadable_module(module_obj), module)\n+        self.assertEqual(\n+            self.prog.linux_kernel_loadable_module(module_obj, create=True),\n+            (module, False),\n+        )\n+\n+    def test_no_sys_module(self):\n+        # Test that we get the same modules with and without using /sys/module.\n+\n+        def module_dict(prog):\n+            return {\n+                (module.name, module.address): (\n+                    module.address_range,\n+                    module.build_id,\n+                    dict(module.section_addresses),\n+                )\n+                for module, _ in prog.loaded_modules()\n+                if isinstance(module, RelocatableModule)\n+            }\n+\n+        use_sys_module = int(os.environ.get(\"DRGN_USE_SYS_MODULE\", \"1\")) != 0\n+\n+        with modifyenv({\"DRGN_USE_SYS_MODULE\": str(int(not use_sys_module))}):\n+            prog = Program()\n+            prog.set_kernel()\n+\n+            if use_sys_module:\n+                with_sys_module = module_dict(self.prog)\n+                without_sys_module = module_dict(prog)\n+            else:\n+                with_sys_module = module_dict(prog)\n+                without_sys_module = module_dict(self.prog)\n \n-    def test_module_debug_info_use_core_dump(self):\n-        self._test_module_debug_info(False)\n+            self.assertEqual(with_sys_module, without_sys_module)\ndiff --git a/tests/test_debug_info.py b/tests/test_debug_info.py\nnew file mode 100644\nindex 00000000..79c79500\n--- /dev/null\n+++ b/tests/test_debug_info.py\n@@ -0,0 +1,2671 @@\n+# Copyright (c) Meta Platforms, Inc. and affiliates.\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+\n+import binascii\n+import contextlib\n+import http.server\n+import os\n+import os.path\n+from pathlib import Path\n+import re\n+import shutil\n+import socket\n+import socketserver\n+import tempfile\n+import threading\n+import unittest\n+import unittest.mock\n+\n+from _drgn_util.elf import ET, PT, SHF, SHT\n+from drgn import (\n+    MainModule,\n+    MissingDebugInfoError,\n+    ModuleFileStatus,\n+    Program,\n+    SharedLibraryModule,\n+    SupplementaryFileKind,\n+    VdsoModule,\n+)\n+from tests import TestCase, modifyenv\n+from tests.dwarfwriter import compile_dwarf\n+from tests.elfwriter import ElfSection, create_elf_file\n+from tests.resources import get_resource\n+\n+\n+def gnu_debuglink_section(path, crc):\n+    path = os.fsencode(path)\n+    return ElfSection(\n+        name=\".gnu_debuglink\",\n+        sh_type=SHT.PROGBITS,\n+        data=path + bytes(4 - len(path) % 4) + crc.to_bytes(4, \"little\"),\n+    )\n+\n+\n+def gnu_debugaltlink_section(path, build_id):\n+    return ElfSection(\n+        name=\".gnu_debugaltlink\",\n+        sh_type=SHT.PROGBITS,\n+        data=os.fsencode(path) + b\"\\0\" + build_id,\n+    )\n+\n+\n+ALLOCATED_SECTION = ElfSection(\n+    name=\".bss\",\n+    sh_type=SHT.PROGBITS,\n+    sh_flags=SHF.ALLOC,\n+    p_type=PT.LOAD,\n+    vaddr=0x10000000,\n+    memsz=0x1000,\n+)\n+\n+\n+@contextlib.contextmanager\n+def NamedTemporaryElfFile(*, loadable=True, debug=True, build_id=None, sections=()):\n+    if loadable:\n+        sections = (ALLOCATED_SECTION,) + sections\n+    with tempfile.NamedTemporaryFile() as f:\n+        if debug:\n+            f.write(compile_dwarf((), sections=sections, build_id=build_id))\n+        else:\n+            f.write(create_elf_file(ET.EXEC, sections=sections, build_id=build_id))\n+        f.flush()\n+        yield f\n+\n+\n+class TestModuleTryFile(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.set_enabled_debug_info_finders([])\n+\n+    def test_want_both(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+        for status in set(ModuleFileStatus) - {ModuleFileStatus.HAVE}:\n+            for file in (\"loaded\", \"debug\"):\n+                with self.subTest(file=file):\n+                    self.assertEqual(getattr(module, f\"wants_{file}_file\")(), False)\n+                    # Test that we can't unset the file once it's set.\n+                    status_attr = file + \"_file_status\"\n+                    with self.subTest(from_=ModuleFileStatus.HAVE, to=status):\n+                        self.assertRaises(\n+                            ValueError, setattr, module, status_attr, status\n+                        )\n+                        self.assertEqual(\n+                            getattr(module, status_attr), ModuleFileStatus.HAVE\n+                        )\n+\n+    def test_want_both_not_loadable(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(loadable=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_want_both_no_debug(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_want_both_is_neither(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(loadable=False, debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_loaded(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_loaded_not_loadable(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(loadable=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_loaded_no_debug(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_loaded_is_neither(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(loadable=False, debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_debug(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_only_want_debug_not_loadable(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(loadable=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_only_want_debug_no_debug(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_only_want_debug_is_neither(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile(loadable=False, debug=False) as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_want_neither(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+    def test_separate_files_loaded_first(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(debug=False) as f1:\n+            module.try_file(f1.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f1.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+        with NamedTemporaryElfFile(loadable=False) as f2:\n+            module.try_file(f2.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f1.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f2.name)\n+\n+    def test_separate_files_debug_first(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(loadable=False) as f1:\n+            module.try_file(f1.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f1.name)\n+\n+        with NamedTemporaryElfFile(debug=False) as f2:\n+            module.try_file(f2.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f2.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f1.name)\n+\n+    def test_loadable_then_both(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(debug=False) as f1:\n+            module.try_file(f1.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f1.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+\n+        with NamedTemporaryElfFile() as f2:\n+            module.try_file(f2.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f1.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f2.name)\n+\n+    def test_debug_then_both(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(loadable=False) as f1:\n+            module.try_file(f1.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f1.name)\n+\n+        with NamedTemporaryElfFile() as f2:\n+            module.try_file(f2.name)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f2.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f1.name)\n+\n+    def test_no_build_id_force(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name, force=True)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_no_build_id_file_has_build_id(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(build_id=b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\") as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_no_build_id_file_has_build_id_force(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile(build_id=b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\") as f:\n+            module.try_file(f.name, force=True)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_match(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile(build_id=b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\") as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_match_force(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile(build_id=b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\") as f:\n+            module.try_file(f.name, force=True)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_mismatch(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile(build_id=b\"\\xff\\xff\\xff\\xff\") as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_mismatch_force(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile(build_id=b\"\\xff\\xff\\xff\\xff\") as f:\n+            module.try_file(f.name, force=True)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_missing(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_build_id_missing_force(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name, force=True)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+    def test_gnu_debugaltlink(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(alt_path, alt_build_id),\n+                    ),\n+                    build_id=build_id,\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+            self.assertRaises(ValueError, module.wanted_supplementary_debug_file)\n+\n+            module.try_file(binary_path)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(module.wants_debug_file(), True)\n+            self.assertIsNone(module.debug_file_path)\n+            self.assertIsNone(module.supplementary_debug_file_kind)\n+            self.assertIsNone(module.supplementary_debug_file_path)\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(alt_path),\n+                    alt_build_id,\n+                ),\n+            )\n+\n+            with self.assertRaises(ValueError):\n+                module.debug_file_status = ModuleFileStatus.HAVE\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            module.debug_file_status = ModuleFileStatus.WANT_SUPPLEMENTARY\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+\n+            module.try_file(alt_path)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+            self.assertEqual(\n+                module.supplementary_debug_file_kind,\n+                SupplementaryFileKind.GNU_DEBUGALTLINK,\n+            )\n+            self.assertEqual(module.supplementary_debug_file_path, str(alt_path))\n+            self.assertRaises(ValueError, module.wanted_supplementary_debug_file)\n+\n+    def test_gnu_debugaltlink_build_id_mismatch(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id[::-1]))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(alt_path, alt_build_id),\n+                    ),\n+                    build_id=build_id,\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+            self.assertRaises(ValueError, module.wanted_supplementary_debug_file)\n+\n+            module.try_file(binary_path)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertIsNone(module.debug_file_path)\n+            self.assertIsNone(module.supplementary_debug_file_kind)\n+            self.assertIsNone(module.supplementary_debug_file_path)\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(alt_path),\n+                    alt_build_id,\n+                ),\n+            )\n+\n+            module.try_file(alt_path)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertIsNone(module.debug_file_path)\n+            self.assertIsNone(module.supplementary_debug_file_kind)\n+            self.assertIsNone(module.supplementary_debug_file_path)\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(alt_path),\n+                    alt_build_id,\n+                ),\n+            )\n+\n+    def test_gnu_debugaltlink_then_both(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+            with NamedTemporaryElfFile(\n+                sections=(gnu_debugaltlink_section(alt_path, alt_build_id),),\n+                build_id=build_id,\n+            ) as f1:\n+                module.try_file(f1.name)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+\n+            with NamedTemporaryElfFile(build_id=build_id) as f2:\n+                module.try_file(f2.name)\n+\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, f1.name)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_path, f2.name)\n+\n+    def test_gnu_debugaltlink_cancel(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+            with NamedTemporaryElfFile(\n+                sections=(gnu_debugaltlink_section(alt_path, alt_build_id),),\n+                build_id=build_id,\n+            ) as f:\n+                module.try_file(f.name)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+\n+            module.debug_file_status = ModuleFileStatus.WANT\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+            self.assertEqual(module.wants_debug_file(), True)\n+            self.assertRaises(ValueError, module.wanted_supplementary_debug_file)\n+\n+    def test_extra_module_no_address_range(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertIsNone(module.address_range)\n+        self.assertEqual(module.loaded_file_bias, 0)\n+        self.assertEqual(module.debug_file_bias, 0)\n+\n+    def test_extra_module_address_range(self):\n+        module = self.prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module.address_range = (0x40000000, 0x40001000)\n+        with NamedTemporaryElfFile() as f:\n+            module.try_file(f.name)\n+        self.assertEqual(module.address_range, (0x40000000, 0x40001000))\n+        self.assertEqual(module.loaded_file_bias, 0x30000000)\n+        self.assertEqual(module.debug_file_bias, 0x30000000)\n+\n+\n+class TestLinuxUserspaceCoreDump(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.debug_info_path = None\n+        self.prog.set_enabled_debug_info_finders([\"standard\"])\n+\n+    def test_loaded_modules(self):\n+        self.prog.set_core_dump(get_resource(\"crashme.core\"))\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, True)\n+            loaded_modules.append(module)\n+        found_modules = []\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            found_modules.append(module)\n+            self.assertEqual(module.name, \"/home/osandov/crashme\")\n+            self.assertEqual(module.address_range, (0x400000, 0x404010))\n+            self.assertEqual(\n+                module.build_id.hex(), \"99a6524c4df01fbff9b43a6ead3d8e8e6201568b\"\n+            )\n+\n+        with self.subTest(module=\"crashme\"):\n+            module = self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F6112CACE08\n+            )\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7F6112CA9000, 0x7F6112CAD010))\n+            self.assertEqual(\n+                module.build_id.hex(), \"7bd58f10e741c3c8fbcf2031aa65f830f933d616\"\n+            )\n+\n+        with self.subTest(module=\"libc\"):\n+            module = self.prog.shared_library_module(\"/lib64/libc.so.6\", 0x7F6112C94960)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7F6112AAE000, 0x7F6112C9EB70))\n+            self.assertEqual(\n+                module.build_id.hex(), \"77c77fee058b19c6f001cf2cb0371ce3b8341211\"\n+            )\n+\n+        with self.subTest(module=\"ld-linux\"):\n+            module = self.prog.shared_library_module(\n+                \"/lib64/ld-linux-x86-64.so.2\", 0x7F6112CEAE68\n+            )\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7F6112CB6000, 0x7F6112CEC2D8))\n+            self.assertEqual(\n+                module.build_id.hex(), \"91dcd0244204201b616bbf59427771b3751736ce\"\n+            )\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7F6112CB4438)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7F6112CB4000, 0x7F6112CB590F))\n+            self.assertEqual(\n+                module.build_id.hex(), \"fdc3e4d463911345fbc6d9cc432e5ebc276e8e03\"\n+            )\n+\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, False)\n+            loaded_modules.append(module)\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+    def _try_vdso_in_core(self, module):\n+        module.debug_file_status = ModuleFileStatus.DONT_WANT\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+\n+    def test_bias(self):\n+        self.prog.set_core_dump(get_resource(\"crashme.core\"))\n+\n+        for _ in self.prog.loaded_modules():\n+            pass\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            module.try_file(get_resource(\"crashme\"))\n+            self.assertEqual(module.loaded_file_bias, 0)\n+            self.assertEqual(module.debug_file_bias, 0)\n+\n+        with self.subTest(module=\"crashme\"):\n+            module = self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F6112CACE08\n+            )\n+            module.try_file(get_resource(\"crashme.so\"))\n+            self.assertEqual(module.loaded_file_bias, 0x7F6112CA9000)\n+            self.assertEqual(module.debug_file_bias, 0x7F6112CA9000)\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7F6112CB4438)\n+            self._try_vdso_in_core(module)\n+            self.assertEqual(module.loaded_file_bias, 0x7F6112CB4000)\n+            self.assertIsNone(module.debug_file_bias)\n+\n+    def test_loaded_modules_pie(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_pie.core\"))\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, True)\n+            loaded_modules.append(module)\n+        found_modules = []\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            found_modules.append(module)\n+            self.assertEqual(module.name, \"/home/osandov/crashme_pie\")\n+            self.assertEqual(module.address_range, (0x557ED343D000, 0x557ED3441018))\n+            self.assertEqual(\n+                module.build_id.hex(), \"eb4ad7aaded3815ab133a6d7784a2c95a4e52998\"\n+            )\n+\n+        with self.subTest(module=\"crashme\"):\n+            module = self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7FAB2C38DE08\n+            )\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FAB2C38A000, 0x7FAB2C38E010))\n+            self.assertEqual(\n+                module.build_id.hex(), \"7bd58f10e741c3c8fbcf2031aa65f830f933d616\"\n+            )\n+\n+        with self.subTest(module=\"libc\"):\n+            module = self.prog.shared_library_module(\"/lib64/libc.so.6\", 0x7FAB2C375960)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FAB2C18F000, 0x7FAB2C37FB70))\n+            self.assertEqual(\n+                module.build_id.hex(), \"77c77fee058b19c6f001cf2cb0371ce3b8341211\"\n+            )\n+\n+        with self.subTest(module=\"ld-linux\"):\n+            module = self.prog.shared_library_module(\n+                \"/lib64/ld-linux-x86-64.so.2\", 0x7FAB2C3CBE68\n+            )\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FAB2C397000, 0x7FAB2C3CD2D8))\n+            self.assertEqual(\n+                module.build_id.hex(), \"91dcd0244204201b616bbf59427771b3751736ce\"\n+            )\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FAB2C395438)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FAB2C395000, 0x7FAB2C39690F))\n+            self.assertEqual(\n+                module.build_id.hex(), \"fdc3e4d463911345fbc6d9cc432e5ebc276e8e03\"\n+            )\n+\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, False)\n+            loaded_modules.append(module)\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+    def test_bias_pie(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_pie.core\"))\n+\n+        for _ in self.prog.loaded_modules():\n+            pass\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            module.try_file(get_resource(\"crashme_pie\"))\n+            self.assertEqual(module.loaded_file_bias, 0x557ED343D000)\n+            self.assertEqual(module.debug_file_bias, 0x557ED343D000)\n+\n+        with self.subTest(module=\"crashme\"):\n+            module = self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7FAB2C38DE08\n+            )\n+            module.try_file(get_resource(\"crashme.so\"))\n+            self.assertEqual(module.loaded_file_bias, 0x7FAB2C38A000)\n+            self.assertEqual(module.debug_file_bias, 0x7FAB2C38A000)\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FAB2C395438)\n+            self._try_vdso_in_core(module)\n+            self.assertEqual(module.loaded_file_bias, 0x7FAB2C395000)\n+            self.assertIsNone(module.debug_file_bias)\n+\n+    def test_loaded_modules_static(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_static.core\"))\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, True)\n+            loaded_modules.append(module)\n+        found_modules = []\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            found_modules.append(module)\n+            self.assertEqual(module.name, \"/home/osandov/crashme_static\")\n+            self.assertEqual(module.address_range, (0x400000, 0x4042B8))\n+            self.assertEqual(\n+                module.build_id.hex(), \"a0b6befad9f0883c52c475ba3cee9c549cd082cf\"\n+            )\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FBC73A66438)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FBC73A66000, 0x7FBC73A6790F))\n+            self.assertEqual(\n+                module.build_id.hex(), \"fdc3e4d463911345fbc6d9cc432e5ebc276e8e03\"\n+            )\n+\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, False)\n+            loaded_modules.append(module)\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+    def test_bias_static(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_static.core\"))\n+\n+        for _ in self.prog.loaded_modules():\n+            pass\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            module.try_file(get_resource(\"crashme_static\"))\n+            self.assertEqual(module.loaded_file_bias, 0x0)\n+            self.assertEqual(module.debug_file_bias, 0x0)\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FBC73A66438)\n+            self._try_vdso_in_core(module)\n+            self.assertEqual(module.loaded_file_bias, 0x7FBC73A66000)\n+            self.assertIsNone(module.debug_file_bias)\n+\n+    def test_loaded_modules_static_pie(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_static_pie.core\"))\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, True)\n+            loaded_modules.append(module)\n+        found_modules = []\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            found_modules.append(module)\n+            self.assertEqual(module.name, \"/home/osandov/crashme_static_pie\")\n+            self.assertEqual(module.address_range, (0x7FD981DC9000, 0x7FD981DCD278))\n+            self.assertEqual(\n+                module.build_id.hex(), \"3e0bc47f80d7e64724e11fc021a251ed0d35bc2c\"\n+            )\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FD981DC7438)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7FD981DC7000, 0x7FD981DC890F))\n+            self.assertEqual(\n+                module.build_id.hex(), \"fdc3e4d463911345fbc6d9cc432e5ebc276e8e03\"\n+            )\n+\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, False)\n+            loaded_modules.append(module)\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+    def test_bias_static_pie(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_static_pie.core\"))\n+\n+        for _ in self.prog.loaded_modules():\n+            pass\n+\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            module.try_file(get_resource(\"crashme_static_pie\"))\n+            self.assertEqual(module.loaded_file_bias, 0x7FD981DC9000)\n+            self.assertEqual(module.debug_file_bias, 0x7FD981DC9000)\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7FD981DC7438)\n+            self._try_vdso_in_core(module)\n+            self.assertEqual(module.loaded_file_bias, 0x7FD981DC7000)\n+            self.assertIsNone(module.debug_file_bias)\n+\n+    def test_loaded_modules_pie_no_headers(self):\n+        self.prog.set_core_dump(get_resource(\"crashme_pie_no_headers.core\"))\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, True)\n+            loaded_modules.append(module)\n+        found_modules = []\n+\n+        # Without ELF headers saved in the core dump, and without the main ELF\n+        # file, only the main module (with limited information) and vDSO can be\n+        # found.\n+        with self.subTest(module=\"main\"):\n+            module = self.prog.main_module()\n+            found_modules.append(module)\n+            self.assertEqual(module.name, \"/home/osandov/crashme_pie\")\n+            self.assertIsNone(module.address_range)\n+            self.assertIsNone(module.build_id)\n+\n+        with self.subTest(module=\"vdso\"):\n+            module = self.prog.vdso_module(\"linux-vdso.so.1\", 0x7F299F607438)\n+            found_modules.append(module)\n+            self.assertEqual(module.address_range, (0x7F299F607000, 0x7F299F60890F))\n+            self.assertEqual(\n+                module.build_id.hex(), \"fdc3e4d463911345fbc6d9cc432e5ebc276e8e03\"\n+            )\n+\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            self.assertEqual(new, False)\n+            loaded_modules.append(module)\n+        self.assertCountEqual(loaded_modules, found_modules)\n+\n+        # If we can read the file headers (specifically, the program header\n+        # table and the interpreter path), then we should be able to get all of\n+        # the modules (with limited information).\n+        exe_file = self.enterContext(open(get_resource(\"crashme_pie\"), \"rb\"))\n+\n+        def read_headers(address, count, offset, physical):\n+            exe_file.seek(offset)\n+            return exe_file.read(count)\n+\n+        self.prog.add_memory_segment(0x5623363D6000, 4096, read_headers, False)\n+\n+        old_loaded_modules = []\n+        new_loaded_modules = []\n+        for module, new in self.prog.loaded_modules():\n+            (new_loaded_modules if new else old_loaded_modules).append(module)\n+        new_found_modules = []\n+\n+        with self.subTest(module=\"main2\"):\n+            module = self.prog.main_module()\n+            self.assertIsNone(module.address_range)\n+            self.assertIsNone(module.build_id)\n+\n+        with self.subTest(module=\"crashme\"):\n+            module = self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+            )\n+            new_found_modules.append(module)\n+            self.assertIsNone(module.address_range)\n+            self.assertIsNone(module.build_id)\n+\n+        with self.subTest(module=\"libc\"):\n+            module = self.prog.shared_library_module(\"/lib64/libc.so.6\", 0x7F299F5E7960)\n+            new_found_modules.append(module)\n+            self.assertIsNone(module.address_range)\n+            self.assertIsNone(module.build_id)\n+\n+        with self.subTest(module=\"ld-linux\"):\n+            module = self.prog.shared_library_module(\n+                \"/lib64/ld-linux-x86-64.so.2\", 0x7F299F63DE68\n+            )\n+            new_found_modules.append(module)\n+            self.assertIsNone(module.address_range)\n+            self.assertIsNone(module.build_id)\n+\n+        self.assertCountEqual(old_loaded_modules, loaded_modules)\n+        self.assertCountEqual(new_loaded_modules, new_found_modules)\n+\n+\n+class TestLoadDebugInfo(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.set_core_dump(get_resource(\"crashme.core\"))\n+        self.prog.set_enabled_debug_info_finders([])\n+        self.finder = unittest.mock.Mock()\n+        self.prog.register_debug_info_finder(\"mock\", self.finder, enable_index=0)\n+\n+    def test_nothing(self):\n+        self.prog.load_debug_info(None, default=False, main=False)\n+        self.assertFalse(list(self.prog.modules()))\n+        self.finder.assert_not_called()\n+\n+    def test_empty_list(self):\n+        self.prog.load_debug_info([], default=False, main=False)\n+        self.assertFalse(list(self.prog.modules()))\n+        self.finder.assert_not_called()\n+\n+    def test_no_such_file(self):\n+        with tempfile.TemporaryDirectory() as tmp_dir:\n+            self.prog.load_debug_info([Path(tmp_dir) / \"file\"])\n+        self.assertFalse(list(self.prog.modules()))\n+        self.finder.assert_not_called()\n+\n+    def test_not_elf(self):\n+        with tempfile.NamedTemporaryFile() as f:\n+            f.write(b\"hello, world\\n\")\n+            f.flush()\n+            self.prog.load_debug_info([f.name])\n+        self.assertFalse(list(self.prog.modules()))\n+        self.finder.assert_not_called()\n+\n+    def test_no_build_id(self):\n+        with NamedTemporaryElfFile() as f:\n+            self.prog.load_debug_info([f.name])\n+        self.assertFalse(list(self.prog.modules()))\n+        self.finder.assert_not_called()\n+\n+    def test_only_main_path(self):\n+        crashme_path = get_resource(\"crashme\")\n+\n+        self.prog.load_debug_info([crashme_path])\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided path should be used for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        # Finders shouldn't be called.\n+        self.finder.assert_not_called()\n+\n+    def test_only_paths(self):\n+        crashme_path = get_resource(\"crashme\")\n+        crashme_so_path = get_resource(\"crashme.so\")\n+\n+        self.prog.load_debug_info([crashme_path, crashme_so_path])\n+\n+        modules = list(self.prog.modules())\n+        # All loaded modules should be created.\n+        self.assertEqual(len(modules), 5)\n+        # The provided files should be used for their respective modules.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        crashme_so_module = next(\n+            module for module in modules if module.name == \"/home/osandov/crashme.so\"\n+        )\n+        self.assertEqual(\n+            crashme_so_module.loaded_file_path,\n+            str(crashme_so_path),\n+        )\n+        self.assertEqual(\n+            crashme_so_module.debug_file_path,\n+            str(crashme_so_path),\n+        )\n+        # The rest should not have a file.\n+        for module in modules:\n+            if module.name not in (\"/home/osandov/crashme\", \"/home/osandov/crashme.so\"):\n+                self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+                self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        # Finders shouldn't be called.\n+        self.finder.assert_not_called()\n+\n+    def test_main_by_path(self):\n+        crashme_path = get_resource(\"crashme\")\n+\n+        self.prog.load_debug_info([crashme_path], main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided path should be used for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        # Finders shouldn't be called.\n+        self.finder.assert_not_called()\n+\n+    def test_main_by_finder(self):\n+        crashme_path = get_resource(\"crashme\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    module.try_file(crashme_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info(main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and set the file for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_default_by_paths(self):\n+        crashme_path = get_resource(\"crashme\")\n+        crashme_so_path = get_resource(\"crashme.so\")\n+\n+        self.assertRaises(\n+            MissingDebugInfoError,\n+            self.prog.load_debug_info,\n+            [crashme_path, crashme_so_path],\n+            default=True,\n+        )\n+\n+        # All loaded modules should be created.\n+        modules = list(self.prog.modules())\n+        self.assertEqual(len(modules), 5)\n+        # The provided files should be used for their respective modules.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        crashme_so_module = next(\n+            module for module in modules if module.name == \"/home/osandov/crashme.so\"\n+        )\n+        self.assertEqual(\n+            crashme_so_module.loaded_file_path,\n+            str(crashme_so_path),\n+        )\n+        self.assertEqual(\n+            crashme_so_module.debug_file_path,\n+            str(crashme_so_path),\n+        )\n+        # The rest should not have a file.\n+        missing_modules = []\n+        for module in modules:\n+            if module.name not in (\"/home/osandov/crashme\", \"/home/osandov/crashme.so\"):\n+                self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+                self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+                missing_modules.append(module)\n+        self.assertEqual(len(missing_modules), 3)\n+        # The finder should be called for the rest.\n+        self.finder.assert_called_once()\n+        self.assertCountEqual(self.finder.call_args[0][0], missing_modules)\n+\n+    def test_default_by_finder(self):\n+        crashme_path = get_resource(\"crashme\")\n+        crashme_so_path = get_resource(\"crashme.so\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    module.try_file(crashme_path)\n+                elif module.name == \"/home/osandov/crashme.so\":\n+                    module.try_file(crashme_so_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.assertRaises(\n+            MissingDebugInfoError, self.prog.load_debug_info, default=True\n+        )\n+\n+        # All loaded modules should be created.\n+        modules = list(self.prog.modules())\n+        self.assertEqual(len(modules), 5)\n+        # The finder should be called and set the files for the matching\n+        # modules.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_path),\n+        )\n+        crashme_so_module = next(\n+            module for module in modules if module.name == \"/home/osandov/crashme.so\"\n+        )\n+        self.assertEqual(\n+            crashme_so_module.loaded_file_path,\n+            str(crashme_so_path),\n+        )\n+        self.assertEqual(\n+            crashme_so_module.debug_file_path,\n+            str(crashme_so_path),\n+        )\n+        # The rest should not have a file.\n+        for module in modules:\n+            if module.name not in (\"/home/osandov/crashme\", \"/home/osandov/crashme.so\"):\n+                self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+                self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        # The finder should be called for all loaded modules.\n+        self.finder.assert_called_once()\n+        self.assertCountEqual(self.finder.call_args[0][0], modules)\n+\n+    def test_main_gnu_debugaltlink_by_path(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        self.prog.load_debug_info([crashme_dwz_path, crashme_alt_path], main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided paths should be used for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        # Finders shouldn't be called.\n+        self.finder.assert_not_called()\n+\n+    def test_main_gnu_debugaltlink_by_finder(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    module.try_file(crashme_dwz_path)\n+                    module.try_file(crashme_alt_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info(main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and set the files for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_by_path_gnu_debugaltlink_not_found(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    self.assertEqual(\n+                        module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+                    )\n+\n+        self.finder.side_effect = finder\n+\n+        self.assertRaises(\n+            MissingDebugInfoError,\n+            self.prog.load_debug_info,\n+            [crashme_dwz_path],\n+            main=True,\n+        )\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided path should be used for the loaded file.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        # The finder should be called and fail to find the supplementary file\n+        # for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().wanted_supplementary_debug_file()[:3],\n+            (\n+                SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                str(crashme_dwz_path),\n+                \"crashme.alt\",\n+            ),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_by_finder_gnu_debugaltlink_not_found(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+                    module.try_file(crashme_dwz_path)\n+                    self.assertEqual(\n+                        module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+                    )\n+\n+        self.finder.side_effect = finder\n+\n+        self.assertRaises(MissingDebugInfoError, self.prog.load_debug_info, main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and set the loaded file for the main\n+        # module but fail to find the supplementary file.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().wanted_supplementary_debug_file()[:3],\n+            (\n+                SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                str(crashme_dwz_path),\n+                \"crashme.alt\",\n+            ),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_by_path_gnu_debugaltlink_by_finder(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if (\n+                    module.name == \"/home/osandov/crashme\"\n+                    and module.debug_file_status == ModuleFileStatus.WANT_SUPPLEMENTARY\n+                ):\n+                    module.try_file(crashme_alt_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info([crashme_dwz_path], main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided path should be used for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        # The finder should be called and set the supplementary file for the\n+        # main module.\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_by_finder_gnu_debugaltlink_by_path(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme\":\n+                    module.try_file(crashme_dwz_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info([crashme_alt_path], main=True)\n+\n+        # The provided path should be used for the supplementary file for the\n+        # main module.\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        # The finder should be called and set the file for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_wants_gnu_debugaltlink_by_path(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.try_file(crashme_dwz_path)\n+                break\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+\n+        self.prog.load_debug_info([crashme_alt_path], main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The provided path should be used for the supplementary file.\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        # Finders shouldn't be called.\n+        self.finder.assert_not_called()\n+\n+    def test_main_wants_gnu_debugaltlink_by_finder(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.try_file(crashme_dwz_path)\n+                break\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+\n+        def finder(modules):\n+            for module in modules:\n+                if (\n+                    module.name == \"/home/osandov/crashme\"\n+                    and module.debug_file_status == ModuleFileStatus.WANT_SUPPLEMENTARY\n+                ):\n+                    module.try_file(crashme_alt_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info(main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and set the supplementary file for the\n+        # main module.\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_main_wants_gnu_debugaltlink_not_found(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.try_file(crashme_dwz_path)\n+                break\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+\n+        self.assertRaises(MissingDebugInfoError, self.prog.load_debug_info, main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and fail to find the supplementary file\n+        # for the main module, but the supplementary file should still be\n+        # wanted.\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_status,\n+            ModuleFileStatus.WANT_SUPPLEMENTARY,\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_default_gnu_debugaltlink_by_paths(self):\n+        crashme_dwz_path = get_resource(\"crashme.dwz\")\n+        crashme_so_dwz_path = get_resource(\"crashme.so.dwz\")\n+        crashme_alt_path = get_resource(\"crashme.alt\")\n+\n+        self.assertRaises(\n+            MissingDebugInfoError,\n+            self.prog.load_debug_info,\n+            [crashme_dwz_path, crashme_so_dwz_path, crashme_alt_path],\n+            default=True,\n+        )\n+\n+        # All loaded modules should be created.\n+        modules = list(self.prog.modules())\n+        self.assertEqual(len(modules), 5)\n+        # The provided files should be used for their respective modules.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_dwz_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        crashme_so_module = next(\n+            module for module in modules if module.name == \"/home/osandov/crashme.so\"\n+        )\n+        self.assertEqual(\n+            crashme_so_module.loaded_file_path,\n+            str(crashme_so_dwz_path),\n+        )\n+        self.assertEqual(\n+            crashme_so_module.debug_file_path,\n+            str(crashme_so_dwz_path),\n+        )\n+        self.assertEqual(\n+            crashme_so_module.supplementary_debug_file_path,\n+            str(crashme_alt_path),\n+        )\n+        # The rest should not have a file.\n+        missing_modules = []\n+        for module in modules:\n+            if module.name not in (\"/home/osandov/crashme\", \"/home/osandov/crashme.so\"):\n+                self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+                self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+                missing_modules.append(module)\n+        self.assertEqual(len(missing_modules), 3)\n+        # The finder should be called for the rest.\n+        self.finder.assert_called_once()\n+        self.assertCountEqual(self.finder.call_args[0][0], missing_modules)\n+\n+    def test_dont_want(self):\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+                module.debug_file_status = ModuleFileStatus.DONT_WANT\n+                break\n+        # DONT_WANT should be reset to WANT.\n+        self.assertRaises(MissingDebugInfoError, self.prog.load_debug_info, main=True)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    def test_dont_need(self):\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                module.loaded_file_status = ModuleFileStatus.DONT_NEED\n+                module.debug_file_status = ModuleFileStatus.DONT_NEED\n+                break\n+        # DONT_NEED should be preserved.\n+        self.prog.load_debug_info(main=True)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_NEED)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_NEED)\n+        self.finder.assert_not_called()\n+\n+    def test_unmatched(self):\n+        self.prog.load_debug_info([get_resource(\"crashme_static\")])\n+        modules = list(self.prog.modules())\n+        # All loaded modules should be created.\n+        self.assertEqual(len(modules), 5)\n+        # None of them should have files.\n+        for module in modules:\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.finder.assert_not_called()\n+\n+\n+class TestLoadDebugInfoCoreNoHeaders(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.set_core_dump(get_resource(\"crashme_pie_no_headers.core\"))\n+        self.prog.set_enabled_debug_info_finders([])\n+        self.finder = unittest.mock.Mock()\n+        self.prog.register_debug_info_finder(\"mock\", self.finder, enable_index=0)\n+\n+    def test_main_by_finder(self):\n+        crashme_pie_path = get_resource(\"crashme_pie\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme_pie\":\n+                    module.try_file(crashme_pie_path)\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info(main=True)\n+\n+        # Only the main module should be created.\n+        self.assertEqual(list(self.prog.modules()), [self.prog.main_module()])\n+        # The finder should be called and set the files, address range, and\n+        # build ID for the main module.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_pie_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_pie_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().address_range, (0x5623363D6000, 0x5623363DA018)\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().build_id.hex(),\n+            \"eb4ad7aaded3815ab133a6d7784a2c95a4e52998\",\n+        )\n+        self.finder.assert_called_once_with([self.prog.main_module()])\n+\n+    @unittest.expectedFailure  # Issue #291\n+    def test_default_by_finder(self):\n+        crashme_pie_path = get_resource(\"crashme_pie\")\n+        crashme_so_path = get_resource(\"crashme.so\")\n+\n+        def finder(modules):\n+            for module in modules:\n+                if module.name == \"/home/osandov/crashme_pie\":\n+                    module.try_file(crashme_pie_path)\n+                elif module.name == \"/home/osandov/crashme.so\":\n+                    module.try_file(crashme_so_path)\n+                else:\n+                    module.loaded_file_status = ModuleFileStatus.DONT_NEED\n+                    module.debug_file_status = ModuleFileStatus.DONT_NEED\n+\n+        self.finder.side_effect = finder\n+\n+        self.prog.load_debug_info(default=True)\n+\n+        # All loaded modules should be created (except ld-linux.so; see\n+        # tests.test_module.TestLinuxUserspaceCoreDump.test_loaded_modules_pie_no_headers).\n+        self.assertCountEqual(\n+            list(self.prog.modules()),\n+            [\n+                self.prog.main_module(),\n+                self.prog.vdso_module(\"linux-vdso.so.1\", 0x7F299F607438),\n+                self.prog.shared_library_module(\n+                    \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+                ),\n+                self.prog.shared_library_module(\"/lib64/libc.so.6\", 0x7F299F5E7960),\n+                self.prog.shared_library_module(\n+                    \"/lib64/ld-linux-x86-64.so.2\", 0x7F299F63DE68\n+                ),\n+            ],\n+        )\n+        # The finder should be called and set the files, address range, and\n+        # build ID for the main and crashme.so modules.\n+        self.assertEqual(\n+            self.prog.main_module().loaded_file_path,\n+            str(crashme_pie_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().debug_file_path,\n+            str(crashme_pie_path),\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().address_range, (0x5623363D6000, 0x5623363DA018)\n+        )\n+        self.assertEqual(\n+            self.prog.main_module().build_id.hex(),\n+            \"eb4ad7aaded3815ab133a6d7784a2c95a4e52998\",\n+        )\n+        self.assertEqual(\n+            self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+            ).loaded_file_path,\n+            str(crashme_so_path),\n+        )\n+        self.assertEqual(\n+            self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+            ).debug_file_path,\n+            str(crashme_so_path),\n+        )\n+        self.assertEqual(\n+            self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+            ).address_range,\n+            (0x7F299F5FC000, 0x7F299F600010),\n+        )\n+        self.assertEqual(\n+            self.prog.shared_library_module(\n+                \"/home/osandov/crashme.so\", 0x7F299F5FFE08\n+            ).build_id.hex(),\n+            \"7bd58f10e741c3c8fbcf2031aa65f830f933d616\",\n+        )\n+        self.finder.assert_called()\n+\n+\n+class TestLoadModuleDebugInfo(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.set_enabled_debug_info_finders([])\n+        self.finder = unittest.mock.Mock()\n+        self.prog.register_debug_info_finder(\"mock\", self.finder, enable_index=0)\n+\n+    def test_empty(self):\n+        self.prog.load_module_debug_info()\n+        self.finder.assert_not_called()\n+\n+    def test_multiple(self):\n+        self.prog.load_module_debug_info(\n+            self.prog.extra_module(\"/foo/bar\", create=True)[0],\n+            self.prog.extra_module(\"/foo/baz\", create=True)[0],\n+        )\n+        self.finder.assert_called_once()\n+        self.assertCountEqual(\n+            self.finder.call_args[0][0],\n+            [\n+                self.prog.extra_module(\"/foo/bar\"),\n+                self.prog.extra_module(\"/foo/baz\"),\n+            ],\n+        )\n+\n+    def test_wrong_program(self):\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"module from wrong program\",\n+            self.prog.load_module_debug_info,\n+            self.prog.extra_module(\"/foo/bar\", create=True)[0],\n+            Program().extra_module(\"/foo/baz\", create=True)[0],\n+        )\n+\n+    def test_type_error(self):\n+        self.assertRaises(\n+            TypeError,\n+            self.prog.load_module_debug_info,\n+            self.prog.extra_module(\"/foo/bar\", create=True)[0],\n+            None,\n+        )\n+\n+\n+class TestStandardDebugInfoFinder(TestCase):\n+    def setUp(self):\n+        self.prog = Program()\n+        self.prog.debug_info_path = None\n+        self.prog.set_enabled_debug_info_finders([\"standard\"])\n+\n+    def test_by_module_name(self):\n+        with NamedTemporaryElfFile() as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_by_module_name_with_build_id(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile(build_id=build_id) as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_by_module_name_missing_build_id(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile() as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_by_module_name_build_id_mismatch(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile(build_id=build_id[::-1]) as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_reuse_loaded_file(self):\n+        with NamedTemporaryElfFile() as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.debug_file_status = ModuleFileStatus.DONT_WANT\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.DONT_WANT)\n+\n+        module.debug_file_status = ModuleFileStatus.WANT\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_reuse_debug_file(self):\n+        with NamedTemporaryElfFile() as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+        module.loaded_file_status = ModuleFileStatus.WANT\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.debug_file_path, f.name)\n+\n+    def test_reuse_wanted_supplementary_debug_file(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with NamedTemporaryElfFile(\n+            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+        ) as f:\n+            module = self.prog.extra_module(f.name, create=True)[0]\n+            module.loaded_file_status = ModuleFileStatus.DONT_WANT\n+            self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.DONT_WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY)\n+\n+        module.loaded_file_status = ModuleFileStatus.WANT\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, f.name)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY)\n+\n+    def test_vdso_in_core(self):\n+        self.prog.set_core_dump(get_resource(\"crashme.core\"))\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, VdsoModule):\n+                break\n+        else:\n+            self.fail(\"vDSO module not found\")\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, \"[vdso]\")\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_main_by_proc(self):\n+        self.prog.set_pid(os.getpid())\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, MainModule):\n+                break\n+        else:\n+            self.fail(\"main module not found\")\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+\n+    def test_vdso_by_proc(self):\n+        self.prog.set_pid(os.getpid())\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, VdsoModule):\n+                break\n+        else:\n+            self.skipTest(\"vDSO module not found\")\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+        self.assertEqual(module.loaded_file_path, \"[vdso]\")\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_shared_library_by_proc(self):\n+        self.prog.set_pid(os.getpid())\n+        for module, _ in self.prog.loaded_modules():\n+            if isinstance(module, SharedLibraryModule):\n+                break\n+        else:\n+            self.skipTest(\"shared library module not found\")\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+\n+    def test_by_build_id(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n+            build_id_dir.mkdir(parents=True)\n+            binary_path = build_id_dir / build_id.hex()[2:]\n+            binary_path.write_bytes(compile_dwarf((), sections=(ALLOCATED_SECTION,)))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+\n+            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+\n+    def test_by_build_id_separate(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n+            build_id_dir.mkdir(parents=True)\n+            loadable_path = build_id_dir / build_id.hex()[2:]\n+            loadable_path.write_bytes(\n+                create_elf_file(ET.EXEC, sections=(ALLOCATED_SECTION,))\n+            )\n+            debug_path = build_id_dir / (build_id.hex()[2:] + \".debug\")\n+            debug_path.write_bytes(compile_dwarf(()))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.build_id = build_id\n+\n+            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+            self.assertEqual(module.debug_file_path, str(debug_path))\n+\n+    def test_by_build_id_from_loaded(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC, sections=(ALLOCATED_SECTION,), build_id=build_id\n+                )\n+            )\n+            build_id_dir = debug_dir / \".build-id\" / build_id.hex()[:2]\n+            build_id_dir.mkdir(parents=True)\n+            debug_path = build_id_dir / (build_id.hex()[2:] + \".debug\")\n+            debug_path.write_bytes(compile_dwarf(()))\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+\n+            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+            self.assertEqual(module.debug_file_path, str(debug_path))\n+\n+    def test_by_gnu_debuglink(self):\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            debug_file_contents = compile_dwarf(())\n+            crc = binascii.crc32(debug_file_contents)\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debuglink_section(\"binary.debug\", crc),\n+                    ),\n+                )\n+            )\n+\n+            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            for i, debug_path in enumerate(\n+                (\n+                    bin_dir / \"binary.debug\",\n+                    bin_dir / \".debug\" / \"binary.debug\",\n+                    debug_dir / bin_dir.relative_to(\"/\") / \"binary.debug\",\n+                )\n+            ):\n+                with self.subTest(debug_path=debug_path):\n+                    try:\n+                        debug_path.parent.mkdir(parents=True, exist_ok=True)\n+                        debug_path.write_bytes(debug_file_contents)\n+\n+                        module = self.prog.extra_module(\n+                            bin_dir / \"binary\", i, create=True\n+                        )[0]\n+\n+                        self.prog.load_module_debug_info(module)\n+                        self.assertEqual(\n+                            module.loaded_file_status, ModuleFileStatus.HAVE\n+                        )\n+                        self.assertEqual(\n+                            module.debug_file_status, ModuleFileStatus.HAVE\n+                        )\n+                        self.assertEqual(module.loaded_file_path, str(loadable_path))\n+                        self.assertEqual(module.debug_file_path, str(debug_path))\n+                    finally:\n+                        try:\n+                            debug_path.unlink()\n+                        except FileNotFoundError:\n+                            pass\n+\n+    def test_by_gnu_debuglink_absolute(self):\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            debug_file_contents = compile_dwarf(())\n+            crc = binascii.crc32(debug_file_contents)\n+            debug_path = debug_dir / \"binary.debug\"\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debuglink_section(debug_path, crc),\n+                    ),\n+                )\n+            )\n+\n+            debug_path.parent.mkdir(parents=True, exist_ok=True)\n+            debug_path.write_bytes(debug_file_contents)\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+            self.assertEqual(module.debug_file_path, str(debug_path))\n+\n+    def test_by_gnu_debuglink_crc_mismatch(self):\n+        with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+            bin_dir = Path(bin_dir)\n+\n+            debug_file_contents = compile_dwarf(())\n+            crc = binascii.crc32(debug_file_contents)\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debuglink_section(\"binary.debug\", crc ^ 1),\n+                    ),\n+                )\n+            )\n+\n+            debug_path = bin_dir / \"binary.debug\"\n+            debug_path.write_bytes(debug_file_contents)\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.debug_info_path = \"\"\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_invalid_gnu_debuglink(self):\n+        with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+            bin_dir = Path(bin_dir)\n+\n+            loadable_path = bin_dir / \"binary\"\n+            loadable_path.write_bytes(\n+                create_elf_file(\n+                    ET.EXEC,\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        ElfSection(\n+                            name=\".gnu_debuglink\", sh_type=SHT.PROGBITS, data=b\"foo\"\n+                        ),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+            self.assertEqual(module.loaded_file_path, str(loadable_path))\n+\n+    def test_gnu_debugaltlink_absolute(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(alt_path, alt_build_id),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+            self.assertEqual(module.supplementary_debug_file_path, str(alt_path))\n+\n+    def test_gnu_debugaltlink_not_found(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(debug_dir / \"alt.debug\", alt_build_id),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(debug_dir / \"alt.debug\"),\n+                    alt_build_id,\n+                ),\n+            )\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+\n+    def test_only_gnu_debugaltlink_absolute(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(alt_path, alt_build_id),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.try_file(binary_path)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+            self.assertEqual(module.supplementary_debug_file_path, str(alt_path))\n+\n+    def test_only_gnu_debugaltlink_not_found(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(debug_dir / \"alt.debug\", alt_build_id),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            module.try_file(binary_path)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(debug_dir / \"alt.debug\"),\n+                    alt_build_id,\n+                ),\n+            )\n+\n+    def test_gnu_debugaltlink_relative(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(\n+                            Path(os.path.relpath(alt_path, bin_dir)), alt_build_id\n+                        ),\n+                    ),\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+            self.assertEqual(module.debug_file_path, str(binary_path))\n+            self.assertEqual(module.supplementary_debug_file_path, str(alt_path))\n+\n+    def test_gnu_debugaltlink_debug_directories(self):\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \".dwz/alt.debug\"\n+            alt_path.parent.mkdir()\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id))\n+\n+            binary_path = bin_dir / \"binary\"\n+\n+            self.prog.debug_info_path = \":.debug:\" + str(debug_dir)\n+            for i, debugaltlink in enumerate(\n+                (\n+                    bin_dir / \"debug/.dwz/alt.debug\",\n+                    Path(\"debug/.dwz/alt.debug\"),\n+                )\n+            ):\n+                with self.subTest(debugaltlink=debugaltlink):\n+                    binary_path.write_bytes(\n+                        compile_dwarf(\n+                            (),\n+                            sections=(\n+                                ALLOCATED_SECTION,\n+                                gnu_debugaltlink_section(debugaltlink, alt_build_id),\n+                            ),\n+                        )\n+                    )\n+\n+                    module = self.prog.extra_module(bin_dir / \"binary\", i, create=True)[\n+                        0\n+                    ]\n+                    self.prog.load_module_debug_info(module)\n+                    self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+                    self.assertEqual(module.loaded_file_path, str(binary_path))\n+                    self.assertEqual(module.debug_file_path, str(binary_path))\n+                    self.assertEqual(\n+                        module.supplementary_debug_file_path, str(alt_path)\n+                    )\n+\n+    def test_gnu_debugaltlink_build_id_mismatch(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with tempfile.TemporaryDirectory(\n+            prefix=\"bin-\"\n+        ) as bin_dir, tempfile.TemporaryDirectory(prefix=\"debug-\") as debug_dir:\n+            bin_dir = Path(bin_dir)\n+            debug_dir = Path(debug_dir)\n+\n+            alt_path = debug_dir / \"alt.debug\"\n+            alt_path.write_bytes(compile_dwarf((), build_id=alt_build_id[::-1]))\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        gnu_debugaltlink_section(alt_path, alt_build_id),\n+                    ),\n+                    build_id=build_id,\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(binary_path),\n+                    str(alt_path),\n+                    alt_build_id,\n+                ),\n+            )\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+\n+    def test_invalid_gnu_debugaltlink(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with tempfile.TemporaryDirectory(prefix=\"bin-\") as bin_dir:\n+            bin_dir = Path(bin_dir)\n+\n+            binary_path = bin_dir / \"binary\"\n+            binary_path.write_bytes(\n+                compile_dwarf(\n+                    (),\n+                    sections=(\n+                        ALLOCATED_SECTION,\n+                        ElfSection(\n+                            name=\".gnu_debugaltlink\",\n+                            sh_type=SHT.PROGBITS,\n+                            data=b\"foo\",\n+                        ),\n+                    ),\n+                    build_id=build_id,\n+                )\n+            )\n+\n+            module = self.prog.extra_module(bin_dir / \"binary\", create=True)[0]\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+            self.assertEqual(module.loaded_file_path, str(binary_path))\n+\n+\n+class _DebuginfodHTTPHandler(http.server.BaseHTTPRequestHandler):\n+    def do_GET(self):\n+        match = re.fullmatch(\n+            r\"/buildid/((?:[0-9a-fA-F][0-9a-fA-F])+)/(executable|debuginfo)\", self.path\n+        )\n+        if not match:\n+            self.send_error(http.HTTPStatus.BAD_REQUEST)\n+            return\n+\n+        build_id = bytes.fromhex(match.group(1))\n+        type = match.group(2)\n+\n+        try:\n+            file_path = self.server.build_ids[build_id][type]\n+        except KeyError:\n+            self.send_error(http.HTTPStatus.NOT_FOUND)\n+            return\n+\n+        try:\n+            f = open(file_path, \"rb\")\n+        except OSError:\n+            self.send_error(http.HTTPStatus.INTERNAL_SERVER_ERROR)\n+            return\n+\n+        with f:\n+            self.send_response(http.HTTPStatus.OK)\n+            st = os.fstat(f.fileno())\n+            self.send_header(\"Content-Type\", \"application/octet-stream\")\n+            self.send_header(\"Content-Length\", str(st.st_size))\n+            self.send_header(\"X-Debuginfod-Size\", str(st.st_size))\n+            self.send_header(\"Last-Modified\", self.date_time_string(st.st_mtime))\n+            self.end_headers()\n+            shutil.copyfileobj(f, self.wfile)\n+\n+\n+class TestDebuginfodDebugInfoFinder(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        cls.server = socketserver.TCPServer((\"localhost\", 0), _DebuginfodHTTPHandler)\n+        cls.server.build_ids = {}\n+        cls.server_thread = threading.Thread(\n+            target=cls.server.serve_forever, daemon=True\n+        )\n+        cls.server_thread.start()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        # By default, serve_forever() only checks if it should shut down every\n+        # 0.5 seconds. Shutting down the socket makes it check immediately.\n+        cls.server.socket.shutdown(socket.SHUT_RD)\n+        cls.server.shutdown()\n+        cls.server_thread.join()\n+\n+    def setUp(self):\n+        self.prog = Program()\n+        try:\n+            self.prog.set_enabled_debug_info_finders([\"debuginfod\"])\n+        except ValueError:\n+            self.skipTest(\"no debuginfod support\")\n+\n+        self.server.build_ids.clear()\n+        self.cache_dir = Path(\n+            self.enterContext(tempfile.TemporaryDirectory(prefix=\"debuginfod-cache-\"))\n+        )\n+        self.enterContext(\n+            modifyenv(\n+                {\n+                    \"DEBUGINFOD_URLS\": \"http://{}:{}/\".format(\n+                        *self.server.server_address\n+                    ),\n+                    \"DEBUGINFOD_CACHE_PATH\": str(self.cache_dir),\n+                }\n+            )\n+        )\n+\n+    def test_no_build_id(self):\n+        module = self.prog.extra_module(\"foo\", create=True)[0]\n+        self.prog.load_module_debug_info(module)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_separate(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile(\n+            loadable=True, debug=False, build_id=build_id\n+        ) as loadable_file, NamedTemporaryElfFile(\n+            loadable=False, debug=True, build_id=build_id\n+        ) as debug_file:\n+            self.server.build_ids[build_id] = {\n+                \"executable\": loadable_file.name,\n+                \"debuginfo\": debug_file.name,\n+            }\n+\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.loaded_file_path,\n+                str(self.cache_dir / build_id.hex() / \"executable\"),\n+            )\n+            self.assertEqual(\n+                module.debug_file_path,\n+                str(self.cache_dir / build_id.hex() / \"debuginfo\"),\n+            )\n+\n+    def test_no_servers(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile(\n+            loadable=True, debug=False, build_id=build_id\n+        ) as loadable_file, NamedTemporaryElfFile(\n+            loadable=False, debug=True, build_id=build_id\n+        ) as debug_file, modifyenv(\n+            {\"DEBUGINFOD_URLS\": None}\n+        ):\n+            self.server.build_ids[build_id] = {\n+                \"executable\": loadable_file.name,\n+                \"debuginfo\": debug_file.name,\n+            }\n+\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+\n+    def test_cache_hit(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+\n+        with NamedTemporaryElfFile(\n+            loadable=False, debug=True, build_id=build_id\n+        ) as debug_file:\n+            self.server.build_ids[build_id] = {\"debuginfo\": debug_file.name}\n+\n+            for i in range(2):\n+                module = self.prog.extra_module(\"foo\", i, create=True)[0]\n+                module.build_id = build_id\n+                self.prog.load_module_debug_info(module)\n+                self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+                self.assertEqual(\n+                    module.debug_file_path,\n+                    str(self.cache_dir / build_id.hex() / \"debuginfo\"),\n+                )\n+\n+    def test_gnu_debugaltlink(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with NamedTemporaryElfFile(\n+            loadable=True, debug=False, build_id=build_id\n+        ) as loadable_file, NamedTemporaryElfFile(\n+            loadable=False,\n+            debug=True,\n+            build_id=build_id,\n+            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+        ) as debug_file, NamedTemporaryElfFile(\n+            loadable=False, debug=True, build_id=alt_build_id\n+        ) as alt_f:\n+            self.server.build_ids[build_id] = {\n+                \"executable\": loadable_file.name,\n+                \"debuginfo\": debug_file.name,\n+            }\n+            self.server.build_ids[alt_build_id] = {\"debuginfo\": alt_f.name}\n+\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.loaded_file_path,\n+                str(self.cache_dir / build_id.hex() / \"executable\"),\n+            )\n+            self.assertEqual(\n+                module.debug_file_path,\n+                str(self.cache_dir / build_id.hex() / \"debuginfo\"),\n+            )\n+            self.assertEqual(\n+                module.supplementary_debug_file_path,\n+                str(self.cache_dir / alt_build_id.hex() / \"debuginfo\"),\n+            )\n+\n+    def test_gnu_debugaltlink_not_found(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with NamedTemporaryElfFile(\n+            loadable=True, debug=False, build_id=build_id\n+        ) as loadable_file, NamedTemporaryElfFile(\n+            loadable=False,\n+            debug=True,\n+            build_id=build_id,\n+            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+        ) as debug_file:\n+            self.server.build_ids[build_id] = {\n+                \"executable\": loadable_file.name,\n+                \"debuginfo\": debug_file.name,\n+            }\n+\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.build_id = build_id\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    str(self.cache_dir / build_id.hex() / \"debuginfo\"),\n+                    \"alt.debug\",\n+                    alt_build_id,\n+                ),\n+            )\n+            self.assertEqual(\n+                module.loaded_file_path,\n+                str(self.cache_dir / build_id.hex() / \"executable\"),\n+            )\n+\n+    def test_only_gnu_debugaltlink(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with NamedTemporaryElfFile(\n+            build_id=build_id,\n+            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+        ) as f, NamedTemporaryElfFile(\n+            loadable=False, debug=True, build_id=alt_build_id\n+        ) as alt_f:\n+            self.server.build_ids[alt_build_id] = {\"debuginfo\": alt_f.name}\n+\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.try_file(f.name)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(module.loaded_file_path, f.name)\n+\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(module.debug_file_path, f.name)\n+            self.assertEqual(\n+                module.supplementary_debug_file_path,\n+                str(self.cache_dir / alt_build_id.hex() / \"debuginfo\"),\n+            )\n+\n+    def test_only_gnu_debugaltlink_not_found(self):\n+        build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        alt_build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+\n+        with NamedTemporaryElfFile(\n+            build_id=build_id,\n+            sections=(gnu_debugaltlink_section(\"alt.debug\", alt_build_id),),\n+        ) as f:\n+            module = self.prog.extra_module(\"foo\", create=True)[0]\n+            module.try_file(f.name)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\n+            self.assertEqual(\n+                module.wanted_supplementary_debug_file(),\n+                (\n+                    SupplementaryFileKind.GNU_DEBUGALTLINK,\n+                    f.name,\n+                    \"alt.debug\",\n+                    alt_build_id,\n+                ),\n+            )\n+            self.assertEqual(module.loaded_file_path, f.name)\n+\n+            self.prog.load_module_debug_info(module)\n+            self.assertEqual(module.loaded_file_status, ModuleFileStatus.HAVE)\n+            self.assertEqual(\n+                module.debug_file_status, ModuleFileStatus.WANT_SUPPLEMENTARY\n+            )\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 7658cd67..f2f0e718 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -202,12 +202,16 @@ labeled_unsigned_int_die = (DwarfLabel(\"unsigned_int_die\"), unsigned_int_die)\n labeled_float_die = (DwarfLabel(\"float_die\"), float_die)\n \n \n+def add_extra_dwarf(prog, path):\n+    prog.extra_module(path, create=True)[0].try_file(path, force=True)\n+\n+\n def dwarf_program(*args, segments=None, **kwds):\n     prog = Program()\n     with tempfile.NamedTemporaryFile() as f:\n         f.write(compile_dwarf(*args, **kwds))\n         f.flush()\n-        prog.load_debug_info([f.name])\n+        add_extra_dwarf(prog, f.name)\n \n     if segments is not None:\n         add_mock_memory_segments(prog, segments)\n@@ -6909,7 +6913,7 @@ class TestSplitDwarf(TestCase):\n                         )\n                     )\n                 )\n-            prog.load_debug_info([f.name])\n+            add_extra_dwarf(prog, f.name)\n             self.assertIdentical(prog.type(\"TEST\").type, prog.int_type(\"int\", 4, True))\n \n     def test_dwo4_not_found(self):\n@@ -6937,7 +6941,12 @@ class TestSplitDwarf(TestCase):\n                     )\n                 )\n             with self.assertLogs(logging.getLogger(\"drgn\"), \"WARNING\") as log:\n-                prog.load_debug_info([f.name])\n+                add_extra_dwarf(prog, f.name)\n+                # Force debug info to be indexed.\n+                try:\n+                    prog[\"foo\"]\n+                except KeyError:\n+                    pass\n             self.assertTrue(\n                 any(\n                     \"split DWARF file split.dwo not found\" in output\n@@ -6989,7 +6998,12 @@ class TestSplitDwarf(TestCase):\n                     )\n                 )\n             with self.assertLogs(logging.getLogger(\"drgn\"), \"WARNING\") as log:\n-                prog.load_debug_info([f.name])\n+                add_extra_dwarf(prog, f.name)\n+                # Force debug info to be indexed.\n+                try:\n+                    prog[\"foo\"]\n+                except KeyError:\n+                    pass\n             self.assertTrue(\n                 any(\n                     \"split DWARF file split.dwo not found\" in output\n@@ -7034,7 +7048,7 @@ class TestSplitDwarf(TestCase):\n                         version=5,\n                     )\n                 )\n-            prog.load_debug_info([f.name])\n+            add_extra_dwarf(prog, f.name)\n             self.assertIdentical(prog.type(\"TEST\").type, prog.int_type(\"int\", 4, True))\n \n     def test_dwo5_not_found(self):\n@@ -7059,7 +7073,12 @@ class TestSplitDwarf(TestCase):\n                     )\n                 )\n             with self.assertLogs(logging.getLogger(\"drgn\"), \"WARNING\") as log:\n-                prog.load_debug_info([f.name])\n+                add_extra_dwarf(prog, f.name)\n+                # Force debug info to be indexed.\n+                try:\n+                    prog[\"foo\"]\n+                except KeyError:\n+                    pass\n             self.assertTrue(\n                 any(\n                     \"split DWARF file split.dwo not found\" in output\n@@ -7105,7 +7124,12 @@ class TestSplitDwarf(TestCase):\n                     )\n                 )\n             with self.assertLogs(logging.getLogger(\"drgn\"), \"WARNING\") as log:\n-                prog.load_debug_info([f.name])\n+                add_extra_dwarf(prog, f.name)\n+                # Force debug info to be indexed.\n+                try:\n+                    prog[\"foo\"]\n+                except KeyError:\n+                    pass\n             self.assertTrue(\n                 any(\n                     \"split DWARF file split.dwo not found\" in output\ndiff --git a/tests/test_module.py b/tests/test_module.py\nnew file mode 100644\nindex 00000000..2ff5c1c8\n--- /dev/null\n+++ b/tests/test_module.py\n@@ -0,0 +1,489 @@\n+# Copyright (c) Meta Platforms, Inc. and affiliates.\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+from pathlib import Path\n+\n+from drgn import (\n+    ExtraModule,\n+    MainModule,\n+    ModuleFileStatus,\n+    Program,\n+    RelocatableModule,\n+    SharedLibraryModule,\n+    VdsoModule,\n+)\n+from tests import TestCase\n+\n+\n+class IntWrapper:\n+    def __init__(self, value):\n+        self._value = value\n+\n+    def __index__(self):\n+        return self._value\n+\n+\n+class TestModule(TestCase):\n+    def _test_module_init_common(self, module):\n+        self.assertIsNone(module.address_range)\n+        self.assertIsNone(module.build_id)\n+        self.assertEqual(module.loaded_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.loaded_file_path)\n+        self.assertIsNone(module.loaded_file_bias)\n+        self.assertEqual(module.debug_file_status, ModuleFileStatus.WANT)\n+        self.assertIsNone(module.debug_file_path)\n+        self.assertIsNone(module.debug_file_bias)\n+        self.assertIsNone(module.supplementary_debug_file_kind)\n+        self.assertIsNone(module.supplementary_debug_file_path)\n+\n+    def test_main_module(self):\n+        prog = Program()\n+\n+        self.assertRaises(LookupError, prog.main_module)\n+        self.assertRaises(LookupError, prog.main_module, \"/foo/bar\")\n+\n+        module, new = prog.main_module(\"/foo/bar\", create=True)\n+        self.assertIsInstance(module, MainModule)\n+        self.assertEqual(new, True)\n+\n+        self.assertEqual(prog.main_module(), module)\n+        self.assertEqual(prog.main_module(create=False), module)\n+        self.assertEqual(prog.main_module(\"/foo/bar\"), module)\n+        self.assertEqual(prog.main_module(b\"/foo/bar\"), module)\n+        self.assertEqual(prog.main_module(Path(\"/foo/bar\")), module)\n+        self.assertEqual(prog.main_module(\"/foo/bar\", create=True), (module, False))\n+\n+        self.assertRaises(LookupError, prog.main_module, \"/foo/baz\")\n+        self.assertRaises(LookupError, prog.main_module, \"/foo/baz\", create=True)\n+\n+        self.assertIs(module.prog, prog)\n+        self.assertEqual(module.name, \"/foo/bar\")\n+        self._test_module_init_common(module)\n+\n+    def test_main_module_invalid(self):\n+        prog = Program()\n+        self.assertRaises(TypeError, prog.main_module, None)\n+        self.assertRaises(TypeError, prog.main_module, create=True)\n+        self.assertRaises(TypeError, prog.main_module, \"/foo/bar\", True)\n+\n+    def test_shared_library_module(self):\n+        prog = Program()\n+\n+        self.assertRaises(\n+            LookupError, prog.shared_library_module, \"/foo/bar\", 0x10000000\n+        )\n+\n+        module, new = prog.shared_library_module(\"/foo/bar\", 0x10000000, create=True)\n+        self.assertIsInstance(module, SharedLibraryModule)\n+        self.assertEqual(new, True)\n+\n+        self.assertEqual(prog.shared_library_module(\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(prog.shared_library_module(b\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(\n+            prog.shared_library_module(Path(\"/foo/bar\"), IntWrapper(0x10000000)), module\n+        )\n+        self.assertEqual(\n+            prog.shared_library_module(\"/foo/bar\", 0x10000000, create=True),\n+            (module, False),\n+        )\n+\n+        self.assertRaises(\n+            LookupError, prog.shared_library_module, \"/foo/bar\", 0x20000000\n+        )\n+        self.assertRaises(\n+            LookupError, prog.shared_library_module, \"/foo/baz\", 0x10000000\n+        )\n+\n+        self.assertNotEqual(\n+            prog.shared_library_module(\"/foo/bar\", 0x20000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.shared_library_module(\"/foo/baz\", 0x10000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.vdso_module(\"/foo/bar\", 0x10000000, create=True)[0], module\n+        )\n+\n+        self.assertIs(module.prog, prog)\n+        self.assertEqual(module.name, \"/foo/bar\")\n+        self.assertEqual(module.dynamic_address, 0x10000000)\n+        self._test_module_init_common(module)\n+\n+    def test_shared_library_module_invalid(self):\n+        prog = Program()\n+        self.assertRaises(TypeError, prog.shared_library_module)\n+        self.assertRaises(TypeError, prog.shared_library_module, \"/foo/bar\")\n+        self.assertRaises(TypeError, prog.shared_library_module, \"/foo/bar\", None)\n+        self.assertRaises(TypeError, prog.shared_library_module, None, 0)\n+        self.assertRaises(\n+            TypeError, prog.shared_library_module, \"/foo/bar\", 0x10000000, True\n+        )\n+\n+    def test_vdso_module(self):\n+        prog = Program()\n+\n+        self.assertRaises(LookupError, prog.vdso_module, \"/foo/bar\", 0x10000000)\n+\n+        module, new = prog.vdso_module(\"/foo/bar\", 0x10000000, create=True)\n+        self.assertIsInstance(module, VdsoModule)\n+        self.assertEqual(new, True)\n+\n+        self.assertEqual(prog.vdso_module(\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(prog.vdso_module(b\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(\n+            prog.vdso_module(Path(\"/foo/bar\"), IntWrapper(0x10000000)), module\n+        )\n+        self.assertEqual(\n+            prog.vdso_module(\"/foo/bar\", 0x10000000, create=True), (module, False)\n+        )\n+\n+        self.assertRaises(LookupError, prog.vdso_module, \"/foo/bar\", 0x20000000)\n+        self.assertRaises(LookupError, prog.vdso_module, \"/foo/baz\", 0x10000000)\n+\n+        self.assertNotEqual(\n+            prog.vdso_module(\"/foo/bar\", 0x20000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.vdso_module(\"/foo/baz\", 0x10000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.shared_library_module(\"/foo/bar\", 0x10000000, create=True)[0], module\n+        )\n+\n+        self.assertIs(module.prog, prog)\n+        self.assertEqual(module.name, \"/foo/bar\")\n+        self.assertEqual(module.dynamic_address, 0x10000000)\n+        self._test_module_init_common(module)\n+\n+    def test_vdso_module_invalid(self):\n+        prog = Program()\n+        self.assertRaises(TypeError, prog.vdso_module)\n+        self.assertRaises(TypeError, prog.vdso_module, \"/foo/bar\")\n+        self.assertRaises(TypeError, prog.vdso_module, \"/foo/bar\", None)\n+        self.assertRaises(TypeError, prog.vdso_module, None, 0)\n+        self.assertRaises(TypeError, prog.vdso_module, \"/foo/bar\", 0x10000000, True)\n+\n+    def test_relocatable_module(self):\n+        prog = Program()\n+\n+        self.assertRaises(LookupError, prog.relocatable_module, \"/foo/bar\", 0x10000000)\n+\n+        module, new = prog.relocatable_module(\"/foo/bar\", 0x10000000, create=True)\n+        self.assertIsInstance(module, RelocatableModule)\n+        self.assertEqual(new, True)\n+\n+        self.assertEqual(prog.relocatable_module(\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(prog.relocatable_module(b\"/foo/bar\", 0x10000000), module)\n+        self.assertEqual(\n+            prog.relocatable_module(Path(\"/foo/bar\"), IntWrapper(0x10000000)), module\n+        )\n+        self.assertEqual(\n+            prog.relocatable_module(\"/foo/bar\", 0x10000000, create=True),\n+            (module, False),\n+        )\n+\n+        self.assertRaises(LookupError, prog.relocatable_module, \"/foo/bar\", 0x20000000)\n+        self.assertRaises(LookupError, prog.relocatable_module, \"/foo/baz\", 0x10000000)\n+\n+        self.assertNotEqual(\n+            prog.relocatable_module(\"/foo/bar\", 0x20000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.relocatable_module(\"/foo/baz\", 0x10000000, create=True)[0], module\n+        )\n+        self.assertNotEqual(\n+            prog.shared_library_module(\"/foo/bar\", 0x10000000, create=True)[0], module\n+        )\n+\n+        self.assertIs(module.prog, prog)\n+        self.assertEqual(module.name, \"/foo/bar\")\n+        self.assertEqual(module.address, 0x10000000)\n+        self._test_module_init_common(module)\n+\n+    def test_section_addresses(self):\n+        prog = Program()\n+        module = prog.relocatable_module(\"/foo/bar\", 0x10000000, create=True)[0]\n+\n+        self.assertNotIn(\".text\", module.section_addresses)\n+        self.assertNotIn(1, module.section_addresses)\n+\n+        with self.assertRaises(KeyError):\n+            module.section_addresses[\".text\"]\n+        with self.assertRaises(KeyError):\n+            module.section_addresses[1]\n+\n+        with self.assertRaises(KeyError):\n+            del module.section_addresses[\".text\"]\n+        with self.assertRaises(KeyError):\n+            del module.section_addresses[1]\n+\n+        module.section_addresses[\".text\"] = 0x10000000\n+        self.assertIn(\".text\", module.section_addresses)\n+        self.assertEqual(module.section_addresses[\".text\"], 0x10000000)\n+\n+        self.assertEqual(len(module.section_addresses), 1)\n+        self.assertCountEqual(list(module.section_addresses), [\".text\"])\n+        self.assertCountEqual(list(module.section_addresses.keys()), [\".text\"])\n+        self.assertCountEqual(list(module.section_addresses.values()), [0x10000000])\n+        self.assertCountEqual(\n+            list(module.section_addresses.items()), [(\".text\", 0x10000000)]\n+        )\n+\n+        module.section_addresses[\".data\"] = 0x10001000\n+\n+        self.assertEqual(len(module.section_addresses), 2)\n+        self.assertCountEqual(list(module.section_addresses), [\".text\", \".data\"])\n+        self.assertCountEqual(list(module.section_addresses.keys()), [\".text\", \".data\"])\n+        self.assertCountEqual(\n+            list(module.section_addresses.values()), [0x10000000, 0x10001000]\n+        )\n+        self.assertCountEqual(\n+            list(module.section_addresses.items()),\n+            [(\".text\", 0x10000000), (\".data\", 0x10001000)],\n+        )\n+\n+        del module.section_addresses[\".data\"]\n+\n+        self.assertEqual(len(module.section_addresses), 1)\n+        self.assertCountEqual(list(module.section_addresses), [\".text\"])\n+        self.assertCountEqual(list(module.section_addresses.keys()), [\".text\"])\n+        self.assertCountEqual(list(module.section_addresses.values()), [0x10000000])\n+        self.assertCountEqual(\n+            list(module.section_addresses.items()), [(\".text\", 0x10000000)]\n+        )\n+\n+    def test_relocatable_module_invalid(self):\n+        prog = Program()\n+        self.assertRaises(TypeError, prog.relocatable_module)\n+        self.assertRaises(TypeError, prog.relocatable_module, \"/foo/bar\")\n+        self.assertRaises(TypeError, prog.relocatable_module, \"/foo/bar\", None)\n+        self.assertRaises(TypeError, prog.relocatable_module, None, 0)\n+        self.assertRaises(\n+            TypeError, prog.relocatable_module, \"/foo/bar\", 0x10000000, True\n+        )\n+\n+    def test_extra_module(self):\n+        prog = Program()\n+\n+        self.assertRaises(LookupError, prog.extra_module, \"/foo/bar\", 1234)\n+\n+        module, new = prog.extra_module(\"/foo/bar\", 1234, create=True)\n+        self.assertIsInstance(module, ExtraModule)\n+        self.assertEqual(new, True)\n+\n+        self.assertEqual(prog.extra_module(\"/foo/bar\", 1234), module)\n+        self.assertEqual(prog.extra_module(b\"/foo/bar\", 1234), module)\n+        self.assertEqual(prog.extra_module(Path(\"/foo/bar\"), IntWrapper(1234)), module)\n+        self.assertEqual(\n+            prog.extra_module(\"/foo/bar\", 1234, create=True), (module, False)\n+        )\n+\n+        self.assertRaises(LookupError, prog.extra_module, \"/foo/bar\", 5678)\n+        self.assertRaises(LookupError, prog.extra_module, \"/foo/baz\", 1234)\n+\n+        self.assertNotEqual(prog.extra_module(\"/foo/bar\", 5678, create=True)[0], module)\n+        self.assertNotEqual(prog.extra_module(\"/foo/baz\", 1234, create=True)[0], module)\n+        self.assertNotEqual(\n+            prog.shared_library_module(\"/foo/bar\", 1234, create=True)[0], module\n+        )\n+        self.assertEqual(prog.extra_module(\"/foo/bar\", create=True)[0].id, 0)\n+\n+        self.assertIs(module.prog, prog)\n+        self.assertEqual(module.name, \"/foo/bar\")\n+        self.assertEqual(module.id, 1234)\n+        self._test_module_init_common(module)\n+\n+    def test_extra_module_invalid(self):\n+        prog = Program()\n+        self.assertRaises(TypeError, prog.extra_module)\n+        self.assertRaises(TypeError, prog.extra_module, \"/foo/bar\", None)\n+        self.assertRaises(TypeError, prog.extra_module, None, 0)\n+        self.assertRaises(TypeError, prog.extra_module, \"/foo/bar\", 1234, True)\n+\n+    def test_address_range(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        module.address_range = (0x10000000, 0x10010000)\n+        self.assertEqual(module.address_range, (0x10000000, 0x10010000))\n+\n+        module.address_range = (0x20000000, 0x20020000)\n+        self.assertEqual(module.address_range, (0x20000000, 0x20020000))\n+\n+        module.address_range = None\n+        self.assertIsNone(module.address_range)\n+\n+        module.address_range = None\n+        self.assertIsNone(module.address_range)\n+\n+    def test_address_range_empty(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        module.address_range = (0, 0)\n+        self.assertEqual(module.address_range, (0, 0))\n+\n+    def test_address_range_type_error(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        with self.assertRaises(TypeError):\n+            module.address_range = 1\n+\n+        with self.assertRaises(TypeError):\n+            module.address_range = (1,)\n+\n+        with self.assertRaises(TypeError):\n+            module.address_range = (\"foo\", 1)\n+\n+        with self.assertRaises(TypeError):\n+            module.address_range = (1, \"bar\")\n+\n+    def test_address_range_invalid(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        with self.assertRaisesRegex(ValueError, \"invalid module address range\"):\n+            module.address_range = (0x10010000, 0x10000000)\n+\n+        with self.assertRaisesRegex(ValueError, \"invalid module address range\"):\n+            module.address_range = (1, 1)\n+\n+        with self.assertRaisesRegex(ValueError, \"invalid module address range\"):\n+            module.address_range = (2**64 - 1, 1)\n+\n+        with self.assertRaisesRegex(ValueError, \"invalid module address range\"):\n+            module.address_range = (2**64 - 1, 2**64 - 1)\n+\n+    def test_build_id(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        module.build_id = b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\"\n+        self.assertEqual(module.build_id, b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\")\n+\n+        module.build_id = b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\"\n+        self.assertEqual(module.build_id, b\"\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10\")\n+\n+        module.build_id = None\n+        self.assertIsNone(module.build_id)\n+\n+        module.build_id = None\n+        self.assertIsNone(module.build_id)\n+\n+    def test_build_id_type_error(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+        with self.assertRaises(TypeError):\n+            module.build_id = \"abcd\"\n+\n+    def test_build_id_invalid_empty(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+        with self.assertRaisesRegex(ValueError, \"build ID cannot be empty\"):\n+            module.build_id = b\"\"\n+\n+    def test_find_by_address(self):\n+        prog = Program()\n+        module1 = prog.extra_module(\"/foo/bar\", create=True)[0]\n+        module1.address_range = (0x10000000, 0x10010000)\n+        module2 = prog.extra_module(\"/asdf/jkl\", create=True)[0]\n+        module2.address_range = (0x20000000, 0x20020000)\n+\n+        self.assertRaises(LookupError, prog.module, 0x0FFFFFFF)\n+        self.assertEqual(prog.module(0x10000000), module1)\n+        self.assertEqual(prog.module(0x10000001), module1)\n+        self.assertEqual(prog.module(0x1000FFFF), module1)\n+        self.assertRaises(LookupError, prog.module, 0x10010000)\n+\n+        self.assertRaises(LookupError, prog.module, 0x1FFFFFFF)\n+        self.assertEqual(prog.module(0x20000000), module2)\n+        self.assertEqual(prog.module(0x20000001), module2)\n+        self.assertEqual(prog.module(0x2001FFFF), module2)\n+        self.assertRaises(LookupError, prog.module, 0x20020000)\n+\n+    # Test all of the state transitions that we can without setting a file.\n+    def _test_file_status(self, which):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+\n+        status_attr = which + \"_file_status\"\n+        wants_file = getattr(module, f\"wants_{which}_file\")\n+\n+        self.assertRaises(TypeError, setattr, module, status_attr, 1)\n+\n+        setattr(module, status_attr, ModuleFileStatus.WANT)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.WANT)\n+        self.assertEqual(wants_file(), True)\n+        for status in set(ModuleFileStatus) - {\n+            ModuleFileStatus.WANT,\n+            ModuleFileStatus.DONT_WANT,\n+            ModuleFileStatus.DONT_NEED,\n+        }:\n+            with self.subTest(from_=ModuleFileStatus.WANT, to=status):\n+                self.assertRaises(ValueError, setattr, module, status_attr, status)\n+                self.assertEqual(getattr(module, status_attr), ModuleFileStatus.WANT)\n+\n+        setattr(module, status_attr, ModuleFileStatus.DONT_WANT)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.DONT_WANT)\n+        self.assertEqual(wants_file(), False)\n+        for status in set(ModuleFileStatus) - {\n+            ModuleFileStatus.WANT,\n+            ModuleFileStatus.DONT_WANT,\n+            ModuleFileStatus.DONT_NEED,\n+        }:\n+            with self.subTest(from_=ModuleFileStatus.DONT_WANT, to=status):\n+                self.assertRaises(ValueError, setattr, module, status_attr, status)\n+                self.assertEqual(\n+                    getattr(module, status_attr), ModuleFileStatus.DONT_WANT\n+                )\n+\n+        setattr(module, status_attr, ModuleFileStatus.DONT_NEED)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.DONT_NEED)\n+        self.assertEqual(wants_file(), False)\n+        for status in set(ModuleFileStatus) - {\n+            ModuleFileStatus.WANT,\n+            ModuleFileStatus.DONT_WANT,\n+            ModuleFileStatus.DONT_NEED,\n+        }:\n+            with self.subTest(from_=ModuleFileStatus.DONT_NEED, to=status):\n+                self.assertRaises(ValueError, setattr, module, status_attr, status)\n+                self.assertEqual(\n+                    getattr(module, status_attr), ModuleFileStatus.DONT_NEED\n+                )\n+\n+        setattr(module, status_attr, ModuleFileStatus.DONT_WANT)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.DONT_WANT)\n+\n+        setattr(module, status_attr, ModuleFileStatus.WANT)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.WANT)\n+\n+        setattr(module, status_attr, ModuleFileStatus.DONT_NEED)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.DONT_NEED)\n+\n+        setattr(module, status_attr, ModuleFileStatus.WANT)\n+        self.assertEqual(getattr(module, status_attr), ModuleFileStatus.WANT)\n+\n+    def test_loaded_file_status(self):\n+        self._test_file_status(\"loaded\")\n+\n+    def test_debug_file_status(self):\n+        self._test_file_status(\"debug\")\n+\n+\n+class TestCreatedModules(TestCase):\n+    def test_empty(self):\n+        self.assertEqual(list(Program().modules()), [])\n+\n+    def test_one(self):\n+        module = Program().extra_module(\"/foo/bar\", create=True)[0]\n+        self.assertEqual(list(module.prog.modules()), [module])\n+\n+    def test_multiple(self):\n+        prog = Program()\n+        modules = [\n+            prog.extra_module(\"/foo/bar\", create=True)[0],\n+            prog.extra_module(\"/asdf/jkl\", create=True)[0],\n+            prog.extra_module(\"/123/456\", create=True)[0],\n+        ]\n+        self.assertCountEqual(list(prog.modules()), modules)\n+\n+    def test_change_during_iteration(self):\n+        prog = Program()\n+        prog.extra_module(\"/foo/bar\", create=True)\n+        with self.assertRaisesRegex(Exception, \"modules changed during iteration\"):\n+            for module in prog.modules():\n+                prog.extra_module(\"/asdf/jkl\", create=True)\n+                prog.extra_module(\"/123/456\", create=True)\ndiff --git a/tests/test_symbol.py b/tests/test_symbol.py\nindex d9cc3dd9..91fac06a 100644\n--- a/tests/test_symbol.py\n+++ b/tests/test_symbol.py\n@@ -1,8 +1,10 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n+\n+import itertools\n import tempfile\n \n-from _drgn_util.elf import ET, PT, SHT, STB, STT\n+from _drgn_util.elf import ET, PT, SHF, SHT, STB, STT\n from drgn import Program, Symbol, SymbolBinding, SymbolIndex, SymbolKind\n from tests import TestCase\n from tests.dwarfwriter import dwarf_sections\n@@ -10,19 +12,20 @@ from tests.elfwriter import ElfSection, ElfSymbol, create_elf_file\n \n \n def create_elf_symbol_file(symbols):\n-    # We need some DWARF data so that libdwfl will load the file.\n     sections = dwarf_sections(())\n     # Create a section for the symbols to reference and the corresponding\n     # segment for address lookups.\n     min_address = min(symbol.value for symbol in symbols)\n     max_address = max(symbol.value + symbol.size for symbol in symbols)\n+    size = max(max_address - min_address, 4096)\n     sections.append(\n         ElfSection(\n             name=\".foo\",\n             sh_type=SHT.NOBITS,\n+            sh_flags=SHF.ALLOC,\n             p_type=PT.LOAD,\n             vaddr=min_address,\n-            memsz=max_address - min_address,\n+            memsz=size,\n         )\n     )\n     symbols = [\n@@ -31,16 +34,20 @@ def create_elf_symbol_file(symbols):\n         )\n         for symbol in symbols\n     ]\n-    return create_elf_file(ET.EXEC, sections, symbols)\n+    return create_elf_file(ET.EXEC, sections, symbols), min_address, min_address + size\n \n \n def elf_symbol_program(*modules):\n     prog = Program()\n     for symbols in modules:\n         with tempfile.NamedTemporaryFile() as f:\n-            f.write(create_elf_symbol_file(symbols))\n+            contents, start, end = create_elf_symbol_file(symbols)\n+            f.write(contents)\n             f.flush()\n-            prog.load_debug_info([f.name])\n+            module = prog.extra_module(f.name, create=True)[0]\n+            module.address_range = (start, end)\n+            module.try_file(f.name, force=True)\n+            print(module.loaded_file_path)\n     return prog\n \n \n@@ -78,59 +85,167 @@ class TestElfSymbol(TestCase):\n                 self.assert_symbols_equal_unordered(prog.symbols(0xFFFF000C), [second])\n                 self.assertRaises(LookupError, prog.symbol, 0xFFFF0010)\n \n-    def test_by_address_precedence(self):\n-        precedence = (STB.GLOBAL, STB.WEAK, STB.LOCAL)\n-        drgn_precedence = (\n-            SymbolBinding.GLOBAL,\n-            SymbolBinding.WEAK,\n-            SymbolBinding.LOCAL,\n+    def test_by_address_closest(self):\n+        # If two symbols contain the given address, then the one whose start\n+        # address is closest to the given address should be preferred\n+        # (regardless of the binding of either symbol).\n+        elf_closest = ElfSymbol(\"closest\", 0xFFFF0008, 0x8, STT.OBJECT, STB.WEAK)\n+        elf_furthest = ElfSymbol(\"furthest\", 0xFFFF0000, 0xC, STT.OBJECT, STB.GLOBAL)\n+        closest = Symbol(\n+            \"closest\", 0xFFFF0008, 0x8, SymbolBinding.WEAK, SymbolKind.OBJECT\n+        )\n+        furthest = Symbol(\n+            \"furthest\", 0xFFFF0000, 0xC, SymbolBinding.GLOBAL, SymbolKind.OBJECT\n         )\n \n-        def assert_find_higher(*modules):\n-            self.assertEqual(\n-                elf_symbol_program(*modules).symbol(0xFFFF0000).name, \"foo\"\n+        def test(elf_symbols):\n+            prog = elf_symbol_program(elf_symbols)\n+            self.assertEqual(prog.symbol(0xFFFF000B), closest)\n+            self.assert_symbols_equal_unordered(\n+                prog.symbols(0xFFFF000B), [closest, furthest]\n             )\n \n-        def assert_finds_both(symbols, *modules):\n+        with self.subTest(\"closest first\"):\n+            test([elf_closest, elf_furthest])\n+\n+        with self.subTest(\"furthest first\"):\n+            test([elf_furthest, elf_closest])\n+\n+    def test_by_address_closest_end(self):\n+        # If two symbols contain the given address and have the same start\n+        # address, then the one whose end address is closest to the given\n+        # address should be preferred (regardless of the binding of either\n+        # symbol).\n+        elf_closest = ElfSymbol(\"closest\", 0xFFFF0000, 0xC, STT.OBJECT, STB.WEAK)\n+        elf_furthest = ElfSymbol(\"furthest\", 0xFFFF0000, 0x10, STT.OBJECT, STB.GLOBAL)\n+        closest = Symbol(\n+            \"closest\", 0xFFFF0000, 0xC, SymbolBinding.WEAK, SymbolKind.OBJECT\n+        )\n+        furthest = Symbol(\n+            \"furthest\", 0xFFFF0000, 0x10, SymbolBinding.GLOBAL, SymbolKind.OBJECT\n+        )\n+\n+        def test(elf_symbols):\n+            prog = elf_symbol_program(elf_symbols)\n+            self.assertEqual(prog.symbol(0xFFFF000B), closest)\n             self.assert_symbols_equal_unordered(\n-                elf_symbol_program(*modules).symbols(0xFFFF0000),\n-                symbols,\n+                prog.symbols(0xFFFF000B), [closest, furthest]\n             )\n \n-        for i in range(len(precedence) - 1):\n-            higher_binding = precedence[i]\n-            higher_binding_drgn = drgn_precedence[i]\n-            for j in range(i + 1, len(precedence)):\n-                lower_binding = precedence[j]\n-                lower_binding_drgn = drgn_precedence[j]\n-                with self.subTest(higher=higher_binding, lower=lower_binding):\n-                    higher = ElfSymbol(\n-                        \"foo\", 0xFFFF0000, 0x8, STT.OBJECT, higher_binding\n-                    )\n-                    lower = ElfSymbol(\"bar\", 0xFFFF0000, 0x8, STT.OBJECT, lower_binding)\n-                    symbols = [\n-                        Symbol(\n-                            \"foo\",\n-                            0xFFFF0000,\n-                            0x8,\n-                            higher_binding_drgn,\n-                            SymbolKind.OBJECT,\n-                        ),\n-                        Symbol(\n-                            \"bar\",\n-                            0xFFFF0000,\n-                            0x8,\n-                            lower_binding_drgn,\n-                            SymbolKind.OBJECT,\n-                        ),\n-                    ]\n-                    # Local symbols must be before global symbols.\n-                    if lower_binding != STB.LOCAL:\n-                        with self.subTest(\"higher before lower\"):\n-                            assert_find_higher((higher, lower))\n-                    with self.subTest(\"lower before higher\"):\n-                        assert_find_higher((lower, higher))\n-                    assert_finds_both(symbols, (lower, higher))\n+        with self.subTest(\"closest first\"):\n+            test([elf_closest, elf_furthest])\n+\n+        with self.subTest(\"furthest first\"):\n+            test([elf_furthest, elf_closest])\n+\n+    def test_by_address_sizeless(self):\n+        label = ElfSymbol(\"label\", 0xFFFF0008, 0x0, STT.FUNC, STB.LOCAL)\n+        less = ElfSymbol(\"less\", 0xFFFF0000, 0x4, STT.FUNC, STB.LOCAL)\n+        greater = ElfSymbol(\"greater\", 0xFFFF0010, 0x4, STT.FUNC, STB.LOCAL)\n+\n+        expected = Symbol(\n+            \"label\", 0xFFFF0008, 0x0, SymbolBinding.LOCAL, SymbolKind.FUNC\n+        )\n+\n+        # Test every permutation of every combination of symbols that includes\n+        # \"label\".\n+        for elf_symbols in itertools.chain.from_iterable(\n+            itertools.permutations((label,) + extra_elf_symbols)\n+            for r in range(3)\n+            for extra_elf_symbols in itertools.combinations((less, greater), r)\n+        ):\n+            with self.subTest(elf_symbols=[sym.name for sym in elf_symbols]):\n+                prog = elf_symbol_program(elf_symbols)\n+                self.assertEqual(prog.symbol(0xFFFF0009), expected)\n+                self.assertEqual(prog.symbols(0xFFFF0009), [expected])\n+\n+    def test_by_address_sizeless_subsumed(self):\n+        import unittest.util\n+\n+        unittest.util._MAX_LENGTH = 999999999\n+        label = ElfSymbol(\"label\", 0xFFFF0008, 0x0, STT.FUNC, STB.LOCAL)\n+        subsume = ElfSymbol(\"subsume\", 0xFFFF0004, 0x8, STT.FUNC, STB.LOCAL)\n+        less = ElfSymbol(\"less\", 0xFFFF0000, 0x4, STT.FUNC, STB.LOCAL)\n+        greater = ElfSymbol(\"greater\", 0xFFFF0010, 0x4, STT.FUNC, STB.LOCAL)\n+\n+        expected = Symbol(\n+            \"subsume\", 0xFFFF0004, 0x8, SymbolBinding.LOCAL, SymbolKind.FUNC\n+        )\n+\n+        # Test every permutation of every combination of symbols that includes\n+        # \"label\" and \"subsume\".\n+        for elf_symbols in itertools.chain.from_iterable(\n+            itertools.permutations((label, subsume) + extra_elf_symbols)\n+            for r in range(3)\n+            for extra_elf_symbols in itertools.combinations((less, greater), r)\n+        ):\n+            with self.subTest(elf_symbols=[sym.name for sym in elf_symbols]):\n+                prog = elf_symbol_program(elf_symbols)\n+                self.assertEqual(prog.symbol(0xFFFF0009), expected)\n+                self.assertEqual(prog.symbols(0xFFFF0009), [expected])\n+\n+    def test_by_address_sizeless_wrong_section(self):\n+        prog = elf_symbol_program(\n+            (ElfSymbol(\"label\", 0xFFFF0008, 0x0, STT.FUNC, STB.LOCAL),)\n+        )\n+        for module in prog.modules():\n+            start, end = module.address_range\n+            module.address_range = (start, 0xFFFFFF00)\n+        self.assertRaises(LookupError, prog.symbol, 0xFFFFFE00)\n+\n+    def test_by_address_binding_precedence(self):\n+        precedence = (\n+            (STB.GLOBAL, STB.GNU_UNIQUE),\n+            (STB.WEAK,),\n+            (STB.LOCAL, STB.HIPROC),\n+        )\n+\n+        def assert_find_higher(*modules, both):\n+            prog = elf_symbol_program(*modules)\n+            self.assertEqual(prog.symbol(0xFFFF0000).name, \"foo\")\n+            # Test that symbols() finds both if expected or either one if not.\n+            if both:\n+                self.assertCountEqual(\n+                    [sym.name for sym in prog.symbols(0xFFFF0000)], [\"foo\", \"bar\"]\n+                )\n+            else:\n+                self.assertIn(\n+                    [sym.name for sym in prog.symbols(0xFFFF0000)], ([\"foo\"], [\"bar\"])\n+                )\n+\n+        for size in (8, 0):\n+            with self.subTest(size=size):\n+                for i in range(len(precedence) - 1):\n+                    for higher_binding in precedence[i]:\n+                        for j in range(i + 1, len(precedence)):\n+                            for lower_binding in precedence[j]:\n+                                with self.subTest(\n+                                    higher=higher_binding, lower=lower_binding\n+                                ):\n+                                    higher = ElfSymbol(\n+                                        \"foo\",\n+                                        0xFFFF0000,\n+                                        size,\n+                                        STT.OBJECT,\n+                                        higher_binding,\n+                                    )\n+                                    lower = ElfSymbol(\n+                                        \"bar\",\n+                                        0xFFFF0000,\n+                                        size,\n+                                        STT.OBJECT,\n+                                        lower_binding,\n+                                    )\n+                                    # Local symbols must be before global symbols.\n+                                    if lower_binding not in precedence[-1]:\n+                                        with self.subTest(\"higher before lower\"):\n+                                            assert_find_higher(\n+                                                (higher, lower), both=size > 0\n+                                            )\n+                                    with self.subTest(\"lower before higher\"):\n+                                        assert_find_higher(\n+                                            (lower, higher), both=size > 0\n+                                        )\n \n     def test_by_name(self):\n         elf_first = ElfSymbol(\"first\", 0xFFFF0000, 0x8, STT.OBJECT, STB.GLOBAL)\n@@ -156,7 +271,7 @@ class TestElfSymbol(TestCase):\n                 self.assert_symbols_equal_unordered(prog.symbols(\"second\"), [second])\n                 self.assertEqual(prog.symbols(\"third\"), [])\n \n-    def test_by_name_precedence(self):\n+    def test_by_name_binding_precedence(self):\n         precedence = (\n             (STB.GLOBAL, STB.GNU_UNIQUE),\n             (STB.WEAK,),\n@@ -170,10 +285,9 @@ class TestElfSymbol(TestCase):\n             prog = elf_symbol_program(*modules)\n             self.assertEqual(prog.symbol(\"foo\").address, expected)\n             # assert symbols() always finds both\n-            symbols = sorted(prog.symbols(\"foo\"), key=lambda s: s.address)\n-            self.assertEqual(len(symbols), 2)\n-            self.assertEqual(symbols[0].address, other)\n-            self.assertEqual(symbols[1].address, expected)\n+            self.assertCountEqual(\n+                [sym.address for sym in prog.symbols(\"foo\")], [expected, other]\n+            )\n \n         for i in range(len(precedence) - 1):\n             for higher_binding in precedence[i]:\n"}
{"repo": "drgn", "commit": "40065816a0f4c4b95eb57908f8cebbdc225d724d", "diff": "diff --git a/drgn/internal/repl.py b/drgn/internal/repl.py\nindex df050e0d..45dabab4 100644\n--- a/drgn/internal/repl.py\n+++ b/drgn/internal/repl.py\n@@ -39,7 +39,7 @@ try:\n         print(banner, file=sys.stderr)\n         run_multiline_interactive_console(console)\n \n-except (ModuleNotFoundError, ImportError):\n+except (ModuleNotFoundError, ImportError, AttributeError):\n     import code\n     import readline\n \n"}
{"repo": "drgn", "commit": "6230a9be28e940d2f18ce586e1967d260fb082ba", "diff": "diff --git a/vmtest/__main__.py b/vmtest/__main__.py\nindex 4c9467d9..d910e424 100644\n--- a/vmtest/__main__.py\n+++ b/vmtest/__main__.py\n@@ -180,11 +180,28 @@ if __name__ == \"__main__\":\n         action=\"store_true\",\n         help=\"run local tests\",\n     )\n+    parser.add_argument(\n+        \"--use-host-rootfs\",\n+        choices=[\"never\", \"auto\"],\n+        default=\"auto\",\n+        help='if \"never\", use $directory/$arch/rootfs even for host architecture; '\n+        'if \"auto\", use / for host architecture',\n+    )\n     args = parser.parse_args()\n \n     if not hasattr(args, \"kernels\") and not args.local:\n         parser.error(\"at least one of -k/--kernel or -l/--local is required\")\n \n+    if args.use_host_rootfs == \"auto\":\n+\n+        def use_host_rootfs(arch: Architecture) -> bool:\n+            return arch is HOST_ARCHITECTURE\n+\n+    else:\n+\n+        def use_host_rootfs(arch: Architecture) -> bool:\n+            return False\n+\n     architecture_names: List[str] = []\n     if hasattr(args, \"architectures\"):\n         for name in args.architectures:\n@@ -257,7 +274,7 @@ if __name__ == \"__main__\":\n         args.directory, to_download, max_pending_kernels\n     ) as downloads:\n         for arch in architectures:\n-            if arch is HOST_ARCHITECTURE:\n+            if use_host_rootfs(arch):\n                 subprocess.check_call(\n                     [sys.executable, \"setup.py\", \"build_ext\", \"-i\"],\n                     env={\n@@ -308,7 +325,7 @@ chroot \"$1\" sh -c 'cd /mnt && pytest -v --ignore=tests/linux_kernel'\n             if not isinstance(kernel, Kernel):\n                 continue\n \n-            if kernel.arch is HOST_ARCHITECTURE:\n+            if use_host_rootfs(kernel.arch):\n                 python_executable = sys.executable\n                 tests_expression = \"\"\n             else:\n@@ -342,7 +359,11 @@ fi\n                 status = run_in_vm(\n                     test_command,\n                     kernel,\n-                    args.directory / kernel.arch.name / \"rootfs\",\n+                    (\n+                        Path(\"/\")\n+                        if use_host_rootfs(kernel.arch)\n+                        else args.directory / kernel.arch.name / \"rootfs\"\n+                    ),\n                     args.directory,\n                     test_kmod=TestKmodMode.BUILD,\n                 )\n"}
{"repo": "drgn", "commit": "fb6c32cf15d4458bd68cd9df40a2180a3149b0e3", "diff": "diff --git a/contrib/cgroup.py b/contrib/cgroup.py\nindex afd0ab48..3cbc30dd 100755\n--- a/contrib/cgroup.py\n+++ b/contrib/cgroup.py\n@@ -20,11 +20,24 @@ from drgn.helpers.linux import (\n     find_task,\n )\n \n-BpfAttachType = enum_type_to_class(\n-    prog.type(\"enum bpf_attach_type\"),\n-    \"BpfAttachType\",\n-    exclude=(\"__MAX_BPF_ATTACH_TYPE\",),\n-)\n+# Since Linux kernel commit 6fc88c354f3a (\"bpf: Migrate cgroup_bpf to internal\n+# cgroup_bpf_attach_type enum\") (in v5.15), the attach type is the\n+# cgroup-specific enum cgroup_bpf_attach_type. Before that, it was the generic\n+# enum bpf_attach_type.\n+try:\n+    enum_cgroup_bpf_attach_type = prog.type(\"enum cgroup_bpf_attach_type\")\n+except LookupError:\n+    CgroupBpfAttachType = enum_type_to_class(\n+        prog.type(\"enum bpf_attach_type\"),\n+        \"CgroupBpfAttachType\",\n+        exclude=(\"__MAX_BPF_ATTACH_TYPE\",),\n+    )\n+else:\n+    CgroupBpfAttachType = enum_type_to_class(\n+        enum_cgroup_bpf_attach_type,\n+        \"CgroupBpfAttachType\",\n+        exclude=(\"CGROUP_BPF_ATTACH_TYPE_INVALID\", \"MAX_CGROUP_BPF_ATTACH_TYPE\",),\n+    )\n \n CgroupSubsysId = enum_type_to_class(\n     prog.type(\"enum cgroup_subsys_id\"),\n@@ -44,7 +57,7 @@ def open_dir(*args, **kwds):\n \n def print_cgroup_bpf_progs(cgrp):\n     cgroup_printed = False\n-    for attach_type in BpfAttachType:\n+    for attach_type in CgroupBpfAttachType:\n         attach_flags = cgrp.bpf.flags[attach_type.value].value_()\n         for prog in cgroup_bpf_prog_for_each(cgrp, attach_type.value):\n             prog_id = prog.aux.id.value_()\ndiff --git a/drgn/helpers/linux/bpf.py b/drgn/helpers/linux/bpf.py\nindex 4b195e3b..ee8dbe4e 100644\n--- a/drgn/helpers/linux/bpf.py\n+++ b/drgn/helpers/linux/bpf.py\n@@ -105,7 +105,8 @@ def cgroup_bpf_prog_for_each(\n     the given cgroup.\n \n     :param cgrp: ``struct cgroup *``\n-    :param bpf_attach_type: ``enum bpf_attach_type``\n+    :param bpf_attach_type: ``enum cgroup_bpf_attach_type`` (``enum\n+        bpf_attach_type`` before Linux 5.15)\n     :return: Iterator of ``struct bpf_prog *`` objects.\n     \"\"\"\n     # Before Linux kernel commit 3007098494be (\"cgroup: add support for eBPF\n"}
{"repo": "drgn", "commit": "127dde95c89c032f2eee2ab420f3e343705fbf43", "diff": "diff --git a/contrib/bpf_inspect.py b/contrib/bpf_inspect.py\nindex 1d950d58..74721a60 100755\n--- a/contrib/bpf_inspect.py\n+++ b/contrib/bpf_inspect.py\n@@ -179,7 +179,10 @@ class BpfProg(object):\n         id_ = self.prog.aux.id.value_()\n         type_ = BpfProgType(self.prog.type).name\n         name = self.get_prog_name()\n-        tail_call_reachable = self.prog.aux.tail_call_reachable.value_()\n+        try:\n+            tail_call_reachable = self.prog.aux.member_(\"tail_call_reachable\").value_()\n+        except LookupError:\n+            tail_call_reachable = None\n \n         tail_call_desc = \" tail_call_reachable\" if tail_call_reachable else \"\"\n \n"}
{"repo": "drgn", "commit": "fd2ffbdaa2da0ab52f4ec5193c83dd6754d6accb", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex a5ce5b8f..f71c2039 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -51,6 +51,10 @@ _PATCHES = (\n         name=\"proc-kcore-allow-enabling-CONFIG_PROC_KCORE-on-ARM.patch\",\n         versions=((None, None),),\n     ),\n+    _Patch(\n+        name=\"9p-fix-slab-cache-name-creation-for-real.patch\",\n+        versions=((KernelVersion(\"6.12\"), None),),\n+    ),\n     _Patch(\n         name=\"filelock-fix-name-of-file_lease-slab-cache.patch\",\n         versions=((KernelVersion(\"6.9\"), KernelVersion(\"6.10\")),),\n@@ -141,7 +145,7 @@ _PATCHES = (\n     _Patch(\n         name=\"lib-raid6-add-option-to-skip-algo-benchmarking.patch\",\n         versions=((None, KernelVersion(\"5.0\")),),\n-    )\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "c95658ce70fc5872b8a879d6050e5ac023a866fe", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex fc4b2281..fc8f59a2 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -138,7 +138,11 @@ def _displayhook(value: Any) -> None:\n         return\n     setattr(builtins, \"_\", None)\n     if isinstance(value, drgn.Object):\n-        text = value.format_(columns=shutil.get_terminal_size((0, 0)).columns)\n+        try:\n+            text = value.format_(columns=shutil.get_terminal_size((0, 0)).columns)\n+        except drgn.FaultError as e:\n+            logger.warning(\"can't print value: %s\", e)\n+            text = repr(value)\n     elif isinstance(value, (drgn.StackFrame, drgn.StackTrace, drgn.Type)):\n         text = str(value)\n     else:\n"}
{"repo": "drgn", "commit": "735b9e8aa2259f3fc7e5cd60316359da595d264d", "diff": "diff --git a/contrib/ptdrgn.py b/contrib/ptdrgn.py\nindex d47c6895..fa7ff93b 100644\n--- a/contrib/ptdrgn.py\n+++ b/contrib/ptdrgn.py\n@@ -108,8 +108,11 @@ def configure(repl) -> None:\n \n     def _format_result_output(result: object):\n         if isinstance(result, drgn.Object):\n-            s = result.format_(columns=shutil.get_terminal_size((0, 0)).columns)\n-            to_format = _maybe_c_format(s)\n+            try:\n+                s = result.format_(columns=shutil.get_terminal_size((0, 0)).columns)\n+                to_format = _maybe_c_format(s)\n+            except drgn.FaultError:\n+                to_format = DummyForRepr(repr(result))\n         elif isinstance(result, (drgn.StackFrame, drgn.StackTrace)):\n             to_format = DummyForRepr(str(result))\n         elif isinstance(result, drgn.Type):\n"}
{"repo": "drgn", "commit": "14c8d566539143f96c061920cb7ea6d31c21cbcd", "diff": "diff --git a/drgn/helpers/experimental/kmodify.py b/drgn/helpers/experimental/kmodify.py\nindex 46e23c75..8840d9b6 100644\n--- a/drgn/helpers/experimental/kmodify.py\n+++ b/drgn/helpers/experimental/kmodify.py\n@@ -713,6 +713,98 @@ class _Arch_X86_64:\n         return code_gen.code, code_gen.relocations\n \n \n+def _find_exported_symbol_in_section(\n+    prog: Program, name: bytes, start: int, stop: int\n+) -> int:\n+    kernel_symbol_type = prog.type(\"struct kernel_symbol\")\n+    if kernel_symbol_type.has_member(\"name_offset\"):\n+\n+        def kernel_symbol_name(sym: Object) -> Object:\n+            return cast(\"char *\", sym.name_offset.address_of_()) + sym.name_offset\n+\n+    else:\n+\n+        def kernel_symbol_name(sym: Object) -> Object:\n+            return sym.name\n+\n+    syms = Object(prog, prog.pointer_type(kernel_symbol_type), start)\n+    lo = 0\n+    hi = (stop - start) // sizeof(kernel_symbol_type)\n+    while lo < hi:\n+        mid = (lo + hi) // 2\n+        sym_name = kernel_symbol_name(syms[mid]).string_()\n+        if sym_name < name:\n+            lo = mid + 1\n+        elif sym_name > name:\n+            hi = mid\n+        else:\n+            return mid\n+    return -1\n+\n+\n+# If CONFIG_MODVERSIONS=y, then we need a __versions section containing a CRC\n+# of each exported symbol that we use. Since we intentionally don't use any\n+# symbols, we only need it for the special module_layout symbol.\n+def _get_versions_section(struct_module: Type) -> Optional[_ElfSection]:\n+    prog = struct_module.prog\n+    try:\n+        return prog.cache[\"kmodify___versions_section\"]\n+    except KeyError:\n+        pass\n+\n+    # module_layout is defined if and only if CONFIG_MODVERSIONS=y.\n+    have_module_layout = False\n+    try:\n+        have_module_layout = prog[\"module_layout\"].address_ is not None\n+    except KeyError:\n+        pass\n+\n+    if have_module_layout:\n+        # We only check the non-GPL-only section because module_layout is\n+        # non-GPL-only.\n+        i = _find_exported_symbol_in_section(\n+            prog,\n+            b\"module_layout\",\n+            prog.symbol(\"__start___ksymtab\").address,\n+            prog.symbol(\"__stop___ksymtab\").address,\n+        )\n+        if i < 0:\n+            raise LookupError(\"module_layout not found\")\n+\n+        # Since Linux kernel commit 71810db27c1c (\"modversions: treat symbol\n+        # CRCs as 32 bit quantities\") (in v4.10), CRCs are in an array of s32.\n+        # Before that, they are in an array of unsigned long. Determine the\n+        # correct type from struct module::crcs.\n+        module_layout_crc = (\n+            Object(\n+                prog,\n+                struct_module.member(\"crcs\").type,\n+                prog.symbol(\"__start___kcrctab\").address,\n+            )[i].value_()\n+            & 0xFFFFFFFF\n+        )\n+\n+        struct_modversion_info = prog.type(\"struct modversion_info\")\n+        section = _ElfSection(\n+            name=\"__versions\",\n+            type=SHT.PROGBITS,\n+            flags=SHF.ALLOC,\n+            data=Object(\n+                prog,\n+                struct_modversion_info,\n+                {\n+                    \"crc\": module_layout_crc,\n+                    \"name\": b\"module_layout\",\n+                },\n+            ).to_bytes_(),\n+            addralign=alignof(struct_modversion_info),\n+        )\n+    else:\n+        section = None\n+    prog.cache[\"kmodify___versions_section\"] = section\n+    return section\n+\n+\n class _Kmodify:\n     def __init__(self, prog: Program) -> None:\n         if prog.flags & (\n@@ -810,6 +902,11 @@ class _Kmodify:\n             ),\n         ]\n \n+        # Add the __versions section if needed.\n+        versions_section = _get_versions_section(struct_module)\n+        if versions_section is not None:\n+            sections.append(versions_section)\n+\n         symbols = [\n             *symbols,\n             _ElfSymbol(\n"}
{"repo": "drgn", "commit": "9dca050dd6aca146d2b5356733c76ad4868e8ebd", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex a2f96d16..2c7eed5d 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -51,10 +51,6 @@ _PATCHES = (\n         name=\"proc-kcore-allow-enabling-CONFIG_PROC_KCORE-on-ARM.patch\",\n         versions=((None, None),),\n     ),\n-    _Patch(\n-        name=\"iov_iter-fix-advancing-slot-in-iter_folioq_get_pages.patch\",\n-        versions=((KernelVersion(\"6.12\"), None),),\n-    ),\n     _Patch(\n         name=\"filelock-fix-name-of-file_lease-slab-cache.patch\",\n         versions=((KernelVersion(\"6.9\"), KernelVersion(\"6.10\")),),\n"}
{"repo": "drgn", "commit": "4b742449472360c2d1c254a21d5897ebfa216866", "diff": "diff --git a/vmtest/__main__.py b/vmtest/__main__.py\nindex 33360815..4c9467d9 100644\n--- a/vmtest/__main__.py\n+++ b/vmtest/__main__.py\n@@ -74,19 +74,19 @@ class _ProgressPrinter:\n             for category, names in self._passed.items():\n                 if first:\n                     first = False\n-                    print(self._green(\"Passed:\"), end=\" \")\n+                    print(self._green(\"Passed:\"), end=\" \", file=self._file)\n                 else:\n-                    print(\"       \", end=\" \")\n-                print(f\"{category}: {', '.join(names)}\")\n+                    print(\"       \", end=\" \", file=self._file)\n+                print(f\"{category}: {', '.join(names)}\", file=self._file)\n         if self._failed:\n             first = True\n             for category, names in self._failed.items():\n                 if first:\n                     first = False\n-                    print(self._red(\"Failed:\"), end=\" \")\n+                    print(self._red(\"Failed:\"), end=\" \", file=self._file)\n                 else:\n-                    print(\"       \", end=\" \")\n-                print(f\"{category}: {', '.join(names)}\")\n+                    print(\"       \", end=\" \", file=self._file)\n+                print(f\"{category}: {', '.join(names)}\", file=self._file)\n \n         print(file=self._file)\n         print(header, file=self._file, flush=True)\n"}
{"repo": "drgn", "commit": "c7f1946e4d0a77264b43bdced588cce754a9dd52", "diff": "diff --git a/tests/linux_kernel/helpers/test_bpf.py b/tests/linux_kernel/helpers/test_bpf.py\nindex 45c4e351..f6a79140 100644\n--- a/tests/linux_kernel/helpers/test_bpf.py\n+++ b/tests/linux_kernel/helpers/test_bpf.py\n@@ -3,6 +3,7 @@\n \n import errno\n import os\n+import resource\n import sys\n import unittest\n \n@@ -16,6 +17,7 @@ from drgn.helpers.linux.bpf import (\n     cgroup_bpf_prog_for_each_effective,\n )\n from drgn.helpers.linux.cgroup import cgroup_get_from_path\n+from tests import classCleanups\n from tests.linux_kernel import LinuxKernelTestCase\n from tests.linux_kernel.bpf import (\n     BPF_CGROUP_INET_INGRESS,\n@@ -47,12 +49,28 @@ class TestBpf(LinuxKernelTestCase):\n         INSNS = (0xB700000000000000, 0x9500000000000000)\n \n     @classmethod\n+    @classCleanups\n     def setUpClass(cls):\n         super().setUpClass()\n         if _SYS_bpf is None:\n             raise unittest.SkipTest(\n                 f\"bpf syscall number is not known on {NORMALIZED_MACHINE_NAME}\"\n             )\n+        # Before the patch series culminating in Linux kernel commit\n+        # 3ac1f01b43b6 (\"bpf: Eliminate rlimit-based memory accounting for bpf\n+        # progs\") (in v5.11), BPF program and map memory usage was limited by\n+        # RLIMIT_MEMLOCK. At that time (before Linux kernel commit 9dcc38e2813e\n+        # (\"Increase default MLOCK_LIMIT to 8 MiB\") (in v5.16)), the limit was\n+        # only 64kB. We only allocate a few small objects at a time, but with\n+        # 64k pages, we can easily blow that limit.\n+        memlock_limit = 8 * 1024 * 1024\n+        old_limit = resource.getrlimit(resource.RLIMIT_MEMLOCK)\n+        if old_limit[0] < memlock_limit:\n+            resource.setrlimit(\n+                resource.RLIMIT_MEMLOCK,\n+                (memlock_limit, max(memlock_limit, old_limit[1])),\n+            )\n+            cls.addClassCleanup(resource.setrlimit, resource.RLIMIT_MEMLOCK, old_limit)\n         try:\n             os.close(bpf_map_create(BPF_MAP_TYPE_HASH, 8, 8, 8))\n         except OSError as e:\n"}
{"repo": "drgn", "commit": "f8edf3eadc3167f0ba499072ab678a9fa4d62e22", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 90082120..bb77812f 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -9,6 +9,7 @@ from pathlib import Path\n from typing import Dict, Mapping, NamedTuple, Sequence\n \n from _drgn_util.platform import NORMALIZED_MACHINE_NAME\n+from util import KernelVersion\n \n # Kernel versions that we run tests on and therefore support. Keep this in sync\n # with docs/support_matrix.rst.\n@@ -428,6 +429,8 @@ def kconfig_localversion(arch: Architecture, flavor: KernelFlavor, version: str)\n     patch_level = 0\n     # If only specific architecture/flavor/version combinations need to be\n     # rebuilt, conditionally increment the patch level here.\n+    if KernelVersion(version) >= KernelVersion(\"6.12\"):\n+        patch_level += 1\n     if patch_level:\n         vmtest_kernel_version.append(patch_level)\n \ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 2c28c195..081f5ced 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -51,6 +51,10 @@ _PATCHES = (\n         name=\"proc-kcore-allow-enabling-CONFIG_PROC_KCORE-on-ARM.patch\",\n         versions=((None, None),),\n     ),\n+    _Patch(\n+        name=\"iov_iter-fix-advancing-slot-in-iter_folioq_get_pages.patch\",\n+        versions=((KernelVersion(\"6.12\"), None),),\n+    ),\n     _Patch(\n         name=\"5.15-kbuild-Unify-options-for-BTF-generation-for-vmlinux.patch\",\n         versions=((KernelVersion(\"5.13\"), KernelVersion(\"5.15.66\")),),\n"}
{"repo": "drgn", "commit": "80c7b806a7c30988e428d8007033ae264d1529e8", "diff": "diff --git a/vmtest/vm.py b/vmtest/vm.py\nindex f02f9fbf..a3b5d433 100644\n--- a/vmtest/vm.py\n+++ b/vmtest/vm.py\n@@ -218,13 +218,8 @@ def run_in_vm(\n         else:\n             root_dir = build_dir / kernel.arch.name / \"rootfs\"\n \n-    if test_kmod == TestKmodMode.NONE:\n-        test_kmod_command = \"\"\n-    else:\n+    if test_kmod != TestKmodMode.NONE:\n         kmod = build_kmod(build_dir, kernel)\n-        test_kmod_command = f\"export DRGN_TEST_KMOD={shlex.quote(str(kmod))}\"\n-        if test_kmod == TestKmodMode.INSERT:\n-            test_kmod_command += '\\ninsmod \"$DRGN_TEST_KMOD\"'\n \n     qemu_exe = \"qemu-system-\" + kernel.arch.name\n     match = re.search(\n@@ -290,6 +285,13 @@ def run_in_vm(\n             init = f'/bin/sh -- -c \"/bin/mount -t tmpfs tmpfs /tmp && /bin/mkdir /tmp/host && /bin/mount -t 9p -o {_9pfs_mount_options},ro host /tmp/host && . /tmp/host{init_path.resolve()}\"'\n             host_dir_prefix = \"/host\"\n \n+        if test_kmod == TestKmodMode.NONE:\n+            test_kmod_command = \"\"\n+        else:\n+            test_kmod_command = f\"export DRGN_TEST_KMOD={shlex.quote(host_dir_prefix + str(kmod.resolve()))}\"\n+            if test_kmod == TestKmodMode.INSERT:\n+                test_kmod_command += '\\ninsmod \"$DRGN_TEST_KMOD\"'\n+\n         with init_path.open(\"w\") as init_file:\n             init_file.write(\n                 _INIT_TEMPLATE.format(\n"}
{"repo": "drgn", "commit": "ad9b2415aca36bb4f569d60c9a82fe47c7bce000", "diff": "diff --git a/docs/exts/drgndoc/format.py b/docs/exts/drgndoc/format.py\nindex 33829a8b..9d77e14e 100644\n--- a/docs/exts/drgndoc/format.py\n+++ b/docs/exts/drgndoc/format.py\n@@ -349,9 +349,11 @@ class Formatter:\n             visit_arg(\n                 arg,\n                 default,\n-                name=arg.arg[2:]\n-                if num_pep_570_posonlyargs <= i < num_posonlyargs\n-                else arg.arg,\n+                name=(\n+                    arg.arg[2:]\n+                    if num_pep_570_posonlyargs <= i < num_posonlyargs\n+                    else arg.arg\n+                ),\n             )\n             if i == num_posonlyargs - 1:\n                 signature.append(\", /\")\ndiff --git a/docs/exts/drgndoc/parse.py b/docs/exts/drgndoc/parse.py\nindex f02c82cd..5d9a63d8 100644\n--- a/docs/exts/drgndoc/parse.py\n+++ b/docs/exts/drgndoc/parse.py\n@@ -27,12 +27,10 @@ from drgndoc.visitor import NodeVisitor\n class _PreTransformer(ast.NodeTransformer):\n     # Replace string forward references with the parsed expression.\n     @overload\n-    def _visit_annotation(self, node: ast.expr) -> ast.expr:\n-        ...\n+    def _visit_annotation(self, node: ast.expr) -> ast.expr: ...\n \n     @overload\n-    def _visit_annotation(self, node: None) -> None:\n-        ...\n+    def _visit_annotation(self, node: None) -> None: ...\n \n     def _visit_annotation(self, node: Optional[ast.expr]) -> Optional[ast.expr]:\n         if isinstance(node, ast.Constant) and isinstance(node.value, str):\ndiff --git a/drgn/helpers/common/prog.py b/drgn/helpers/common/prog.py\nindex 5f3ce15d..54349534 100644\n--- a/drgn/helpers/common/prog.py\n+++ b/drgn/helpers/common/prog.py\n@@ -35,30 +35,32 @@ if typing.TYPE_CHECKING:\n     R_co = TypeVar(\"R_co\", covariant=True)\n \n     class TakesProgram(Protocol[P, R_co]):\n-        def __call__(self, prog: Program, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(\n+            self, prog: Program, *args: P.args, **kwargs: P.kwargs\n+        ) -> R_co: ...\n \n     class TakesProgramOrDefault(Protocol[P, R_co]):\n         @overload\n-        def __call__(self, prog: Program, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(\n+            self, prog: Program, *args: P.args, **kwargs: P.kwargs\n+        ) -> R_co: ...\n \n         @overload\n-        def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R_co: ...\n \n     class TakesObjectOrProgramOrDefault(Protocol[P, R_co]):\n         @overload\n-        def __call__(self, prog: Program, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(\n+            self, prog: Program, *args: P.args, **kwargs: P.kwargs\n+        ) -> R_co: ...\n \n         @overload\n-        def __call__(self, __obj: Object, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(\n+            self, __obj: Object, *args: P.args, **kwargs: P.kwargs\n+        ) -> R_co: ...\n \n         @overload\n-        def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R_co:\n-            ...\n+        def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R_co: ...\n \n \n def takes_program_or_default(f: \"TakesProgram[P, R]\") -> \"TakesProgramOrDefault[P, R]\":\ndiff --git a/drgn/helpers/experimental/kmodify.py b/drgn/helpers/experimental/kmodify.py\nindex 95015dc3..c25d94c9 100644\n--- a/drgn/helpers/experimental/kmodify.py\n+++ b/drgn/helpers/experimental/kmodify.py\n@@ -167,9 +167,11 @@ def _write_elf(\n             return (\n                 (sym.binding << 4) + (sym.type & 0xF),\n                 sym.visibility,\n-                section_name_to_index[sym.section]\n-                if isinstance(sym.section, str)\n-                else sym.section,\n+                (\n+                    section_name_to_index[sym.section]\n+                    if isinstance(sym.section, str)\n+                    else sym.section\n+                ),\n                 sym.value,\n                 sym.size,\n             )\n@@ -190,9 +192,11 @@ def _write_elf(\n                 sym.size,\n                 (sym.binding << 4) + (sym.type & 0xF),\n                 sym.visibility,\n-                section_name_to_index[sym.section]\n-                if isinstance(sym.section, str)\n-                else sym.section,\n+                (\n+                    section_name_to_index[sym.section]\n+                    if isinstance(sym.section, str)\n+                    else sym.section\n+                ),\n             )\n \n     section_symbols = [\ndiff --git a/tests/linux_kernel/helpers/test_mapletree.py b/tests/linux_kernel/helpers/test_mapletree.py\nindex 97474790..3911b8ab 100644\n--- a/tests/linux_kernel/helpers/test_mapletree.py\n+++ b/tests/linux_kernel/helpers/test_mapletree.py\n@@ -274,9 +274,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_dense_1\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * (node_slots - 1) * (maple_range64_slots - 1) + (\n                 maple_range64_slots - 1\n@@ -297,9 +299,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         maple_range64_slots = self.prog[\"drgn_test_maple_range64_slots\"].value_()\n         for mt, arange in self.maple_trees(\"three_levels_dense_1\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * (node_slots - 1) * (maple_range64_slots - 1) + (\n                 maple_range64_slots - 1\n@@ -314,9 +318,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_dense_2\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * node_slots * maple_range64_slots\n             for i in range(n):\n@@ -335,9 +341,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         maple_range64_slots = self.prog[\"drgn_test_maple_range64_slots\"].value_()\n         for mt, arange in self.maple_trees(\"three_levels_dense_2\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * node_slots * maple_range64_slots\n             self.assertIdentical(\n@@ -350,9 +358,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_ranges_1\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * (node_slots - 1) * (maple_range64_slots - 1) + (\n                 maple_range64_slots - 1\n@@ -386,9 +396,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_ranges_1\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * (node_slots - 1) * (maple_range64_slots - 1) + (\n                 maple_range64_slots - 1\n@@ -407,9 +419,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_ranges_2\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * node_slots * maple_range64_slots\n             for i in range(n):\n@@ -441,9 +455,11 @@ class TestMapleTree(LinuxKernelTestCase):\n         ulong_max = (1 << (sizeof(self.prog.type(\"unsigned long\")) * 8)) - 1\n         for mt, arange in self.maple_trees(\"three_levels_ranges_2\"):\n             node_slots = self.prog[\n-                \"drgn_test_maple_arange64_slots\"\n-                if arange\n-                else \"drgn_test_maple_range64_slots\"\n+                (\n+                    \"drgn_test_maple_arange64_slots\"\n+                    if arange\n+                    else \"drgn_test_maple_range64_slots\"\n+                )\n             ].value_()\n             n = 2 * node_slots * maple_range64_slots\n             self.assertIdentical(\ndiff --git a/tools/fsrefs.py b/tools/fsrefs.py\nindex 8249e160..f710511b 100755\n--- a/tools/fsrefs.py\n+++ b/tools/fsrefs.py\n@@ -62,14 +62,11 @@ format_args = {\n if typing.TYPE_CHECKING:\n \n     class Visitor(typing.Protocol):  # novermin\n-        def visit_file(self, file: Object) -> Optional[str]:\n-            ...\n+        def visit_file(self, file: Object) -> Optional[str]: ...\n \n-        def visit_inode(self, inode: Object) -> Optional[str]:\n-            ...\n+        def visit_inode(self, inode: Object) -> Optional[str]: ...\n \n-        def visit_path(self, path: Object) -> Optional[str]:\n-            ...\n+        def visit_path(self, path: Object) -> Optional[str]: ...\n \n \n class InodeVisitor:\n"}
{"repo": "drgn", "commit": "ee328188c1e07515ab05b4b812c9fe43622ec65b", "diff": "diff --git a/drgn/helpers/experimental/kmodify.py b/drgn/helpers/experimental/kmodify.py\nindex 325195b6..95015dc3 100644\n--- a/drgn/helpers/experimental/kmodify.py\n+++ b/drgn/helpers/experimental/kmodify.py\n@@ -997,7 +997,7 @@ def write_object(\n         (``*ptr = value``). If ``False``, then write to the pointer itself\n         (``ptr = value``). This is a common source of confusion, so it is\n         required if *object* is a pointer.\n-    :raises ValueError: is *object* is not a reference object (i.e., its\n+    :raises ValueError: if *object* is not a reference object (i.e., its\n         address is not known)\n     :raises TypeError: if *object* is a pointer and *dereference* is not given\n     :raises TypeError: if *object* is not a pointer and *dereference* is\n@@ -1109,13 +1109,12 @@ def call_function(prog: Program, func: Union[str, Object], *args: Any) -> Object\n     :param args: Function arguments. :class:`int`, :class:`float`, and\n         :class:`bool` arguments are converted as \"literals\" with\n         ``Object(prog, value=...)``. :class:`str` and :class:`bytes` arguments\n-        are automatically converted to a ``char`` array object.\n-        :class:`pass_pointer` arguments are copied to the kernel, passed by\n-        pointer, and copied back.\n+        are converted to ``char`` array objects. :class:`pass_pointer`\n+        arguments are copied to the kernel, passed by pointer, and copied back.\n     :return: Function return value.\n     :raises TypeError: if the passed arguments have incorrect types for the\n         function\n-    :raises ObjectAbsentError: if function cannot be called because it is\n+    :raises ObjectAbsentError: if the function cannot be called because it is\n         inlined\n     :raises LookupError: if a function with the given name is not found\n         (possibly because it is actually a function-like macro)\n"}
{"repo": "drgn", "commit": "630c00a9cce2ce16a71c962b52d21b59eedb5e2a", "diff": "diff --git a/tests/test_language_c.py b/tests/test_language_c.py\nindex 1012a9aa..448feb32 100644\n--- a/tests/test_language_c.py\n+++ b/tests/test_language_c.py\n@@ -764,7 +764,11 @@ class TestLiteral(MockProgramTestCase):\n             pass\n \n         self.assertRaisesRegex(\n-            TypeError, \"cannot create Foo literal\", Object, self.prog, value=Foo()\n+            TypeError,\n+            \"literal must be int, float, or bool, not 'Foo'\",\n+            Object,\n+            self.prog,\n+            value=Foo(),\n         )\n \n \n"}
{"repo": "drgn", "commit": "fd474f04272ed863152f21968e4358bf649b24eb", "diff": "diff --git a/tests/test_language_c.py b/tests/test_language_c.py\nindex 940cc931..8710a0cf 100644\n--- a/tests/test_language_c.py\n+++ b/tests/test_language_c.py\n@@ -1168,6 +1168,26 @@ class TestOperators(MockProgramTestCase):\n             cast(\"void\", Object(self.prog, \"int [2]\")), Object(self.prog, \"void\")\n         )\n \n+    def test_cast_to_bool(self):\n+        self.assertIdentical(\n+            cast(\"_Bool\", Object(self.prog, \"int\", 0)),\n+            Object(self.prog, \"_Bool\", False),\n+        )\n+        for value in (1, -1, 2, 256, 32767):\n+            with self.subTest(value=value):\n+                self.assertIdentical(\n+                    cast(\"_Bool\", Object(self.prog, \"int\", value)),\n+                    Object(self.prog, \"_Bool\", True),\n+                )\n+        self.assertIdentical(\n+            cast(\"_Bool\", Object(self.prog, \"void *\", 0)),\n+            Object(self.prog, \"_Bool\", False),\n+        )\n+        self.assertIdentical(\n+            cast(\"_Bool\", Object(self.prog, \"void *\", 1)),\n+            Object(self.prog, \"_Bool\", True),\n+        )\n+\n     def _test_arithmetic(\n         self, op, lhs, rhs, result, integral=True, floating_point=False\n     ):\n"}
{"repo": "drgn", "commit": "5332fcd906dbed2bcd37d0090ef15c1f6a46f433", "diff": "diff --git a/tests/test_language_c.py b/tests/test_language_c.py\nindex 62b7198a..e4fd1a1a 100644\n--- a/tests/test_language_c.py\n+++ b/tests/test_language_c.py\n@@ -1113,6 +1113,11 @@ class TestCommonRealType(MockProgramTestCase):\n \n \n class TestOperators(MockProgramTestCase):\n+    def test_bool_arrays(self):\n+        self.assertTrue(Object(self.prog, \"int [2]\", [0, 0]))\n+        self.assertTrue(Object(self.prog, \"int [0]\", address=0x1234))\n+        self.assertFalse(Object(self.prog, \"int [2]\", address=0))\n+\n     def test_cast_array(self):\n         obj = Object(self.prog, \"int []\", address=0xFFFF0000)\n         self.assertIdentical(\ndiff --git a/tests/test_object.py b/tests/test_object.py\nindex 3823109b..5afe21df 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -1315,8 +1315,6 @@ class TestConversions(MockProgramTestCase):\n         self.assertTrue(Object(self.prog, \"int *\", value=0xFFFF0000))\n         self.assertFalse(Object(self.prog, \"int *\", value=0x0))\n \n-        self.assertTrue(Object(self.prog, \"int []\", address=0))\n-\n         self.assertRaisesRegex(\n             TypeError,\n             \"cannot convert 'struct point' to bool\",\n"}
{"repo": "drgn", "commit": "9ad29fd86499eb32847473e928b6540872d3d59a", "diff": "diff --git a/drgn/helpers/common/memory.py b/drgn/helpers/common/memory.py\nindex e28f5426..95b9019f 100644\n--- a/drgn/helpers/common/memory.py\n+++ b/drgn/helpers/common/memory.py\n@@ -54,6 +54,7 @@ def _identify_kernel_vmap(\n                     break\n             except AttributeError:\n                 # CONFIG_VMAP_STACK must be disabled.\n+                task = None\n                 break\n             except FaultError:\n                 continue\ndiff --git a/tests/linux_kernel/helpers/test_common.py b/tests/linux_kernel/helpers/test_common.py\nindex 43b57970..85a720a9 100644\n--- a/tests/linux_kernel/helpers/test_common.py\n+++ b/tests/linux_kernel/helpers/test_common.py\n@@ -52,20 +52,28 @@ class TestIdentifyAddress(LinuxKernelTestCase):\n \n     @skip_unless_have_test_kmod\n     def test_identify_vmap(self):\n-        self.assertTrue(\n-            identify_address(self.prog[\"drgn_test_vmalloc_va\"]).startswith(\"vmap: 0x\")\n-        )\n+        for cache in (None, {}):\n+            with self.subTest(\"uncached\" if cache is None else \"cached\"):\n+                self.assertTrue(\n+                    identify_address(\n+                        self.prog[\"drgn_test_vmalloc_va\"], cache=cache\n+                    ).startswith(\"vmap: 0x\")\n+                )\n \n     @skip_unless_have_test_kmod\n     def test_identify_vmap_stack(self):\n         if not self.prog[\"drgn_test_vmap_stack_enabled\"]:\n             self.skipTest(\"kernel does not use vmap stacks (CONFIG_VMAP_STACK)\")\n-        self.assertEqual(\n-            identify_address(\n-                self.prog, self.prog[\"drgn_test_kthread\"].stack.value_() + 1234\n-            ),\n-            f\"vmap stack: {self.prog['drgn_test_kthread'].pid.value_()} (drgn_test_kthre) +0x4d2\",\n-        )\n+        for cache in (None, {}):\n+            with self.subTest(\"uncached\" if cache is None else \"cached\"):\n+                self.assertEqual(\n+                    identify_address(\n+                        self.prog,\n+                        self.prog[\"drgn_test_kthread\"].stack.value_() + 1234,\n+                        cache=cache,\n+                    ),\n+                    f\"vmap stack: {self.prog['drgn_test_kthread'].pid.value_()} (drgn_test_kthre) +0x4d2\",\n+                )\n \n     @skip_unless_have_full_mm_support\n     @skip_unless_have_test_kmod\n"}
{"repo": "drgn", "commit": "7e8c5d7bb280b3745d0d121751d003760053d2ea", "diff": "diff --git a/tests/linux_kernel/helpers/test_common.py b/tests/linux_kernel/helpers/test_common.py\nindex c39eabc3..43b57970 100644\n--- a/tests/linux_kernel/helpers/test_common.py\n+++ b/tests/linux_kernel/helpers/test_common.py\n@@ -92,7 +92,11 @@ class TestPrintAnnotatedMemory(LinuxKernelTestCase):\n                 self.prog[\"drgn_test_small_slab_objects\"].address_,\n                 sizeof(self.prog[\"drgn_test_small_slab_objects\"]),\n             )\n-        self.assertIn(\"slab object: drgn_test_small+0x0\", f.getvalue())\n+        # For CONFIG_SLOB, we cannot find slab objects. However,\n+        # print_annotated_memory() should still function with no error. So we\n+        # don't skip the test here: just skip the assertion.\n+        if not self.prog[\"drgn_test_slob\"]:\n+            self.assertIn(\"slab object: drgn_test_small+0x0\", f.getvalue())\n \n \n class TestPrintAnnotatedStack(LinuxKernelTestCase):\n"}
{"repo": "drgn", "commit": "545aa52fe1ce63d10897769831396d00cbaea4cf", "diff": "diff --git a/drgn/helpers/common/memory.py b/drgn/helpers/common/memory.py\nindex 27a04e14..e28f5426 100644\n--- a/drgn/helpers/common/memory.py\n+++ b/drgn/helpers/common/memory.py\n@@ -14,26 +14,12 @@ import typing\n from typing import Any, Dict, Optional\n \n import drgn\n-from drgn import (\n-    FaultError,\n-    IntegerLike,\n-    Object,\n-    PlatformFlags,\n-    Program,\n-    SymbolKind,\n-    cast,\n-)\n+from drgn import FaultError, IntegerLike, Object, PlatformFlags, Program, SymbolKind\n from drgn.helpers.common.format import escape_ascii_string\n from drgn.helpers.common.prog import takes_program_or_default\n-from drgn.helpers.linux.mm import (\n-    PageSlab,\n-    compound_head,\n-    find_vmap_area,\n-    pfn_to_virt,\n-    virt_to_page,\n-)\n+from drgn.helpers.linux.mm import find_vmap_area, in_direct_map\n from drgn.helpers.linux.pid import for_each_task\n-from drgn.helpers.linux.slab import _get_slab_cache_helper, _get_slab_type\n+from drgn.helpers.linux.slab import _find_containing_slab, _get_slab_cache_helper\n \n __all__ = (\n     \"identify_address\",\n@@ -111,27 +97,17 @@ def _identify_kernel_address(\n     prog: Program, addr: int, cache: Optional[Dict[Any, Any]] = None\n ) -> Optional[str]:\n     try:\n-        direct_map_start = pfn_to_virt(prog[\"min_low_pfn\"]).value_()\n-        direct_map_end = (pfn_to_virt(prog[\"max_low_pfn\"]) + prog[\"PAGE_SIZE\"]).value_()\n-        in_direct_map = direct_map_start <= addr < direct_map_end\n+        direct_map = in_direct_map(prog, addr)\n     except NotImplementedError:\n         # Virtual address translation isn't implemented for this\n         # architecture.\n-        in_direct_map = False\n-    if in_direct_map:\n-        page = virt_to_page(prog, addr)\n+        direct_map = False\n \n-        try:\n-            head_page = compound_head(page)\n-            is_slab = PageSlab(head_page)\n-        except FaultError:\n-            return None\n-\n-        if is_slab:\n-            slab = cast(_get_slab_type(prog), head_page)\n-            slab_info = _get_slab_cache_helper(slab.slab_cache).object_info(\n-                head_page, slab, addr\n-            )\n+    if direct_map:\n+        result = _find_containing_slab(prog, addr)\n+        if result is not None:\n+            slab_cache, page, slab = result\n+            slab_info = _get_slab_cache_helper(slab_cache).object_info(page, slab, addr)\n             if slab_info:\n                 cache_name = escape_ascii_string(\n                     slab_info.slab_cache.name.string_(), escape_backslash=True\ndiff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 3d8495c3..14213e26 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -1377,3 +1377,15 @@ def totalram_pages(prog: Program) -> int:\n         return prog[\"_totalram_pages\"].counter.value_()\n     except KeyError:\n         return prog[\"totalram_pages\"].value_()\n+\n+\n+@takes_program_or_default\n+def in_direct_map(prog: Program, addr: IntegerLike) -> bool:\n+    \"\"\"\n+    Return True if an address is within the kernel's direct memory mapping\n+    :param addr: address to check\n+    \"\"\"\n+    addr = operator.index(addr)\n+    start_addr = pfn_to_virt(prog[\"min_low_pfn\"]).value_()\n+    end_addr = (pfn_to_virt(prog[\"max_low_pfn\"]) + prog[\"PAGE_SIZE\"]).value_()\n+    return start_addr <= addr < end_addr\ndiff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex 2b6dd5aa..f1b56dc9 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -39,8 +39,8 @@ from drgn.helpers.linux.mm import (\n     _get_PageSlab_impl,\n     compound_head,\n     for_each_page,\n+    in_direct_map,\n     page_to_virt,\n-    pfn_to_virt,\n     virt_to_page,\n )\n from drgn.helpers.linux.percpu import per_cpu_ptr\n@@ -464,12 +464,6 @@ def slab_cache_for_each_allocated_object(\n def _find_containing_slab(\n     prog: Program, addr: int\n ) -> Optional[Tuple[Object, Object, Object]]:\n-    start_addr = pfn_to_virt(prog[\"min_low_pfn\"]).value_()\n-    end_addr = (pfn_to_virt(prog[\"max_low_pfn\"]) + prog[\"PAGE_SIZE\"]).value_()\n-    if addr < start_addr or addr >= end_addr:\n-        # Not a directly mapped address\n-        return None\n-\n     page = virt_to_page(prog, addr)\n \n     try:\n@@ -516,6 +510,8 @@ def slab_object_info(prog: Program, addr: IntegerLike) -> \"Optional[SlabObjectIn\n         if not.\n     \"\"\"\n     addr = operator.index(addr)\n+    if not in_direct_map(prog, addr):\n+        return None\n     result = _find_containing_slab(prog, addr)\n     if result is None:\n         return None\n@@ -568,6 +564,8 @@ def find_containing_slab_cache(prog: Program, addr: IntegerLike) -> Object:\n     :return: ``struct kmem_cache *`` containing *addr*, or ``NULL`` if *addr*\n         is not from a slab cache.\n     \"\"\"\n+    if not in_direct_map(prog, addr):\n+        return NULL(prog, \"struct kmem_cache *\")\n     result = _find_containing_slab(prog, operator.index(addr))\n     if result is None:\n         return NULL(prog, \"struct kmem_cache *\")\n"}
{"repo": "drgn", "commit": "cd7d84d71961992b8c366f02c634e7b786cc791c", "diff": "diff --git a/contrib/bpf_inspect.py b/contrib/bpf_inspect.py\nindex 171a8908..8dfa4264 100755\n--- a/contrib/bpf_inspect.py\n+++ b/contrib/bpf_inspect.py\n@@ -118,7 +118,7 @@ class BpfProg(object):\n             # Try to get dst_trampoline first.\n             tr = self.prog.aux.member_(\"dst_trampoline\")\n         except LookupError:\n-            pass\n+            tr = None\n \n         try:\n             tr = self.prog.aux.member_(\"trampoline\") if not tr else tr\n"}
{"repo": "drgn", "commit": "45c67be431ce1cd3e2b16778e24908e882d04b36", "diff": "diff --git a/drgn/helpers/linux/block.py b/drgn/helpers/linux/block.py\nindex cc7e436b..a1a570b2 100644\n--- a/drgn/helpers/linux/block.py\n+++ b/drgn/helpers/linux/block.py\n@@ -14,13 +14,14 @@ Before that, they were represented by ``struct hd_struct``.\n \n from typing import Iterator\n \n-from drgn import Object, Program, container_of\n+from drgn import Object, Program, cast, container_of\n from drgn.helpers.common.format import escape_ascii_string\n from drgn.helpers.common.prog import takes_program_or_default\n from drgn.helpers.linux.device import MAJOR, MINOR, MKDEV\n from drgn.helpers.linux.list import list_for_each_entry\n \n __all__ = (\n+    \"bdev_partno\",\n     \"disk_devt\",\n     \"disk_name\",\n     \"for_each_disk\",\n@@ -51,6 +52,35 @@ def disk_name(disk: Object) -> bytes:\n     return disk.disk_name.string_()\n \n \n+def _bdev_partno_flags(bdev: Object) -> Object:\n+    return cast(\"u8\", bdev.__bd_flags.counter)\n+\n+\n+def _bdev_partno_old(bdev: Object) -> Object:\n+    return bdev.bd_partno.read_()\n+\n+\n+def bdev_partno(bdev: Object) -> Object:\n+    \"\"\"\n+    Get the partition number of a block device.\n+\n+    :param bdev: ``struct block_device *``\n+    :return: ``u8``\n+    \"\"\"\n+    try:\n+        impl = bdev.prog_.cache[\"bdev_partno\"]\n+    except KeyError:\n+        # Since Linux kernel commit 1116b9fa15c0 (\"bdev: infrastructure for\n+        # flags\") (in v6.10), partno is part of the atomic_t __bd_flags member.\n+        # Before that, it's its own member.\n+        bdev.prog_.cache[\"bdev_partno\"] = impl = (\n+            _bdev_partno_flags\n+            if bdev.prog_.type(\"struct block_device\").has_member(\"__bd_flags\")\n+            else _bdev_partno_old\n+        )\n+    return impl(bdev)\n+\n+\n def _class_to_subsys(class_: Object) -> Object:\n     # Walk the list of registered classes to find the struct subsys_private\n     # matching the given class. Note that before Linux kernel commit\n@@ -112,7 +142,7 @@ def for_each_disk(prog: Program) -> Iterator[Object]:\n             except LookupError:\n                 have_bd_device = False\n             else:\n-                if bdev.bd_partno == 0:\n+                if not bdev_partno(bdev):\n                     yield bdev.bd_disk\n                 continue\n         part = container_of(device, \"struct hd_struct\", \"__dev\")\ndiff --git a/tests/linux_kernel/helpers/test_block.py b/tests/linux_kernel/helpers/test_block.py\nindex dec344fc..4412eaa0 100644\n--- a/tests/linux_kernel/helpers/test_block.py\n+++ b/tests/linux_kernel/helpers/test_block.py\n@@ -4,7 +4,9 @@\n import os\n import os.path\n \n+from drgn import Object\n from drgn.helpers.linux.block import (\n+    bdev_partno,\n     disk_devt,\n     disk_name,\n     for_each_disk,\n@@ -44,3 +46,17 @@ class TestBlock(LinuxKernelTestCase):\n             {part_name(part).decode() for part in for_each_partition(self.prog)},\n             set(os.listdir(\"/sys/class/block\")),\n         )\n+\n+    def test_bdev_partno(self):\n+        for part in for_each_partition(self.prog):\n+            try:\n+                with open(\n+                    os.path.join(b\"/sys/class/block\", part_name(part), b\"partition\"),\n+                    \"r\",\n+                ) as f:\n+                    partition = int(f.read())\n+            except FileNotFoundError:\n+                partition = 0\n+            if part.type_.type.tag == \"hd_struct\":\n+                self.skipTest(\"can't get bdev easily on old kernels\")\n+            self.assertIdentical(bdev_partno(part), Object(self.prog, \"u8\", partition))\n"}
{"repo": "drgn", "commit": "3cd224ece91b3ee909907523b67494b85ebc0424", "diff": "diff --git a/docs/exts/drgndoc/format.py b/docs/exts/drgndoc/format.py\nindex 96f3bcc4..6d45205a 100644\n--- a/docs/exts/drgndoc/format.py\n+++ b/docs/exts/drgndoc/format.py\n@@ -132,7 +132,7 @@ class _FormatVisitor(NodeVisitor):\n         while True:\n             value = node.value\n             if isinstance(value, ast.Attribute):\n-                name_stack.append(node.attr)\n+                name_stack.append(value.attr)\n                 node = value\n                 continue\n             elif isinstance(value, ast.Name):\n"}
{"repo": "drgn", "commit": "2c13112fc62db963ab3707fcd4e29e11069c8c9b", "diff": "diff --git a/contrib/btrfs_tree.py b/contrib/btrfs_tree.py\nindex 3610b018..ca8349be 100644\n--- a/contrib/btrfs_tree.py\n+++ b/contrib/btrfs_tree.py\n@@ -613,7 +613,7 @@ def _print_inode_item(\n {indent}ctime {item.ctime}\n {indent}mtime {item.mtime}\n {indent}otime {item.otime}\n-        \"\"\",\n+\"\"\",\n         end=\"\",\n         file=file,\n     )\n"}
{"repo": "drgn", "commit": "eb485dac65a3751c1d442902de7255f501d4eac5", "diff": "diff --git a/contrib/gcore.py b/contrib/gcore.py\nindex 996399df..8f05b47e 100755\n--- a/contrib/gcore.py\n+++ b/contrib/gcore.py\n@@ -157,7 +157,7 @@ def vma_snapshot(\n \n         if file:\n             path = d_path(file.f_path)\n-            offset = vma.vm_pgoff.value_()\n+            offset = vma.vm_pgoff.value_() * page_size\n             if (\n                 mapped_files\n                 and mapped_files[-1].path == path\n@@ -293,9 +293,9 @@ def nt_auxv(task: Object) -> bytes:\n     return prog.read(auxv.address_, auxv[i + 2].address_ - auxv.address_)\n \n \n-def nt_file(mapped_files: Sequence[MappedFile]) -> bytes:\n+def nt_file(mapped_files: Sequence[MappedFile], page_size: int) -> bytes:\n     buf = bytearray(16 + 24 * len(mapped_files))\n-    struct.pack_into(\"QQ\", buf, 0, len(mapped_files), 4096)\n+    struct.pack_into(\"QQ\", buf, 0, len(mapped_files), page_size)\n     for i, mapped_file in enumerate(mapped_files):\n         struct.pack_into(\n             \"QQQ\",\n@@ -303,7 +303,7 @@ def nt_file(mapped_files: Sequence[MappedFile]) -> bytes:\n             16 + 24 * i,\n             mapped_file.start,\n             mapped_file.end,\n-            mapped_file.offset // 4096,\n+            mapped_file.offset // page_size,\n         )\n     for mapped_file in mapped_files:\n         buf.extend(mapped_file.path)\n@@ -312,7 +312,7 @@ def nt_file(mapped_files: Sequence[MappedFile]) -> bytes:\n \n \n def gen_notes(\n-    task: Object, mapped_files: Sequence[MappedFile], use_procfs: bool\n+    task: Object, mapped_files: Sequence[MappedFile], page_size: int, use_procfs: bool\n ) -> bytearray:\n     notes = []\n \n@@ -355,7 +355,7 @@ def gen_notes(\n         (\n             b\"CORE\",\n             0x46494C45,  # NT_FILE\n-            nt_file(mapped_files),\n+            nt_file(mapped_files, page_size),\n         )\n     )\n \n@@ -465,7 +465,7 @@ def main(prog: Program, argv: Sequence[str]) -> None:\n         sys.exit(f\"PID {args.pid} not found\")\n \n     segments, mapped_files = vma_snapshot(page_size, task)\n-    notes = gen_notes(task, mapped_files, args.use_procfs)\n+    notes = gen_notes(task, mapped_files, page_size, args.use_procfs)\n \n     with contextlib.ExitStack() as exit_stack:\n         if args.use_procfs:\n"}
{"repo": "drgn", "commit": "a6b25064568cce7f26a762a2ee319de95c74e2f6", "diff": "diff --git a/contrib/irq.py b/contrib/irq.py\nindex 758cadf6..8af808af 100644\n--- a/contrib/irq.py\n+++ b/contrib/irq.py\n@@ -5,6 +5,7 @@\n \"\"\" Script to dump irq stats using drgn\"\"\"\n \n from typing import Iterator\n+from typing import Tuple\n \n from drgn import NULL\n from drgn import Object\n@@ -12,17 +13,27 @@ from drgn import Program\n from drgn.helpers.common.format import escape_ascii_string\n from drgn.helpers.linux.cpumask import for_each_present_cpu\n from drgn.helpers.linux.cpumask import cpumask_to_cpulist\n+from drgn.helpers.linux.mapletree import mtree_load\n+from drgn.helpers.linux.mapletree import mt_for_each\n from drgn.helpers.linux.percpu import per_cpu_ptr\n from drgn.helpers.linux.radixtree import radix_tree_for_each\n from drgn.helpers.linux.radixtree import radix_tree_lookup\n \n \n-def _sparse_irq_supported(prog: Program) -> bool:\n+def _sparse_irq_supported(prog: Program) -> Tuple[bool, str]:\n     try:\n-        _ = prog[\"irq_desc_tree\"]\n-        return True\n+        # Since Linux kernel commit 721255b9826b (\"genirq: Use a maple\n+        # tree for interrupt descriptor management\") (in v6.5), sparse\n+        # irq descriptors are stored in a maple tree.\n+        _ = prog[\"sparse_irqs\"]\n+        return True, \"maple\"\n     except KeyError:\n-        return False\n+        # Before that, they are in radix tree.\n+        try:\n+            _ = prog[\"irq_desc_tree\"]\n+            return True, \"radix\"\n+        except KeyError:\n+            return False, None\n \n \n def _kstat_irqs_cpu(prog: Program, irq: int, cpu: int) -> int:\n@@ -73,10 +84,16 @@ def for_each_irq(prog: Program) -> Iterator[int]:\n \n     :return: Iterator of irq numbers\n     \"\"\"\n-    if _sparse_irq_supported(prog):\n+    _, tree_type = _sparse_irq_supported(prog)\n+\n+    if tree_type == \"radix\":\n         irq_desc_tree = prog[\"irq_desc_tree\"].address_of_()\n         for irq, _ in radix_tree_for_each(irq_desc_tree):\n             yield irq\n+    elif tree_type == \"maple\":\n+        irq_desc_tree = prog[\"sparse_irqs\"].address_of_()\n+        for irq, _, _ in mt_for_each(irq_desc_tree):\n+            yield irq\n     else:\n         count = len(prog[\"irq_desc\"])\n         for irq_num in range(count):\n@@ -91,12 +108,16 @@ def for_each_irq_desc(prog: Program) -> Iterator[Object]:\n \n     :return: Iterator of ``struct irq_desc *`` objects.\n     \"\"\"\n-    if _sparse_irq_supported(prog):\n+    _, tree_type = _sparse_irq_supported(prog)\n+    if tree_type == \"radix\":\n         irq_desc_tree = prog[\"irq_desc_tree\"].address_of_()\n         for _, addr in radix_tree_for_each(irq_desc_tree):\n-            irq_desc = Object(\n-                prog, \"struct irq_desc\", address=addr\n-            ).address_of_()\n+            irq_desc = Object(prog, \"struct irq_desc\", address=addr).address_of_()\n+            yield irq_desc\n+    elif tree_type == \"maple\":\n+        irq_desc_tree = prog[\"sparse_irqs\"].address_of_()\n+        for _, _, addr in mt_for_each(irq_desc_tree):\n+            irq_desc = Object(prog, \"struct irq_desc\", address=addr).address_of_()\n             yield irq_desc\n     else:\n         count = len(prog[\"irq_desc\"])\n@@ -131,8 +152,14 @@ def irq_to_desc(prog: Program, irq: int) -> Object:\n     :return: ``struct irq_desc *`` object if irq descriptor is found.\n              NULL otherwise\n     \"\"\"\n-    if _sparse_irq_supported(prog):\n-        addr = radix_tree_lookup(prog[\"irq_desc_tree\"].address_of_(), irq)\n+    _, tree_type = _sparse_irq_supported(prog)\n+\n+    if tree_type:\n+        if tree_type == \"radix\":\n+            addr = radix_tree_lookup(prog[\"irq_desc_tree\"].address_of_(), irq)\n+        else:\n+            addr = mtree_load(prog[\"sparse_irqs\"].address_of_(), irq)\n+\n         if addr:\n             return Object(prog, \"struct irq_desc\", address=addr).address_of_()\n         else:\n@@ -193,6 +220,7 @@ def get_irq_affinity_list(prog: Program, irq: int) -> Object:\n     else:\n         return None\n \n+\n def show_irq_num_stats(prog: Program, irq: int) -> None:\n     \"\"\"\n     Show stats for a given irq number\n"}
{"repo": "drgn", "commit": "7e60bc7ac367845662c89a695a47fadb628a4651", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 95b9f12a..93b5463a 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -39,7 +39,7 @@ SUPPORTED_KERNEL_VERSIONS = (\n )\n \n KERNEL_ORG_COMPILER_VERSION = \"12.2.0\"\n-VMTEST_KERNEL_VERSION = 28\n+VMTEST_KERNEL_VERSION = 29\n \n \n BASE_KCONFIG = \"\"\"\ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 782b63cb..45e0ebee 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -130,6 +130,10 @@ _PATCHES = (\n         name=\"s390-kernel-emit-CFI-data-in-.debug_frame-and-discar.patch\",\n         versions=((None, KernelVersion(\"4.15\")),),\n     ),\n+    _Patch(\n+        name=\"s390-crash-fix-proc-vmcore-reads.patch\",\n+        versions=((KernelVersion(\"5.18\"), KernelVersion(\"6.0\")),),\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "b568474a142c82b774b13947285261f5759aea79", "diff": "diff --git a/vmtest/__main__.py b/vmtest/__main__.py\nindex 86292fb7..97b594c1 100644\n--- a/vmtest/__main__.py\n+++ b/vmtest/__main__.py\n@@ -7,6 +7,7 @@ from pathlib import Path\n import shlex\n import subprocess\n import sys\n+from typing import Dict, List, TextIO\n \n from util import KernelVersion\n from vmtest.config import (\n@@ -16,7 +17,12 @@ from vmtest.config import (\n     SUPPORTED_KERNEL_VERSIONS,\n     Kernel,\n )\n-from vmtest.download import DownloadCompiler, DownloadKernel, download_in_thread\n+from vmtest.download import (\n+    Download,\n+    DownloadCompiler,\n+    DownloadKernel,\n+    download_in_thread,\n+)\n from vmtest.kmod import build_kmod\n from vmtest.rootfsbuild import build_drgn_in_rootfs\n from vmtest.vm import LostVMError, run_in_vm\n@@ -25,7 +31,7 @@ logger = logging.getLogger(__name__)\n \n \n class _ProgressPrinter:\n-    def __init__(self, file):\n+    def __init__(self, file: TextIO) -> None:\n         self._file = file\n         if hasattr(file, \"fileno\"):\n             try:\n@@ -35,8 +41,8 @@ class _ProgressPrinter:\n                 columns = 80\n                 self._color = False\n         self._header = \"#\" * columns\n-        self._passed = {}\n-        self._failed = {}\n+        self._passed: Dict[str, List[str]] = {}\n+        self._failed: Dict[str, List[str]] = {}\n \n     def _green(self, s: str) -> str:\n         if self._color:\n@@ -50,7 +56,7 @@ class _ProgressPrinter:\n         else:\n             return s\n \n-    def update(self, category: str, name: str, passed: bool):\n+    def update(self, category: str, name: str, passed: bool) -> None:\n         d = self._passed if passed else self._failed\n         d.setdefault(category, []).append(name)\n \n@@ -162,7 +168,7 @@ if __name__ == \"__main__\":\n     )\n     args = parser.parse_args()\n \n-    architecture_names = []\n+    architecture_names: List[str] = []\n     if hasattr(args, \"architectures\"):\n         for name in args.architectures:\n             if name == \"all\":\n@@ -181,6 +187,7 @@ if __name__ == \"__main__\":\n             ARCHITECTURES[name] for name in OrderedDict.fromkeys(architecture_names)\n         ]\n     else:\n+        assert HOST_ARCHITECTURE is not None\n         architectures = [HOST_ARCHITECTURE]\n \n     if hasattr(args, \"kernels\"):\n@@ -208,7 +215,7 @@ if __name__ == \"__main__\":\n         parser.error(\"at least one of -k/--kernel or -l/--local is required\")\n \n     if args.kernels:\n-        to_download = [DownloadCompiler(arch) for arch in architectures]\n+        to_download: List[Download] = [DownloadCompiler(arch) for arch in architectures]\n         for pattern in args.kernels:\n             for arch in architectures:\n                 to_download.append(DownloadKernel(arch, pattern))\ndiff --git a/vmtest/enter_kdump.py b/vmtest/enter_kdump.py\nindex ce4af17c..8cf59792 100644\n--- a/vmtest/enter_kdump.py\n+++ b/vmtest/enter_kdump.py\n@@ -12,7 +12,7 @@ KEXEC_FILE_ON_CRASH = 2\n KEXEC_FILE_NO_INITRAMFS = 4\n \n \n-def main():\n+def main() -> None:\n     with open(\"/proc/cmdline\", \"rb\") as f:\n         cmdline = f.read().rstrip(b\"\\n\")\n         cmdline = re.sub(rb\"(^|\\s)crashkernel=\\S+\", b\"\", cmdline)\n"}
{"repo": "drgn", "commit": "85bb738a9ffdfe4b205122441f3036be45560475", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 17f6fbb0..014dfe44 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -39,7 +39,7 @@ SUPPORTED_KERNEL_VERSIONS = (\n )\n \n KERNEL_ORG_COMPILER_VERSION = \"12.2.0\"\n-VMTEST_KERNEL_VERSION = 26\n+VMTEST_KERNEL_VERSION = 27\n \n \n BASE_KCONFIG = \"\"\"\ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 4457bedc..de5db08f 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -106,6 +106,22 @@ _PATCHES = (\n         name=\"sched-work-around-mystery-QEMU-hang.patch\",\n         versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.14\")),),\n     ),\n+    _Patch(\n+        name=\"5.4-arm64-build-Remove-.eh_frame-sections-due-to-unwind-.patch\",\n+        versions=((KernelVersion(\"5.4\"), KernelVersion(\"5.5\")),),\n+    ),\n+    _Patch(\n+        name=\"4.19-arm64-build-Remove-.eh_frame-sections-due-to-unwind-.patch\",\n+        versions=((KernelVersion(\"4.19.15\"), KernelVersion(\"4.20\")),),\n+    ),\n+    _Patch(\n+        name=\"4.14-arm64-build-Remove-.eh_frame-sections-due-to-unwind-.patch\",\n+        versions=((KernelVersion(\"4.14.93\"), KernelVersion(\"4.15\")),),\n+    ),\n+    _Patch(\n+        name=\"4.9-arm64-build-Remove-.eh_frame-sections-due-to-unwind-.patch\",\n+        versions=((KernelVersion(\"4.9\"), KernelVersion(\"4.10\")),),\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "52c2a1c4b3e5a9b3551d35629f3d7ed24f2dfb75", "diff": "diff --git a/vmtest/vm.py b/vmtest/vm.py\nindex 6ad10d62..74af10ee 100644\n--- a/vmtest/vm.py\n+++ b/vmtest/vm.py\n@@ -5,6 +5,7 @@ import os\n from pathlib import Path\n import re\n import shlex\n+import signal\n import socket\n import subprocess\n import sys\n@@ -285,7 +286,9 @@ def run_in_vm(\n         with disk_path.open(\"wb\") as f:\n             os.ftruncate(f.fileno(), 1024 * 1024 * 1024)\n \n-        with subprocess.Popen(\n+        signal.signal(signal.SIGTERM, lambda *_: sys.exit(1))\n+\n+        proc = subprocess.Popen(\n             [\n                 # fmt: off\n                 *unshare_args,\n@@ -322,7 +325,8 @@ def run_in_vm(\n                 # fmt: on\n             ],\n             env=env,\n-        ):\n+        )\n+        try:\n             server_sock.settimeout(5)\n             try:\n                 sock = server_sock.accept()[0]\n@@ -342,6 +346,11 @@ def run_in_vm(\n                     status_buf.extend(buf)\n             finally:\n                 sock.close()\n+        except BaseException:\n+            proc.terminate()\n+            raise\n+        finally:\n+            proc.wait()\n         if not status_buf:\n             raise LostVMError(\"VM did not return status\")\n         if status_buf[-1] != ord(\"\\n\") or not status_buf[:-1].isdigit():\n"}
{"repo": "drgn", "commit": "0e4d69472bfe87f64c0af7549d77c6683593a2ec", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 406d5650..7c08e280 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -74,7 +74,7 @@ CONFIG_VIRTIO_PCI=y\n CONFIG_HW_RANDOM=m\n CONFIG_HW_RANDOM_VIRTIO=m\n \n-# Lots of stuff expect Unix sockets.\n+# Lots of things expect Unix sockets.\n CONFIG_UNIX=y\n \n # drgn needs debug info.\n"}
{"repo": "drgn", "commit": "241afd5b62579bc49ec85f761ff9aed644514601", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 06c3c197..2bbfcec3 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -345,6 +345,7 @@ def run_interactive(\n         \"__doc__\": None,\n     }\n     drgn_globals = [\n+        \"FaultError\",\n         \"NULL\",\n         \"Object\",\n         \"cast\",\n"}
{"repo": "drgn", "commit": "2ebdc103ba2f7abdc18c1a19f3c19f8cca66b44b", "diff": "diff --git a/docs/exts/linuxsrc.py b/docs/exts/linuxsrc.py\nindex 04e8f503..954d3608 100644\n--- a/docs/exts/linuxsrc.py\n+++ b/docs/exts/linuxsrc.py\n@@ -31,10 +31,10 @@ as inline text instead of inline code.\n \"\"\"\n \n import re\n-from typing import Any, Dict, List, Optional, Tuple, Type\n+from typing import Any, Dict, List, Tuple\n \n from docutils import nodes\n-from docutils.nodes import Element, Node, system_message\n+from docutils.nodes import Node, system_message\n import sphinx.application\n import sphinx.util.docutils\n \n"}
{"repo": "drgn", "commit": "35bc08e4b46d6358ac758b0affde73954788547b", "diff": "diff --git a/contrib/btrfs_orphan_subvolumes.py b/contrib/btrfs_orphan_subvolumes.py\nindex 1b23eb52..21ab0df2 100755\n--- a/contrib/btrfs_orphan_subvolumes.py\n+++ b/contrib/btrfs_orphan_subvolumes.py\n@@ -11,6 +11,7 @@ from drgn.helpers.linux.rbtree import rbtree_inorder_for_each_entry\n \n \n def dump_orphan_subvolumes(fs_info: Object) -> None:\n+    prog = fs_info.prog_\n     BTRFS_ROOT_ORPHAN_ITEM_INSERTED = prog[\"BTRFS_ROOT_ORPHAN_ITEM_INSERTED\"]\n     for objectid, entry in radix_tree_for_each(fs_info.fs_roots_radix):\n         root = cast(\"struct btrfs_root *\", entry)\n"}
{"repo": "drgn", "commit": "7c881f105c15f64991c05ef46fc964ab63014584", "diff": "diff --git a/drgn/helpers/common/prog.py b/drgn/helpers/common/prog.py\nindex 23d90e96..5f3ce15d 100644\n--- a/drgn/helpers/common/prog.py\n+++ b/drgn/helpers/common/prog.py\n@@ -20,18 +20,15 @@ __all__ = (\n     \"takes_program_or_default\",\n )\n \n-# This would require Python 3.10, but we don't need any of it at runtime.\n+# We don't need any of this at runtime.\n if typing.TYPE_CHECKING:\n-    from typing import (  # novermin\n-        Any,\n-        Callable,\n-        Concatenate,\n-        Optional,\n-        ParamSpec,\n-        Protocol,\n-        TypeVar,\n-        overload,\n-    )\n+    import sys\n+    from typing import Any, Optional, Protocol, TypeVar, overload  # novermin\n+\n+    if sys.version_info < (3, 10):\n+        from typing_extensions import Callable, Concatenate, ParamSpec\n+    else:\n+        from typing import Callable, Concatenate, ParamSpec  # novermin\n \n     P = ParamSpec(\"P\")\n     R = TypeVar(\"R\")\n"}
{"repo": "drgn", "commit": "c3449b85eb1fdbbff2b8c91c8939fc375454bc7e", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 44839ec3..a2ea78c0 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -240,7 +240,7 @@ def _main() -> None:\n         try:\n             script_type = _identify_script(args.script[0])\n         except OSError as e:\n-            sys.exit(e)\n+            sys.exit(str(e))\n         if script_type == \"core\":\n             sys.exit(\n                 f\"error: {args.script[0]} is a core dump\\n\"\n@@ -280,7 +280,7 @@ def _main() -> None:\n                 else:\n                     prog.set_core_dump(open_via_sudo(\"/proc/kcore\", os.O_RDONLY))\n     except OSError as e:\n-        sys.exit(e)\n+        sys.exit(str(e))\n     except ValueError as e:\n         # E.g., \"not an ELF core file\"\n         sys.exit(f\"error: {e}\")\ndiff --git a/drgn/helpers/common/format.py b/drgn/helpers/common/format.py\nindex 2497a02f..489ff08b 100644\n--- a/drgn/helpers/common/format.py\n+++ b/drgn/helpers/common/format.py\n@@ -232,7 +232,7 @@ def number_in_binary_units(n: SupportsFloat, precision: int = 1) -> str:\n     for prefix in (\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\"):\n         if abs(n) < 1024:\n             break\n-        n /= 1024\n+        n /= 1024.0\n     else:\n         prefix = \"Y\"\n     if n.is_integer():\n"}
{"repo": "drgn", "commit": "a1a6dd607660ec3a274e025663aa383ec0f74878", "diff": "diff --git a/docs/exts/setuptools_config.py b/docs/exts/setuptools_config.py\nindex 13272e52..1f47d937 100644\n--- a/docs/exts/setuptools_config.py\n+++ b/docs/exts/setuptools_config.py\n@@ -1,6 +1,6 @@\n # Copyright Jason R. Coombs\n # SPDX-License-Identifier: MIT\n-# From https://pypi.org/project/jaraco.packaging/.\n+# Based on https://pypi.org/project/jaraco.packaging/.\n \n from __future__ import unicode_literals\n \n@@ -14,13 +14,13 @@ if \"check_output\" not in dir(subprocess):\n \n def setup(app):\n     app.add_config_value(\"package_url\", \"\", \"\")\n-    app.connect(\"builder-inited\", load_config_from_setup)\n+    app.connect(\"config-inited\", load_config_from_setup)\n     app.connect(\"html-page-context\", add_package_url)\n \n \n-def load_config_from_setup(app):\n+def load_config_from_setup(app, config):\n     \"\"\"\n-    Replace values in app.config from package metadata\n+    Replace values in config from package metadata\n     \"\"\"\n     # for now, assume project root is one level up\n     root = os.path.join(app.confdir, \"..\")\n@@ -30,10 +30,10 @@ def load_config_from_setup(app):\n     output = subprocess.check_output(dist_info_cmd, cwd=root, universal_newlines=True)\n     outputs = output.strip().split(\"\\n\")\n     project, version, url, author = outputs\n-    app.config.project = project\n-    app.config.version = app.config.release = version\n-    app.config.package_url = url\n-    app.config.author = app.config.copyright = author\n+    config.project = project\n+    config.version = config.release = version\n+    config.package_url = url\n+    config.author = config.copyright = author\n \n \n def add_package_url(app, pagename, templatename, context, doctree):\n"}
{"repo": "drgn", "commit": "d9ec78afa1fbe1cb6d22f78209657b10cc6f1634", "diff": "diff --git a/drgn/helpers/linux/device.py b/drgn/helpers/linux/device.py\nindex 8e8c14d5..0705052f 100644\n--- a/drgn/helpers/linux/device.py\n+++ b/drgn/helpers/linux/device.py\n@@ -29,7 +29,7 @@ def MAJOR(dev: IntegerLike) -> int:\n     \"\"\"\n     Return the major ID of a kernel ``dev_t``.\n \n-    :param dev: ``dev_t`` object or :class:``int``.\n+    :param dev: ``dev_t`` object or :class:`int`.\n     \"\"\"\n     return operator.index(dev) >> _MINORBITS\n \n@@ -38,7 +38,7 @@ def MINOR(dev: IntegerLike) -> int:\n     \"\"\"\n     Return the minor ID of a kernel ``dev_t``.\n \n-    :param dev: ``dev_t`` object or :class:``int``.\n+    :param dev: ``dev_t`` object or :class:`int`.\n     \"\"\"\n     return operator.index(dev) & _MINORMASK\n \n"}
{"repo": "drgn", "commit": "a2bd731d98084abd7574d95179d88891c241a11e", "diff": "diff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex 62607b89..6cfd8db7 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -79,16 +79,13 @@ class DrgnDocBuildEnvironment(sphinx.environment.BuildEnvironment):\n def drgndoc_init(app: sphinx.application.Sphinx) -> None:\n     env = cast(DrgnDocBuildEnvironment, app.env)\n \n-    paths = [\n-        os.path.join(app.confdir, path)\n-        for path in app.config.drgndoc_paths  # type: ignore\n-    ]\n+    paths = [os.path.join(app.confdir, path) for path in app.config.drgndoc_paths]\n     env.drgndoc_namespace = Namespace(parse_paths(paths, logger.warning))\n     env.drgndoc_formatter = Formatter(\n         env.drgndoc_namespace,\n         [\n             (re.compile(pattern), repl)\n-            for pattern, repl in app.config.drgndoc_substitutions  # type: ignore\n+            for pattern, repl in app.config.drgndoc_substitutions\n         ],\n     )\n \ndiff --git a/docs/exts/drgndoc/format.py b/docs/exts/drgndoc/format.py\nindex 1306d272..fb823852 100644\n--- a/docs/exts/drgndoc/format.py\n+++ b/docs/exts/drgndoc/format.py\n@@ -38,7 +38,9 @@ class _FormatVisitor(NodeVisitor):\n         self._context_class = context_class\n         self._parts: List[str] = []\n \n-    def visit(self, node: ast.AST, rst: bool, qualify_typing: bool) -> str:\n+    def visit(  # type: ignore[override]  # This is intentionally incompatible with the supertype.\n+        self, node: ast.AST, rst: bool, qualify_typing: bool\n+    ) -> str:\n         self._rst = rst\n         self._qualify_typing = qualify_typing\n         super().visit(node)\ndiff --git a/docs/exts/drgndoc/parse.py b/docs/exts/drgndoc/parse.py\nindex 153acf92..41dc9c50 100644\n--- a/docs/exts/drgndoc/parse.py\n+++ b/docs/exts/drgndoc/parse.py\n@@ -35,9 +35,7 @@ class _PreTransformer(ast.NodeTransformer):\n \n     def _visit_annotation(self, node: Optional[ast.expr]) -> Optional[ast.expr]:\n         if isinstance(node, ast.Constant) and isinstance(node.value, str):\n-            node = self.visit(\n-                cast(ast.Expression, ast.parse(node.value, \"<string>\", \"eval\")).body\n-            )\n+            node = self.visit(ast.parse(node.value, \"<string>\", \"eval\").body)\n         return node\n \n     def visit_arg(self, node: ast.arg) -> ast.arg:\n"}
{"repo": "drgn", "commit": "6668618b2d2817caa4c498f5adf6f83a44edaddc", "diff": "diff --git a/libdrgn/build-aux/gen_elf_sections.py b/libdrgn/build-aux/gen_elf_sections.py\nindex 1d8ecd96..56fa3ab6 100755\n--- a/libdrgn/build-aux/gen_elf_sections.py\n+++ b/libdrgn/build-aux/gen_elf_sections.py\n@@ -15,8 +15,6 @@ DWARF_INDEX_SECTIONS = (\n     \".debug_abbrev\",\n     \".debug_str\",\n     \".debug_str_offsets\",\n-    \".debug_line\",\n-    \".debug_line_str\",\n )\n \n CACHED_SECTIONS = (\n"}
{"repo": "drgn", "commit": "26ec38fcf01f5cf36a4377d8ed997a45985f27db", "diff": "diff --git a/scripts/gen_tests_elf_py.py b/scripts/gen_tests_elf_py.py\nindex 8fdf271a..24dc6724 100755\n--- a/scripts/gen_tests_elf_py.py\n+++ b/scripts/gen_tests_elf_py.py\n@@ -3,15 +3,13 @@\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n import argparse\n-import subprocess\n import re\n+import subprocess\n import sys\n \n \n def main() -> None:\n-    argparse.ArgumentParser(\n-        description=\"Generate tests/elf.py from elf.h\"\n-    ).parse_args()\n+    argparse.ArgumentParser(description=\"Generate tests/elf.py from elf.h\").parse_args()\n \n     contents = subprocess.check_output(\n         [\"gcc\", \"-dD\", \"-E\", \"-\"],\n"}
{"repo": "drgn", "commit": "3afa6b266515dff2df8fa11028154cfe58704a18", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex e0a15faa..1b327937 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -112,7 +112,7 @@ async def apply_patches(kernel_dir: Path) -> None:\n         .decode()\n         .strip()\n     )\n-    logging.info(\"applying patches for kernel version %s\", version)\n+    logger.info(\"applying patches for kernel version %s\", version)\n     any_applied = False\n     for patch in _PATCHES:\n         for min_version, max_version in patch.versions:\n@@ -122,7 +122,7 @@ async def apply_patches(kernel_dir: Path) -> None:\n                 break\n         else:\n             continue\n-        logging.info(\"applying %s\", patch.name)\n+        logger.info(\"applying %s\", patch.name)\n         any_applied = True\n         proc = await asyncio.create_subprocess_exec(\n             \"git\",\n@@ -147,9 +147,9 @@ async def apply_patches(kernel_dir: Path) -> None:\n                 sys.stderr.buffer.write(stderr)\n                 sys.stderr.buffer.flush()\n                 raise\n-            logging.info(\"already applied\")\n+            logger.info(\"already applied\")\n     if not any_applied:\n-        logging.info(\"no patches\")\n+        logger.info(\"no patches\")\n \n \n class KBuild:\ndiff --git a/vmtest/kmod.py b/vmtest/kmod.py\nindex c35d63df..9e686917 100644\n--- a/vmtest/kmod.py\n+++ b/vmtest/kmod.py\n@@ -23,7 +23,7 @@ def build_kmod(download_dir: Path, kernel: Kernel) -> Path:\n     kmod_source_dir = Path(\"tests/linux_kernel/kmod\")\n     source_files = (\"drgn_test.c\", \"Makefile\")\n     if out_of_date(kmod, *[kmod_source_dir / filename for filename in source_files]):\n-        logging.info(\"building %s\", kmod)\n+        logger.info(\"building %s\", kmod)\n \n         compiler = downloaded_compiler(download_dir, kernel.arch)\n         kernel_build_dir = kernel.path / \"build\"\n@@ -55,7 +55,7 @@ def build_kmod(download_dir: Path, kernel: Kernel) -> Path:\n             )\n             (tmp_dir / \"drgn_test.ko\").rename(kmod)\n     else:\n-        logging.info(\"%s is up to date\", kmod)\n+        logger.info(\"%s is up to date\", kmod)\n     return kmod\n \n \ndiff --git a/vmtest/manage.py b/vmtest/manage.py\nindex 9b9669ed..941b2710 100644\n--- a/vmtest/manage.py\n+++ b/vmtest/manage.py\n@@ -360,7 +360,7 @@ async def main() -> None:\n         if to_build:\n             logger.info(\"kernel versions to build:\")\n             for tag, tag_arches_to_build in to_build:\n-                logging.info(\n+                logger.info(\n                     \"  %s (%s)\",\n                     tag,\n                     \", \".join(\n"}
{"repo": "drgn", "commit": "a66d033f1ceab116d3a7a8271199a459ca61c930", "diff": "diff --git a/tests/linux_kernel/test_stack_trace.py b/tests/linux_kernel/test_stack_trace.py\nindex 393fe80c..620ff587 100644\n--- a/tests/linux_kernel/test_stack_trace.py\n+++ b/tests/linux_kernel/test_stack_trace.py\n@@ -43,7 +43,7 @@ class TestStackTrace(LinuxKernelTestCase):\n                 prog.set_kernel()\n                 self._load_debug_info(prog)\n             self._test_drgn_test_kthread_trace(\n-                self.prog.stack_trace(self.prog[\"drgn_test_kthread\"].pid)\n+                prog.stack_trace(prog[\"drgn_test_kthread\"].pid)\n             )\n \n     @skip_unless_have_test_kmod\n"}
{"repo": "drgn", "commit": "bc8514512f3262c7a8fc5867302bf0b0b303ee41", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 9094fe37..12357445 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -1013,6 +1013,120 @@ class TestTypes(TestCase):\n                     ),\n                 )\n \n+    def test_incomplete_to_complete_nested(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                DwarfDie(\n+                    DW_TAG.pointer_type,\n+                    (\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 8),\n+                        DwarfAttrib(DW_AT.type, DW_FORM.ref4, \"incomplete_class_die\"),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.class_type,\n+                    (\n+                        DwarfAttrib(DW_AT.name, DW_FORM.string, \"Foo\"),\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 0),\n+                    ),\n+                    (\n+                        DwarfLabel(\"incomplete_class_die\"),\n+                        DwarfDie(\n+                            DW_TAG.class_type,\n+                            (\n+                                DwarfAttrib(DW_AT.name, DW_FORM.string, \"Bar\"),\n+                                DwarfAttrib(\n+                                    DW_AT.declaration, DW_FORM.flag_present, True\n+                                ),\n+                            ),\n+                        ),\n+                        DwarfDie(\n+                            DW_TAG.class_type,\n+                            (\n+                                DwarfAttrib(DW_AT.name, DW_FORM.string, \"Bar\"),\n+                                DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 0),\n+                            ),\n+                        ),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.class_type,\n+                    (\n+                        DwarfAttrib(DW_AT.name, DW_FORM.string, \"Bar\"),\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 1),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.subprogram,\n+                    (DwarfAttrib(DW_AT.name, DW_FORM.string, \"main\"),),\n+                ),\n+            ),\n+            lang=DW_LANG.C_plus_plus,\n+        )\n+        self.assertIdentical(\n+            prog.type(\"TEST\").type.type,\n+            prog.class_type(\"Bar\", 0, ()),\n+        )\n+\n+    def test_incomplete_to_complete_nested_specification(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                DwarfDie(\n+                    DW_TAG.pointer_type,\n+                    (\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 8),\n+                        DwarfAttrib(DW_AT.type, DW_FORM.ref4, \"incomplete_class_die\"),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.class_type,\n+                    (\n+                        DwarfAttrib(DW_AT.name, DW_FORM.string, \"Foo\"),\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 0),\n+                    ),\n+                    (\n+                        DwarfLabel(\"incomplete_class_die\"),\n+                        DwarfDie(\n+                            DW_TAG.class_type,\n+                            (\n+                                DwarfAttrib(DW_AT.name, DW_FORM.string, \"Bar\"),\n+                                DwarfAttrib(\n+                                    DW_AT.declaration, DW_FORM.flag_present, True\n+                                ),\n+                            ),\n+                        ),\n+                        DwarfDie(\n+                            DW_TAG.class_type,\n+                            (\n+                                DwarfAttrib(\n+                                    DW_AT.specification,\n+                                    DW_FORM.ref4,\n+                                    \"incomplete_class_die\",\n+                                ),\n+                                DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 0),\n+                            ),\n+                        ),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.class_type,\n+                    (\n+                        DwarfAttrib(DW_AT.name, DW_FORM.string, \"Bar\"),\n+                        DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 1),\n+                    ),\n+                ),\n+                DwarfDie(\n+                    DW_TAG.subprogram,\n+                    (DwarfAttrib(DW_AT.name, DW_FORM.string, \"main\"),),\n+                ),\n+            ),\n+            lang=DW_LANG.C_plus_plus,\n+        )\n+        self.assertIdentical(\n+            prog.type(\"TEST\").type.type,\n+            prog.class_type(\"Bar\", 0, ()),\n+        )\n+\n     def test_filename(self):\n         dies = (\n             DwarfDie(\n"}
{"repo": "drgn", "commit": "3ce37c80027411e2a255280ab99fc8b8cf18283c", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 848c2160..e8e54e99 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -918,6 +918,28 @@ class TestValue(MockProgramTestCase):\n         self.assertIdentical(obj.x, Object(self.prog, \"int\", value=100))\n         self.assertIdentical(obj.y, Object(self.prog, \"int\", value=-5))\n \n+    def test_compound_float(self):\n+        for byteorder in (\"little\", \"big\"):\n+            for type in (\n+                self.prog.float_type(\"double\", 8, byteorder),\n+                self.prog.float_type(\"float\", 4, byteorder),\n+            ):\n+                with self.subTest(byteorder=byteorder, type=type.name):\n+                    obj = Object(\n+                        self.prog,\n+                        self.prog.struct_type(\n+                            None,\n+                            type.size * 2,\n+                            (\n+                                TypeMember(type, \"a\"),\n+                                TypeMember(type, \"b\", type.size * 8),\n+                            ),\n+                        ),\n+                        value={\"a\": 1234, \"b\": -3.125},\n+                    )\n+                    self.assertEqual(obj.a.value_(), 1234.0)\n+                    self.assertEqual(obj.b.value_(), -3.125)\n+\n     def test_pointer(self):\n         obj = Object(self.prog, \"int *\", value=0xFFFF0000)\n         self.assertFalse(obj.absent_)\n"}
{"repo": "drgn", "commit": "0bc79c877ad2eb260374c8e8015399575201a5e4", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 1294abfe..848c2160 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -141,6 +141,72 @@ class TestInit(MockProgramTestCase):\n         )\n \n \n+def _int_bits_cases(prog):\n+    for signed in (True, False):\n+        for byteorder in (\"little\", \"big\"):\n+            for bit_size in range(1, 65):\n+                if bit_size <= 8:\n+                    size = 1\n+                else:\n+                    size = 1 << ((bit_size - 1).bit_length() - 3)\n+                type = prog.int_type(\n+                    \"\" if signed else \"u\" + f\"int{size}\", size, signed, byteorder\n+                )\n+                if signed:\n+                    values = (\n+                        0xF8935CF44C45202748DE66B49BA0CBAC % (1 << (bit_size - 1)),\n+                        ~0xF8935CF44C45202748DE66B49BA0CBAC % (1 << (bit_size - 1)),\n+                        -0xC256D5AAFFDC3179A6AC84E7154A215D % -(1 << (bit_size - 1)),\n+                        ~-0xC256D5AAFFDC3179A6AC84E7154A215D % -(1 << (bit_size - 1)),\n+                    )\n+                else:\n+                    values = (\n+                        0xF8935CF44C45202748DE66B49BA0CBAC % (1 << bit_size),\n+                        ~0xF8935CF44C45202748DE66B49BA0CBAC % (1 << bit_size),\n+                    )\n+                for value in values:\n+                    # value_bytes is the value converted to bytes.\n+                    if byteorder == \"little\":\n+                        value_bytes = (value & ((1 << bit_size) - 1)).to_bytes(\n+                            (bit_size + 7) // 8, byteorder\n+                        )\n+                    else:\n+                        value_bytes = (value << (-bit_size % 8)).to_bytes(\n+                            (bit_size + 7) // 8, byteorder, signed=signed\n+                        )\n+                    for bit_offset in range(8):\n+                        # source_bytes is a buffer containing the value at the\n+                        # given bit offset, with extra bits that should be\n+                        # ignored.\n+                        if byteorder == \"little\":\n+                            source_bytes = bytearray(\n+                                (value << bit_offset).to_bytes(\n+                                    (bit_offset + bit_size + 7) // 8,\n+                                    byteorder,\n+                                    signed=signed,\n+                                )\n+                            )\n+                            source_bytes[0] |= (1 << bit_offset) - 1\n+                            if (bit_offset + bit_size) % 8 != 0:\n+                                source_bytes[-1] ^= (\n+                                    0xFF << ((bit_offset + bit_size) % 8)\n+                                ) & 0xFF\n+                        else:\n+                            source_bytes = bytearray(\n+                                (value << (-(bit_offset + bit_size) % 8)).to_bytes(\n+                                    (bit_offset + bit_size + 7) // 8,\n+                                    byteorder,\n+                                    signed=signed,\n+                                )\n+                            )\n+                            source_bytes[0] ^= (0xFF00 >> bit_offset) & 0xFF\n+                            if (bit_offset + bit_size) % 8 != 0:\n+                                source_bytes[-1] |= (\n+                                    1 << (-(bit_offset + bit_size) % 8)\n+                                ) - 1\n+                        yield signed, byteorder, bit_size, type, bit_offset, value, value_bytes, source_bytes\n+\n+\n class TestReference(MockProgramTestCase):\n     def test_basic(self):\n         self.add_memory_segment((1000).to_bytes(4, \"little\"), virt_addr=0xFFFF0000)\n@@ -197,28 +263,36 @@ class TestReference(MockProgramTestCase):\n             bit_offset=7,\n         )\n \n-    def test_read_unsigned(self):\n-        value = 12345678912345678989\n-        for bit_size in range(1, 65):\n-            for bit_offset in range(8):\n-                size = (bit_size + bit_offset + 7) // 8\n-                size_mask = (1 << (8 * size)) - 1\n-                for byteorder in [\"little\", \"big\"]:\n-                    if byteorder == \"little\":\n-                        tmp = value << bit_offset\n-                    else:\n-                        tmp = value << (8 - bit_size - bit_offset) % 8\n-                    tmp &= size_mask\n-                    buf = tmp.to_bytes(size, byteorder)\n-                    prog = mock_program(segments=[MockMemorySegment(buf, 0)])\n-                    obj = Object(\n-                        prog,\n-                        prog.int_type(\"unsigned long long\", 8, False, byteorder),\n-                        address=0,\n-                        bit_field_size=bit_size,\n-                        bit_offset=bit_offset,\n-                    )\n-                    self.assertEqual(obj.value_(), value & ((1 << bit_size) - 1))\n+    def test_int_bits(self):\n+        buffer = bytearray(9)\n+        self.add_memory_segment(buffer, virt_addr=0xFFFF0000)\n+        for (\n+            signed,\n+            byteorder,\n+            bit_size,\n+            type,\n+            bit_offset,\n+            value,\n+            value_bytes,\n+            source_bytes,\n+        ) in _int_bits_cases(self.prog):\n+            with self.subTest(\n+                signed=signed,\n+                byteorder=byteorder,\n+                bit_size=bit_size,\n+                bit_offset=bit_offset,\n+                value=value,\n+            ):\n+                buffer[: len(source_bytes)] = source_bytes\n+                obj = Object(\n+                    self.prog,\n+                    type,\n+                    address=0xFFFF0000,\n+                    bit_offset=bit_offset,\n+                    bit_field_size=bit_size,\n+                )\n+                self.assertEqual(obj.value_(), value)\n+                self.assertEqual(obj.to_bytes_(), value_bytes)\n \n     def test_read_float(self):\n         pi32 = struct.unpack(\"f\", struct.pack(\"f\", math.pi))[0]\n@@ -628,6 +702,38 @@ class TestValue(MockProgramTestCase):\n                 value & ((1 << bit_size) - 1),\n             )\n \n+    def test_int_bits(self):\n+        for (\n+            signed,\n+            byteorder,\n+            bit_size,\n+            type,\n+            bit_offset,\n+            value,\n+            value_bytes,\n+            source_bytes,\n+        ) in _int_bits_cases(self.prog):\n+            with self.subTest(\n+                signed=signed,\n+                byteorder=byteorder,\n+                bit_size=bit_size,\n+                bit_offset=bit_offset,\n+                value=value,\n+            ):\n+                obj = Object(self.prog, type, value, bit_field_size=bit_size)\n+                self.assertEqual(obj.value_(), value)\n+                self.assertEqual(obj.to_bytes_(), value_bytes)\n+                self.assertIdentical(\n+                    Object.from_bytes_(\n+                        self.prog,\n+                        obj.type_,\n+                        source_bytes,\n+                        bit_offset=bit_offset,\n+                        bit_field_size=bit_size,\n+                    ),\n+                    obj,\n+                )\n+\n     def test_float(self):\n         obj = Object(self.prog, \"double\", value=3.14)\n         self.assertIs(obj.prog_, self.prog)\n"}
{"repo": "drgn", "commit": "1787e25a715684c761eac421c994da22f206df90", "diff": "diff --git a/drgn/helpers/common/format.py b/drgn/helpers/common/format.py\nindex b4e561a3..2497a02f 100644\n--- a/drgn/helpers/common/format.py\n+++ b/drgn/helpers/common/format.py\n@@ -207,23 +207,23 @@ def number_in_binary_units(n: SupportsFloat, precision: int = 1) -> str:\n     Format a number in binary units (i.e., \"K\" is 1024, \"M\" is 1024\\\\ :sup:`2`,\n     etc.).\n \n-    >>> binary_units(1280)\n+    >>> number_in_binary_units(1280)\n     '1.2K'\n \n     A precision can be specified:\n \n-    >>> binary_units(1280, precision=2)\n+    >>> number_in_binary_units(1280, precision=2)\n     '1.25K'\n \n     Exact numbers are printed without a fractional part:\n \n-    >>> binary_units(1024 * 1024)\n+    >>> number_in_binary_units(1024 * 1024)\n     '1M'\n \n     Numbers less than 1024 are not scaled:\n \n-    >>> binary_units(10)\n-    \"10\"\n+    >>> number_in_binary_units(10)\n+    '10'\n \n     :param n: Number to format.\n     :param precision: Number of digits to include in fractional part.\n"}
{"repo": "drgn", "commit": "28e7a79925fcf16daad6b27a17307cd5ba851588", "diff": "diff --git a/setup.py b/setup.py\nindex ab4c9119..fc1cd5df 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -2,12 +2,7 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: LGPL-2.1-or-later\n \n-# setuptools must be imported before distutils (see pypa/setuptools#2230).\n-import setuptools  # isort: skip  # noqa: F401\n-\n import contextlib\n-from distutils.command.build import build as _build\n-from distutils.errors import DistutilsError\n import logging\n import os\n import os.path\n@@ -23,6 +18,19 @@ from setuptools.command.egg_info import egg_info as _egg_info\n from setuptools.command.sdist import sdist as _sdist\n from setuptools.extension import Extension\n \n+# setuptools must be imported before distutils (see pypa/setuptools#2230), so\n+# make sure to keep these fallbacks after the other setuptools imports.\n+try:\n+    # This was added in setuptools 62.4.0 (released June 13th, 2022).\n+    from setuptools.command.build import build as _build\n+except ImportError:\n+    from distutils.command.build import build as _build\n+try:\n+    # This was added in setuptools 59.0.0 (released November 12th, 2021).\n+    from setuptools.errors import BaseError\n+except ImportError:\n+    from distutils.errors import DistutilsError as BaseError\n+\n from util import nproc, out_of_date\n from vmtest.config import KERNEL_FLAVORS, SUPPORTED_KERNEL_VERSIONS\n \n@@ -296,7 +304,7 @@ fi\n             raise\n \n         if failed:\n-            raise DistutilsError(\"some tests failed\")\n+            raise BaseError(\"some tests failed\")\n         else:\n             logger.info(\"all tests passed\")\n \n"}
{"repo": "drgn", "commit": "104a14781de08cd6f8fe48cd69d0e22a79c2aaea", "diff": "diff --git a/scripts/gen_tests_elf_py.py b/scripts/gen_tests_elf_py.py\nindex 0b717fa6..040d87b6 100755\n--- a/scripts/gen_tests_elf_py.py\n+++ b/scripts/gen_tests_elf_py.py\n@@ -22,6 +22,7 @@ def main() -> None:\n         for name in (\n             \"ET\",\n             \"PT\",\n+            \"SHF\",\n             \"SHN\",\n             \"SHT\",\n             \"STB\",\n@@ -32,13 +33,16 @@ def main() -> None:\n     for match in re.finditer(\n         r\"^\\s*#\\s*define\\s+(?P<enum>\"\n         + \"|\".join(enums)\n-        + r\")_(?P<name>\\w+)\\s+(?P<value>0x[0-9a-fA-F]+|[0-9]+)\",\n+        + r\")_(?P<name>\\w+)\\s+(?:(?P<value>0x[0-9a-fA-F]+|[0-9]+)|(?:\\(\\s*1U?\\s*<<\\s*(?P<bitshift>[0-9]+)\\s*\\)))\",\n         contents,\n         re.MULTILINE,\n     ):\n         enum = match.group(\"enum\")\n         name = match.group(\"name\")\n-        value = int(match.group(\"value\"), 0)\n+        if match.group(\"value\"):\n+            value = int(match.group(\"value\"), 0)\n+        else:\n+            value = 1 << int(match.group(\"bitshift\"), 10)\n         enums[enum].append((name, value))\n \n     f = sys.stdout\ndiff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex 0e81bb9c..5e77256f 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -3,6 +3,7 @@\n \n import os.path\n from typing import Any, NamedTuple, Optional, Sequence, Union\n+import zlib\n \n from tests.assembler import _append_sleb128, _append_uleb128\n from tests.dwarf import DW_AT, DW_FORM, DW_TAG\n@@ -232,7 +233,13 @@ _UNIT_TAGS = frozenset({DW_TAG.type_unit, DW_TAG.compile_unit})\n \n \n def dwarf_sections(\n-    dies, little_endian=True, bits=64, *, lang=None, use_dw_form_indirect=False\n+    dies,\n+    little_endian=True,\n+    bits=64,\n+    *,\n+    lang=None,\n+    use_dw_form_indirect=False,\n+    compress=None,\n ):\n     if isinstance(dies, DwarfDie):\n         dies = (dies,)\n@@ -263,29 +270,47 @@ def dwarf_sections(\n         unit_dies, little_endian, bits, use_dw_form_indirect\n     )\n \n+    if compress == \"zlib-gnu\":\n+\n+        def debug_section(name, data):\n+            assert name.startswith(\".debug\")\n+            compressed_data = bytearray(b\"ZLIB\")\n+            compressed_data.extend(len(data).to_bytes(8, \"big\"))\n+            compressed_data.extend(zlib.compress(data))\n+            return ElfSection(\n+                name=\".z\" + name[1:], sh_type=SHT.PROGBITS, data=compressed_data\n+            )\n+\n+    else:\n+        assert compress is None or compress == \"zlib-gabi\", compress\n+        compressed = compress is not None\n+\n+        def debug_section(name, data):\n+            return ElfSection(\n+                name=name, sh_type=SHT.PROGBITS, data=data, compressed=compressed\n+            )\n+\n     sections = [\n-        ElfSection(\n-            name=\".debug_abbrev\",\n-            sh_type=SHT.PROGBITS,\n-            data=_compile_debug_abbrev(unit_dies, use_dw_form_indirect),\n+        debug_section(\n+            \".debug_abbrev\", _compile_debug_abbrev(unit_dies, use_dw_form_indirect)\n         ),\n-        ElfSection(name=\".debug_info\", sh_type=SHT.PROGBITS, data=debug_info),\n-        ElfSection(\n-            name=\".debug_line\",\n-            sh_type=SHT.PROGBITS,\n-            data=_compile_debug_line(unit_dies, little_endian),\n-        ),\n-        ElfSection(name=\".debug_str\", sh_type=SHT.PROGBITS, data=b\"\\0\"),\n+        debug_section(\".debug_info\", data=debug_info),\n+        debug_section(\".debug_line\", _compile_debug_line(unit_dies, little_endian)),\n+        debug_section(\".debug_str\", b\"\\0\"),\n     ]\n     if debug_types:\n-        sections.append(\n-            ElfSection(name=\".debug_types\", sh_type=SHT.PROGBITS, data=debug_types)\n-        )\n+        sections.append(debug_section(\".debug_types\", debug_types))\n     return sections\n \n \n def compile_dwarf(\n-    dies, little_endian=True, bits=64, *, lang=None, use_dw_form_indirect=False\n+    dies,\n+    little_endian=True,\n+    bits=64,\n+    *,\n+    lang=None,\n+    use_dw_form_indirect=False,\n+    compress=None,\n ):\n     return create_elf_file(\n         ET.EXEC,\n@@ -295,6 +320,7 @@ def compile_dwarf(\n             bits=bits,\n             lang=lang,\n             use_dw_form_indirect=use_dw_form_indirect,\n+            compress=compress,\n         ),\n         little_endian=little_endian,\n         bits=bits,\ndiff --git a/tests/elf.py b/tests/elf.py\nindex 2674495a..cc81219f 100644\n--- a/tests/elf.py\n+++ b/tests/elf.py\n@@ -63,6 +63,48 @@ class PT(enum.IntEnum):\n             return hex(value)\n \n \n+class SHF(enum.IntEnum):\n+    WRITE = 0x1\n+    ALLOC = 0x2\n+    EXECINSTR = 0x4\n+    MERGE = 0x10\n+    STRINGS = 0x20\n+    INFO_LINK = 0x40\n+    LINK_ORDER = 0x80\n+    OS_NONCONFORMING = 0x100\n+    GROUP = 0x200\n+    TLS = 0x400\n+    COMPRESSED = 0x800\n+    MASKOS = 0xFF00000\n+    MASKPROC = 0xF0000000\n+    GNU_RETAIN = 0x200000\n+    ORDERED = 0x40000000\n+    EXCLUDE = 0x80000000\n+    MIPS_GPREL = 0x10000000\n+    MIPS_MERGE = 0x20000000\n+    MIPS_ADDR = 0x40000000\n+    MIPS_STRINGS = 0x80000000\n+    MIPS_NOSTRIP = 0x8000000\n+    MIPS_LOCAL = 0x4000000\n+    MIPS_NAMES = 0x2000000\n+    MIPS_NODUPE = 0x1000000\n+    PARISC_SHORT = 0x20000000\n+    PARISC_HUGE = 0x40000000\n+    PARISC_SBP = 0x80000000\n+    ALPHA_GPREL = 0x10000000\n+    ARM_ENTRYSECT = 0x10000000\n+    ARM_COMDEF = 0x80000000\n+    IA_64_SHORT = 0x10000000\n+    IA_64_NORECOV = 0x20000000\n+\n+    @classmethod\n+    def str(cls, value: int) -> Text:\n+        try:\n+            return f\"SHF_{cls(value).name}\"\n+        except ValueError:\n+            return hex(value)\n+\n+\n class SHN(enum.IntEnum):\n     UNDEF = 0x0\n     LORESERVE = 0xFF00\ndiff --git a/tests/elfwriter.py b/tests/elfwriter.py\nindex e0f35556..c8f80dc4 100644\n--- a/tests/elfwriter.py\n+++ b/tests/elfwriter.py\n@@ -3,8 +3,9 @@\n \n import struct\n from typing import List, NamedTuple, Optional, Sequence\n+import zlib\n \n-from tests.elf import ET, PT, SHN, SHT, STB, STT, STV\n+from tests.elf import ET, PT, SHF, SHN, SHT, STB, STT, STV\n \n \n class ElfSection:\n@@ -21,14 +22,16 @@ class ElfSection:\n         sh_link: int = 0,\n         sh_info: int = 0,\n         sh_entsize: int = 0,\n+        compressed=False,\n     ):\n         self.data = data\n         self.name = name\n         self.sh_type = sh_type\n+        self.sh_flags = SHF.COMPRESSED if compressed else 0\n         self.p_type = p_type\n         self.vaddr = vaddr\n         self.paddr = paddr\n-        self.memsz = len(self.data) if memsz is None else memsz\n+        self.memsz = memsz\n         self.p_align = p_align\n         self.sh_link = sh_link\n         self.sh_info = sh_info\n@@ -36,6 +39,7 @@ class ElfSection:\n \n         assert (self.name is not None) or (self.p_type is not None)\n         assert (self.name is None) == (self.sh_type is None)\n+        assert self.p_type is None or not compressed\n \n \n class ElfSymbol(NamedTuple):\n@@ -122,12 +126,14 @@ def create_elf_file(\n         ehdr_struct = struct.Struct(endian + \"16BHHIQQQIHHHHHH\")\n         shdr_struct = struct.Struct(endian + \"IIQQQQIIQQ\")\n         phdr_struct = struct.Struct(endian + \"IIQQQQQQ\")\n+        chdr_struct = struct.Struct(endian + \"IIQQ\")\n         e_machine = 62 if little_endian else 43  # EM_X86_64 or EM_SPARCV9\n     else:\n         assert bits == 32\n         ehdr_struct = struct.Struct(endian + \"16BHHIIIIIHHHHHH\")\n         shdr_struct = struct.Struct(endian + \"10I\")\n         phdr_struct = struct.Struct(endian + \"8I\")\n+        chdr_struct = struct.Struct(endian + \"III\")\n         e_machine = 3 if little_endian else 8  # EM_386 or EM_MIPS\n \n     sections = list(sections)\n@@ -189,6 +195,15 @@ def create_elf_file(\n \n     shdr_offset += shdr_struct.size\n     for section in sections:\n+        ch_addralign = 1 if section.p_type is None else bits // 8\n+        memsz = len(section.data) if section.memsz is None else section.memsz\n+        if section.sh_flags & SHF.COMPRESSED:\n+            sh_addralign = bits // 8\n+            compressed_data = zlib.compress(section.data)\n+            sh_size = chdr_struct.size + len(compressed_data)\n+        else:\n+            sh_addralign = ch_addralign\n+            sh_size = memsz\n         if section.p_align:\n             padding = section.vaddr % section.p_align - len(buf) % section.p_align\n             buf.extend(bytes(padding))\n@@ -198,13 +213,13 @@ def create_elf_file(\n                 shdr_offset,\n                 shstrtab.index(section.name.encode()),  # sh_name\n                 section.sh_type,  # sh_type\n-                0,  # sh_flags\n+                section.sh_flags,  # sh_flags\n                 section.vaddr,  # sh_addr\n                 len(buf),  # sh_offset\n-                section.memsz,  # sh_size\n+                sh_size,  # sh_size\n                 section.sh_link,  # sh_link\n                 section.sh_info,  # sh_info\n-                1 if section.p_type is None else bits // 8,  # sh_addralign\n+                sh_addralign,  # sh_addralign\n                 section.sh_entsize,  # sh_entsize\n             )\n             shdr_offset += shdr_struct.size\n@@ -220,7 +235,7 @@ def create_elf_file(\n                     section.vaddr,  # p_vaddr\n                     section.paddr,  # p_paddr\n                     len(section.data),  # p_filesz\n-                    section.memsz,  # p_memsz\n+                    memsz,  # p_memsz\n                     section.p_align,  # p_align\n                 )\n             else:\n@@ -232,11 +247,32 @@ def create_elf_file(\n                     section.vaddr,  # p_vaddr\n                     section.paddr,  # p_paddr\n                     len(section.data),  # p_filesz\n-                    section.memsz,  # p_memsz\n+                    memsz,  # p_memsz\n                     flags,  # p_flags\n                     section.p_align,  # p_align\n                 )\n             phdr_offset += phdr_struct.size\n-        buf.extend(section.data)\n+        if section.sh_flags & SHF.COMPRESSED:\n+            ELFCOMPRESS_ZLIB = 1\n+            if bits == 64:\n+                buf.extend(\n+                    chdr_struct.pack(\n+                        ELFCOMPRESS_ZLIB,  # ch_type\n+                        0,  # ch_reserved\n+                        memsz,  # ch_size\n+                        ch_addralign,  # ch_addralign\n+                    )\n+                )\n+            else:\n+                buf.extend(\n+                    chdr_struct.pack(\n+                        ELFCOMPRESS_ZLIB,  # ch_type\n+                        memsz,  # ch_size\n+                        ch_addralign,  # ch_addralign\n+                    )\n+                )\n+            buf.extend(compressed_data)\n+        else:\n+            buf.extend(section.data)\n \n     return buf\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 50263908..46dba40e 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -6490,3 +6490,13 @@ class TestProgram(TestCase):\n             *labeled_int_die,\n         )\n         self.assertIsNotNone(repr(dwarf_program(dies).type(\"TEST\").type.parameters[0]))\n+\n+\n+class TestCompressedDebugSections(TestCase):\n+    def test_zlib_gnu(self):\n+        prog = dwarf_program(wrap_test_type_dies(int_die), compress=\"zlib-gnu\")\n+        self.assertIdentical(prog.type(\"TEST\").type, prog.int_type(\"int\", 4, True))\n+\n+    def test_zlib_gabi(self):\n+        prog = dwarf_program(wrap_test_type_dies(int_die), compress=\"zlib-gabi\")\n+        self.assertIdentical(prog.type(\"TEST\").type, prog.int_type(\"int\", 4, True))\n"}
{"repo": "drgn", "commit": "573bfad9fbc18579c8b655b51bf746f6550ff994", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 3f6e06ae..e0a15faa 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -56,23 +56,19 @@ _PATCHES = (\n         versions=((KernelVersion(\"5.13\"), KernelVersion(\"5.15.66\")),),\n     ),\n     _Patch(\n-        name=\"5.12.19-bpf-Generate-BTF_KIND_FLOAT-when-linking-vmlinux.patch\",\n-        versions=((KernelVersion(\"5.12.10\"), KernelVersion(\"5.13\")),),\n-    ),\n-    _Patch(\n-        name=\"5.10-bpf-Generate-BTF_KIND_FLOAT-when-linking-vmlinux.patch\",\n+        name=\"5.12-kbuild-Quote-OBJCOPY-var-to-avoid-a-pahole-call-brea.patch\",\n         versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.12.10\")),),\n     ),\n     _Patch(\n-        name=\"5.10-kbuild-Quote-OBJCOPY-var-to-avoid-a-pahole-call-brea.patch\",\n-        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.12.10\")),),\n+        name=\"5.11-bpf-Generate-BTF_KIND_FLOAT-when-linking-vmlinux.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n     ),\n     _Patch(\n         name=\"5.10-kbuild-skip-per-CPU-BTF-generation-for-pahole-v1.18-.patch\",\n         versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n     ),\n     _Patch(\n-        name=\"5.10-kbuild-Unify-options-for-BTF-generation-for-vmlinux.patch\",\n+        name=\"5.11-kbuild-Unify-options-for-BTF-generation-for-vmlinux.patch\",\n         versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n     ),\n     _Patch(\n"}
{"repo": "drgn", "commit": "de1251a72a2c7dc68ecafb52f0c420766e70ad60", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 366e4248..9a39cd61 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -11,7 +11,7 @@ from typing import Dict, Mapping, NamedTuple, Sequence\n from util import NORMALIZED_MACHINE_NAME\n \n KERNEL_ORG_COMPILER_VERSION = \"12.2.0\"\n-VMTEST_KERNEL_VERSION = 20\n+VMTEST_KERNEL_VERSION = 21\n \n \n BASE_KCONFIG = \"\"\"\ndiff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex c7f04e80..3f6e06ae 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -94,6 +94,18 @@ _PATCHES = (\n         name=\"s390-mm-make-memory_block_size_bytes-available-for-M.patch\",\n         versions=((KernelVersion(\"4.3\"), KernelVersion(\"4.11\")),),\n     ),\n+    _Patch(\n+        name=\"libsubcmd-Fix-use-after-free-for-realloc-.-0.patch\",\n+        versions=(\n+            (KernelVersion(\"5.16\"), KernelVersion(\"5.16.11\")),\n+            (KernelVersion(\"5.11\"), KernelVersion(\"5.15.25\")),\n+            (KernelVersion(\"5.5\"), KernelVersion(\"5.10.102\")),\n+            (KernelVersion(\"4.20\"), KernelVersion(\"5.4.181\")),\n+            (KernelVersion(\"4.15\"), KernelVersion(\"4.19.231\")),\n+            (KernelVersion(\"4.10\"), KernelVersion(\"4.14.268\")),\n+            (KernelVersion(\"4.5\"), KernelVersion(\"4.9.303\")),\n+        ),\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "2d2a69a322707f6b0d52926292bc31587a0f8141", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 9e54b2df..4903de1d 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -646,9 +646,28 @@ def compound_order(page: Object) -> Object:\n     :param page: ``struct page *``\n     :return: ``unsigned int``\n     \"\"\"\n+    prog = page.prog_\n+\n     if not PageHead(page):\n-        return Object(page.prog_, \"unsigned int\", 0)\n-    return cast(\"unsigned int\", page[1].compound_order)\n+        return Object(prog, \"unsigned int\", 0)\n+\n+    # Before Linux kernel commit 379708ffde1b (\"mm: add the first tail page to\n+    # struct folio\") (in v6.1), the compound order is in struct page. Since\n+    # that commit, it is also in struct folio. Since Linux kernel commit\n+    # 1c5509be58f6 (\"mm: remove 'First tail page' members from struct page\")\n+    # (in v6.3), it is _only_ in struct folio.\n+    try:\n+        from_folio = prog.cache[\"compound_order_from_folio\"]\n+    except KeyError:\n+        try:\n+            from_folio = prog.type(\"struct folio\").has_member(\"_folio_order\")\n+        except LookupError:\n+            from_folio = False\n+        prog.cache[\"compound_order_from_folio\"] = from_folio\n+    if from_folio:\n+        return cast(\"unsigned int\", cast(\"struct folio *\", page)._folio_order)\n+    else:\n+        return cast(\"unsigned int\", page[1].compound_order)\n \n \n def compound_nr(page: Object) -> Object:\n@@ -658,9 +677,7 @@ def compound_nr(page: Object) -> Object:\n     :param page: ``struct page *``\n     :return: ``unsigned long``\n     \"\"\"\n-    if not PageHead(page):\n-        return Object(page.prog_, \"unsigned long\", 1)\n-    return Object(page.prog_, \"unsigned long\", 1) << page[1].compound_order\n+    return Object(page.prog_, \"unsigned long\", 1) << compound_order(page)\n \n \n def page_size(page: Object) -> Object:\n"}
{"repo": "drgn", "commit": "fc3ea4184a2576bd1682e4dd34159f1ff51895cb", "diff": "diff --git a/scripts/iwyu.py b/scripts/iwyu.py\nindex f854163e..8ca02d16 100755\n--- a/scripts/iwyu.py\n+++ b/scripts/iwyu.py\n@@ -130,44 +130,6 @@ def gen_python_mapping_file(mapping_path):\n     os.rename(mapping_path + \".tmp\", mapping_path)\n \n \n-def iwyu_associated_header(path):\n-    with open(path, \"r\") as f:\n-        match = re.search(\n-            r'^\\s*#\\s*include\\s+\"([^\"]+)\"\\s+//\\s+IWYU\\s+pragma:\\s+associated',\n-            f.read(),\n-            re.M,\n-        )\n-        if match:\n-            return os.path.join(os.path.dirname(path), match.group(1))\n-    if path.endswith(\".c\"):\n-        return path[:-2] + \".h\"\n-    return None\n-\n-\n-def ignore_line(path, state, line):\n-    # include-what-you-use/include-what-you-use#969: iwyu recommends bogus\n-    # forward declarations for the anonymous unions generated by\n-    # BINARY_OP_SIGNED_2C.\n-    if line.endswith(\"::;\"):\n-        return True\n-\n-    # include-what-you-use/include-what-you-use#971: drgn.h \"exports\" a forward\n-    # declaration of several opaque types, but iwyu doesn't have such a notion.\n-    if re.fullmatch(\n-        r\"struct drgn_(language|platform|program|register|stack_trace|symbol);\", line\n-    ):\n-        paths = [path]\n-        associated_header = iwyu_associated_header(path)\n-        if associated_header is not None:\n-            paths.append(associated_header)\n-        for path in paths:\n-            with open(path, \"r\") as f:\n-                if re.search(r'^#include \"(drgn.h|drgnpy.h)\"', f.read(), re.M):\n-                    return True\n-\n-    return False\n-\n-\n def main():\n     parser = argparse.ArgumentParser(description=\"run include-what-you-use on drgn\")\n     parser.add_argument(\n@@ -247,11 +209,7 @@ def main():\n                     else:\n                         header = None\n                     lines.clear()\n-                elif (\n-                    line\n-                    and state != \"include_list\"\n-                    and not ignore_line(path, state, line)\n-                ):\n+                elif line and state != \"include_list\":\n                     if header is not None:\n                         print(\"\\n\" + header)\n                         header = None\n"}
{"repo": "drgn", "commit": "1133b2fd318ec75019cfc2820a761e9f52f4f609", "diff": "diff --git a/contrib/lsmod.py b/contrib/lsmod.py\nindex 61a4b776..87c40b83 100755\n--- a/contrib/lsmod.py\n+++ b/contrib/lsmod.py\n@@ -12,7 +12,7 @@ for mod in list_for_each_entry(\"struct module\", prog[\"modules\"].address_of_(), \"\n     name = mod.name.string_().decode()\n     size = (mod.init_layout.size + mod.core_layout.size).value_()\n     if config_module_unload:\n-        refcnt = mod.refcnt.counter.value_()\n+        refcnt = mod.refcnt.counter.value_() - 1\n         used_by = [\n             use.source.name.string_().decode()\n             for use in list_for_each_entry(\n@@ -22,4 +22,8 @@ for mod in list_for_each_entry(\"struct module\", prog[\"modules\"].address_of_(), \"\n     else:\n         refcnt = \"-\"\n         used_by = []\n-    print(f\"{name:19} {size:>8}  {refcnt} {','.join(used_by)}\")\n+\n+    used = \",\".join(used_by)\n+    if used:\n+        used = \" \" + used\n+    print(f\"{name:19} {size:>8}  {refcnt}{used}\")\n"}
{"repo": "drgn", "commit": "e6228245a0446420fbbcd9b61dc4fffc741eabf4", "diff": "diff --git a/contrib/tcp_sock.py b/contrib/tcp_sock.py\nindex e43e3967..fc7a857f 100755\n--- a/contrib/tcp_sock.py\n+++ b/contrib/tcp_sock.py\n@@ -8,12 +8,12 @@ import ipaddress\n import socket\n import struct\n \n-from drgn import cast, container_of\n+from drgn import cast\n from drgn.helpers.common.type import enum_type_to_class\n from drgn.helpers.linux import (\n     cgroup_path,\n-    hlist_for_each,\n     hlist_nulls_empty,\n+    hlist_nulls_for_each_entry,\n     sk_fullsock,\n     sk_nulls_for_each,\n     sk_tcpstate,\n@@ -99,8 +99,9 @@ tcp_hashinfo = prog.object(\"tcp_hashinfo\")\n \n try:\n     for ilb in tcp_hashinfo.listening_hash:\n-        for pos in hlist_for_each(ilb.head):\n-            sk = container_of(pos, \"struct sock\", \"__sk_common.skc_node\")\n+        for sk in hlist_nulls_for_each_entry(\n+            \"struct sock\", ilb.nulls_head, \"__sk_common.skc_node\"\n+        ):\n             _print_sk(sk)\n except AttributeError:\n     for i in range(tcp_hashinfo.lhash2_mask + 1):\n"}
{"repo": "drgn", "commit": "0b7238baa3c27fb5c1fecd092e040f237e205faf", "diff": "diff --git a/vmtest/config.py b/vmtest/config.py\nindex 85071623..4d36666c 100644\n--- a/vmtest/config.py\n+++ b/vmtest/config.py\n@@ -275,7 +275,10 @@ ARCHITECTURES = {\n             name=\"s390x\",\n             kernel_arch=\"s390\",\n             kernel_srcarch=\"s390\",\n-            kernel_config=\"\",\n+            kernel_config=\"\"\"\n+                # Needed for CONFIG_KEXEC_FILE.\n+                CONFIG_CRYPTO_SHA256_S390=y\n+            \"\"\",\n             kernel_flavor_configs={},\n             kernel_org_compiler_name=\"s390-linux\",\n             qemu_options=(),\n"}
{"repo": "drgn", "commit": "ff89a6d26704d4f733d9735877414608b5526f6c", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex 3c564b0e..ab6f0bf8 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -454,7 +454,7 @@ def _find_containing_slab(\n     prog: Program, addr: int\n ) -> Optional[Tuple[Object, Object, Object]]:\n     start_addr = pfn_to_virt(prog[\"min_low_pfn\"]).value_()\n-    end_addr = (pfn_to_virt(prog[\"max_pfn\"]) + prog[\"PAGE_SIZE\"]).value_()\n+    end_addr = (pfn_to_virt(prog[\"max_low_pfn\"]) + prog[\"PAGE_SIZE\"]).value_()\n     if addr < start_addr or addr >= end_addr:\n         # Not a directly mapped address\n         return None\n"}
{"repo": "drgn", "commit": "45e7fc2d3b998ee071b2901d06dacca3e84f1dbe", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 79889305..d38bad40 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -90,6 +90,10 @@ _PATCHES = (\n         name=\"5.10-kbuild-Add-skip_encoding_btf_enum64-option-to-pahole.patch\",\n         versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n     ),\n+    _Patch(\n+        name=\"s390-mm-make-memory_block_size_bytes-available-for-M.patch\",\n+        versions=((KernelVersion(\"4.3\"), KernelVersion(\"4.11\")),),\n+    ),\n )\n \n \n"}
{"repo": "drgn", "commit": "bf45199682400fad584e515a069d81be777ad11c", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex 235669c1..068c643e 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -46,7 +46,47 @@ class _Patch(NamedTuple):\n     versions: Sequence[Tuple[Optional[KernelVersion], Optional[KernelVersion]]]\n \n \n-_PATCHES = ()\n+_PATCHES = (\n+    _Patch(\n+        name=\"5.15-kbuild-Unify-options-for-BTF-generation-for-vmlinux.patch\",\n+        versions=((KernelVersion(\"5.13\"), KernelVersion(\"5.15.66\")),),\n+    ),\n+    _Patch(\n+        name=\"5.12.19-bpf-Generate-BTF_KIND_FLOAT-when-linking-vmlinux.patch\",\n+        versions=((KernelVersion(\"5.12.10\"), KernelVersion(\"5.13\")),),\n+    ),\n+    _Patch(\n+        name=\"5.10-bpf-Generate-BTF_KIND_FLOAT-when-linking-vmlinux.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.12.10\")),),\n+    ),\n+    _Patch(\n+        name=\"5.10-kbuild-Quote-OBJCOPY-var-to-avoid-a-pahole-call-brea.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.12.10\")),),\n+    ),\n+    _Patch(\n+        name=\"5.10-kbuild-skip-per-CPU-BTF-generation-for-pahole-v1.18-.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n+    ),\n+    _Patch(\n+        name=\"5.10-kbuild-Unify-options-for-BTF-generation-for-vmlinux.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n+    ),\n+    _Patch(\n+        name=\"kbuild-Add-skip_encoding_btf_enum64-option-to-pahole.patch\",\n+        versions=((KernelVersion(\"5.18\"), KernelVersion(\"5.19.17\")),),\n+    ),\n+    _Patch(\n+        name=\"5.15-kbuild-Add-skip_encoding_btf_enum64-option-to-pahole.patch\",\n+        versions=(\n+            (KernelVersion(\"5.16\"), KernelVersion(\"5.18\")),\n+            (KernelVersion(\"5.13\"), KernelVersion(\"5.15.66\")),\n+        ),\n+    ),\n+    _Patch(\n+        name=\"5.10-kbuild-Add-skip_encoding_btf_enum64-option-to-pahole.patch\",\n+        versions=((KernelVersion(\"5.11\"), KernelVersion(\"5.13\")),),\n+    ),\n+)\n \n \n async def apply_patches(kernel_dir: Path) -> None:\n"}
{"repo": "drgn", "commit": "7ab5b487370a9ee2e637f2bfcb61994b304b2684", "diff": "diff --git a/drgn/helpers/linux/cgroup.py b/drgn/helpers/linux/cgroup.py\nindex 59ff38f6..b1150fe9 100644\n--- a/drgn/helpers/linux/cgroup.py\n+++ b/drgn/helpers/linux/cgroup.py\n@@ -37,7 +37,14 @@ def sock_cgroup_ptr(skcd: Object) -> Object:\n     :param skcd: ``struct sock_cgroup_data *``\n     :return: ``struct cgroup *``\n     \"\"\"\n-    return cast(\"struct cgroup *\", skcd.val)\n+\n+    # Since Linux kernel commit 8520e224f547 (\"bpf, cgroups: Fix\n+    # cgroup v2 fallback on v1/v2 mixed mode\") (in v5.15), the sock_cgroup_data\n+    # contains directly cgroup member (of struct cgroup * type).\n+    try:\n+        return skcd.cgroup\n+    except AttributeError:\n+        return cast(\"struct cgroup *\", skcd.val)\n \n \n def cgroup_parent(cgrp: Object) -> Object:\n"}
{"repo": "drgn", "commit": "c710ea7713d32db012ead3d807bf2bfeb778ab56", "diff": "diff --git a/contrib/fs_inodes.py b/contrib/fs_inodes.py\nindex 4253afcb..5c34bf28 100755\n--- a/contrib/fs_inodes.py\n+++ b/contrib/fs_inodes.py\n@@ -28,5 +28,5 @@ for inode in list_for_each_entry(\n ):\n     try:\n         print(os.fsdecode(inode_path(inode)))\n-    except ValueError:\n+    except (TypeError, ValueError):\n         continue\n"}
{"repo": "drgn", "commit": "7a3ddf20d35c54129cf990b2b3d983c76447e2fd", "diff": "diff --git a/vmtest/kbuild.py b/vmtest/kbuild.py\nindex a831bf71..cdc995c3 100644\n--- a/vmtest/kbuild.py\n+++ b/vmtest/kbuild.py\n@@ -63,7 +63,7 @@ CONFIG_SLAB=y\n CONFIG_SMP=n\n CONFIG_SLOB=y\n # Linux kernel commit 149b6fa228ed (\"mm, slob: rename CONFIG_SLOB to\n-# CONFIG_SLOB_DEPRECATED\") (in v6.2) renamed to option for SLOB.\n+# CONFIG_SLOB_DEPRECATED\") (in v6.2) renamed the option for SLOB.\n CONFIG_SLOB_DEPRECATED=y\n # CONFIG_PREEMPT_DYNAMIC is not set\n CONFIG_PREEMPT_NONE=y\n"}
{"repo": "drgn", "commit": "55ddc19be40fe53ae2a22b95620b60db047c6435", "diff": "diff --git a/setup.py b/setup.py\nindex 00055d2c..94187963 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -284,6 +284,8 @@ fi\n         return returncode == 0\n \n     def run(self):\n+        import urllib.error\n+\n         from vmtest.download import download_kernels_in_thread\n \n         if os.getenv(\"GITHUB_ACTIONS\") == \"true\":\n@@ -304,46 +306,53 @@ fi\n \n         # Start downloads ASAP so that they're hopefully done by the time we\n         # need them.\n-        with download_kernels_in_thread(\n-            Path(self.vmtest_dir), \"x86_64\", self.kernels\n-        ) as kernel_downloads:\n-            if self.kernels:\n-                self.announce(\"downloading kernels in the background\", log.INFO)\n+        try:\n+            with download_kernels_in_thread(\n+                Path(self.vmtest_dir), \"x86_64\", self.kernels\n+            ) as kernel_downloads:\n+                if self.kernels:\n+                    self.announce(\"downloading kernels in the background\", log.INFO)\n+\n+                with github_workflow_group(\"Build extension\"):\n+                    self.run_command(\"egg_info\")\n+                    self.reinitialize_command(\"build_ext\", inplace=1)\n+                    self.run_command(\"build_ext\")\n \n-            with github_workflow_group(\"Build extension\"):\n-                self.run_command(\"egg_info\")\n-                self.reinitialize_command(\"build_ext\", inplace=1)\n-                self.run_command(\"build_ext\")\n+                passed = []\n+                failed = []\n \n-            passed = []\n-            failed = []\n+                with github_workflow_group(\"Run unit tests\"):\n+                    if self.kernels:\n+                        self.announce(\"running tests locally\", log.INFO)\n+                    if self._run_local():\n+                        passed.append(\"local\")\n+                    else:\n+                        failed.append(\"local\")\n \n-            with github_workflow_group(\"Run unit tests\"):\n                 if self.kernels:\n-                    self.announce(\"running tests locally\", log.INFO)\n-                if self._run_local():\n-                    passed.append(\"local\")\n-                else:\n-                    failed.append(\"local\")\n-\n-            if self.kernels:\n-                for kernel in kernel_downloads:\n-                    kernel_release = kernel.name\n-                    if kernel_release.startswith(\"kernel-\"):\n-                        kernel_release = kernel_release[len(\"kernel-\") :]\n-\n-                    with github_workflow_group(\n-                        f\"Run integration tests on Linux {kernel_release}\"\n-                    ):\n-                        if self._run_vm(kernel, kernel_release):\n-                            passed.append(kernel_release)\n-                        else:\n-                            failed.append(kernel_release)\n-\n-                if passed:\n-                    self.announce(f'Passed: {\", \".join(passed)}', log.INFO)\n-                if failed:\n-                    self.announce(f'Failed: {\", \".join(failed)}', log.ERROR)\n+                    for kernel in kernel_downloads:\n+                        kernel_release = kernel.name\n+                        if kernel_release.startswith(\"kernel-\"):\n+                            kernel_release = kernel_release[len(\"kernel-\") :]\n+\n+                        with github_workflow_group(\n+                            f\"Run integration tests on Linux {kernel_release}\"\n+                        ):\n+                            if self._run_vm(kernel, kernel_release):\n+                                passed.append(kernel_release)\n+                            else:\n+                                failed.append(kernel_release)\n+\n+                    if passed:\n+                        self.announce(f'Passed: {\", \".join(passed)}', log.INFO)\n+                    if failed:\n+                        self.announce(f'Failed: {\", \".join(failed)}', log.ERROR)\n+        except urllib.error.HTTPError as e:\n+            if e.code == 403:\n+                print(e, file=sys.stderr)\n+                print(\"Headers:\", e.headers, file=sys.stderr)\n+                print(\"Body:\", e.read().decode(), file=sys.stderr)\n+            raise\n \n         if failed:\n             raise DistutilsError(\"some tests failed\")\n"}
{"repo": "drgn", "commit": "6ad80feb8331ce1e6ed388abe491a706ad30d4b9", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex 8af0e52e..d24ed1fa 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -188,11 +188,15 @@ def main() -> None:\n \n     if args.default_symbols is None:\n         args.default_symbols = {\"default\": True, \"main\": True}\n+    missing_debug_info_warning = None\n     try:\n         prog.load_debug_info(args.symbols, **args.default_symbols)\n     except drgn.MissingDebugInfoError as e:\n         if not args.quiet:\n-            print(str(e), file=sys.stderr)\n+            prefix = \"warning:\"\n+            if hasattr(sys.stderr, \"fileno\") and os.isatty(sys.stderr.fileno()):\n+                prefix = f\"\\033[33m{prefix}\\033[0m\"\n+            missing_debug_info_warning = f\"{prefix} {e}\"\n \n     init_globals: Dict[str, Any] = {\"prog\": prog}\n     if args.script:\n@@ -200,6 +204,8 @@ def main() -> None:\n         script = args.script[0]\n         if pkgutil.get_importer(script) is None:\n             sys.path.insert(0, os.path.dirname(os.path.abspath(script)))\n+        if missing_debug_info_warning is not None:\n+            print(missing_debug_info_warning, file=sys.stderr)\n         runpy.run_path(script, init_globals=init_globals, run_name=\"__main__\")\n     else:\n         sys.path.insert(0, \"\")\n@@ -261,4 +267,6 @@ For help, type help(drgn).\n             module = importlib.import_module(\"drgn.helpers.linux\")\n             for name in module.__dict__[\"__all__\"]:\n                 init_globals[name] = getattr(module, name)\n+        if missing_debug_info_warning is not None:\n+            banner += \"\\n\" + missing_debug_info_warning\n         code.interact(banner=banner, exitmsg=\"\", local=init_globals)\n"}
{"repo": "drgn", "commit": "868ae513291886d533a67597220ce77b5238eed1", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 209c8d39..1f18aef4 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -708,6 +708,8 @@ def for_each_page(prog: Program) -> Iterator[Object]:\n         0xfffffb4a000c0040\n         ...\n \n+        This may be fixed in the future.\n+\n     :return: Iterator of ``struct page *`` objects.\n     \"\"\"\n     vmemmap = prog[\"vmemmap\"]\n"}
{"repo": "drgn", "commit": "0d9252ea0c7bb39715964c0ee31a93e2bcc010bf", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 5896ff9a..209c8d39 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -690,7 +690,23 @@ def decode_page_flags(page: Object) -> str:\n \n def for_each_page(prog: Program) -> Iterator[Object]:\n     \"\"\"\n-    Iterate over all pages in the system.\n+    Iterate over every ``struct page *`` from the minimum to the maximum page.\n+\n+    .. note::\n+\n+        This may include offline pages which don't have a valid ``struct\n+        page``. Wrap accesses in a ``try`` ... ``except``\n+        :class:`drgn.FaultError`:\n+\n+        >>> for page in for_each_page(prog):\n+        ...     try:\n+        ...         if PageLRU(page):\n+        ...             print(hex(page))\n+        ...     except drgn.FaultError:\n+        ...         continue\n+        0xfffffb4a000c0000\n+        0xfffffb4a000c0040\n+        ...\n \n     :return: Iterator of ``struct page *`` objects.\n     \"\"\"\n"}
{"repo": "drgn", "commit": "8867b6ee7e55b505645cf6bf389cec89d74cec11", "diff": "diff --git a/drgn/helpers/linux/xarray.py b/drgn/helpers/linux/xarray.py\nindex c78e39a7..77d318d1 100644\n--- a/drgn/helpers/linux/xarray.py\n+++ b/drgn/helpers/linux/xarray.py\n@@ -211,7 +211,7 @@ def xa_to_value(entry: Object) -> Object:\n     >>> xa_is_value(entry)\n     True\n     >>> xa_to_value(entry)\n-    100\n+    (unsigned long)100\n \n     :param entry: ``void *``\n     :return: ``unsigned long``\n@@ -228,6 +228,7 @@ def xa_is_zero(entry: Object) -> bool:\n     :func:`xa_load()` and :func:`xa_for_each()` when ``advanced = True``.\n \n     >>> entry = xa_load(xa, 10, advanced=True)\n+    >>> entry\n     (void *)0x406\n     >>> xa_is_zero(entry)\n     True\n"}
{"repo": "drgn", "commit": "cd769c06f000a1bb839b7ed62a3586df59d6e4e5", "diff": "diff --git a/drgn/helpers/linux/xarray.py b/drgn/helpers/linux/xarray.py\nindex 26bc3479..c78e39a7 100644\n--- a/drgn/helpers/linux/xarray.py\n+++ b/drgn/helpers/linux/xarray.py\n@@ -12,7 +12,7 @@ The ``drgn.helpers.linux.xarray`` module provides helpers for working with the\n .. note::\n \n     XArrays were introduced in Linux 4.20 as a replacement for `radix trees`_.\n-    To make it easier to work with data structure that were changed from a\n+    To make it easier to work with data structures that were changed from a\n     radix tree to an XArray (like ``struct address_space::i_pages``), drgn\n     treats XArrays and radix trees interchangeably in some cases.\n \n"}
{"repo": "drgn", "commit": "64860731482b691e549e2246a99fc01441c76d7d", "diff": "diff --git a/libdrgn/build-aux/gen_constants.py b/libdrgn/build-aux/gen_constants.py\nindex ecdb9aa7..8e2180b1 100644\n--- a/libdrgn/build-aux/gen_constants.py\n+++ b/libdrgn/build-aux/gen_constants.py\n@@ -59,7 +59,7 @@ static int add_{constant_class.name}(PyObject *m, PyObject *enum_module)\n     for i, (name, value) in enumerate(constants):\n         output_file.write(\n             f\"\"\"\\\n-        item = Py_BuildValue(\"sk\", \"{name}\", {value});\n+\titem = Py_BuildValue(\"sK\", \"{name}\", (unsigned long long){value});\n \tif (!item)\n \t\tgoto out;\n \tPyList_SET_ITEM(tmp, {i}, item);\n"}
{"repo": "drgn", "commit": "220c1c72f5fe76237e86afb5f2332bb3344c33bf", "diff": "diff --git a/drgn/helpers/common/stack.py b/drgn/helpers/common/stack.py\nindex 5a0c02f8..a9d73d91 100644\n--- a/drgn/helpers/common/stack.py\n+++ b/drgn/helpers/common/stack.py\n@@ -1,5 +1,5 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n-# SPDX-License-Identifier: GPL-3.0-or-later\n+# SPDX-License-Identifier: LGPL-2.1-or-later\n \n \"\"\"\n Stack\n"}
{"repo": "drgn", "commit": "0fad8a591ac6b633f7d7e3e2d21cad8b888f6916", "diff": "diff --git a/tests/test_program.py b/tests/test_program.py\nindex d96fd997..9936837d 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -541,6 +541,26 @@ class TestTypes(MockProgramTestCase):\n             ValueError, \"no suitable integer type for ptrdiff_t\", prog.type, \"ptrdiff_t\"\n         )\n \n+    def test_not_size_t_or_ptrdiff_t(self):\n+        self.types.append(\n+            self.prog.typedef_type(\n+                \"size_tea\", self.prog.int_type(\"unsigned char\", 1, False)\n+            )\n+        )\n+        self.types.append(\n+            self.prog.typedef_type(\"ptrdiff_tee\", self.prog.int_type(\"char\", 1, True))\n+        )\n+        self.assertIdentical(\n+            self.prog.type(\"size_tea\"),\n+            self.prog.typedef_type(\n+                \"size_tea\", self.prog.int_type(\"unsigned char\", 1, False)\n+            ),\n+        )\n+        self.assertIdentical(\n+            self.prog.type(\"ptrdiff_tee\"),\n+            self.prog.typedef_type(\"ptrdiff_tee\", self.prog.int_type(\"char\", 1, True)),\n+        )\n+\n     def test_tagged_type(self):\n         self.types.append(self.point_type)\n         self.types.append(self.option_type)\n"}
{"repo": "drgn", "commit": "72f1db796844c36ef7cf542166ad44336881e19e", "diff": "diff --git a/drgn/helpers/linux/kconfig.py b/drgn/helpers/linux/kconfig.py\nindex fb125cbb..568bae55 100644\n--- a/drgn/helpers/linux/kconfig.py\n+++ b/drgn/helpers/linux/kconfig.py\n@@ -48,7 +48,7 @@ def get_kconfig(prog: Program) -> Mapping[str, str]:\n         except KeyError:\n             raise LookupError(\n                 \"kernel configuration data not found; kernel must be compiled with CONFIG_IKCONFIG\"\n-            )\n+            ) from None\n         # The data is delimited by the magic strings \"IKCFG_ST\" and \"IKCFG_ED\"\n         # plus a NUL byte.\n         start = kernel_config_data.address_ + 8  # type: ignore[operator]\n"}
{"repo": "drgn", "commit": "fb554b32ded25a63af341370e0f0d5168d5a4758", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex 40d01d99..916c0408 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -160,12 +160,32 @@ def main() -> None:\n         os.environ[\"DEBUGINFOD_PROGRESS\"] = \"1\"\n \n     prog = drgn.Program()\n-    if args.core is not None:\n-        prog.set_core_dump(args.core)\n-    elif args.pid is not None:\n-        prog.set_pid(args.pid or os.getpid())\n-    else:\n-        prog.set_kernel()\n+    try:\n+        if args.core is not None:\n+            prog.set_core_dump(args.core)\n+        elif args.pid is not None:\n+            prog.set_pid(args.pid or os.getpid())\n+        else:\n+            prog.set_kernel()\n+    except PermissionError as e:\n+        print(e, file=sys.stderr)\n+        if args.pid is not None:\n+            print(\n+                \"error: attaching to live process requires ptrace attach permissions\",\n+                file=sys.stderr,\n+            )\n+        elif args.core is None:\n+            print(\n+                \"error: drgn debugs the live kernel by default, which requires root\",\n+                file=sys.stderr,\n+            )\n+        sys.exit(1)\n+    except OSError as e:\n+        sys.exit(e)\n+    except ValueError as e:\n+        # E.g., \"not an ELF core file\"\n+        sys.exit(f\"error: {e}\")\n+\n     if args.default_symbols is None:\n         args.default_symbols = {\"default\": True, \"main\": True}\n     try:\n"}
{"repo": "drgn", "commit": "0b7ac5b046c54f05bdfc23beb9b36b4435e53c73", "diff": "diff --git a/drgn/helpers/linux/sched.py b/drgn/helpers/linux/sched.py\nindex b0fc5d0e..27fb7303 100644\n--- a/drgn/helpers/linux/sched.py\n+++ b/drgn/helpers/linux/sched.py\n@@ -9,11 +9,15 @@ The ``drgn.helpers.linux.sched`` module provides helpers for working with the\n Linux CPU scheduler.\n \"\"\"\n \n-from _drgn import _linux_helper_idle_task as idle_task\n+from _drgn import (\n+    _linux_helper_idle_task as idle_task,\n+    _linux_helper_task_cpu as task_cpu,\n+)\n from drgn import Object\n \n __all__ = (\n     \"idle_task\",\n+    \"task_cpu\",\n     \"task_state_to_char\",\n )\n \ndiff --git a/tests/linux_kernel/helpers/test_sched.py b/tests/linux_kernel/helpers/test_sched.py\nindex 76cddd35..28543153 100644\n--- a/tests/linux_kernel/helpers/test_sched.py\n+++ b/tests/linux_kernel/helpers/test_sched.py\n@@ -6,7 +6,7 @@ import signal\n \n from drgn.helpers.linux.cpumask import for_each_possible_cpu\n from drgn.helpers.linux.pid import find_task\n-from drgn.helpers.linux.sched import idle_task, task_state_to_char\n+from drgn.helpers.linux.sched import idle_task, task_cpu, task_state_to_char\n from tests.linux_kernel import (\n     LinuxKernelTestCase,\n     fork_and_sigwait,\n@@ -17,6 +17,11 @@ from tests.linux_kernel import (\n \n \n class TestSched(LinuxKernelTestCase):\n+    def test_task_cpu(self):\n+        cpu = os.cpu_count() - 1\n+        with fork_and_sigwait(lambda: os.sched_setaffinity(0, (cpu,))) as pid:\n+            self.assertEqual(task_cpu(find_task(self.prog, pid)), cpu)\n+\n     def test_task_state_to_char(self):\n         task = find_task(self.prog, os.getpid())\n         self.assertEqual(task_state_to_char(task), \"R\")\n"}
{"repo": "drgn", "commit": "2f9b2742574b164e28329f6f1f2bbc8d77a9ca75", "diff": "diff --git a/tests/linux_kernel/__init__.py b/tests/linux_kernel/__init__.py\nindex 7cb616c9..f8f702e2 100644\n--- a/tests/linux_kernel/__init__.py\n+++ b/tests/linux_kernel/__init__.py\n@@ -10,7 +10,9 @@ import platform\n import re\n import signal\n import socket\n+import sys\n import time\n+import traceback\n from typing import NamedTuple\n import unittest\n \n@@ -97,47 +99,62 @@ skip_unless_have_full_mm_support = unittest.skipUnless(\n \n _machine = platform.machine()\n if _machine.startswith(\"aarch64\") or _machine.startswith(\"arm64\"):\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"alpha\":\n-    SYS = {\"bpf\": 515}\n+    SYS = {\"bpf\": 515, \"rt_sigtimedwait\": 355}\n elif _machine == \"arc\":\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"arm\"):\n-    SYS = {\"bpf\": 386}\n+    SYS = {\"bpf\": 386, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"csky\":\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"hexagon\":\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif re.fullmatch(r\"i.86\", _machine):\n-    SYS = {\"bpf\": 357}\n+    SYS = {\"bpf\": 357, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"ia64\":\n-    SYS = {\"bpf\": 317}\n+    SYS = {\"bpf\": 317, \"rt_sigtimedwait\": 159}\n elif _machine.startswith(\"loongarch\"):\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"m68k\":\n-    SYS = {\"bpf\": 354}\n+    SYS = {\"bpf\": 354, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"microblaze\":\n-    SYS = {\"bpf\": 387}\n+    SYS = {\"bpf\": 387, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"nios2\":\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"openrisc\":\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"parisc\"):\n-    SYS = {\"bpf\": 341}\n+    if sys.maxsize > 2**32:\n+        SYS = {\"bpf\": 341, \"rt_sigtimedwait\": 177}\n+    else:\n+        SYS = {\"bpf\": 341, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"ppc\"):\n-    SYS = {\"bpf\": 361}\n+    if sys.maxsize > 2**32:\n+        SYS = {\"bpf\": 361, \"rt_sigtimedwait\": 176}\n+    else:\n+        SYS = {\"bpf\": 361, \"rt_sigtimedwait\": 176, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"riscv\"):\n-    SYS = {\"bpf\": 280}\n+    SYS = {\"bpf\": 280, \"rt_sigtimedwait\": 137, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"s390\"):\n-    SYS = {\"bpf\": 351}\n+    if sys.maxsize > 2**32:\n+        SYS = {\"bpf\": 351, \"rt_sigtimedwait\": 177}\n+    else:\n+        SYS = {\"bpf\": 351, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"sh\"):\n-    SYS = {\"bpf\": 375}\n+    SYS = {\"bpf\": 375, \"rt_sigtimedwait\": 177, \"rt_sigtimedwait_time64\": 421}\n elif _machine.startswith(\"sparc\"):\n-    SYS = {\"bpf\": 349}\n+    if sys.maxsize > 2**32:\n+        SYS = {\"bpf\": 349, \"rt_sigtimedwait\": 105}\n+    else:\n+        SYS = {\"bpf\": 349, \"rt_sigtimedwait\": 105, \"rt_sigtimedwait_time64\": 421}\n elif _machine == \"x86_64\":\n-    SYS = {\"bpf\": 321}\n+    if sys.maxsize > 2**32:\n+        SYS = {\"bpf\": 321, \"rt_sigtimedwait\": 128}\n+    else:\n+        SYS = {\"bpf\": 321, \"rt_sigtimedwait\": 523}\n elif _machine == \"xtensa\":\n-    SYS = {\"bpf\": 340}\n+    SYS = {\"bpf\": 340, \"rt_sigtimedwait\": 229, \"rt_sigtimedwait_time64\": 421}\n else:\n     # TODO: the only other architecture supported by Linux as of 6.0 is mips,\n     # but I don't know how to distinguish between the o32, n32, and n64 ABIs.\n@@ -158,31 +175,51 @@ def wait_until(fn, *args, **kwds):\n         sleep *= 2\n \n \n-def fork_and_pause(fn=None):\n-    pid = os.fork()\n-    if pid == 0:\n-        if fn:\n-            fn()\n-        try:\n-            while True:\n-                signal.pause()\n-        finally:\n-            os._exit(1)\n-    return pid\n-\n-\n def proc_state(pid):\n     with open(f\"/proc/{pid}/status\", \"r\") as f:\n         return re.search(r\"State:\\s*(\\S)\", f.read(), re.M).group(1)\n \n \n-# Return whether a process is blocked and fully scheduled out. The process\n-# state is updated while the process is still running, so use this instead of\n-# proc_state(pid) != \"R\" to avoid races. This is not accurate if pid is the\n-# calling thread.\n-def proc_blocked(pid):\n+_sigwait_syscall_number_strs = {\n+    str(SYS[name])\n+    for name in (\"rt_sigtimedwait\", \"rt_sigtimedwait_time64\")\n+    if name in SYS\n+}\n+\n+\n+# Return whether a process is blocked in sigwait().\n+def proc_in_sigwait(pid):\n+    if proc_state(pid) != \"S\":\n+        return False\n     with open(f\"/proc/{pid}/syscall\", \"r\") as f:\n-        return f.read() != \"running\\n\"\n+        return f.read().partition(\" \")[0] in _sigwait_syscall_number_strs\n+\n+\n+# Context manager that:\n+# 1. Forks a process that blocks in sigwait() forever, optionally calling a\n+#    function beforehand.\n+# 2. Waits for the process to be in sigwait().\n+# 3. Returns the PID from __enter__().\n+# 4. Kills the process in __exit__().\n+@contextlib.contextmanager\n+def fork_and_sigwait(fn=None):\n+    pid = os.fork()\n+    try:\n+        if pid == 0:\n+            try:\n+                if fn:\n+                    fn()\n+                while True:\n+                    signal.sigwait(())\n+            finally:\n+                traceback.print_exc()\n+                sys.stderr.flush()\n+                os._exit(1)\n+        wait_until(proc_in_sigwait, pid)\n+        yield pid\n+    finally:\n+        os.kill(pid, signal.SIGKILL)\n+        os.waitpid(pid, 0)\n \n \n def smp_enabled():\ndiff --git a/tests/linux_kernel/helpers/test_cgroup.py b/tests/linux_kernel/helpers/test_cgroup.py\nindex c934166b..6d88897a 100644\n--- a/tests/linux_kernel/helpers/test_cgroup.py\n+++ b/tests/linux_kernel/helpers/test_cgroup.py\n@@ -4,7 +4,6 @@\n import contextlib\n import os\n from pathlib import Path\n-import signal\n import tempfile\n import unittest\n \n@@ -18,7 +17,7 @@ from drgn.helpers.linux.cgroup import (\n     css_for_each_descendant_pre,\n )\n from drgn.helpers.linux.pid import find_task\n-from tests.linux_kernel import LinuxKernelTestCase, fork_and_pause, iter_mounts\n+from tests.linux_kernel import LinuxKernelTestCase, fork_and_sigwait, iter_mounts\n \n \n @contextlib.contextmanager\n@@ -56,8 +55,7 @@ class TestCgroup(LinuxKernelTestCase):\n \n             cls.root_cgroup = cls.prog[\"cgrp_dfl_root\"].cgrp.address_of_()\n \n-            pid = fork_and_pause()\n-            try:\n+            with fork_and_sigwait() as pid:\n                 task = find_task(cls.prog, pid)\n \n                 cls.parent_cgroup_name = os.fsencode(parent_cgroup_dir.name)\n@@ -73,9 +71,6 @@ class TestCgroup(LinuxKernelTestCase):\n \n                 (child_cgroup_dir / \"cgroup.procs\").write_text(str(pid))\n                 cls.child_cgroup = task.cgroups.dfl_cgrp.read_()\n-            finally:\n-                os.kill(pid, signal.SIGKILL)\n-                os.waitpid(pid, 0)\n         except BaseException:\n             for cleanup in reversed(cls.__cleanups):\n                 cleanup[0](*cleanup[1:])\ndiff --git a/tests/linux_kernel/helpers/test_sched.py b/tests/linux_kernel/helpers/test_sched.py\nindex c77f347d..76cddd35 100644\n--- a/tests/linux_kernel/helpers/test_sched.py\n+++ b/tests/linux_kernel/helpers/test_sched.py\n@@ -9,7 +9,7 @@ from drgn.helpers.linux.pid import find_task\n from drgn.helpers.linux.sched import idle_task, task_state_to_char\n from tests.linux_kernel import (\n     LinuxKernelTestCase,\n-    fork_and_pause,\n+    fork_and_sigwait,\n     proc_state,\n     smp_enabled,\n     wait_until,\n@@ -21,21 +21,19 @@ class TestSched(LinuxKernelTestCase):\n         task = find_task(self.prog, os.getpid())\n         self.assertEqual(task_state_to_char(task), \"R\")\n \n-        pid = fork_and_pause()\n-        task = find_task(self.prog, pid)\n+        with fork_and_sigwait() as pid:\n+            task = find_task(self.prog, pid)\n \n-        wait_until(lambda: proc_state(pid) == \"S\")\n-        self.assertEqual(task_state_to_char(task), \"S\")\n+            wait_until(lambda: proc_state(pid) == \"S\")\n+            self.assertEqual(task_state_to_char(task), \"S\")\n \n-        os.kill(pid, signal.SIGSTOP)\n-        wait_until(lambda: proc_state(pid) == \"T\")\n-        self.assertEqual(task_state_to_char(task), \"T\")\n+            os.kill(pid, signal.SIGSTOP)\n+            wait_until(lambda: proc_state(pid) == \"T\")\n+            self.assertEqual(task_state_to_char(task), \"T\")\n \n-        os.kill(pid, signal.SIGKILL)\n-        wait_until(lambda: proc_state(pid) == \"Z\")\n-        self.assertEqual(task_state_to_char(task), \"Z\")\n-\n-        os.waitpid(pid, 0)\n+            os.kill(pid, signal.SIGKILL)\n+            wait_until(lambda: proc_state(pid) == \"Z\")\n+            self.assertEqual(task_state_to_char(task), \"Z\")\n \n     def test_idle_task(self):\n         if smp_enabled():\ndiff --git a/tests/linux_kernel/helpers/test_user.py b/tests/linux_kernel/helpers/test_user.py\nindex 2065d059..703e891f 100644\n--- a/tests/linux_kernel/helpers/test_user.py\n+++ b/tests/linux_kernel/helpers/test_user.py\n@@ -1,17 +1,12 @@\n # Copyright (c) Meta Platforms, Inc. and affiliates.\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n+import contextlib\n import functools\n import os\n-import signal\n \n from drgn.helpers.linux.user import find_user, for_each_user\n-from tests.linux_kernel import (\n-    LinuxKernelTestCase,\n-    fork_and_pause,\n-    proc_state,\n-    wait_until,\n-)\n+from tests.linux_kernel import LinuxKernelTestCase, fork_and_sigwait\n \n \n class TestUser(LinuxKernelTestCase):\n@@ -20,23 +15,13 @@ class TestUser(LinuxKernelTestCase):\n \n     def test_find_user(self):\n         for uid in self.UIDS:\n-            pid = fork_and_pause(functools.partial(os.setuid, uid))\n-            try:\n-                wait_until(lambda: proc_state(pid) == \"S\")\n+            with fork_and_sigwait(functools.partial(os.setuid, uid)):\n                 found_uid = find_user(self.prog, uid).uid.val.value_()\n-            finally:\n-                os.kill(pid, signal.SIGKILL)\n             self.assertEqual(found_uid, uid)\n \n     def test_for_each_user(self):\n-        pids = []\n-        try:\n+        with contextlib.ExitStack() as stack:\n             for uid in self.UIDS:\n-                pid = fork_and_pause(functools.partial(os.setuid, uid))\n-                wait_until(lambda: proc_state(pid) == \"S\")\n-                pids.append(pid)\n+                stack.enter_context(fork_and_sigwait(functools.partial(os.setuid, uid)))\n             found_uids = {user.uid.val.value_() for user in for_each_user(self.prog)}\n-        finally:\n-            for pid in pids:\n-                os.kill(pid, signal.SIGKILL)\n         self.assertTrue(self.UIDS.issubset(found_uids))\ndiff --git a/tests/linux_kernel/test_stack_trace.py b/tests/linux_kernel/test_stack_trace.py\nindex 7e6bb52f..4d3c7e9d 100644\n--- a/tests/linux_kernel/test_stack_trace.py\n+++ b/tests/linux_kernel/test_stack_trace.py\n@@ -2,33 +2,25 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n import os\n-import signal\n \n from drgn import Object, Program, cast\n from drgn.helpers.linux.pid import find_task\n from tests import assertReprPrettyEqualsStr\n-from tests.linux_kernel import (\n-    LinuxKernelTestCase,\n-    fork_and_pause,\n-    proc_blocked,\n-    setenv,\n-    wait_until,\n-)\n+from tests.linux_kernel import LinuxKernelTestCase, fork_and_sigwait, setenv\n \n \n class TestStackTrace(LinuxKernelTestCase):\n-    def _assert_trace_paused(self, trace):\n+    def _assert_trace_in_sigwait(self, trace):\n         for frame in trace:\n-            if \"pause\" in frame.name or \"poll\" in frame.name:\n+            if frame.name and \"sigtimedwait\" in frame.name:\n                 return\n-        self.fail(f\"pause frame not found in {str(trace)!r}\")\n+        self.fail(f\"sigwait frame not found in {str(trace)!r}\")\n \n     def test_by_task_struct(self):\n-        pid = fork_and_pause()\n-        wait_until(proc_blocked, pid)\n-        self._assert_trace_paused(self.prog.stack_trace(find_task(self.prog, pid)))\n-        os.kill(pid, signal.SIGKILL)\n-        os.waitpid(pid, 0)\n+        with fork_and_sigwait() as pid:\n+            self._assert_trace_in_sigwait(\n+                self.prog.stack_trace(find_task(self.prog, pid))\n+            )\n \n     def _test_by_pid(self, orc):\n         old_orc = int(os.environ.get(\"DRGN_PREFER_ORC_UNWINDER\", \"0\")) != 0\n@@ -39,11 +31,8 @@ class TestStackTrace(LinuxKernelTestCase):\n                 prog = Program()\n                 prog.set_kernel()\n                 self._load_debug_info(prog)\n-            pid = fork_and_pause()\n-            wait_until(proc_blocked, pid)\n-            self._assert_trace_paused(prog.stack_trace(pid))\n-            os.kill(pid, signal.SIGKILL)\n-            os.waitpid(pid, 0)\n+            with fork_and_sigwait() as pid:\n+                self._assert_trace_in_sigwait(prog.stack_trace(pid))\n \n     def test_by_pid_dwarf(self):\n         self._test_by_pid(False)\n@@ -52,21 +41,18 @@ class TestStackTrace(LinuxKernelTestCase):\n         self._test_by_pid(True)\n \n     def test_local_variable(self):\n-        pid = fork_and_pause()\n-        wait_until(proc_blocked, pid)\n-        for frame in self.prog.stack_trace(pid):\n-            if frame.name in (\"context_switch\", \"__schedule\"):\n-                try:\n-                    prev = frame[\"prev\"]\n-                except KeyError:\n-                    continue\n-                if not prev.absent_:\n-                    self.assertEqual(prev.pid, pid)\n-                    break\n-        else:\n-            self.skipTest(\"prev not found in context_switch or __schedule\")\n-        os.kill(pid, signal.SIGKILL)\n-        os.waitpid(pid, 0)\n+        with fork_and_sigwait() as pid:\n+            for frame in self.prog.stack_trace(pid):\n+                if frame.name in (\"context_switch\", \"__schedule\"):\n+                    try:\n+                        prev = frame[\"prev\"]\n+                    except KeyError:\n+                        continue\n+                    if not prev.absent_:\n+                        self.assertEqual(prev.pid, pid)\n+                        break\n+            else:\n+                self.skipTest(\"prev not found in context_switch or __schedule\")\n \n     def test_pt_regs(self):\n         # This won't unwind anything useful, but at least make sure it accepts\n@@ -81,17 +67,14 @@ class TestStackTrace(LinuxKernelTestCase):\n     def test_registers(self):\n         # Smoke test that we get at least one register and that\n         # StackFrame.registers() agrees with StackFrame.register().\n-        pid = fork_and_pause()\n-        wait_until(proc_blocked, pid)\n-        trace = self.prog.stack_trace(pid)\n-        have_registers = False\n-        for frame in trace:\n-            for name, value in frame.registers().items():\n-                self.assertEqual(frame.register(name), value)\n-                have_registers = True\n-        self.assertTrue(have_registers)\n-        os.kill(pid, signal.SIGKILL)\n-        os.waitpid(pid, 0)\n+        with fork_and_sigwait() as pid:\n+            trace = self.prog.stack_trace(pid)\n+            have_registers = False\n+            for frame in trace:\n+                for name, value in frame.registers().items():\n+                    self.assertEqual(frame.register(name), value)\n+                    have_registers = True\n+            self.assertTrue(have_registers)\n \n     def test_prog(self):\n         self.assertEqual(\n@@ -100,11 +83,8 @@ class TestStackTrace(LinuxKernelTestCase):\n         )\n \n     def test_stack__repr_pretty_(self):\n-        pid = fork_and_pause()\n-        wait_until(proc_blocked, pid)\n-        trace = self.prog.stack_trace(pid)\n-        assertReprPrettyEqualsStr(trace)\n-        for frame in trace:\n-            assertReprPrettyEqualsStr(frame)\n-        os.kill(pid, signal.SIGKILL)\n-        os.waitpid(pid, 0)\n+        with fork_and_sigwait() as pid:\n+            trace = self.prog.stack_trace(pid)\n+            assertReprPrettyEqualsStr(trace)\n+            for frame in trace:\n+                assertReprPrettyEqualsStr(frame)\n"}
{"repo": "drgn", "commit": "0825dda1166aeea319ffb93e79323c5ce2aa1fde", "diff": "diff --git a/drgn/helpers/common/memory.py b/drgn/helpers/common/memory.py\nindex 6550ce4d..507ee2dd 100644\n--- a/drgn/helpers/common/memory.py\n+++ b/drgn/helpers/common/memory.py\n@@ -5,7 +5,7 @@\n Memory\n ------\n \n-The ``drgn.helpers.memory`` module provides helpers for working with memory and addresses.\n+The ``drgn.helpers.common.memory`` module provides helpers for working with memory and addresses.\n \"\"\"\n \n import operator\n"}
{"repo": "drgn", "commit": "30c9ad452db65d745cfecea12ce8e46b1f829a80", "diff": "diff --git a/tests/linux_kernel/helpers/test_percpu.py b/tests/linux_kernel/helpers/test_percpu.py\nindex 2c952fa8..cdd94215 100644\n--- a/tests/linux_kernel/helpers/test_percpu.py\n+++ b/tests/linux_kernel/helpers/test_percpu.py\n@@ -2,8 +2,12 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n from drgn.helpers.linux.cpumask import for_each_possible_cpu\n-from drgn.helpers.linux.percpu import per_cpu\n-from tests.linux_kernel import LinuxKernelTestCase, smp_enabled\n+from drgn.helpers.linux.percpu import per_cpu, per_cpu_ptr\n+from tests.linux_kernel import (\n+    LinuxKernelTestCase,\n+    skip_unless_have_test_kmod,\n+    smp_enabled,\n+)\n \n \n class TestPerCpu(LinuxKernelTestCase):\n@@ -18,3 +22,21 @@ class TestPerCpu(LinuxKernelTestCase):\n                 self.assertEqual(\n                     per_cpu(self.prog[\"runqueues\"], cpu).idle.comm.string_(), b\"swapper\"\n                 )\n+\n+    @skip_unless_have_test_kmod\n+    def test_per_cpu_module_static(self):\n+        expected = prime = self.prog[\"drgn_test_percpu_static_prime\"]\n+        for cpu in for_each_possible_cpu(self.prog):\n+            expected *= prime\n+            self.assertEqual(\n+                per_cpu(self.prog[\"drgn_test_percpu_static\"], cpu), expected\n+            )\n+\n+    @skip_unless_have_test_kmod\n+    def test_per_cpu_module_dynamic(self):\n+        expected = prime = self.prog[\"drgn_test_percpu_dynamic_prime\"]\n+        for cpu in for_each_possible_cpu(self.prog):\n+            expected *= prime\n+            self.assertEqual(\n+                per_cpu_ptr(self.prog[\"drgn_test_percpu_dynamic\"], cpu)[0], expected\n+            )\n"}
{"repo": "drgn", "commit": "be04182ae79e279b6b193c1b3913122f3ad7ddfb", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex 3cedfd70..3d1e1760 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -300,12 +300,12 @@ def find_containing_slab_cache(  # type: ignore  # Need positional-only argument\n     page = virt_to_page(prog, addr)\n \n     try:\n-        PG_slab_mask = 1 << prog.constant(\"PG_slab\")\n+        page_flags = page.flags\n     except FaultError:\n         # Page does not exist\n         return NULL(prog, \"struct kmem_cache *\")\n \n-    if not page.flags & PG_slab_mask:\n+    if not page_flags & (1 << prog.constant(\"PG_slab\")):\n         # Not a slab page\n         return NULL(prog, \"struct kmem_cache *\")\n \n"}
{"repo": "drgn", "commit": "ca373fe38a8fb23308e4c0664686154297de4e34", "diff": "diff --git a/docs/conf.py b/docs/conf.py\nindex f8fad5a0..2e401113 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -36,7 +36,7 @@ html_static_path = [\"_static\"]\n html_theme = \"alabaster\"\n \n html_theme_options = {\n-    \"description\": \"Debugger-as-a-library\",\n+    \"description\": \"Programmable debugger\",\n     \"logo\": \"logo.png\",\n     \"logo_name\": True,\n     \"logo_text_align\": \"center\",\ndiff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 58c4eb2c..06e6aee6 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -2,9 +2,9 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n \"\"\"\n-Scriptable debugger library\n+Programmable debugger\n \n-drgn is a scriptable debugger. It is built on top of Python, so if you\n+drgn is a programmable debugger. It is built on top of Python, so if you\n don't know at least a little bit of Python, go learn it first.\n \n drgn supports an interactive mode and a script mode. Both are simply a\ndiff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex bd5a73a3..77536b09 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -75,7 +75,7 @@ def main() -> None:\n     python_version = \".\".join(str(v) for v in sys.version_info[:3])\n     libkdumpfile = f'with{\"\" if drgn._with_libkdumpfile else \"out\"} libkdumpfile'\n     version = f\"drgn {drgn.__version__} (using Python {python_version}, elfutils {drgn._elfutils_version}, {libkdumpfile})\"\n-    parser = argparse.ArgumentParser(prog=\"drgn\", description=\"Scriptable debugger\")\n+    parser = argparse.ArgumentParser(prog=\"drgn\", description=\"Programmable debugger\")\n \n     program_group = parser.add_argument_group(\n         title=\"program selection\",\ndiff --git a/setup.py b/setup.py\nindex d91d9c17..2c0703ad 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -448,7 +448,7 @@ setup(\n     python_requires=\">=3.6\",\n     author=\"Omar Sandoval\",\n     author_email=\"osandov@osandov.com\",\n-    description=\"Scriptable debugger library\",\n+    description=\"Programmable debugger\",\n     long_description=long_description,\n     long_description_content_type=\"text/x-rst\",\n     url=\"https://github.com/osandov/drgn\",\n"}
{"repo": "drgn", "commit": "f5b25763143d8c207c9a006aeb852bea7ec16a45", "diff": "diff --git a/drgn/helpers/linux/bpf.py b/drgn/helpers/linux/bpf.py\nindex e062e3e2..8ca242fe 100644\n--- a/drgn/helpers/linux/bpf.py\n+++ b/drgn/helpers/linux/bpf.py\n@@ -16,7 +16,7 @@ from typing import Iterator\n \n from drgn import IntegerLike, Object, Program, cast\n from drgn.helpers.linux.idr import idr_for_each\n-from drgn.helpers.linux.list import list_for_each_entry\n+from drgn.helpers.linux.list import hlist_for_each_entry, list_for_each_entry\n \n __all__ = (\n     \"bpf_btf_for_each\",\n@@ -127,9 +127,15 @@ def cgroup_bpf_prog_for_each(\n         if prog:\n             yield prog\n     else:\n-        for pl in list_for_each_entry(\n-            \"struct bpf_prog_list\", progs[bpf_attach_type].address_of_(), \"node\"\n-        ):\n+        # Since Linux kernel commit 00442143a2ab (\"bpf: convert\n+        # cgroup_bpf.progs to hlist\") (in v6.0-rc1), the list of programs is an\n+        # hlist_head. Before that, it was a list_head.\n+        list = progs[bpf_attach_type].address_of_()\n+        if hasattr(list, \"first\"):\n+            iterator = hlist_for_each_entry\n+        else:\n+            iterator = list_for_each_entry\n+        for pl in iterator(\"struct bpf_prog_list\", list, \"node\"):\n             yield pl.prog\n \n \n"}
{"repo": "drgn", "commit": "6f3408829f82114d765f27de70712d4c1e1f2118", "diff": "diff --git a/drgn/helpers/linux/llist.py b/drgn/helpers/linux/llist.py\nindex e40083af..08127dd9 100644\n--- a/drgn/helpers/linux/llist.py\n+++ b/drgn/helpers/linux/llist.py\n@@ -3,7 +3,7 @@\n \n \"\"\"\n Lockless Lists\n-------------\n+--------------\n \n The ``drgn.helpers.linux.llist`` module provides helpers for working with the\n lockless, ``NULL``-terminated, singly-linked list implementation in\n"}
{"repo": "drgn", "commit": "901c1fb190d76f058f263380c1fbde9329288e85", "diff": "diff --git a/tests/linux_kernel/__init__.py b/tests/linux_kernel/__init__.py\nindex 2d9cadae..481a31d7 100644\n--- a/tests/linux_kernel/__init__.py\n+++ b/tests/linux_kernel/__init__.py\n@@ -191,19 +191,26 @@ MS_STRICTATIME = 1 << 24\n MS_LAZYTIME = 1 << 25\n \n \n+def _check_ctypes_syscall(ret, *args):\n+    if ret == -1:\n+        errno = ctypes.get_errno()\n+        raise OSError(errno, os.strerror(errno), *args)\n+    return ret\n+\n+\n def mount(source, target, fstype, flags=0, data=None):\n-    if (\n+    _check_ctypes_syscall(\n         _mount(\n             os.fsencode(source),\n             os.fsencode(target),\n             fstype.encode(),\n             flags,\n             None if data is None else data.encode(),\n-        )\n-        == -1\n-    ):\n-        errno = ctypes.get_errno()\n-        raise OSError(errno, os.strerror(errno), source, None, target)\n+        ),\n+        source,\n+        None,\n+        target,\n+    )\n \n \n _umount2 = _c.umount2\n@@ -212,9 +219,7 @@ _umount2.argtypes = [ctypes.c_char_p, ctypes.c_int]\n \n \n def umount(target, flags=0):\n-    if _umount2(os.fsencode(target), flags) == -1:\n-        errno = ctypes.get_errno()\n-        raise OSError(errno, os.strerror(errno), target)\n+    _check_ctypes_syscall(_umount2(os.fsencode(target), flags), target)\n \n \n _MOUNTS_RE = re.compile(\n@@ -249,9 +254,7 @@ _mlock.argtypes = [ctypes.c_void_p, ctypes.c_size_t]\n \n \n def mlock(addr, len):\n-    if _mlock(addr, len) == -1:\n-        errno = ctypes.get_errno()\n-        raise OSError(errno, os.strerror(errno))\n+    _check_ctypes_syscall(_mlock(addr, len))\n \n \n def create_socket(*args, **kwds):\n"}
{"repo": "drgn", "commit": "e0b24903d760ba92cf71ccbe205f993add8e6c6b", "diff": "diff --git a/tests/linux_kernel/test_debug_info.py b/tests/linux_kernel/test_debug_info.py\nindex 4ee94f58..e1779643 100644\n--- a/tests/linux_kernel/test_debug_info.py\n+++ b/tests/linux_kernel/test_debug_info.py\n@@ -18,7 +18,7 @@ KALLSYMS_PATH = Path(\"/proc/kallsyms\")\n class TestModuleDebugInfo(LinuxKernelTestCase):\n     # Arbitrary symbol that we can use to check that the module debug info was\n     # loaded.\n-    SYMBOL = \"drgn_test_empty_list\"\n+    SYMBOL = \"drgn_test_function\"\n \n     def setUp(self):\n         super().setUp()\n"}
{"repo": "drgn", "commit": "cbdf6094b782e548106059bb1a565b33b17a8f15", "diff": "diff --git a/libdrgn/arch_ppc64_defs.py b/libdrgn/arch_ppc64_defs.py\nindex 2b5ecadd..4edf810f 100644\n--- a/libdrgn/arch_ppc64_defs.py\n+++ b/libdrgn/arch_ppc64_defs.py\n@@ -3,6 +3,7 @@\n \n REGISTERS = [\n     *[DrgnRegister(f\"r{i}\") for i in range(32)],\n+    DrgnRegister(\"lr\"),\n     *[DrgnRegister(f\"cr{i}\") for i in range(8)],\n ]\n \n@@ -15,10 +16,7 @@ REGISTERS = [\n # 1: https://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html\n # 2: https://openpowerfoundation.org/specifications/64bitelfabi/\n REGISTER_LAYOUT = [\n-    # The psABI calls register 65 the link register, but it's used as the DWARF\n-    # CFI return_address_register, so it usually contains the program counter.\n-    # To avoid confusing users, we don't expose it in REGISTERS.\n-    DrgnRegisterLayout(\"ra\", size=8, dwarf_number=65),\n+    DrgnRegisterLayout(\"lr\", size=8, dwarf_number=65),\n     *[DrgnRegisterLayout(f\"r{i}\", size=8, dwarf_number=i) for i in range(32)],\n     *[DrgnRegisterLayout(f\"cr{i}\", size=8, dwarf_number=68 + i) for i in range(8)],\n ]\n"}
{"repo": "drgn", "commit": "0eccc61b30c5101b0c35a890e390b6b4d855b326", "diff": "diff --git a/tests/linux_kernel/test_debug_info.py b/tests/linux_kernel/test_debug_info.py\nindex 020602f5..4ee94f58 100644\n--- a/tests/linux_kernel/test_debug_info.py\n+++ b/tests/linux_kernel/test_debug_info.py\n@@ -6,7 +6,7 @@ from pathlib import Path\n import unittest\n \n from drgn import Program\n-from tests.linux_kernel import LinuxKernelTestCase, setenv\n+from tests.linux_kernel import LinuxKernelTestCase, setenv, skip_unless_have_test_kmod\n \n KALLSYMS_PATH = Path(\"/proc/kallsyms\")\n \n@@ -14,20 +14,14 @@ KALLSYMS_PATH = Path(\"/proc/kallsyms\")\n @unittest.skipUnless(\n     KALLSYMS_PATH.exists(), \"kernel does not have kallsyms (CONFIG_KALLSYMS)\"\n )\n+@skip_unless_have_test_kmod\n class TestModuleDebugInfo(LinuxKernelTestCase):\n     # Arbitrary symbol that we can use to check that the module debug info was\n     # loaded.\n-    SYMBOL = \"lo_open\"\n+    SYMBOL = \"drgn_test_empty_list\"\n \n     def setUp(self):\n         super().setUp()\n-        with open(\"/proc/modules\", \"r\") as f:\n-            for line in f:\n-                if line.startswith(\"loop \"):\n-                    break\n-            else:\n-                self.skipTest(\"loop module is built in or not loaded\")\n-\n         with KALLSYMS_PATH.open() as f:\n             for line in f:\n                 tokens = line.split()\n"}
{"repo": "drgn", "commit": "32687f8f9c38639b1c7f4d5b29c9c42f415e1f5c", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex c7dd7328..df05eec3 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -175,9 +175,13 @@ def slab_cache_for_each_allocated_object(\n \n         cpu_freelists: Set[int] = set()\n         cpu_slab = slab_cache.cpu_slab.read_()\n+        # Since Linux kernel commit bb192ed9aa71 (\"mm/slub: Convert most struct\n+        # page to struct slab by spatch\") (in v5.17), the current slab for a\n+        # CPU is `struct slab *slab`. Before that, it is `struct page *page`.\n+        cpu_slab_attr = \"slab\" if hasattr(cpu_slab, \"slab\") else \"page\"\n         for cpu in for_each_online_cpu(prog):\n             this_cpu_slab = per_cpu_ptr(cpu_slab, cpu)\n-            slab = this_cpu_slab.slab.read_()\n+            slab = getattr(this_cpu_slab, cpu_slab_attr).read_()\n             if slab and slab.slab_cache == slab_cache:\n                 _slub_get_freelist(this_cpu_slab.freelist, cpu_freelists)\n \n"}
{"repo": "drgn", "commit": "200d7eb80c9df8153257dd96480f955842cf4d2f", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex e3f525bc..c7dd7328 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -17,7 +17,7 @@ Linux slab allocator.\n \n from typing import Iterator, Optional, Set, Union\n \n-from drgn import FaultError, Object, Program, Type, cast\n+from drgn import FaultError, Object, Program, Type, cast, sizeof\n from drgn.helpers import escape_ascii_string\n from drgn.helpers.linux.cpumask import for_each_online_cpu\n from drgn.helpers.linux.list import list_for_each_entry\n@@ -140,23 +140,46 @@ def slab_cache_for_each_allocated_object(\n         except AttributeError:\n             red_left_pad = 0\n \n+        # In SLUB, the freelist is a linked list with the next pointer located\n+        # at ptr + slab_cache->offset.\n         try:\n             freelist_offset = slab_cache.offset.value_()\n         except AttributeError:\n             raise ValueError(\"SLOB is not supported\") from None\n \n+        # If CONFIG_SLAB_FREELIST_HARDENED is enabled, then the next pointer is\n+        # obfuscated using slab_cache->random.\n+        try:\n+            freelist_random = slab_cache.random.value_()\n+        except AttributeError:\n+\n+            def _freelist_dereference(ptr_addr: int) -> int:\n+                return prog.read_word(ptr_addr)\n+\n+        else:\n+            ulong_size = sizeof(prog.type(\"unsigned long\"))\n+\n+            def _freelist_dereference(ptr_addr: int) -> int:\n+                # *ptr_addr ^ slab_cache->random ^ byteswap(ptr_addr)\n+                return (\n+                    prog.read_word(ptr_addr)\n+                    ^ freelist_random\n+                    ^ int.from_bytes(ptr_addr.to_bytes(ulong_size, \"little\"), \"big\")\n+                )\n+\n         def _slub_get_freelist(freelist: Object, freelist_set: Set[int]) -> None:\n-            # In SLUB, the freelist is a linked list with the next pointer\n-            # located at ptr + slab_cache->offset.\n             ptr = freelist.value_()\n             while ptr:\n                 freelist_set.add(ptr)\n-                ptr = prog.read_word(ptr + freelist_offset)\n+                ptr = _freelist_dereference(ptr + freelist_offset)\n \n         cpu_freelists: Set[int] = set()\n         cpu_slab = slab_cache.cpu_slab.read_()\n         for cpu in for_each_online_cpu(prog):\n-            _slub_get_freelist(per_cpu_ptr(cpu_slab, cpu).freelist, cpu_freelists)\n+            this_cpu_slab = per_cpu_ptr(cpu_slab, cpu)\n+            slab = this_cpu_slab.slab.read_()\n+            if slab and slab.slab_cache == slab_cache:\n+                _slub_get_freelist(this_cpu_slab.freelist, cpu_freelists)\n \n         def _slab_page_objects(page: Object, slab: Object) -> Iterator[Object]:\n             freelist: Set[int] = set()\n"}
{"repo": "drgn", "commit": "a3b72e33c8879f2962e3edc54291183233613b44", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 45605be6..58c4eb2c 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -76,8 +76,6 @@ from _drgn import (\n     TypeMember,\n     TypeParameter,\n     TypeTemplateParameter,\n-    _elfutils_version as _elfutils_version,\n-    _with_libkdumpfile as _with_libkdumpfile,\n     cast,\n     container_of,\n     filename_matches,\n@@ -89,7 +87,14 @@ from _drgn import (\n     reinterpret,\n     sizeof,\n )\n-from drgn.internal.version import __version__ as __version__\n+\n+# flake8 doesn't honor import X as X. See PyCQA/pyflakes#474.\n+# isort: split\n+from _drgn import (  # noqa: F401\n+    _elfutils_version as _elfutils_version,\n+    _with_libkdumpfile as _with_libkdumpfile,\n+)\n+from drgn.internal.version import __version__ as __version__  # noqa: F401\n \n __all__ = (\n     \"Architecture\",\ndiff --git a/drgn/helpers/linux/rbtree.py b/drgn/helpers/linux/rbtree.py\nindex c2340cde..e97d7d55 100644\n--- a/drgn/helpers/linux/rbtree.py\n+++ b/drgn/helpers/linux/rbtree.py\n@@ -9,7 +9,7 @@ The ``drgn.helpers.linux.rbtree`` module provides helpers for working with\n red-black trees from :linux:`include/linux/rbtree.h`.\n \"\"\"\n \n-from typing import Callable, Generator, Iterator, Optional, Tuple, TypeVar, Union\n+from typing import Callable, Generator, Iterator, Tuple, TypeVar, Union\n \n from drgn import NULL, Object, Type, container_of\n from drgn.helpers import ValidationError\ndiff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex c5747950..d2ad381f 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -25,7 +25,6 @@ def _identify_script(path: str) -> str:\n         header = f.read(EI_NIDENT + SIZEOF_E_TYPE)\n \n     ELFMAG = b\"\\177ELF\"\n-    SELFMAG = 4\n     EI_DATA = 5\n     ELFDATA2LSB = 1\n     ELFDATA2MSB = 2\ndiff --git a/libdrgn/build-aux/gen_arch_inc_strswitch.py b/libdrgn/build-aux/gen_arch_inc_strswitch.py\nindex d5d8bc09..ff09f784 100755\n--- a/libdrgn/build-aux/gen_arch_inc_strswitch.py\n+++ b/libdrgn/build-aux/gen_arch_inc_strswitch.py\n@@ -166,8 +166,8 @@ def gen_arch_inc_strswitch(in_file: TextIO, in_filename: str, out_file: TextIO)\n         for name in register.names:\n             out_file.write(f\"\\t@case {c_string_literal(name)}@\\n\")\n             out_file.write(f\"\\t\\treturn &registers[{i}];\\n\")\n-    out_file.write(f\"\\t@default@\\n\")\n-    out_file.write(f\"\\t\\treturn NULL;\\n\")\n+    out_file.write(\"\\t@default@\\n\")\n+    out_file.write(\"\\t\\treturn NULL;\\n\")\n     out_file.write(\"\\t@endswitch@\\n\")\n     out_file.write(\"}\\n\")\n \ndiff --git a/libdrgn/build-aux/gen_c_keywords_inc_strswitch.py b/libdrgn/build-aux/gen_c_keywords_inc_strswitch.py\nindex 1201900b..03e99441 100755\n--- a/libdrgn/build-aux/gen_c_keywords_inc_strswitch.py\n+++ b/libdrgn/build-aux/gen_c_keywords_inc_strswitch.py\n@@ -46,7 +46,7 @@ def main() -> None:\n         else:\n             print(f\"\\t\\treturn {token_kind};\")\n     print(\"\\t@default@\")\n-    print(f\"\\t\\treturn C_TOKEN_IDENTIFIER;\")\n+    print(\"\\t\\treturn C_TOKEN_IDENTIFIER;\")\n     print(\"\\t@endswitch@\")\n     print(\"}\")\n \ndiff --git a/libdrgn/build-aux/gen_strswitch.py b/libdrgn/build-aux/gen_strswitch.py\nindex eb15a0c7..b9716f85 100755\n--- a/libdrgn/build-aux/gen_strswitch.py\n+++ b/libdrgn/build-aux/gen_strswitch.py\n@@ -51,9 +51,7 @@ String switches may be nested.\n \"\"\"\n \n import argparse\n-import ast\n import operator\n-import os\n import re\n import sys\n from typing import Any, Dict, List, NamedTuple, Optional, TextIO, Union\n@@ -178,7 +176,7 @@ def handle_switch_directive(\n     switches: List[StrSwitch],\n     switch_counts: Dict[str, int],\n ) -> None:\n-    match = re.fullmatch(r\"((\\s*)@\\s*\" + directive + \"\\s*\\()(.*)\\)\\s*@\\s*\", line.line)\n+    match = re.fullmatch(r\"((\\s*)@\\s*\" + directive + r\"\\s*\\()(.*)\\)\\s*@\\s*\", line.line)\n     if not match:\n         raise CodeGenError(f\"invalid {directive} directive\", line.filename, line.lineno)\n \n@@ -523,9 +521,9 @@ def handle_endswitch_directive(\n ) -> None:\n     match = re.fullmatch(r\"\\s*@\\s*endswitch\\s*@\\s*\", line.line)\n     if not match:\n-        raise CodeGenError(f\"invalid endswitch directive\", line.line, line.lineno)\n+        raise CodeGenError(\"invalid endswitch directive\", line.line, line.lineno)\n     if not switches:\n-        raise CodeGenError(f\"unmatched endswitch\", line.filename, line.lineno)\n+        raise CodeGenError(\"unmatched endswitch\", line.filename, line.lineno)\n \n     switch = switches.pop()\n     if switches:\ndiff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex 827ed925..85cc42ac 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -6,7 +6,7 @@ import os.path\n \n from tests.assembler import _append_sleb128, _append_uleb128\n from tests.dwarf import DW_AT, DW_FORM, DW_TAG\n-from tests.elf import ET, PT, SHT\n+from tests.elf import ET, SHT\n from tests.elfwriter import ElfSection, create_elf_file\n \n DwarfAttrib = namedtuple(\"DwarfAttrib\", [\"name\", \"form\", \"value\"])\ndiff --git a/tests/linux_kernel/helpers/test_cgroup.py b/tests/linux_kernel/helpers/test_cgroup.py\nindex fd2851d5..2f4d37a7 100644\n--- a/tests/linux_kernel/helpers/test_cgroup.py\n+++ b/tests/linux_kernel/helpers/test_cgroup.py\n@@ -85,7 +85,7 @@ class TestCgroup(LinuxKernelTestCase):\n             finally:\n                 os.kill(pid, signal.SIGKILL)\n                 os.waitpid(pid, 0)\n-        except:\n+        except BaseException:\n             for cleanup in reversed(cls.__cleanups):\n                 cleanup[0](*cleanup[1:])\n             raise\ndiff --git a/tests/linux_kernel/helpers/test_net.py b/tests/linux_kernel/helpers/test_net.py\nindex 83b98b7f..2be433d9 100644\n--- a/tests/linux_kernel/helpers/test_net.py\n+++ b/tests/linux_kernel/helpers/test_net.py\n@@ -3,7 +3,6 @@\n \n import os\n import socket\n-import sys\n import tempfile\n \n from drgn import cast\ndiff --git a/tests/linux_kernel/helpers/test_pid.py b/tests/linux_kernel/helpers/test_pid.py\nindex b5e71748..cc7ea854 100644\n--- a/tests/linux_kernel/helpers/test_pid.py\n+++ b/tests/linux_kernel/helpers/test_pid.py\n@@ -46,7 +46,7 @@ class TestPid(LinuxKernelTestCase):\n                 self.assertIn(proc.pid, pids)\n             self.assertIn(os.getpid(), pids)\n             barrier.wait()\n-        except:\n+        except BaseException:\n             barrier.abort()\n             for proc in procs:\n                 proc.terminate()\ndiff --git a/tests/linux_kernel/test_threads.py b/tests/linux_kernel/test_threads.py\nindex b5cd8b34..23223042 100644\n--- a/tests/linux_kernel/test_threads.py\n+++ b/tests/linux_kernel/test_threads.py\n@@ -25,7 +25,7 @@ class TestThreads(LinuxKernelTestCase):\n                 self.assertIn(proc.pid, pids)\n             self.assertIn(os.getpid(), pids)\n             barrier.wait()\n-        except:\n+        except BaseException:\n             barrier.abort()\n             for proc in procs:\n                 proc.terminate()\ndiff --git a/vmtest/download.py b/vmtest/download.py\nindex 2ef42b82..ad7ed6cb 100644\n--- a/vmtest/download.py\n+++ b/vmtest/download.py\n@@ -60,7 +60,7 @@ def _download_kernel(gh: GitHubApi, url: str, dir: Path) -> None:\n             raise subprocess.CalledProcessError(zstd_proc.returncode, zstd_proc.args)\n         if tar_proc.returncode != 0:\n             raise subprocess.CalledProcessError(tar_proc.returncode, tar_proc.args)\n-    except:\n+    except BaseException:\n         shutil.rmtree(tmp_dir, ignore_errors=True)\n         raise\n     else:\n"}
{"repo": "drgn", "commit": "c936b699eb0fb235e44b66f9b4c8efa7ee698973", "diff": "diff --git a/drgn/helpers/linux/slab.py b/drgn/helpers/linux/slab.py\nindex 3f645b95..09970c10 100644\n--- a/drgn/helpers/linux/slab.py\n+++ b/drgn/helpers/linux/slab.py\n@@ -19,8 +19,10 @@ from typing import Iterator, Optional, Set, Union\n \n from drgn import FaultError, Object, Program, Type, cast\n from drgn.helpers import escape_ascii_string\n+from drgn.helpers.linux.cpumask import for_each_online_cpu\n from drgn.helpers.linux.list import list_for_each_entry\n from drgn.helpers.linux.mm import for_each_page, page_to_virt\n+from drgn.helpers.linux.percpu import per_cpu_ptr\n \n __all__ = (\n     \"find_slab_cache\",\n@@ -129,7 +131,6 @@ def slab_cache_for_each_allocated_object(\n         freelist_type = prog.type(\"freelist_idx_t *\")\n         slub = False\n     except LookupError:\n-        freelist_type = prog.type(\"void **\")\n         slub = True\n \n     if slub:\n@@ -143,23 +144,26 @@ def slab_cache_for_each_allocated_object(\n         except AttributeError:\n             raise ValueError(\"SLOB is not supported\") from None\n \n-        def _slub_freelist(slab: Object, offset: int) -> Set[int]:\n+        def _slub_get_freelist(freelist: Object, freelist_set: Set[int]) -> None:\n             # In SLUB, the freelist is a linked list with the next pointer\n             # located at ptr + slab_cache->offset.\n-            freelist_set = set()\n-            freelist = slab.freelist.read_()\n+            ptr = freelist.value_()\n+            while ptr:\n+                freelist_set.add(ptr)\n+                ptr = prog.read_word(ptr + freelist_offset)\n \n-            while freelist:\n-                freelist_set.add(freelist.value_())\n-                freelist = cast(freelist_type, freelist + offset)[0].read_()\n-            return freelist_set\n+        cpu_freelists: Set[int] = set()\n+        cpu_slab = slab_cache.cpu_slab.read_()\n+        for cpu in for_each_online_cpu(prog):\n+            _slub_get_freelist(per_cpu_ptr(cpu_slab, cpu).freelist, cpu_freelists)\n \n         def _slab_page_objects(page: Object, slab: Object) -> Iterator[Object]:\n-            freelist_set = _slub_freelist(slab, freelist_offset)\n+            freelist: Set[int] = set()\n+            _slub_get_freelist(slab.freelist, freelist)\n             addr = page_to_virt(page).value_() + red_left_pad\n             end = addr + slab_cache_size * slab.objects\n             while addr < end:\n-                if addr not in freelist_set:\n+                if addr not in freelist and addr not in cpu_freelists:\n                     yield Object(prog, pointer_type, value=addr)\n                 addr += slab_cache_size\n \n@@ -171,20 +175,28 @@ def slab_cache_for_each_allocated_object(\n \n         slab_cache_num = slab_cache.num.value_()\n \n+        cpu_cache = slab_cache.cpu_cache.read_()\n+        cpu_caches_avail: Set[int] = set()\n+        for cpu in for_each_online_cpu(prog):\n+            ac = per_cpu_ptr(cpu_cache, cpu)\n+            for i in range(ac.avail):\n+                cpu_caches_avail.add(ac.entry[i].value_())\n+\n         def _slab_freelist(slab: Object) -> Set[int]:\n             # In SLAB, the freelist is an array of free object indices.\n             freelist = cast(freelist_type, slab.freelist)\n             return {freelist[i].value_() for i in range(slab.active, slab_cache_num)}\n \n         def _slab_page_objects(page: Object, slab: Object) -> Iterator[Object]:\n-            freelist_set = _slab_freelist(slab)\n+            freelist = _slab_freelist(slab)\n             s_mem = slab.s_mem.value_()\n             for i in range(slab_cache_num):\n-                if i in freelist_set:\n+                if i in freelist:\n+                    continue\n+                addr = s_mem + i * slab_cache_size + obj_offset\n+                if addr in cpu_caches_avail:\n                     continue\n-                yield Object(\n-                    prog, pointer_type, value=s_mem + i * slab_cache_size + obj_offset\n-                )\n+                yield Object(prog, pointer_type, value=addr)\n \n     # Linux kernel commit d122019bf061cccc4583eb9ad40bf58c2fe517be (\"mm: Split\n     # slab into its own type\") (in v5.17) moved slab information from struct\n"}
{"repo": "drgn", "commit": "13144eda119790cdbc11f360c15a04efdf81ae9a", "diff": "diff --git a/vmtest/download.py b/vmtest/download.py\nindex 588d4768..2ef42b82 100644\n--- a/vmtest/download.py\n+++ b/vmtest/download.py\n@@ -49,12 +49,13 @@ def _download_kernel(gh: GitHubApi, url: str, dir: Path) -> None:\n         ) as zstd_proc, subprocess.Popen(\n             [\"tar\", \"-C\", str(tmp_dir), \"-x\"],\n             stdin=zstd_proc.stdout,\n-        ) as tar_proc, gh.download(\n-            url\n-        ) as resp:\n+        ) as tar_proc:\n             assert zstd_proc.stdin is not None\n-            shutil.copyfileobj(resp, zstd_proc.stdin)\n-            zstd_proc.stdin.close()\n+            try:\n+                with gh.download(url) as resp:\n+                    shutil.copyfileobj(resp, zstd_proc.stdin)\n+            finally:\n+                zstd_proc.stdin.close()\n         if zstd_proc.returncode != 0:\n             raise subprocess.CalledProcessError(zstd_proc.returncode, zstd_proc.args)\n         if tar_proc.returncode != 0:\n"}
{"repo": "drgn", "commit": "eb75ecadd6e726179bf736905a7a8d89ea67ee01", "diff": "diff --git a/tests/helpers/linux/test_slab.py b/tests/helpers/linux/test_slab.py\nindex 6d1f675c..ac752a63 100644\n--- a/tests/helpers/linux/test_slab.py\n+++ b/tests/helpers/linux/test_slab.py\n@@ -13,14 +13,41 @@ def get_proc_slabinfo_names():\n         return [line.split()[0] for line in f]\n \n \n+def fallback_slab_cache_names(prog):\n+    # SLOB does not provide /proc/slabinfo. It is also disabled for SLUB if\n+    # CONFIG_SLUB_DEBUG=n. Before Linux kernel commit 5b36577109be (\"mm:\n+    # slabinfo: remove CONFIG_SLABINFO\") (in v4.15), it could also be disabled\n+    # for SLAB. So, pick a few slab caches which we know exist to test against.\n+    # In case they were merged into other caches, get their names from the\n+    # structs rather than just returning the names.\n+    return {\n+        prog[\"dentry_cache\"].name.string_(),\n+        prog[\"mm_cachep\"].name.string_(),\n+        prog[\"uid_cachep\"].name.string_(),\n+    }\n+\n+\n class TestSlab(LinuxKernelTestCase):\n     def test_for_each_slab_cache(self):\n-        self.assertCountEqual(\n-            get_proc_slabinfo_names(),\n-            [s.name.string_() for s in for_each_slab_cache(self.prog)],\n-        )\n+        try:\n+            slab_cache_names = get_proc_slabinfo_names()\n+        except FileNotFoundError:\n+            # The found names should be a superset of the fallback names.\n+            self.assertGreaterEqual(\n+                {s.name.string_() for s in for_each_slab_cache(self.prog)},\n+                fallback_slab_cache_names(self.prog),\n+            )\n+        else:\n+            self.assertCountEqual(\n+                [s.name.string_() for s in for_each_slab_cache(self.prog)],\n+                slab_cache_names,\n+            )\n \n     def test_find_slab_cache(self):\n-        for name in get_proc_slabinfo_names():\n+        try:\n+            slab_cache_names = get_proc_slabinfo_names()\n+        except FileNotFoundError:\n+            slab_cache_names = fallback_slab_cache_names(self.prog)\n+        for name in slab_cache_names:\n             slab = find_slab_cache(self.prog, name)\n             self.assertEqual(name, slab.name.string_())\n"}
{"repo": "drgn", "commit": "98577e5e23515d553a4d09038280a46909318c2d", "diff": "diff --git a/tests/linux_kernel/vmcore/test_vmcore.py b/tests/linux_kernel/vmcore/test_vmcore.py\nindex 5691a56f..1a8856ad 100644\n--- a/tests/linux_kernel/vmcore/test_vmcore.py\n+++ b/tests/linux_kernel/vmcore/test_vmcore.py\n@@ -24,6 +24,13 @@ class TestVMCore(LinuxVMCoreTestCase):\n         crashed_thread_tid = self.prog.crashed_thread().tid\n         self.assertEqual(self.prog.thread(crashed_thread_tid).tid, crashed_thread_tid)\n \n+    def test_thread_not_found(self):\n+        tids = {thread.tid for thread in self.prog.threads()}\n+        tid = 1\n+        while tid in tids:\n+            tid += 1\n+        self.assertRaises(LookupError, self.prog.thread, tid)\n+\n     def test_main_thread(self):\n         self.assertRaisesRegex(\n             ValueError,\ndiff --git a/tests/test_thread.py b/tests/test_thread.py\nindex 01b52234..b4bad8a0 100644\n--- a/tests/test_thread.py\n+++ b/tests/test_thread.py\n@@ -60,6 +60,8 @@ class TestCoreDump(TestCase):\n     def test_thread(self):\n         for tid in self.TIDS:\n             self.assertEqual(self.prog.thread(tid).tid, tid)\n+\n+    def test_thread_not_found(self):\n         self.assertRaises(LookupError, self.prog.thread, 99)\n \n     def test_main_thread(self):\n"}
{"repo": "drgn", "commit": "248d16137b002d041cfbf60a658b37b9f4511aa5", "diff": "diff --git a/tests/helpers/linux/__init__.py b/tests/helpers/linux/__init__.py\nindex f9a52fb9..5d71598d 100644\n--- a/tests/helpers/linux/__init__.py\n+++ b/tests/helpers/linux/__init__.py\n@@ -34,32 +34,35 @@ class LinuxHelperTestCase(TestCase):\n                 force_run = False\n             else:\n                 force_run = run_tests\n-            if not run_tests:\n-                LinuxHelperTestCase.skip_reason = \"env DRGN_RUN_LINUX_HELPER_TESTS=0\"\n-            elif not force_run and os.geteuid() != 0:\n-                LinuxHelperTestCase.skip_reason = (\n-                    \"Linux helper tests must be run as root \"\n-                    \"(run with env DRGN_RUN_LINUX_HELPER_TESTS=1 to force)\"\n-                )\n-            else:\n-                # Some of the tests use the loop module. Open loop-control so\n-                # that it is loaded.\n-                try:\n-                    with open(\"/dev/loop-control\", \"r\"):\n-                        pass\n-                except FileNotFoundError:\n-                    pass\n-\n+            if run_tests:\n                 prog = drgn.Program()\n-                prog.set_kernel()\n                 try:\n-                    prog.load_default_debug_info()\n-                    LinuxHelperTestCase.prog = prog\n-                    return\n-                except drgn.MissingDebugInfoError as e:\n+                    prog.set_kernel()\n+                except PermissionError:\n                     if force_run:\n                         raise\n-                    LinuxHelperTestCase.skip_reason = str(e)\n+                    LinuxHelperTestCase.skip_reason = (\n+                        \"Linux helper tests must be run as root \"\n+                        \"(run with env DRGN_RUN_LINUX_HELPER_TESTS=1 to force)\"\n+                    )\n+                else:\n+                    # Some of the tests use the loop module. Open loop-control\n+                    # so that it is loaded.\n+                    try:\n+                        with open(\"/dev/loop-control\", \"r\"):\n+                            pass\n+                    except FileNotFoundError:\n+                        pass\n+                    try:\n+                        prog.load_default_debug_info()\n+                        LinuxHelperTestCase.prog = prog\n+                        return\n+                    except drgn.MissingDebugInfoError as e:\n+                        if force_run:\n+                            raise\n+                        LinuxHelperTestCase.skip_reason = str(e)\n+            else:\n+                LinuxHelperTestCase.skip_reason = \"env DRGN_RUN_LINUX_HELPER_TESTS=0\"\n         raise unittest.SkipTest(LinuxHelperTestCase.skip_reason)\n \n \n"}
{"repo": "drgn", "commit": "289cdafa7fc829e991763b45c91263b60a9e83be", "diff": "diff --git a/drgn/helpers/linux/rbtree.py b/drgn/helpers/linux/rbtree.py\nindex a1572b04..1f6e22c2 100644\n--- a/drgn/helpers/linux/rbtree.py\n+++ b/drgn/helpers/linux/rbtree.py\n@@ -197,6 +197,8 @@ def rb_find(\n         the key matches the entry.\n     :return: ``type *`` found entry, or ``NULL`` if not found.\n     \"\"\"\n+    prog = root.prog_\n+    type = prog.type(type)\n     node = root.rb_node.read_()\n     while node:\n         entry = container_of(node, type, member)\n@@ -207,4 +209,4 @@ def rb_find(\n             node = node.rb_right.read_()\n         else:\n             return entry\n-    return NULL(root.prog_, type)\n+    return NULL(prog, prog.pointer_type(type))\n"}
{"repo": "drgn", "commit": "b341c212f4936c21900f3d554abcf49653bb5a7e", "diff": "diff --git a/tests/helpers/linux/test_sched.py b/tests/helpers/linux/test_sched.py\nindex cbdb02f4..6294cb3c 100644\n--- a/tests/helpers/linux/test_sched.py\n+++ b/tests/helpers/linux/test_sched.py\n@@ -40,7 +40,9 @@ class TestSched(LinuxHelperTestCase):\n         if self.prog.type(\"struct task_struct\").has_member(\"wake_cpu\"):\n             # SMP\n             for cpu in for_each_possible_cpu(self.prog):\n-                self.assertEqual(idle_task(self.prog, cpu).comm.string_(), f\"swapper/{cpu}\".encode())\n+                self.assertEqual(\n+                    idle_task(self.prog, cpu).comm.string_(), f\"swapper/{cpu}\".encode()\n+                )\n         else:\n             # UP\n             self.assertEqual(idle_task(self.prog, 0).comm.string_(), b\"swapper\")\n"}
{"repo": "drgn", "commit": "a70e5d7893b1f539cf4a6083db640346cda90e3a", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex 16f1b8ab..b377dce3 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -106,6 +106,10 @@ def main() -> None:\n \n     args = parser.parse_args()\n \n+    if not args.script:\n+        print(version, file=sys.stderr, flush=True)\n+        os.environ[\"DEBUGINFOD_PROGRESS\"] = \"1\"\n+\n     prog = drgn.Program()\n     if args.core is not None:\n         prog.set_core_dump(args.core)\n@@ -170,13 +174,11 @@ def main() -> None:\n \n         sys.displayhook = displayhook\n \n-        banner = (\n-            version\n-            + \"\"\"\n+        banner = \"\"\"\\\n For help, type help(drgn).\n >>> import drgn\n->>> from drgn import \"\"\"\n-            + \", \".join(drgn_globals)\n+>>> from drgn import \"\"\" + \", \".join(\n+            drgn_globals\n         )\n         if prog.flags & drgn.ProgramFlags.IS_LINUX_KERNEL:\n             banner += \"\\n>>> from drgn.helpers.linux import *\"\n"}
{"repo": "drgn", "commit": "02912ca7d07314597172970d0510d57d0d3574ba", "diff": "diff --git a/tests/test_program.py b/tests/test_program.py\nindex 889f1cde..bc8ea8cc 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -806,7 +806,7 @@ class TestCoreDump(TestCase):\n         self.assertEqual(prog.read(0xFFFF0000, len(data)), data)\n         self.assertEqual(prog.read(0xA0, len(data), physical=True), data)\n \n-    def test_zero_fill(self):\n+    def test_unsaved(self):\n         data = b\"hello, world\"\n         prog = Program()\n         with tempfile.NamedTemporaryFile() as f:\n@@ -825,4 +825,6 @@ class TestCoreDump(TestCase):\n             )\n             f.flush()\n             prog.set_core_dump(f.name)\n-        self.assertEqual(prog.read(0xFFFF0000, len(data) + 4), data + bytes(4))\n+        with self.assertRaisesRegex(FaultError, \"memory not saved in core dump\") as cm:\n+            prog.read(0xFFFF0000, len(data) + 4)\n+        self.assertEqual(cm.exception.address, 0xFFFF000C)\n"}
{"repo": "drgn", "commit": "3914bb8e29d4c571fac916834a044d7bc1492832", "diff": "diff --git a/tests/test_language_c.py b/tests/test_language_c.py\nindex 60afafd0..48a959bd 100644\n--- a/tests/test_language_c.py\n+++ b/tests/test_language_c.py\n@@ -340,6 +340,67 @@ class TestPrettyPrintTypeName(MockProgramTestCase):\n             \"int (void)\",\n         )\n \n+    def test_pointer_to_anonymous_struct(self):\n+        self.assertTypeName(\n+            self.prog.pointer_type(\n+                self.prog.struct_type(\n+                    None, 8, (TypeMember(self.prog.int_type(\"int\", 4, True), \"x\", 0),)\n+                )\n+            ),\n+            \"struct <anonymous> *\",\n+        )\n+\n+    def test_array_of_anonymous_struct(self):\n+        self.assertTypeName(\n+            self.prog.array_type(\n+                self.prog.struct_type(\n+                    None, 8, (TypeMember(self.prog.int_type(\"int\", 4, True), \"x\", 0),)\n+                ),\n+                2,\n+            ),\n+            \"struct <anonymous> [2]\",\n+        )\n+\n+    def test_function_returning_anonymous_struct(self):\n+        self.assertTypeName(\n+            self.prog.function_type(\n+                self.prog.struct_type(\n+                    None, 8, (TypeMember(self.prog.int_type(\"int\", 4, True), \"x\", 0),)\n+                ),\n+                (),\n+            ),\n+            \"struct <anonymous> (void)\",\n+        )\n+\n+    def test_function_of_anonymous_struct(self):\n+        self.assertTypeName(\n+            self.prog.function_type(\n+                self.prog.int_type(\"int\", 4, True),\n+                (\n+                    TypeParameter(\n+                        self.prog.struct_type(\n+                            None,\n+                            8,\n+                            (TypeMember(self.prog.int_type(\"int\", 4, True), \"x\", 0),),\n+                        ),\n+                        \"x\",\n+                    ),\n+                ),\n+            ),\n+            \"int (struct <anonymous> x)\",\n+        )\n+\n+    def test_typedef_of_anonymous_struct(self):\n+        self.assertTypeName(\n+            self.prog.typedef_type(\n+                \"onymous\",\n+                self.prog.struct_type(\n+                    None, 8, (TypeMember(self.prog.int_type(\"int\", 4, True), \"x\", 0),)\n+                ),\n+            ),\n+            \"onymous\",\n+        )\n+\n \n class TestPrettyPrintType(MockProgramTestCase):\n     def assertPrettyPrint(self, type, expected):\n"}
{"repo": "drgn", "commit": "cdee38af7a6fd08aaa319237d35df1949b7f8db7", "diff": "diff --git a/tests/helpers/linux/test_debug_info.py b/tests/helpers/linux/test_debug_info.py\nindex 94dc53b8..3a39ebaa 100644\n--- a/tests/helpers/linux/test_debug_info.py\n+++ b/tests/helpers/linux/test_debug_info.py\n@@ -10,7 +10,7 @@ from tests.helpers.linux import LinuxHelperTestCase, setenv\n class TestModuleDebugInfo(LinuxHelperTestCase):\n     # Arbitrary symbol that we can use to check that the module debug info was\n     # loaded.\n-    SYMBOL = \"loop_register_transfer\"\n+    SYMBOL = \"lo_fops\"\n \n     def setUp(self):\n         super().setUp()\n"}
{"repo": "drgn", "commit": "d1745755f116cf4b082074b0d720ca36ae45dff4", "diff": "diff --git a/scripts/iwyu.py b/scripts/iwyu.py\nindex 85c684d5..07423d0f 100755\n--- a/scripts/iwyu.py\n+++ b/scripts/iwyu.py\n@@ -122,7 +122,7 @@ def gen_python_mapping_file(mapping_path):\n         # For some reason, include-what-you-mean wants struct _typeobject, but\n         # find-all-symbols only reports PyTypeObject. Add it manually.\n         imp.write(\n-            '  {{\"symbol\": [\"_typeobject\", \"private\", \"<Python.h>\", \"public\"]}},  # From cpython/object.h\\n'\n+            '  {\"symbol\": [\"_typeobject\", \"private\", \"<Python.h>\", \"public\"]},  # From cpython/object.h\\n'\n         )\n \n         imp.write(\"]\\n\")\n@@ -130,6 +130,44 @@ def gen_python_mapping_file(mapping_path):\n     os.rename(mapping_path + \".tmp\", mapping_path)\n \n \n+def iwyu_associated_header(path):\n+    with open(path, \"r\") as f:\n+        match = re.search(\n+            r'^\\s*#\\s*include\\s+\"([^\"]+)\"\\s+//\\s+IWYU\\s+pragma:\\s+associated',\n+            f.read(),\n+            re.M,\n+        )\n+        if match:\n+            return os.path.join(os.path.dirname(path), match.group(1))\n+    if path.endswith(\".c\"):\n+        return path[:-2] + \".h\"\n+    return None\n+\n+\n+def ignore_line(path, state, line):\n+    # include-what-you-use/include-what-you-use#969: iwyu recommends bogus\n+    # forward declarations for the anonymous unions generated by\n+    # BINARY_OP_SIGNED_2C.\n+    if line.endswith(\"::;\"):\n+        return True\n+\n+    # include-what-you-use/include-what-you-use#971: drgn.h \"exports\" a forward\n+    # declaration of several opaque types, but iwyu doesn't have such a notion.\n+    if re.fullmatch(\n+        r\"struct drgn_(language|platform|program|register|stack_trace|symbol);\", line\n+    ):\n+        paths = [path]\n+        associated_header = iwyu_associated_header(path)\n+        if associated_header is not None:\n+            paths.append(associated_header)\n+        for path in paths:\n+            with open(path, \"r\") as f:\n+                if re.search(r'^#include \"(drgn.h|drgnpy.h)\"', f.read(), re.M):\n+                    return True\n+\n+    return False\n+\n+\n def main():\n     parser = argparse.ArgumentParser(description=\"run include-what-you-use on drgn\")\n     parser.add_argument(\n@@ -181,6 +219,8 @@ def main():\n             + [\n                 \"-Xiwyu\",\n                 \"--mapping_file=\" + os.path.abspath(python_mapping_file),\n+                \"-Xiwyu\",\n+                \"--mapping_file=\" + os.path.abspath(\"scripts/iwyu.imp\"),\n                 \"-w\",  # We don't want warnings from Clang.\n             ],\n             cwd=command[\"directory\"],\n@@ -209,14 +249,15 @@ def main():\n                     else:\n                         header = None\n                     lines.clear()\n-                elif state != \"include_list\" and line:\n+                elif (\n+                    line\n+                    and state != \"include_list\"\n+                    and not ignore_line(path, state, line)\n+                ):\n                     if header is not None:\n                         print(\"\\n\" + header)\n                         header = None\n                     print(line)\n-    print(\n-        \"Please ignore suggestions to declare opaque types if the appropriate header has already been included.\"\n-    )\n \n \n if __name__ == \"__main__\":\n"}
{"repo": "drgn", "commit": "a5845e63d48d427b559dda64c3e0aa0d18b8f961", "diff": "diff --git a/tests/helpers/linux/__init__.py b/tests/helpers/linux/__init__.py\nindex f4866be8..b6508158 100644\n--- a/tests/helpers/linux/__init__.py\n+++ b/tests/helpers/linux/__init__.py\n@@ -94,6 +94,15 @@ def proc_state(pid):\n         return re.search(r\"State:\\s*(\\S)\", f.read(), re.M).group(1)\n \n \n+# Return whether a process is blocked and fully scheduled out. The process\n+# state is updated while the process is still running, so use this instead of\n+# proc_state(pid) != \"R\" to avoid races. This is not accurate if pid is the\n+# calling thread.\n+def proc_blocked(pid):\n+    with open(f\"/proc/{pid}/syscall\", \"r\") as f:\n+        return f.read() != \"running\\n\"\n+\n+\n def parse_range_list(s):\n     values = set()\n     s = s.strip()\ndiff --git a/tests/helpers/linux/test_stack_trace.py b/tests/helpers/linux/test_stack_trace.py\nindex 0716439b..92c10e1d 100644\n--- a/tests/helpers/linux/test_stack_trace.py\n+++ b/tests/helpers/linux/test_stack_trace.py\n@@ -9,7 +9,7 @@ from drgn.helpers.linux.pid import find_task\n from tests.helpers.linux import (\n     LinuxHelperTestCase,\n     fork_and_pause,\n-    proc_state,\n+    proc_blocked,\n     setenv,\n     wait_until,\n )\n@@ -18,7 +18,7 @@ from tests.helpers.linux import (\n class TestStackTrace(LinuxHelperTestCase):\n     def test_by_task_struct(self):\n         pid = fork_and_pause()\n-        wait_until(lambda: proc_state(pid) == \"S\")\n+        wait_until(proc_blocked, pid)\n         self.assertIn(\"pause\", str(self.prog.stack_trace(find_task(self.prog, pid))))\n         os.kill(pid, signal.SIGKILL)\n         os.waitpid(pid, 0)\n@@ -33,7 +33,7 @@ class TestStackTrace(LinuxHelperTestCase):\n                 prog.set_kernel()\n                 prog.load_default_debug_info()\n             pid = fork_and_pause()\n-            wait_until(lambda: proc_state(pid) == \"S\")\n+            wait_until(proc_blocked, pid)\n             self.assertIn(\"pause\", str(prog.stack_trace(pid)))\n             os.kill(pid, signal.SIGKILL)\n             os.waitpid(pid, 0)\n@@ -46,7 +46,7 @@ class TestStackTrace(LinuxHelperTestCase):\n \n     def test_local_variable(self):\n         pid = fork_and_pause()\n-        wait_until(lambda: proc_state(pid) == \"S\")\n+        wait_until(proc_blocked, pid)\n         for frame in self.prog.stack_trace(pid):\n             if frame.name in (\"context_switch\", \"__schedule\"):\n                 try:\n@@ -75,7 +75,7 @@ class TestStackTrace(LinuxHelperTestCase):\n         # Smoke test that we get at least one register and that\n         # StackFrame.registers() agrees with StackFrame.register().\n         pid = fork_and_pause()\n-        wait_until(lambda: proc_state(pid) == \"S\")\n+        wait_until(proc_blocked, pid)\n         trace = self.prog.stack_trace(pid)\n         have_registers = False\n         for frame in trace:\n"}
{"repo": "drgn", "commit": "8d383fb89a137311a6778addb95e92d77f3f61a3", "diff": "diff --git a/libdrgn/build-aux/gen_constants.py b/libdrgn/build-aux/gen_constants.py\nindex 441a559c..25d9f3f1 100644\n--- a/libdrgn/build-aux/gen_constants.py\n+++ b/libdrgn/build-aux/gen_constants.py\n@@ -69,8 +69,8 @@ def gen_constants(input_file, output_file):\n \n PyObject *Architecture_class;\n PyObject *FindObjectFlags_class;\n-PyObject *PrimitiveType_class;\n PyObject *PlatformFlags_class;\n+PyObject *PrimitiveType_class;\n PyObject *ProgramFlags_class;\n PyObject *Qualifiers_class;\n PyObject *TypeKind_class;\n@@ -90,18 +90,18 @@ PyObject *TypeKind_class;\n     gen_constant_class(\n         drgn_h,\n         output_file,\n-        \"PrimitiveType\",\n-        \"Enum\",\n+        \"PlatformFlags\",\n+        \"Flag\",\n         (),\n-        r\"DRGN_(C)_TYPE_([a-zA-Z0-9_]+)\",\n+        r\"DRGN_PLATFORM_([a-zA-Z0-9_]+)(?<!DRGN_PLATFORM_DEFAULT_FLAGS)\",\n     )\n     gen_constant_class(\n         drgn_h,\n         output_file,\n-        \"PlatformFlags\",\n-        \"Flag\",\n+        \"PrimitiveType\",\n+        \"Enum\",\n         (),\n-        r\"DRGN_PLATFORM_([a-zA-Z0-9_]+)(?<!DRGN_PLATFORM_DEFAULT_FLAGS)\",\n+        r\"DRGN_(C)_TYPE_([a-zA-Z0-9_]+)\",\n     )\n     gen_constant_class(\n         drgn_h,\n@@ -135,8 +135,8 @@ int add_module_constants(PyObject *m)\n \n \tif (add_Architecture(m, enum_module) == -1 ||\n \t    add_FindObjectFlags(m, enum_module) == -1 ||\n-\t    add_PrimitiveType(m, enum_module) == -1 ||\n \t    add_PlatformFlags(m, enum_module) == -1 ||\n+\t    add_PrimitiveType(m, enum_module) == -1 ||\n \t    add_ProgramFlags(m, enum_module) == -1 ||\n \t    add_Qualifiers(m, enum_module) == -1 ||\n \t    add_TypeKind(m, enum_module) == -1)\n"}
{"repo": "drgn", "commit": "333652dba3e02fb50082666b120cb075f91843e9", "diff": "diff --git a/vmtest/vm.py b/vmtest/vm.py\nindex 1d9971c1..b0680db3 100644\n--- a/vmtest/vm.py\n+++ b/vmtest/vm.py\n@@ -222,10 +222,10 @@ def run_in_vm(command: str, kernel_dir: Path, build_dir: Path) -> int:\n                 \"-no-reboot\",\n \n                 \"-virtfs\",\n-                f\"local,id=root,path=/,mount_tag=/dev/root,security_model=none,readonly{multidevs}\",\n+                f\"local,id=root,path=/,mount_tag=/dev/root,security_model=none,readonly=on{multidevs}\",\n \n                 \"-virtfs\",\n-                f\"local,path={kernel_dir},mount_tag=modules,security_model=none,readonly\",\n+                f\"local,path={kernel_dir},mount_tag=modules,security_model=none,readonly=on\",\n \n                 \"-device\", \"virtio-serial\",\n                 \"-chardev\", f\"socket,id=vmtest,path={socket_path}\",\n"}
{"repo": "drgn", "commit": "980d1c64188211b7b4ca57c440637aa345a15921", "diff": "diff --git a/drgn/helpers/linux/list.py b/drgn/helpers/linux/list.py\nindex b72d1e0e..6e557b26 100644\n--- a/drgn/helpers/linux/list.py\n+++ b/drgn/helpers/linux/list.py\n@@ -156,7 +156,9 @@ def list_for_each_reverse(head: Object) -> Iterator[Object]:\n         pos = pos.prev.read_()\n \n \n-def list_for_each_entry(type: str, head: Object, member: str) -> Iterator[Object]:\n+def list_for_each_entry(\n+    type: Union[str, Type], head: Object, member: str\n+) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all of the entries in a list.\n \n@@ -170,7 +172,7 @@ def list_for_each_entry(type: str, head: Object, member: str) -> Iterator[Object\n \n \n def list_for_each_entry_reverse(\n-    type: str, head: Object, member: str\n+    type: Union[str, Type], head: Object, member: str\n ) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all of the entries in a list in reverse order.\n@@ -206,7 +208,9 @@ def hlist_for_each(head: Object) -> Iterator[Object]:\n         pos = pos.next.read_()\n \n \n-def hlist_for_each_entry(type: str, head: Object, member: str) -> Iterator[Object]:\n+def hlist_for_each_entry(\n+    type: Union[str, Type], head: Object, member: str\n+) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all of the entries in a hash list.\n \ndiff --git a/drgn/helpers/linux/list_nulls.py b/drgn/helpers/linux/list_nulls.py\nindex f007c68c..a3b9536b 100644\n--- a/drgn/helpers/linux/list_nulls.py\n+++ b/drgn/helpers/linux/list_nulls.py\n@@ -11,9 +11,9 @@ hlist_nulls_node``) in :linux:`include/linux/list_nulls.h` where the end of\n list is not a ``NULL`` pointer, but a \"nulls\" marker.\n \"\"\"\n \n-from typing import Iterator\n+from typing import Iterator, Union\n \n-from drgn import Object, container_of\n+from drgn import Object, Type, container_of\n \n __all__ = (\n     \"hlist_nulls_empty\",\n@@ -41,7 +41,7 @@ def hlist_nulls_empty(head: Object) -> bool:\n \n \n def hlist_nulls_for_each_entry(\n-    type: str, head: Object, member: str\n+    type: Union[str, Type], head: Object, member: str\n ) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all the entries in a nulls hash list.\ndiff --git a/drgn/helpers/linux/rbtree.py b/drgn/helpers/linux/rbtree.py\nindex c81e2bb9..32d02567 100644\n--- a/drgn/helpers/linux/rbtree.py\n+++ b/drgn/helpers/linux/rbtree.py\n@@ -9,9 +9,9 @@ The ``drgn.helpers.linux.rbtree`` module provides helpers for working with\n red-black trees from :linux:`include/linux/rbtree.h`.\n \"\"\"\n \n-from typing import Callable, Iterator, TypeVar\n+from typing import Callable, Iterator, TypeVar, Union\n \n-from drgn import NULL, Object, container_of\n+from drgn import NULL, Object, Type, container_of\n \n __all__ = (\n     \"RB_EMPTY_NODE\",\n@@ -158,7 +158,7 @@ def rbtree_inorder_for_each(root: Object) -> Iterator[Object]:\n \n \n def rbtree_inorder_for_each_entry(\n-    type: str, root: Object, member: str\n+    type: Union[str, Type], root: Object, member: str\n ) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all of the entries in a red-black tree in sorted order.\n@@ -176,7 +176,7 @@ KeyType = TypeVar(\"KeyType\")\n \n \n def rb_find(\n-    type: str,\n+    type: Union[str, Type],\n     root: Object,\n     member: str,\n     key: KeyType,\n"}
{"repo": "drgn", "commit": "5541fad063aa2298a5d349ab98320c80fe25acf8", "diff": "diff --git a/docs/exts/drgndoc/docstrings.py b/docs/exts/drgndoc/docstrings.py\nindex e6bab536..a07994fc 100644\n--- a/docs/exts/drgndoc/docstrings.py\n+++ b/docs/exts/drgndoc/docstrings.py\n@@ -5,7 +5,7 @@\n import argparse\n import functools\n import sys\n-from typing import Union, cast\n+from typing import cast\n \n from drgndoc.format import Formatter\n from drgndoc.namespace import Namespace, ResolvedNode\n@@ -74,7 +74,7 @@ if __name__ == \"__main__\":\n \n     if args.header:\n         output_file.write(\n-            f\"\"\"\\\n+            \"\"\"\\\n /*\n  * Generated by drgndoc.docstrings -H.\n  *\n@@ -86,7 +86,7 @@ if __name__ == \"__main__\":\n \"\"\"\n         )\n     else:\n-        output_file.write(f\"/* Generated by drgndoc.docstrings. */\\n\\n\")\n+        output_file.write(\"/* Generated by drgndoc.docstrings. */\\n\\n\")\n \n     def aux(resolved: ResolvedNode[Node], name: str) -> None:\n         node = resolved.node\ndiff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex 6ca33b9d..2d252f8e 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -42,7 +42,7 @@ file for the C extension itself (drgndoc.docstrings).\n \n import os.path\n import re\n-from typing import Any, Dict, List, cast\n+from typing import Any, Dict, cast\n \n import docutils.nodes\n import docutils.parsers.rst.directives\ndiff --git a/docs/exts/drgndoc/namespace.py b/docs/exts/drgndoc/namespace.py\nindex 808c1cb0..9b19f72e 100644\n--- a/docs/exts/drgndoc/namespace.py\n+++ b/docs/exts/drgndoc/namespace.py\n@@ -2,7 +2,7 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n import itertools\n-from typing import Generic, Iterator, List, Mapping, Optional, Sequence, TypeVar, Union\n+from typing import Generic, Iterator, List, Mapping, Sequence, TypeVar, Union\n \n from drgndoc.parse import (\n     Class,\n@@ -14,7 +14,6 @@ from drgndoc.parse import (\n     Node,\n     Variable,\n )\n-from drgndoc.util import dot_join\n \n NodeT_co = TypeVar(\"NodeT_co\", bound=Node, covariant=True)\n \ndiff --git a/docs/exts/drgndoc/visitor.py b/docs/exts/drgndoc/visitor.py\nindex 6cf132ff..b527b22e 100644\n--- a/docs/exts/drgndoc/visitor.py\n+++ b/docs/exts/drgndoc/visitor.py\n@@ -2,7 +2,6 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n import ast\n-import sys\n from typing import Any, Optional\n \n \ndiff --git a/drgn/helpers/__init__.py b/drgn/helpers/__init__.py\nindex 552451c9..b52f7e47 100644\n--- a/drgn/helpers/__init__.py\n+++ b/drgn/helpers/__init__.py\n@@ -23,7 +23,7 @@ useful for scripts or for implementing other helpers.\n \n import enum\n import typing\n-from typing import Container, Iterable, List, Tuple\n+from typing import Container, Iterable\n \n from drgn import Type\n \ndiff --git a/drgn/helpers/linux/idr.py b/drgn/helpers/linux/idr.py\nindex b9497cd8..623fc0ca 100644\n--- a/drgn/helpers/linux/idr.py\n+++ b/drgn/helpers/linux/idr.py\n@@ -15,7 +15,7 @@ from typing import Iterator, Tuple\n \n from _drgn import _linux_helper_idr_find as idr_find\n from drgn import Object\n-from drgn.helpers.linux.radixtree import radix_tree_for_each, radix_tree_lookup\n+from drgn.helpers.linux.radixtree import radix_tree_for_each\n \n __all__ = (\n     \"idr_find\",\ndiff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 8a5b9d9e..927f0caa 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -11,7 +11,7 @@ implemented.\n \"\"\"\n \n import operator\n-from typing import Any, Iterator, List, Optional, Union, overload\n+from typing import Iterator, List, Optional, Union, overload\n \n from _drgn import _linux_helper_read_vm\n from drgn import IntegerLike, Object, Program, cast\ndiff --git a/drgn/helpers/linux/net.py b/drgn/helpers/linux/net.py\nindex a153cb53..3b23694d 100644\n--- a/drgn/helpers/linux/net.py\n+++ b/drgn/helpers/linux/net.py\n@@ -15,7 +15,6 @@ from typing import Iterator, Union\n from drgn import NULL, IntegerLike, Object, Program\n from drgn.helpers.linux.list import hlist_for_each_entry\n from drgn.helpers.linux.list_nulls import hlist_nulls_for_each_entry\n-from drgn.helpers.linux.tcp import sk_tcpstate\n \n __all__ = (\n     \"netdev_get_by_index\",\ndiff --git a/drgn/helpers/linux/pid.py b/drgn/helpers/linux/pid.py\nindex 9f4d7cab..d2e786ed 100644\n--- a/drgn/helpers/linux/pid.py\n+++ b/drgn/helpers/linux/pid.py\n@@ -16,8 +16,8 @@ from _drgn import (\n     _linux_helper_find_task as find_task,\n     _linux_helper_pid_task as pid_task,\n )\n-from drgn import NULL, Object, Program, cast, container_of\n-from drgn.helpers.linux.idr import idr_find, idr_for_each\n+from drgn import Object, Program, cast, container_of\n+from drgn.helpers.linux.idr import idr_for_each\n from drgn.helpers.linux.list import hlist_for_each_entry\n \n __all__ = (\ndiff --git a/examples/linux/fs_inodes.py b/examples/linux/fs_inodes.py\nindex 856d13f7..6e1a4c19 100755\n--- a/examples/linux/fs_inodes.py\n+++ b/examples/linux/fs_inodes.py\n@@ -6,7 +6,6 @@\n \n import os\n import sys\n-import time\n \n from drgn.helpers.linux.fs import for_each_mount, inode_path\n from drgn.helpers.linux.list import list_for_each_entry\ndiff --git a/libdrgn/build-aux/gen_constants.py b/libdrgn/build-aux/gen_constants.py\nindex b859dfd8..441a559c 100644\n--- a/libdrgn/build-aux/gen_constants.py\n+++ b/libdrgn/build-aux/gen_constants.py\n@@ -1,7 +1,6 @@\n # Copyright (c) Facebook, Inc. and its affiliates.\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n-import os.path\n import re\n import sys\n \n@@ -63,7 +62,7 @@ out:\n def gen_constants(input_file, output_file):\n     drgn_h = input_file.read()\n     output_file.write(\n-        f\"\"\"\\\n+        \"\"\"\\\n /* Generated by libdrgn/build-aux/gen_constants.py. */\n \n #include \"drgnpy.h\"\ndiff --git a/scripts/iwyu.py b/scripts/iwyu.py\nindex 42eb2a06..85c684d5 100755\n--- a/scripts/iwyu.py\n+++ b/scripts/iwyu.py\n@@ -122,7 +122,7 @@ def gen_python_mapping_file(mapping_path):\n         # For some reason, include-what-you-mean wants struct _typeobject, but\n         # find-all-symbols only reports PyTypeObject. Add it manually.\n         imp.write(\n-            f'  {{\"symbol\": [\"_typeobject\", \"private\", \"<Python.h>\", \"public\"]}},  # From cpython/object.h\\n'\n+            '  {{\"symbol\": [\"_typeobject\", \"private\", \"<Python.h>\", \"public\"]}},  # From cpython/object.h\\n'\n         )\n \n         imp.write(\"]\\n\")\ndiff --git a/setup.py b/setup.py\nindex 802207e4..1f0051fe 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -3,7 +3,7 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n # setuptools must be imported before distutils (see pypa/setuptools#2230).\n-import setuptools  # isort: skip\n+import setuptools  # isort: skip  # noqa: F401\n \n import contextlib\n from distutils import log\ndiff --git a/tests/__init__.py b/tests/__init__.py\nindex 43367aec..07d307df 100644\n--- a/tests/__init__.py\n+++ b/tests/__init__.py\n@@ -2,7 +2,6 @@\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n import functools\n-import types\n from typing import Any, NamedTuple, Optional\n import unittest\n \ndiff --git a/tests/helpers/linux/test_fs.py b/tests/helpers/linux/test_fs.py\nindex aff6e1a9..d127c351 100644\n--- a/tests/helpers/linux/test_fs.py\n+++ b/tests/helpers/linux/test_fs.py\n@@ -51,9 +51,9 @@ class TestFs(LinuxHelperTestCase):\n         with tempfile.TemporaryDirectory(prefix=\"drgn-tests-\") as dir:\n             path1 = os.fsencode(os.path.abspath(os.path.join(dir, \"a\")))\n             path2 = os.fsencode(os.path.abspath(os.path.join(dir, \"b\")))\n-            with open(path1, \"w\") as f:\n+            with open(path1, \"w\"):\n                 os.link(path1, path2)\n-                with open(path2, \"r\") as f:\n+                with open(path2, \"r\"):\n                     inode = path_lookup(self.prog, path1).dentry.d_inode\n                     paths = list(inode_paths(inode))\n                     self.assertEqual(len(paths), 2)\ndiff --git a/tests/libdrgn.py b/tests/libdrgn.py\nindex 900eccca..bdf3b693 100644\n--- a/tests/libdrgn.py\n+++ b/tests/libdrgn.py\n@@ -7,7 +7,6 @@ from enum import auto\n import os\n \n import _drgn\n-import drgn\n \n _drgn_pydll = ctypes.PyDLL(_drgn.__file__)\n _drgn_cdll = ctypes.CDLL(_drgn.__file__)\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex cffc8d7f..d266bd55 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -6,7 +6,6 @@ import operator\n import os.path\n import re\n import tempfile\n-import unittest\n \n import drgn\n from drgn import (\n@@ -1025,22 +1024,25 @@ class TestTypes(TestCase):\n             ),\n         ]\n \n-        point_type = lambda prog: prog.struct_type(\n-            \"point\",\n-            8,\n-            (\n-                TypeMember(prog.int_type(\"int\", 4, True), \"x\"),\n-                TypeMember(prog.int_type(\"int\", 4, True), \"y\", 32),\n-            ),\n-        )\n-        other_point_type = lambda prog: prog.struct_type(\n-            \"point\",\n-            8,\n-            (\n-                TypeMember(prog.int_type(\"int\", 4, True), \"a\"),\n-                TypeMember(prog.int_type(\"int\", 4, True), \"b\", 32),\n-            ),\n-        )\n+        def point_type(prog):\n+            return prog.struct_type(\n+                \"point\",\n+                8,\n+                (\n+                    TypeMember(prog.int_type(\"int\", 4, True), \"x\"),\n+                    TypeMember(prog.int_type(\"int\", 4, True), \"y\", 32),\n+                ),\n+            )\n+\n+        def other_point_type(prog):\n+            return prog.struct_type(\n+                \"point\",\n+                8,\n+                (\n+                    TypeMember(prog.int_type(\"int\", 4, True), \"a\"),\n+                    TypeMember(prog.int_type(\"int\", 4, True), \"b\", 32),\n+                ),\n+            )\n \n         prog = dwarf_program(dies)\n         for dir in [\"\", \"src\", \"usr/src\", \"/usr/src\"]:\ndiff --git a/tests/test_object.py b/tests/test_object.py\nindex 4ed895da..811d7838 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -11,7 +11,6 @@ from drgn import (\n     ObjectAbsentError,\n     OutOfBoundsError,\n     Qualifiers,\n-    Type,\n     TypeMember,\n     cast,\n     reinterpret,\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex 7ac393e8..435db974 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -1,8 +1,6 @@\n # Copyright (c) Facebook, Inc. and its affiliates.\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n-import operator\n-\n from drgn import (\n     Language,\n     Object,\ndiff --git a/tools/bpf_inspect.py b/tools/bpf_inspect.py\nindex 17749405..0c51044c 100755\n--- a/tools/bpf_inspect.py\n+++ b/tools/bpf_inspect.py\n@@ -2,13 +2,7 @@\n # Copyright (c) Facebook, Inc. and its affiliates.\n # SPDX-License-Identifier: GPL-3.0-or-later\n \n-DESCRIPTION = \"\"\"\n-drgn script to list BPF programs or maps and their properties\n-unavailable via kernel API.\n-\"\"\"\n-\n import argparse\n-import sys\n \n from drgn.helpers import enum_type_to_class\n from drgn.helpers.linux import bpf_map_for_each, bpf_prog_for_each, hlist_for_each_entry\n@@ -116,7 +110,7 @@ def list_bpf_maps(args):\n \n def main():\n     parser = argparse.ArgumentParser(\n-        description=DESCRIPTION, formatter_class=argparse.RawTextHelpFormatter\n+        description=\"drgn script to list BPF programs or maps and their properties unavailable via kernel API\"\n     )\n \n     subparsers = parser.add_subparsers(title=\"subcommands\", dest=\"subcommand\")\ndiff --git a/vmtest/download.py b/vmtest/download.py\nindex 8565d761..b5abf1f5 100644\n--- a/vmtest/download.py\n+++ b/vmtest/download.py\n@@ -27,7 +27,7 @@ VMTEST_GITHUB_RELEASE = (\"osandov\", \"drgn\", \"vmtest-assets\")\n def available_kernel_releases(\n     github_release: Dict[str, Any], arch: str\n ) -> Dict[str, Dict[str, Any]]:\n-    pattern = re.compile(r\"kernel-(.*)\\.\" + re.escape(arch) + \"\\.tar\\.zst\")\n+    pattern = re.compile(r\"kernel-(.*)\\.\" + re.escape(arch) + r\"\\.tar\\.zst\")\n     releases = {}\n     for asset in github_release[\"assets\"]:\n         match = pattern.fullmatch(asset[\"name\"])\ndiff --git a/vmtest/manage.py b/vmtest/manage.py\nindex daddf592..0bbff359 100644\n--- a/vmtest/manage.py\n+++ b/vmtest/manage.py\n@@ -87,7 +87,7 @@ async def fetch_kernel_tags(kernel_dir: Path, kernel_tags: Sequence[str]) -> Non\n     mainline_tags = []\n     stable_tags = []\n     for tag in kernel_tags:\n-        if re.fullmatch(\"v[0-9]+\\.[0-9]+\\.[0-9]+\", tag):\n+        if re.fullmatch(r\"v[0-9]+\\.[0-9]+\\.[0-9]+\", tag):\n             stable_tags.append(tag)\n         else:\n             mainline_tags.append(tag)\ndiff --git a/vmtest/vm.py b/vmtest/vm.py\nindex c3fe15c7..1d9971c1 100644\n--- a/vmtest/vm.py\n+++ b/vmtest/vm.py\n@@ -162,7 +162,7 @@ class LostVMError(Exception):\n \n def run_in_vm(command: str, kernel_dir: Path, build_dir: Path) -> int:\n     match = re.search(\n-        \"QEMU emulator version ([0-9]+(?:\\.[0-9]+)*)\",\n+        r\"QEMU emulator version ([0-9]+(?:\\.[0-9]+)*)\",\n         subprocess.check_output(\n             [\"qemu-system-x86_64\", \"-version\"], universal_newlines=True\n         ),\n@@ -238,7 +238,7 @@ def run_in_vm(command: str, kernel_dir: Path, build_dir: Path) -> int:\n                 # fmt: on\n             ],\n             env=env,\n-        ) as qemu:\n+        ):\n             server_sock.settimeout(5)\n             try:\n                 sock = server_sock.accept()[0]\n"}
{"repo": "drgn", "commit": "65b65b27b09347542792678f0e0106fa3e70d560", "diff": "diff --git a/drgn/helpers/linux/user.py b/drgn/helpers/linux/user.py\nindex d9fd7475..7eeca5bb 100644\n--- a/drgn/helpers/linux/user.py\n+++ b/drgn/helpers/linux/user.py\n@@ -32,7 +32,7 @@ def find_user(prog: Program, uid: Union[Object, IntegerLike]) -> Object:\n     Return the user structure with the given UID.\n \n     :param uid: ``kuid_t`` object or integer.\n-    :return: ``struct user_state *``\n+    :return: ``struct user_struct *`` (``NULL`` if not found)\n     \"\"\"\n     try:\n         uidhashentry = prog.cache[\"uidhashentry\"]\n"}
{"repo": "drgn", "commit": "faad25d7b26a5cdaed510b399914ef9cf2d354a5", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 8bc6406e..fd1b6f3b 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -3750,6 +3750,39 @@ class TestObjects(TestCase):\n             FindObjectFlags.CONSTANT,\n         )\n \n+    def test_zero_size_variable(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.array_type,\n+                        (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),),\n+                    ),\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                b\"\\x03\\x04\\x03\\x02\\x01\\xff\\xff\\xff\\xff\",\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            )\n+        )\n+        self.assertIdentical(\n+            prog[\"x\"],\n+            Object(\n+                prog,\n+                prog.array_type(prog.int_type(\"int\", 4, True)),\n+                address=0xFFFFFFFF01020304,\n+            ),\n+        )\n+\n     def test_variable_no_address(self):\n         prog = dwarf_program(\n             wrap_test_type_dies(\n@@ -4400,6 +4433,131 @@ class TestObjects(TestCase):\n                 )\n                 self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n \n+    def test_variable_expr_empty_piece_non_contiguous_address(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFF0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                    # This piece is not contiguous with\n+                                    # the previous one, but it is zero\n+                                    # bits so it should be ignored.\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xEEEE0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(0),\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFF0002),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", address=0xFFFF0000))\n+\n+    def test_variable_expr_previous_empty_piece_non_contiguous_address(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xEEEE0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(0),\n+                                    # This piece is not contiguous with\n+                                    # the previous one, but the\n+                                    # previous one was zero bits so it\n+                                    # should be ignored.\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFF0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(4),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", address=0xFFFF0000))\n+\n+    def test_variable_expr_address_empty_piece(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xEEEE0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(0),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n+\n+    def test_variable_expr_absent_empty_piece(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(0),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n+\n     def test_variable_expr_unknown(self):\n         prog = dwarf_program(\n             wrap_test_type_dies(\n"}
{"repo": "drgn", "commit": "ffcb9ccb19e747494f12d24d45fc609baa290543", "diff": "diff --git a/tests/__init__.py b/tests/__init__.py\nindex 028062ae..43367aec 100644\n--- a/tests/__init__.py\n+++ b/tests/__init__.py\n@@ -41,6 +41,23 @@ def mock_memory_read(data, address, count, offset, physical):\n     return data[offset : offset + count]\n \n \n+def add_mock_memory_segments(prog, segments):\n+    for segment in segments:\n+        if segment.virt_addr is not None:\n+            prog.add_memory_segment(\n+                segment.virt_addr,\n+                len(segment.buf),\n+                functools.partial(mock_memory_read, segment.buf),\n+            )\n+        if segment.phys_addr is not None:\n+            prog.add_memory_segment(\n+                segment.phys_addr,\n+                len(segment.buf),\n+                functools.partial(mock_memory_read, segment.buf),\n+                True,\n+            )\n+\n+\n class MockObject(NamedTuple):\n     name: str\n     type: Type\n@@ -84,20 +101,7 @@ def mock_program(platform=MOCK_PLATFORM, *, segments=None, types=None, objects=N\n \n     prog = Program(platform)\n     if segments is not None:\n-        for segment in segments:\n-            if segment.virt_addr is not None:\n-                prog.add_memory_segment(\n-                    segment.virt_addr,\n-                    len(segment.buf),\n-                    functools.partial(mock_memory_read, segment.buf),\n-                )\n-            if segment.phys_addr is not None:\n-                prog.add_memory_segment(\n-                    segment.phys_addr,\n-                    len(segment.buf),\n-                    functools.partial(mock_memory_read, segment.buf),\n-                    True,\n-                )\n+        add_mock_memory_segments(prog, segments)\n     if types is not None:\n         prog.add_type_finder(mock_find_type)\n     if objects is not None:\ndiff --git a/tests/assembler.py b/tests/assembler.py\nnew file mode 100644\nindex 00000000..b4aa7aaf\n--- /dev/null\n+++ b/tests/assembler.py\n@@ -0,0 +1,62 @@\n+# Copyright (c) Facebook, Inc. and its affiliates.\n+# SPDX-License-Identifier: GPL-3.0-or-later\n+\n+from collections import namedtuple\n+\n+\n+def _append_uleb128(buf, value):\n+    while True:\n+        byte = value & 0x7F\n+        value >>= 7\n+        if value:\n+            buf.append(byte | 0x80)\n+        else:\n+            buf.append(byte)\n+            break\n+\n+\n+def _append_sleb128(buf, value):\n+    while True:\n+        byte = value & 0x7F\n+        value >>= 7\n+        if (not value and not (byte & 0x40)) or (value == -1 and (byte & 0x40)):\n+            buf.append(byte)\n+            break\n+        else:\n+            buf.append(byte | 0x80)\n+\n+\n+U8 = namedtuple(\"U8\", [\"value\"])\n+U8._append = lambda self, buf, byteorder: buf.append(self.value)\n+S8 = namedtuple(\"S8\", [\"value\"])\n+S8._append = lambda self, buf, byteorder: buf.append(self.value & 0xFF)\n+U16 = namedtuple(\"U16\", [\"value\"])\n+U16._append = lambda self, buf, byteorder: buf.extend(self.value.to_bytes(2, byteorder))\n+S16 = namedtuple(\"S16\", [\"value\"])\n+S16._append = lambda self, buf, byteorder: buf.extend(\n+    self.value.to_bytes(2, byteorder, signed=True)\n+)\n+U32 = namedtuple(\"U32\", [\"value\"])\n+U32._append = lambda self, buf, byteorder: buf.extend(self.value.to_bytes(4, byteorder))\n+S32 = namedtuple(\"S32\", [\"value\"])\n+S32._append = lambda self, buf, byteorder: buf.extend(\n+    self.value.to_bytes(4, byteorder, signed=True)\n+)\n+U64 = namedtuple(\"U64\", [\"value\"])\n+U64._append = lambda self, buf, byteorder: buf.extend(self.value.to_bytes(8, byteorder))\n+S64 = namedtuple(\"S64\", [\"value\"])\n+S64._append = lambda self, buf, byteorder: buf.extend(\n+    self.value.to_bytes(8, byteorder, signed=True)\n+)\n+ULEB128 = namedtuple(\"ULEB128\", [\"value\"])\n+ULEB128._append = lambda self, buf, byteorder: _append_uleb128(buf, self.value)\n+SLEB128 = namedtuple(\"SLEB128\", [\"value\"])\n+SLEB128._append = lambda self, buf, byteorder: _append_sleb128(buf, self.value)\n+\n+\n+def assemble(*args, little_endian=True):\n+    byteorder = \"little\" if little_endian else \"big\"\n+    buf = bytearray()\n+    for arg in args:\n+        arg._append(buf, byteorder)\n+    return buf\ndiff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex bc1320dc..9e82f9df 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -4,6 +4,7 @@\n from collections import namedtuple\n import os.path\n \n+from tests.assembler import _append_sleb128, _append_uleb128\n from tests.dwarf import DW_AT, DW_FORM, DW_TAG\n from tests.elf import ET, PT, SHT\n from tests.elfwriter import ElfSection, create_elf_file\n@@ -13,28 +14,6 @@ DwarfDie = namedtuple(\"DwarfAttrib\", [\"tag\", \"attribs\", \"children\"])\n DwarfDie.__new__.__defaults__ = (None,)\n \n \n-def _append_uleb128(buf, value):\n-    while True:\n-        byte = value & 0x7F\n-        value >>= 7\n-        if value:\n-            buf.append(byte | 0x80)\n-        else:\n-            buf.append(byte)\n-            break\n-\n-\n-def _append_sleb128(buf, value):\n-    while True:\n-        byte = value & 0x7F\n-        value >>= 7\n-        if (not value and not (byte & 0x40)) or (value == -1 and (byte & 0x40)):\n-            buf.append(byte)\n-            break\n-        else:\n-            buf.append(byte | 0x80)\n-\n-\n def _compile_debug_abbrev(unit_dies, use_dw_form_indirect):\n     buf = bytearray()\n     code = 1\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 018409b8..beec5662 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -3,12 +3,14 @@\n \n import ctypes\n import functools\n+import operator\n import os.path\n import re\n import tempfile\n import unittest\n \n from drgn import (\n+    FaultError,\n     FindObjectFlags,\n     Language,\n     Object,\n@@ -20,8 +22,15 @@ from drgn import (\n     TypeParameter,\n     TypeTemplateParameter,\n )\n-from tests import DEFAULT_LANGUAGE, TestCase, identical\n-from tests.dwarf import DW_AT, DW_ATE, DW_END, DW_FORM, DW_LANG, DW_TAG\n+from tests import (\n+    DEFAULT_LANGUAGE,\n+    MockMemorySegment,\n+    TestCase,\n+    add_mock_memory_segments,\n+    identical,\n+)\n+import tests.assembler as assembler\n+from tests.dwarf import DW_AT, DW_ATE, DW_END, DW_FORM, DW_LANG, DW_OP, DW_TAG\n from tests.dwarfwriter import DwarfAttrib, DwarfDie, compile_dwarf\n \n libdw = ctypes.CDLL(\"libdw.so\")\n@@ -189,12 +198,14 @@ base_type_dies += (\n )\n \n \n-def dwarf_program(*args, **kwds):\n+def dwarf_program(*args, segments=None, **kwds):\n     prog = Program()\n     with tempfile.NamedTemporaryFile() as f:\n         f.write(compile_dwarf(*args, **kwds))\n         f.flush()\n         prog.load_debug_info([f.name])\n+    if segments is not None:\n+        add_mock_memory_segments(prog, segments)\n     return prog\n \n \n@@ -3759,7 +3770,7 @@ class TestObjects(TestCase):\n         )\n         self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n \n-    def test_variable_unimplemented_location(self):\n+    def test_variable_expr_empty(self):\n         prog = dwarf_program(\n             wrap_test_type_dies(\n                 (\n@@ -3769,13 +3780,1527 @@ class TestObjects(TestCase):\n                         (\n                             DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n                             DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n-                            DwarfAttrib(DW_AT.location, DW_FORM.exprloc, b\"\\xe0\"),\n+                            DwarfAttrib(DW_AT.location, DW_FORM.exprloc, b\"\"),\n                         ),\n                     ),\n                 )\n             )\n         )\n-        self.assertRaisesRegex(Exception, \"unimplemented operation\", prog.object, \"x\")\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n+\n+    def test_variable_expr_bit_piece(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFFFFFF01020304),\n+                                    assembler.U8(DW_OP.bit_piece),\n+                                    assembler.ULEB128(32),\n+                                    assembler.ULEB128(4),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(\n+            prog.object(\"x\"),\n+            Object(prog, \"int\", address=0xFFFFFFFF01020304, bit_offset=4),\n+        )\n+\n+    def test_variable_expr_implicit_value(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(4),\n+                                            assembler.U32(0x12345678),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n+\n+    def test_variable_expr_implicit_value_pieces(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U16(\n+                                                0x5678 if little_endian else 0x1234\n+                                            ),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U16(\n+                                                0x1234 if little_endian else 0x5678\n+                                            ),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n+\n+    def test_variable_expr_implicit_value_pieces_too_large(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U16(\n+                                                0x5678 if little_endian else 0x1234\n+                                            ),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(4),\n+                                            assembler.U32(\n+                                                0x1234 if little_endian else 0x5678\n+                                            ),\n+                                            assembler.U8(DW_OP.piece),\n+                                            # Piece size is larger than remaining size of object.\n+                                            assembler.ULEB128(4),\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(4),\n+                                            assembler.U32(0),\n+                                            # There is nothing remaining in the object.\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(4),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n+\n+    def test_variable_expr_implicit_value_too_small(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(1),\n+                                            assembler.U8(0x99),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x99))\n+\n+    def test_variable_expr_implicit_value_bit_pieces(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(1),\n+                                            assembler.U8(\n+                                                0x8F if little_endian else 0x1F\n+                                            ),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(4),\n+                                            assembler.ULEB128(4),\n+                                            assembler.U8(DW_OP.implicit_value),\n+                                            assembler.ULEB128(4),\n+                                            assembler.U32(\n+                                                0x1234567\n+                                                if little_endian\n+                                                else 0x2345678\n+                                            ),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(28),\n+                                            assembler.ULEB128(0),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n+\n+    def test_variable_expr_implicit_value_piece_empty(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.implicit_value),\n+                                    assembler.ULEB128(2),\n+                                    assembler.U16(0),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n+\n+    def test_variable_expr_stack_value(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.lit31),\n+                                            assembler.U8(DW_OP.stack_value),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 31))\n+\n+    def test_variable_expr_stack_value_pieces(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(\n+                                                DW_OP.lit2\n+                                                if little_endian\n+                                                else DW_OP.lit1\n+                                            ),\n+                                            assembler.U8(DW_OP.stack_value),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(\n+                                                3 if little_endian else 1\n+                                            ),\n+                                            assembler.U8(\n+                                                DW_OP.lit1\n+                                                if little_endian\n+                                                else DW_OP.lit2\n+                                            ),\n+                                            assembler.U8(DW_OP.stack_value),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(\n+                                                1 if little_endian else 3\n+                                            ),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x1000002))\n+\n+    def test_variable_expr_stack_value_bit_pieces(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(\n+                                                DW_OP.lit2\n+                                                if little_endian\n+                                                else DW_OP.lit31\n+                                            ),\n+                                            assembler.U8(DW_OP.stack_value),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(\n+                                                4 if little_endian else 28\n+                                            ),\n+                                            assembler.ULEB128(\n+                                                0 if little_endian else 4\n+                                            ),\n+                                            assembler.U8(\n+                                                DW_OP.lit31\n+                                                if little_endian\n+                                                else DW_OP.lit2\n+                                            ),\n+                                            assembler.U8(DW_OP.stack_value),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(\n+                                                28 if little_endian else 4\n+                                            ),\n+                                            assembler.ULEB128(\n+                                                4 if little_endian else 0\n+                                            ),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12))\n+\n+    def test_variable_expr_stack_value_piece_empty(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.lit1),\n+                                    assembler.U8(DW_OP.stack_value),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\"))\n+\n+    def test_variable_expr_contiguous_piece_addresses(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFF0000),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                    assembler.U8(DW_OP.addr),\n+                                    assembler.U64(0xFFFF0002),\n+                                    assembler.U8(DW_OP.piece),\n+                                    assembler.ULEB128(2),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+        )\n+        self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", address=0xFFFF0000))\n+\n+    def test_variable_expr_contiguous_bit_piece_addresses(self):\n+        for bit_offset in (0, 1):\n+            with self.subTest(bit_offset=bit_offset):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0000),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(10),\n+                                            assembler.ULEB128(bit_offset),\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0001),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(22),\n+                                            assembler.ULEB128(bit_offset + 2),\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                )\n+                self.assertIdentical(\n+                    prog.object(\"x\"),\n+                    Object(prog, \"int\", address=0xFFFF0000, bit_offset=bit_offset),\n+                )\n+\n+    def test_variable_expr_non_contiguous_piece_addresses(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0002),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0000),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                    segments=[\n+                        MockMemorySegment(\n+                            (0x12345678).to_bytes(\n+                                4, \"little\" if little_endian else \"big\"\n+                            ),\n+                            0xFFFF0000,\n+                        )\n+                    ],\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x56781234))\n+\n+    def test_variable_expr_non_contiguous_piece_addresses_too_large(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0002),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(2),\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0000),\n+                                            assembler.U8(DW_OP.piece),\n+                                            assembler.ULEB128(256),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                    segments=[\n+                        MockMemorySegment(\n+                            (0x12345678).to_bytes(\n+                                4, \"little\" if little_endian else \"big\"\n+                            ),\n+                            0xFFFF0000,\n+                        )\n+                    ],\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x56781234))\n+\n+    def test_variable_expr_non_contiguous_bit_piece_addresses(self):\n+        for little_endian in (True, False):\n+            with self.subTest(little_endian=little_endian):\n+                prog = dwarf_program(\n+                    wrap_test_type_dies(\n+                        (\n+                            int_die,\n+                            DwarfDie(\n+                                DW_TAG.variable,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                                    DwarfAttrib(\n+                                        DW_AT.location,\n+                                        DW_FORM.exprloc,\n+                                        assembler.assemble(\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0000),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(4),\n+                                            assembler.ULEB128(0),\n+                                            assembler.U8(DW_OP.addr),\n+                                            assembler.U64(0xFFFF0000),\n+                                            assembler.U8(DW_OP.bit_piece),\n+                                            assembler.ULEB128(28),\n+                                            assembler.ULEB128(5),\n+                                            little_endian=little_endian,\n+                                        ),\n+                                    ),\n+                                ),\n+                            ),\n+                        )\n+                    ),\n+                    little_endian=little_endian,\n+                    segments=[\n+                        MockMemorySegment(\n+                            (\n+                                (0x2468ACE8).to_bytes(5, \"little\")\n+                                if little_endian\n+                                else (0x111A2B3C00).to_bytes(5, \"big\")\n+                            ),\n+                            0xFFFF0000,\n+                        )\n+                    ],\n+                )\n+                self.assertIdentical(prog.object(\"x\"), Object(prog, \"int\", 0x12345678))\n+\n+    def test_variable_expr_unknown(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(DW_AT.location, DW_FORM.exprloc, b\"\\xdf\"),\n+                        ),\n+                    ),\n+                )\n+            )\n+        )\n+        self.assertRaisesRegex(\n+            Exception, \"unknown DWARF expression opcode\", prog.object, \"x\"\n+        )\n+\n+    def test_variable_expr_unknown_after_location(self):\n+        prog = dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    int_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    assembler.U8(DW_OP.implicit_value),\n+                                    assembler.ULEB128(4),\n+                                    assembler.U32(0),\n+                                    assembler.U8(0xDF),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            )\n+        )\n+        self.assertRaisesRegex(\n+            Exception, \"unknown DWARF expression opcode\", prog.object, \"x\"\n+        )\n+\n+    def _eval_dwarf_expr(self, ops, **kwds):\n+        assemble_kwds = {\n+            key: value for key, value in kwds.items() if key == \"little_endian\"\n+        }\n+        return dwarf_program(\n+            wrap_test_type_dies(\n+                (\n+                    unsigned_long_long_die,\n+                    DwarfDie(\n+                        DW_TAG.variable,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                            DwarfAttrib(\n+                                DW_AT.location,\n+                                DW_FORM.exprloc,\n+                                assembler.assemble(\n+                                    *ops,\n+                                    assembler.U8(DW_OP.stack_value),\n+                                    **assemble_kwds,\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                )\n+            ),\n+            **kwds,\n+        )[\"x\"].value_()\n+\n+    def _assert_dwarf_expr_eval(self, ops, expected, **kwds):\n+        self.assertEqual(self._eval_dwarf_expr(ops, **kwds), expected)\n+\n+    def _assert_dwarf_expr_stack_underflow(self, ops, **kwds):\n+        with self.assertRaisesRegex(Exception, \"stack underflow\"):\n+            self._eval_dwarf_expr(ops, **kwds)\n+\n+    def test_variable_expr_op_lit(self):\n+        for i in range(32):\n+            with self.subTest(i=i):\n+                self._assert_dwarf_expr_eval([assembler.U8(DW_OP.lit0 + i)], i)\n+\n+    def test_variable_expr_op_addr(self):\n+        with self.subTest(bits=64):\n+            self._assert_dwarf_expr_eval(\n+                [assembler.U8(DW_OP.addr), assembler.U64(2 ** 64 - 1)],\n+                2 ** 64 - 1,\n+                bits=64,\n+            )\n+        with self.subTest(bits=32):\n+            self._assert_dwarf_expr_eval(\n+                [assembler.U8(DW_OP.addr), assembler.U32(2 ** 32 - 1)],\n+                2 ** 32 - 1,\n+                bits=32,\n+            )\n+\n+    def test_variable_expr_op_constu(self):\n+        for bits in (64, 32):\n+            for size in (1, 2, 4, 8):\n+                op_name = f\"const{size}u\"\n+                with self.subTest(bits=bits, op=op_name):\n+                    op = getattr(DW_OP, op_name)\n+                    type_ = getattr(assembler, f\"U{size * 8}\")\n+                    self._assert_dwarf_expr_eval(\n+                        [assembler.U8(op), type_(2 ** (size * 8) - 1)],\n+                        (2 ** (size * 8) - 1) & (2 ** bits - 1),\n+                        bits=bits,\n+                    )\n+            with self.subTest(bits=bits, op=\"constu\"):\n+                self._assert_dwarf_expr_eval(\n+                    [assembler.U8(DW_OP.constu), assembler.ULEB128(0x123456789)],\n+                    0x123456789 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_consts(self):\n+        for bits in (64, 32):\n+            for size in (1, 2, 4, 8):\n+                op_name = f\"const{size}s\"\n+                with self.subTest(bits=bits, op=op_name):\n+                    op = getattr(DW_OP, op_name)\n+                    type_ = getattr(assembler, f\"S{size * 8}\")\n+                    self._assert_dwarf_expr_eval(\n+                        [assembler.U8(op), type_(-1)],\n+                        -1 & (2 ** bits - 1),\n+                        bits=bits,\n+                    )\n+            with self.subTest(bits=bits, op=\"consts\"):\n+                self._assert_dwarf_expr_eval(\n+                    [assembler.U8(DW_OP.consts), assembler.SLEB128(-0x123456789)],\n+                    -0x123456789 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_dup(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit1),\n+                assembler.U8(DW_OP.dup),\n+                assembler.U8(DW_OP.plus),\n+            ],\n+            2,\n+        )\n+\n+    def test_variable_expr_op_drop(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit1),\n+                assembler.U8(DW_OP.lit2),\n+                assembler.U8(DW_OP.drop),\n+                assembler.U8(DW_OP.lit3),\n+                assembler.U8(DW_OP.plus),\n+            ],\n+            4,\n+        )\n+\n+    def test_variable_expr_op_pick(self):\n+        for i, value in enumerate((30, 20, 10)):\n+            with self.subTest(i=i):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit10),\n+                        assembler.U8(DW_OP.lit20),\n+                        assembler.U8(DW_OP.lit30),\n+                        assembler.U8(DW_OP.pick),\n+                        assembler.U8(i),\n+                    ],\n+                    value,\n+                )\n+\n+    def test_variable_expr_op_pick_underflow(self):\n+        for i in (3, 255):\n+            with self.subTest(i=i):\n+                self._assert_dwarf_expr_stack_underflow(\n+                    [\n+                        assembler.U8(DW_OP.lit10),\n+                        assembler.U8(DW_OP.lit20),\n+                        assembler.U8(DW_OP.lit30),\n+                        assembler.U8(DW_OP.pick),\n+                        assembler.U8(i),\n+                    ]\n+                )\n+\n+    def test_variable_expr_op_over(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit10),\n+                assembler.U8(DW_OP.lit20),\n+                assembler.U8(DW_OP.over),\n+            ],\n+            10,\n+        )\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit10),\n+                assembler.U8(DW_OP.lit20),\n+                assembler.U8(DW_OP.lit30),\n+                assembler.U8(DW_OP.over),\n+            ],\n+            20,\n+        )\n+\n+    def test_variable_expr_op_swap(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit3),\n+                assembler.U8(DW_OP.lit5),\n+                assembler.U8(DW_OP.swap),\n+                assembler.U8(DW_OP.minus),\n+            ],\n+            2,\n+        )\n+\n+    def test_variable_expr_op_rot(self):\n+        for i, value in enumerate((5, 3, 7, 1)):\n+            self._assert_dwarf_expr_eval(\n+                [\n+                    assembler.U8(DW_OP.lit1),\n+                    assembler.U8(DW_OP.lit3),\n+                    assembler.U8(DW_OP.lit5),\n+                    assembler.U8(DW_OP.lit7),\n+                    assembler.U8(DW_OP.rot),\n+                    assembler.U8(DW_OP.pick),\n+                    assembler.U8(i),\n+                ],\n+                value,\n+            )\n+\n+    def test_variable_expr_op_deref(self):\n+        for bits in (64, 32):\n+            for little_endian in (True, False):\n+                with self.subTest(bits=bits, little_endian=little_endian):\n+                    self._assert_dwarf_expr_eval(\n+                        [\n+                            assembler.U8(DW_OP.addr),\n+                            (assembler.U64 if bits == 64 else assembler.U32)(\n+                                0xFFFF0000\n+                            ),\n+                            assembler.U8(DW_OP.deref),\n+                        ],\n+                        0x12345678,\n+                        bits=bits,\n+                        little_endian=little_endian,\n+                        segments=[\n+                            MockMemorySegment(\n+                                (0x12345678).to_bytes(\n+                                    bits // 8, \"little\" if little_endian else \"big\"\n+                                ),\n+                                0xFFFF0000,\n+                            )\n+                        ],\n+                    )\n+\n+    def test_variable_expr_op_deref_fault(self):\n+        with self.assertRaises(FaultError):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.addr),\n+                    assembler.U64(0xFFFF0000),\n+                    assembler.U8(DW_OP.deref),\n+                ]\n+            )\n+\n+    def test_variable_expr_op_deref_size(self):\n+        for bits in (64, 32):\n+            for little_endian in (True, False):\n+                with self.subTest(bits=bits, little_endian=little_endian):\n+                    self._assert_dwarf_expr_eval(\n+                        [\n+                            assembler.U8(DW_OP.addr),\n+                            (assembler.U64 if bits == 64 else assembler.U32)(\n+                                0xFFFF0000\n+                            ),\n+                            assembler.U8(DW_OP.deref_size),\n+                            assembler.U8(2),\n+                        ],\n+                        0x1337,\n+                        bits=bits,\n+                        little_endian=little_endian,\n+                        segments=[\n+                            MockMemorySegment(\n+                                (0x1337).to_bytes(\n+                                    2, \"little\" if little_endian else \"big\"\n+                                ),\n+                                0xFFFF0000,\n+                            )\n+                        ],\n+                    )\n+\n+    def test_variable_expr_op_deref_size_fault(self):\n+        with self.assertRaises(FaultError):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.addr),\n+                    assembler.U64(0xFFFF0000),\n+                    assembler.U8(DW_OP.deref_size),\n+                    assembler.U8(1),\n+                ]\n+            )\n+\n+    def test_variable_expr_stack_underflow(self):\n+        for case in [\n+            (DW_OP.dup, 1),\n+            (DW_OP.drop, 1),\n+            (DW_OP.over, 2),\n+            (DW_OP.swap, 2),\n+            (DW_OP.rot, 3),\n+            (DW_OP.deref, 1),\n+            (DW_OP.deref_size, 1, assembler.U8(1)),\n+            (DW_OP.abs, 1),\n+            (DW_OP.and_, 2),\n+            (DW_OP.div, 2),\n+            (DW_OP.minus, 2),\n+            (DW_OP.mod, 2),\n+            (DW_OP.mul, 2),\n+            (DW_OP.neg, 1),\n+            (DW_OP.not_, 1),\n+            (DW_OP.or_, 2),\n+            (DW_OP.plus, 2),\n+            (DW_OP.plus_uconst, 1, assembler.ULEB128(1)),\n+            (DW_OP.shl, 2),\n+            (DW_OP.shr, 2),\n+            (DW_OP.shra, 2),\n+            (DW_OP.xor, 2),\n+            (DW_OP.le, 2),\n+            (DW_OP.ge, 2),\n+            (DW_OP.eq, 2),\n+            (DW_OP.lt, 2),\n+            (DW_OP.gt, 2),\n+            (DW_OP.ne, 2),\n+            (DW_OP.bra, 1, assembler.S16(1)),\n+        ]:\n+            op = case[0]\n+            min_entries = case[1]\n+            extra_args = case[2:]\n+            with self.subTest(op=op):\n+                for i in range(min_entries):\n+                    self._assert_dwarf_expr_stack_underflow(\n+                        [assembler.U8(DW_OP.lit1)] * i + [assembler.U8(op), *extra_args]\n+                    )\n+\n+    def test_variable_expr_op_abs(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-9),\n+                        assembler.U8(DW_OP.abs),\n+                    ],\n+                    9,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_and(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.and_),\n+                    ],\n+                    1,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_div(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.div),\n+                    ],\n+                    2,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit0),\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.div),\n+                    ],\n+                    0,\n+                    bits=bits,\n+                )\n+                # The DWARF 5 specification doesn't specify how signed division\n+                # should be rounded. We assume truncation towards zero like C.\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.div),\n+                    ],\n+                    -2 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_div_by_zero(self):\n+        with self.assertRaisesRegex(Exception, \"division by zero\"):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.lit1),\n+                    assembler.U8(DW_OP.lit0),\n+                    assembler.U8(DW_OP.div),\n+                ]\n+            )\n+\n+    def test_variable_expr_op_minus(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.minus),\n+                    ],\n+                    3,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.minus),\n+                    ],\n+                    -3 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_mod(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.mod),\n+                    ],\n+                    1,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit0),\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.mod),\n+                    ],\n+                    0,\n+                    bits=bits,\n+                )\n+                # Although DW_OP_div is signed, DW_OP_mod is unsigned.\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.mod),\n+                    ],\n+                    1,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_mod_by_zero(self):\n+        with self.assertRaisesRegex(Exception, \"modulo by zero\"):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.lit1),\n+                    assembler.U8(DW_OP.lit0),\n+                    assembler.U8(DW_OP.mod),\n+                ]\n+            )\n+\n+    def test_variable_expr_op_mul(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.mul),\n+                    ],\n+                    10,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-5),\n+                        assembler.U8(DW_OP.lit2),\n+                        assembler.U8(DW_OP.mul),\n+                    ],\n+                    ((-5 & (2 ** bits - 1)) * 2) & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_neg(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit7),\n+                        assembler.U8(DW_OP.neg),\n+                    ],\n+                    -7 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-7),\n+                        assembler.U8(DW_OP.neg),\n+                    ],\n+                    7,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_not(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit0),\n+                        assembler.U8(DW_OP.not_),\n+                    ],\n+                    2 ** bits - 1,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit31),\n+                        assembler.U8(DW_OP.not_),\n+                    ],\n+                    ~31 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_or(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.or_),\n+                    ],\n+                    7,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_plus(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit6),\n+                        assembler.U8(DW_OP.lit7),\n+                        assembler.U8(DW_OP.plus),\n+                    ],\n+                    13,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.S8(DW_OP.const1s),\n+                        assembler.S8(-3),\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.plus),\n+                    ],\n+                    2,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_plus_uconst(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit6),\n+                        assembler.U8(DW_OP.plus_uconst),\n+                        assembler.ULEB128(7),\n+                    ],\n+                    13,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.S8(DW_OP.const1s),\n+                        assembler.S8(-3),\n+                        assembler.U8(DW_OP.plus_uconst),\n+                        assembler.ULEB128(5),\n+                    ],\n+                    2,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_shl(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.lit4),\n+                        assembler.U8(DW_OP.shl),\n+                    ],\n+                    48,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.constu),\n+                        assembler.ULEB128(2 ** (bits - 2)),\n+                        assembler.U8(DW_OP.lit1),\n+                        assembler.U8(DW_OP.shl),\n+                    ],\n+                    2 ** (bits - 1),\n+                    bits=bits,\n+                )\n+                # The DWARF specification doesn't define the behavior of\n+                # shifting by a number of bits larger than the width of the\n+                # type. We evaluate it to zero.\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.const1u),\n+                        assembler.U8(bits),\n+                        assembler.U8(DW_OP.shl),\n+                    ],\n+                    0,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_shr(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1u),\n+                        assembler.U8(48),\n+                        assembler.U8(DW_OP.lit4),\n+                        assembler.U8(DW_OP.shr),\n+                    ],\n+                    3,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.constu),\n+                        assembler.ULEB128(2 ** (bits - 1)),\n+                        assembler.U8(DW_OP.lit1),\n+                        assembler.U8(DW_OP.shr),\n+                    ],\n+                    2 ** (bits - 2),\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-1),\n+                        assembler.U8(DW_OP.const1u),\n+                        assembler.U8(bits),\n+                        assembler.U8(DW_OP.shr),\n+                    ],\n+                    0,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_shra(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1u),\n+                        assembler.U8(48),\n+                        assembler.U8(DW_OP.lit4),\n+                        assembler.U8(DW_OP.shra),\n+                    ],\n+                    3,\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-48),\n+                        assembler.U8(DW_OP.lit4),\n+                        assembler.U8(DW_OP.shra),\n+                    ],\n+                    -3 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.constu),\n+                        assembler.ULEB128(2 ** (bits - 1)),\n+                        assembler.U8(DW_OP.lit1),\n+                        assembler.U8(DW_OP.shra),\n+                    ],\n+                    2 ** (bits - 2) + 2 ** (bits - 1),\n+                    bits=bits,\n+                )\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.const1s),\n+                        assembler.S8(-2),\n+                        assembler.U8(DW_OP.const1u),\n+                        assembler.U8(bits),\n+                        assembler.U8(DW_OP.shra),\n+                    ],\n+                    -1 & (2 ** bits - 1),\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_op_xor(self):\n+        for bits in (64, 32):\n+            with self.subTest(bits=bits):\n+                self._assert_dwarf_expr_eval(\n+                    [\n+                        assembler.U8(DW_OP.lit3),\n+                        assembler.U8(DW_OP.lit5),\n+                        assembler.U8(DW_OP.xor),\n+                    ],\n+                    6,\n+                    bits=bits,\n+                )\n+\n+    def test_variable_expr_relational(self):\n+        for op, py_op in [\n+            (DW_OP.le, operator.le),\n+            (DW_OP.ge, operator.ge),\n+            (DW_OP.eq, operator.eq),\n+            (DW_OP.lt, operator.lt),\n+            (DW_OP.gt, operator.gt),\n+            (DW_OP.ne, operator.ne),\n+        ]:\n+            for bits in (64, 32):\n+                for val1, val2 in [\n+                    (3, 5),\n+                    (3, -5),\n+                    (-3, 5),\n+                    (-3, -5),\n+                    (5, 5),\n+                    (5, -5),\n+                    (-5, 5),\n+                    (-5, -5),\n+                    (6, 5),\n+                    (6, -5),\n+                    (-6, 5),\n+                    (-6, -5),\n+                ]:\n+                    with self.subTest(bits=bits, val1=val1, val2=val2):\n+                        self._assert_dwarf_expr_eval(\n+                            [\n+                                assembler.U8(DW_OP.const1s),\n+                                assembler.S8(val1),\n+                                assembler.U8(DW_OP.const1s),\n+                                assembler.S8(val2),\n+                                assembler.U8(op),\n+                            ],\n+                            int(py_op(val1, val2)),\n+                        )\n+\n+    def test_variable_expr_op_skip(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.skip),\n+                assembler.S16(3),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.div),\n+                assembler.U8(DW_OP.lit20),\n+            ],\n+            20,\n+        )\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit1),\n+                assembler.U8(DW_OP.skip),\n+                assembler.S16(4),\n+                assembler.U8(DW_OP.lit3),\n+                assembler.U8(DW_OP.skip),\n+                assembler.S16(4),\n+                assembler.U8(DW_OP.lit2),\n+                assembler.U8(DW_OP.skip),\n+                assembler.S16(-8),\n+            ],\n+            3,\n+        )\n+\n+    def test_variable_expr_op_skip_infinite(self):\n+        with self.assertRaisesRegex(Exception, \"too many operations\"):\n+            self._eval_dwarf_expr([assembler.U8(DW_OP.skip), assembler.S16(-3)])\n+\n+    def test_variable_expr_op_skip_out_of_bounds(self):\n+        with self.assertRaisesRegex(Exception, \"out of bounds\"):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.skip),\n+                    # 1 extra for for the DW_OP_stack_value added by\n+                    # _eval_dwarf_expr().\n+                    assembler.U16(3),\n+                    assembler.U8(DW_OP.nop),\n+                ],\n+            )\n+\n+    def test_variable_expr_op_bra(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit31),\n+                assembler.U8(DW_OP.bra),\n+                assembler.S16(3),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.div),\n+                assembler.U8(DW_OP.lit20),\n+            ],\n+            20,\n+        )\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit1),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.bra),\n+                assembler.S16(1),\n+                assembler.U8(DW_OP.lit2),\n+            ],\n+            2,\n+        )\n+        # More complicated expression implementing something like this:\n+        # i = 0\n+        # x = 0\n+        # do {\n+        #     x += 2;\n+        #     i += 1;\n+        # while (i <= 5);\n+        # return x;\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.plus_uconst),\n+                assembler.ULEB128(2),\n+                assembler.U8(DW_OP.swap),\n+                assembler.U8(DW_OP.plus_uconst),\n+                assembler.ULEB128(1),\n+                assembler.U8(DW_OP.swap),\n+                assembler.U8(DW_OP.over),\n+                assembler.U8(DW_OP.lit5),\n+                assembler.U8(DW_OP.lt),\n+                assembler.U8(DW_OP.bra),\n+                assembler.S16(-12),\n+            ],\n+            10,\n+        )\n+\n+    def test_variable_expr_op_bra_out_of_bounds(self):\n+        with self.assertRaisesRegex(Exception, \"out of bounds\"):\n+            self._eval_dwarf_expr(\n+                [\n+                    assembler.U8(DW_OP.lit1),\n+                    assembler.U8(DW_OP.bra),\n+                    # 1 extra for for the DW_OP_stack_value added by\n+                    # _eval_dwarf_expr().\n+                    assembler.U16(3),\n+                    assembler.U8(DW_OP.nop),\n+                ],\n+            )\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.lit0),\n+                assembler.U8(DW_OP.bra),\n+                assembler.U16(3),\n+                assembler.U8(DW_OP.lit2),\n+            ],\n+            2,\n+        )\n+\n+    def test_variable_expr_op_nop(self):\n+        self._assert_dwarf_expr_eval(\n+            [\n+                assembler.U8(DW_OP.nop),\n+                assembler.U8(DW_OP.nop),\n+                assembler.U8(DW_OP.lit25),\n+                assembler.U8(DW_OP.nop),\n+                assembler.U8(DW_OP.nop),\n+            ],\n+            25,\n+        )\n \n     def test_variable_const_signed(self):\n         for form in (\n"}
{"repo": "drgn", "commit": "179b33c76f82d0b6109c3eb3299b5e9d85b96d04", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex f3998cc0..48cad265 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -195,7 +195,7 @@ def execscript(path: str, *args: str) -> None:\n     :param args: Zero or more additional arguments to pass to the script. This\n         is a :ref:`variable argument list <python:tut-arbitraryargs>`.\n     \"\"\"\n-    # This is based on runpy.run_code, which we can't use because we want to\n+    # This is based on runpy.run_path(), which we can't use because we want to\n     # update globals even if the script throws an exception.\n     saved_module = []\n     try:\n"}
{"repo": "drgn", "commit": "47ab6142d54e43311dd6d556be8a293996eea7f2", "diff": "diff --git a/vmtest/vm.py b/vmtest/vm.py\nindex 20a61d67..c3fe15c7 100644\n--- a/vmtest/vm.py\n+++ b/vmtest/vm.py\n@@ -307,9 +307,7 @@ if __name__ == \"__main__\":\n     else:\n         from vmtest.download import download_kernels\n \n-        kernel_dir = next(\n-            download_kernels(args.directory, \"x86_64\", getattr(args, \"kernel\", \"*\"))\n-        )\n+        kernel_dir = next(download_kernels(args.directory, \"x86_64\", (kernel,)))\n \n     try:\n         command = \" \".join(args.command) if args.command else '\"$BUSYBOX\" sh -i'\n"}
{"repo": "drgn", "commit": "abeea40b8a5281ede0e68e2c8d38138e0cf0f31a", "diff": "diff --git a/vmtest/download.py b/vmtest/download.py\nindex 4531fd88..8565d761 100644\n--- a/vmtest/download.py\n+++ b/vmtest/download.py\n@@ -38,8 +38,8 @@ def available_kernel_releases(\n \n def _download_kernel(gh: GitHubApi, url: str, dir: Path) -> None:\n     dir.parent.mkdir(parents=True, exist_ok=True)\n-    with tempfile.TemporaryDirectory(dir=dir.parent) as tmp_name:\n-        tmp_dir = Path(tmp_name)\n+    tmp_dir = Path(tempfile.mkdtemp(dir=dir.parent))\n+    try:\n         # Don't assume that the available version of tar has zstd support or\n         # the non-standard -I/--use-compress-program option.\n         with subprocess.Popen(\n@@ -59,7 +59,10 @@ def _download_kernel(gh: GitHubApi, url: str, dir: Path) -> None:\n             raise subprocess.CalledProcessError(zstd_proc.returncode, zstd_proc.args)\n         if tar_proc.returncode != 0:\n             raise subprocess.CalledProcessError(tar_proc.returncode, tar_proc.args)\n-\n+    except:\n+        shutil.rmtree(tmp_dir, ignore_errors=True)\n+        raise\n+    else:\n         tmp_dir.rename(dir)\n \n \n"}
{"repo": "drgn", "commit": "a15de13a7c091be7314359deb18c11d61af8f519", "diff": "diff --git a/vmtest/download.py b/vmtest/download.py\nindex 3514408f..4531fd88 100644\n--- a/vmtest/download.py\n+++ b/vmtest/download.py\n@@ -14,7 +14,7 @@ import shutil\n import subprocess\n import tempfile\n import threading\n-from typing import Any, Dict, Iterator, Optional, Sequence\n+from typing import Any, Dict, Iterator, Sequence, Union\n \n from util import KernelVersion\n from vmtest.githubapi import GitHubApi\n@@ -136,25 +136,30 @@ def _download_kernels_thread(\n     download_dir: Path,\n     arch: str,\n     kernels: Sequence[str],\n-    q: \"queue.Queue[Optional[Path]]\",\n+    q: \"queue.Queue[Union[Path, Exception]]\",\n ) -> None:\n-    for kernel in download_kernels(download_dir, arch, kernels):\n-        q.put(kernel)\n-    q.put(None)\n+    try:\n+        it = download_kernels(download_dir, arch, kernels)\n+        while True:\n+            q.put(next(it))\n+    except Exception as e:\n+        q.put(e)\n \n \n @contextmanager\n def download_kernels_in_thread(\n     download_dir: Path, arch: str, kernels: Sequence[str]\n ) -> Iterator[Iterator[Path]]:\n-    q: \"queue.Queue[Optional[Path]]\" = queue.Queue()\n+    q: \"queue.Queue[Union[Path, Exception]]\" = queue.Queue()\n \n     def aux() -> Iterator[Path]:\n         while True:\n-            kernel = q.get()\n-            if kernel is None:\n+            obj = q.get()\n+            if isinstance(obj, StopIteration):\n                 break\n-            yield kernel\n+            elif isinstance(obj, Exception):\n+                raise obj\n+            yield obj\n \n     thread = None\n     try:\n"}
{"repo": "drgn", "commit": "6b79b21ab5682a1270f07e0d84b4952cec7b314a", "diff": "diff --git a/tests/test_type.py b/tests/test_type.py\nindex 2ebfa1ad..7ac393e8 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -945,7 +945,8 @@ class TestType(MockProgramTestCase):\n         t = self.prog.void_type(qualifiers=Qualifiers.CONST | Qualifiers.VOLATILE)\n         self.assertEqual(t.qualifiers, Qualifiers.CONST | Qualifiers.VOLATILE)\n         self.assertEqual(\n-            repr(t), \"prog.void_type(qualifiers=<Qualifiers.VOLATILE|CONST: 3>)\"\n+            repr(t),\n+            f\"prog.void_type(qualifiers={repr(Qualifiers.CONST | Qualifiers.VOLATILE)})\",\n         )\n \n         self.assertIdentical(\n"}
{"repo": "drgn", "commit": "12723a0c0836856972fa697d318770dd242a2efe", "diff": "diff --git a/tests/helpers/linux/__init__.py b/tests/helpers/linux/__init__.py\nindex 409fb657..bc84e98e 100644\n--- a/tests/helpers/linux/__init__.py\n+++ b/tests/helpers/linux/__init__.py\n@@ -1,6 +1,7 @@\n # Copyright (c) Facebook, Inc. and its affiliates.\n # SPDX-License-Identifier: GPL-3.0+\n \n+import contextlib\n import ctypes\n import errno\n import os\n@@ -151,3 +152,19 @@ def create_socket(*args, **kwds):\n             raise unittest.SkipTest(\"kernel does not support TCP\")\n         else:\n             raise\n+\n+\n+@contextlib.contextmanager\n+def setenv(key, value):\n+    old_value = os.environ.get(key)\n+    try:\n+        if value is not None:\n+            os.environ[key] = value\n+        elif old_value is not None:\n+            del os.environ[key]\n+        yield\n+    finally:\n+        if old_value is None:\n+            del os.environ[key]\n+        else:\n+            os.environ[key] = old_value\ndiff --git a/tests/helpers/linux/test_debug_info.py b/tests/helpers/linux/test_debug_info.py\nindex 96648eb0..cb60ddf8 100644\n--- a/tests/helpers/linux/test_debug_info.py\n+++ b/tests/helpers/linux/test_debug_info.py\n@@ -3,12 +3,17 @@\n \n import os\n \n-import drgn\n-from tests.helpers.linux import LinuxHelperTestCase\n+from drgn import Program\n+from tests.helpers.linux import LinuxHelperTestCase, setenv\n \n \n-class TestDebugInfo(LinuxHelperTestCase):\n-    def test_module_debug_info(self):\n+class TestModuleDebugInfo(LinuxHelperTestCase):\n+    # Arbitrary symbol that we can use to check that the module debug info was\n+    # loaded.\n+    SYMBOL = \"loop_register_transfer\"\n+\n+    def setUp(self):\n+        super().setUp()\n         with open(\"/proc/modules\", \"r\") as f:\n             for line in f:\n                 if line.startswith(\"loop \"):\n@@ -16,34 +21,30 @@ class TestDebugInfo(LinuxHelperTestCase):\n             else:\n                 self.skipTest(\"loop module is built in or not loaded\")\n \n-        # An arbitrary symbol that we can use to check that the module debug\n-        # info was loaded.\n         with open(\"/proc/kallsyms\", \"r\") as f:\n             for line in f:\n                 tokens = line.split()\n-                if tokens[2] == \"loop_register_transfer\":\n-                    address = int(tokens[0], 16)\n+                if tokens[2] == self.SYMBOL:\n+                    self.symbol_address = int(tokens[0], 16)\n                     break\n             else:\n-                self.skipTest(\"loop_register_transfer symbol not found\")\n-\n-        # Test with and without using /proc and /sys.\n-        key = \"DRGN_USE_PROC_AND_SYS_MODULES\"\n-        old_value = os.environ.get(key)\n-        if old_value is None or int(old_value):\n-            new_value = \"0\"\n-        else:\n-            new_value = \"1\"\n-        try:\n-            os.environ[key] = new_value\n-            other_prog = drgn.Program()\n-            other_prog.set_kernel()\n-            other_prog.load_default_debug_info()\n-\n-            for prog in (self.prog, other_prog):\n-                self.assertEqual(prog.symbol(\"loop_register_transfer\").address, address)\n-        finally:\n-            if old_value is None:\n-                del os.environ[key]\n+                self.fail(f\"{self.SYMBOL!r} symbol not found\")\n+\n+    def _test_module_debug_info(self, use_proc_and_sys):\n+        old_use_proc_and_sys = (\n+            int(os.environ.get(\"DRGN_USE_PROC_AND_SYS_MODULES\", \"1\")) != 0\n+        )\n+        with setenv(\"DRGN_USE_PROC_AND_SYS_MODULES\", \"1\" if use_proc_and_sys else \"0\"):\n+            if old_use_proc_and_sys == use_proc_and_sys:\n+                prog = self.prog\n             else:\n-                os.environ[key] = old_value\n+                prog = Program()\n+                prog.set_kernel()\n+                prog.load_default_debug_info()\n+            self.assertEqual(prog.symbol(self.SYMBOL).address, self.symbol_address)\n+\n+    def test_module_debug_info_use_proc_and_sys(self):\n+        self._test_module_debug_info(True)\n+\n+    def test_module_debug_info_use_core_dump(self):\n+        self._test_module_debug_info(False)\n"}
{"repo": "drgn", "commit": "b5ed8924810990a0e7e444b2de09ff5714fe7fdd", "diff": "diff --git a/scripts/iwyu.py b/scripts/iwyu.py\nindex 262204ec..3a5ef688 100755\n--- a/scripts/iwyu.py\n+++ b/scripts/iwyu.py\n@@ -140,12 +140,14 @@ def main():\n     if args.source:\n         sources = {os.path.realpath(source) for source in args.source}\n \n+    os.makedirs(BUILD_BASE, exist_ok=True)\n     subprocess.check_call(\n         [\n             \"bear\",\n-            \"--cdb\",\n+            \"--output\",\n             CDB,\n-            \"-a\",\n+            \"--append\",\n+            \"--\",\n             sys.executable,\n             \"setup.py\",\n             \"build\",\n"}
{"repo": "drgn", "commit": "c22e501295980f95e6027bd1aae80d62e5f06055", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 17e9c73c..3377924e 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -879,6 +879,71 @@ class TestTypes(TestCase):\n             prog.type(\"TEST\").type, prog.pointer_type(prog.struct_type(\"point\"))\n         )\n \n+    def test_incomplete_to_complete_specification(self):\n+        prog = dwarf_program(\n+            test_type_dies(\n+                (\n+                    DwarfDie(\n+                        DW_TAG.pointer_type,\n+                        (\n+                            DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 8),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),\n+                        ),\n+                    ),\n+                    DwarfDie(\n+                        DW_TAG.structure_type,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"point\"),\n+                            DwarfAttrib(DW_AT.declaration, DW_FORM.flag_present, True),\n+                        ),\n+                    ),\n+                    DwarfDie(\n+                        DW_TAG.structure_type,\n+                        (\n+                            DwarfAttrib(DW_AT.specification, DW_FORM.ref4, 1),\n+                            DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 8),\n+                        ),\n+                        (\n+                            DwarfDie(\n+                                DW_TAG.member,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                                    DwarfAttrib(\n+                                        DW_AT.data_member_location, DW_FORM.data1, 0\n+                                    ),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 3),\n+                                ),\n+                            ),\n+                            DwarfDie(\n+                                DW_TAG.member,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"y\"),\n+                                    DwarfAttrib(\n+                                        DW_AT.data_member_location, DW_FORM.data1, 4\n+                                    ),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 3),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                    int_die,\n+                )\n+            )\n+        )\n+        self.assertIdentical(\n+            prog.type(\"TEST\").type,\n+            prog.pointer_type(\n+                prog.struct_type(\n+                    \"point\",\n+                    8,\n+                    (\n+                        TypeMember(prog.int_type(\"int\", 4, True), \"x\"),\n+                        TypeMember(prog.int_type(\"int\", 4, True), \"y\", 32),\n+                    ),\n+                )\n+            ),\n+        )\n+\n     def test_filename(self):\n         dies = list(base_type_dies) + [\n             DwarfDie(\n"}
{"repo": "drgn", "commit": "0e1f85516a47464048a497fb80e8ffa8042935fd", "diff": "diff --git a/vmtest/manage.py b/vmtest/manage.py\nindex f6988c3a..16fb2a4b 100644\n--- a/vmtest/manage.py\n+++ b/vmtest/manage.py\n@@ -315,7 +315,7 @@ async def try_build_kernel(commit: str) -> Optional[Tuple[str, Path]]:\n             try:\n                 return await build_kernel(commit, build_dir, log_file)\n             except Exception:\n-                logger.exception(\"building %s failed; see %r\", commit, repr(log_path))\n+                logger.exception(\"building %s failed; see %r\", commit, str(log_path))\n                 return None\n     except Exception:\n         logger.exception(\"preparing %r failed\", str(build_dir))\n"}
{"repo": "drgn", "commit": "9e3b3a36cff13a8066685696e81d5b2ab776f10e", "diff": "diff --git a/setup.py b/setup.py\nindex 3508ff76..75c833e4 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -301,7 +301,9 @@ def get_version():\n         else:\n             # The saved version must start with the public version.\n             match = re.search(\n-                fr'^__version__ = \"{re.escape(public_version)}([^\"]*)\"$', version_py, re.M\n+                fr'^__version__ = \"{re.escape(public_version)}([^\"]*)\"$',\n+                version_py,\n+                re.M,\n             )\n             if match:\n                 local_version = match.group(1)\n"}
{"repo": "drgn", "commit": "2977bee278098c5d8e52db814921a9f80c20cbe7", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 224fb368..d15fc127 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -85,7 +85,7 @@ from _drgn import (\n     reinterpret,\n     sizeof,\n )\n-from drgn.internal.version import version as __version__\n+from drgn.internal.version import __version__ as __version__\n \n __all__ = (\n     \"Architecture\",\ndiff --git a/setup.py b/setup.py\nindex f071f30e..3508ff76 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -301,7 +301,7 @@ def get_version():\n         else:\n             # The saved version must start with the public version.\n             match = re.search(\n-                fr'^version = \"{re.escape(public_version)}([^\"]*)\"$', version_py, re.M\n+                fr'^__version__ = \"{re.escape(public_version)}([^\"]*)\"$', version_py, re.M\n             )\n             if match:\n                 local_version = match.group(1)\n@@ -310,7 +310,7 @@ def get_version():\n \n     version = public_version + local_version\n     # Update version.py if necessary.\n-    new_version_py = f'version = \"{version}\"\\n'\n+    new_version_py = f'__version__ = \"{version}\"\\n'\n     if new_version_py != version_py:\n         with open(\"drgn/internal/version.py\", \"w\") as f:\n             f.write(new_version_py)\n"}
{"repo": "drgn", "commit": "0a396d60f377e6fb396f4abbe07a1d5b7f81522a", "diff": "diff --git a/drgn/helpers/linux/block.py b/drgn/helpers/linux/block.py\nindex b6ecce59..0d2c5c49 100644\n--- a/drgn/helpers/linux/block.py\n+++ b/drgn/helpers/linux/block.py\n@@ -6,8 +6,10 @@ Block Layer\n -----------\n \n The ``drgn.helpers.linux.block`` module provides helpers for working with the\n-Linux block layer, including disks (``struct gendisk``) and partitions\n-(``struct hd_struct``).\n+Linux block layer, including disks (``struct gendisk``) and partitions.\n+\n+Since Linux v5.11, partitions are represented by ``struct block_device``.\n+Before that, they were represented by ``struct hd_struct``.\n \"\"\"\n \n from typing import Iterator\n@@ -73,10 +75,25 @@ def for_each_disk(prog: Program) -> Iterator[Object]:\n \n     :return: Iterator of ``struct gendisk *`` objects.\n     \"\"\"\n-    disk_type = prog[\"disk_type\"].address_of_()\n+    # Before Linux kernel commit 0d02129e76ed (\"block: merge struct\n+    # block_device and struct hd_struct\") (in v5.11), partition devices are in\n+    # struct hd_struct::__dev. After that commit, they are in struct\n+    # block_device::bd_device. We start by assuming that the kernel has this\n+    # commit and fall back to the old path if that fails.\n+    have_bd_device = True\n     for device in _for_each_block_device(prog):\n-        if device.type == disk_type:\n-            yield container_of(device, \"struct gendisk\", \"part0.__dev\")\n+        if have_bd_device:\n+            try:\n+                bdev = container_of(device, \"struct block_device\", \"bd_device\")\n+            except LookupError:\n+                have_bd_device = False\n+            else:\n+                if bdev.bd_partno == 0:\n+                    yield bdev.bd_disk\n+                continue\n+        part = container_of(device, \"struct hd_struct\", \"__dev\")\n+        if part.partno == 0:\n+            yield container_of(part, \"struct gendisk\", \"part0\")\n \n \n def print_disks(prog: Program) -> None:\n@@ -92,28 +109,46 @@ def part_devt(part: Object) -> Object:\n     \"\"\"\n     Get a partition's device number.\n \n-    :param part: ``struct hd_struct *``\n+    :param part: ``struct block_device *`` or ``struct hd_struct *`` depending\n+        on the kernel version.\n     :return: ``dev_t``\n     \"\"\"\n-    return part.__dev.devt\n+    try:\n+        return part.bd_dev\n+    except AttributeError:\n+        return part.__dev.devt\n \n \n def part_name(part: Object) -> bytes:\n     \"\"\"\n     Get the name of a partition (e.g., ``sda1``).\n \n-    :param part: ``struct hd_struct *``\n+    :param part: ``struct block_device *`` or ``struct hd_struct *`` depending\n+        on the kernel version.\n     \"\"\"\n-    return part.__dev.kobj.name.string_()\n+    try:\n+        bd_device = part.bd_device\n+    except AttributeError:\n+        return part.__dev.kobj.name.string_()\n+    return bd_device.kobj.name.string_()\n \n \n def for_each_partition(prog: Program) -> Iterator[Object]:\n     \"\"\"\n     Iterate over all partitions in the system.\n \n-    :return: Iterator of ``struct hd_struct *`` objects.\n+    :return: Iterator of ``struct block_device *`` or ``struct hd_struct *``\n+        objects depending on the kernel version.\n     \"\"\"\n+    # See the comment in for_each_disk().\n+    have_bd_device = True\n     for device in _for_each_block_device(prog):\n+        if have_bd_device:\n+            try:\n+                yield container_of(device, \"struct block_device\", \"bd_device\")\n+                continue\n+            except LookupError:\n+                have_bd_device = False\n         yield container_of(device, \"struct hd_struct\", \"__dev\")\n \n \n"}
{"repo": "drgn", "commit": "bbefc573d8ea7250328a8ba59073b34dee0fa39d", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex ea589f78..200f3b46 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -1442,6 +1442,35 @@ class TestTypes(TestCase):\n             ),\n         )\n \n+    def test_template_value_parameter_missing_value(self):\n+        with self.assertRaisesRegex(\n+            Exception, \"DW_AT_template_value_parameter is missing value\"\n+        ):\n+            dwarf_program(\n+                test_type_dies(\n+                    (\n+                        DwarfDie(\n+                            DW_TAG.class_type,\n+                            (\n+                                DwarfAttrib(\n+                                    DW_AT.declaration, DW_FORM.flag_present, True\n+                                ),\n+                            ),\n+                            (\n+                                DwarfDie(\n+                                    DW_TAG.template_value_parameter,\n+                                    (\n+                                        DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),\n+                                        DwarfAttrib(DW_AT.name, DW_FORM.string, \"N\"),\n+                                    ),\n+                                ),\n+                            ),\n+                        ),\n+                        unsigned_int_die,\n+                    )\n+                )\n+            ).type(\"TEST\").type.template_parameters[0].argument\n+\n     def test_lazy_cycle(self):\n         prog = dwarf_program(\n             test_type_dies(\n"}
{"repo": "drgn", "commit": "81a203c48f0e9763f0b7701dc3c067bc0e4afe4f", "diff": "diff --git a/drgn/helpers/linux/cpumask.py b/drgn/helpers/linux/cpumask.py\nindex 2547452b..dac26d2c 100644\n--- a/drgn/helpers/linux/cpumask.py\n+++ b/drgn/helpers/linux/cpumask.py\n@@ -36,16 +36,28 @@ def for_each_cpu(mask: Object) -> Iterator[int]:\n                 yield (word_bits * i) + j\n \n \n-def for_each_possible_cpu(prog: Program) -> Iterator[int]:\n-    \"\"\"Iterate over all possible CPUs.\"\"\"\n-    return for_each_cpu(prog[\"__cpu_possible_mask\"])\n+def _for_each_cpu_mask(prog: Program, name: str) -> Iterator[int]:\n+    try:\n+        mask = prog[name]\n+    except KeyError:\n+        # Before Linux kernel commit c4c54dd1caf1 (\"kernel/cpu.c: change type\n+        # of cpu_possible_bits and friends\") (in v4.5), the CPU masks are\n+        # struct cpumask *cpu_foo_mask instead of\n+        # struct cpumask __cpu_foo_mask.\n+        mask = prog[name[2:]][0]\n+    return for_each_cpu(mask)\n \n \n def for_each_online_cpu(prog: Program) -> Iterator[int]:\n     \"\"\"Iterate over all online CPUs.\"\"\"\n-    return for_each_cpu(prog[\"__cpu_online_mask\"])\n+    return _for_each_cpu_mask(prog, \"__cpu_online_mask\")\n+\n+\n+def for_each_possible_cpu(prog: Program) -> Iterator[int]:\n+    \"\"\"Iterate over all possible CPUs.\"\"\"\n+    return _for_each_cpu_mask(prog, \"__cpu_possible_mask\")\n \n \n def for_each_present_cpu(prog: Program) -> Iterator[int]:\n     \"\"\"Iterate over all present CPUs.\"\"\"\n-    return for_each_cpu(prog[\"__cpu_present_mask\"])\n+    return _for_each_cpu_mask(prog, \"__cpu_present_mask\")\ndiff --git a/tests/helpers/linux/test_cpumask.py b/tests/helpers/linux/test_cpumask.py\nnew file mode 100644\nindex 00000000..b9d49d19\n--- /dev/null\n+++ b/tests/helpers/linux/test_cpumask.py\n@@ -0,0 +1,41 @@\n+# Copyright (c) Facebook, Inc. and its affiliates.\n+# SPDX-License-Identifier: GPL-3.0+\n+\n+from pathlib import Path\n+\n+from drgn.helpers.linux.cpumask import (\n+    for_each_online_cpu,\n+    for_each_possible_cpu,\n+    for_each_present_cpu,\n+)\n+from tests.helpers.linux import LinuxHelperTestCase\n+\n+CPU_PATH = Path(\"/sys/devices/system/cpu\")\n+\n+\n+def parse_cpulist(cpulist):\n+    cpus = set()\n+    for cpu_range in cpulist.split(\",\"):\n+        first, sep, last = cpu_range.partition(\"-\")\n+        if sep:\n+            cpus.update(range(int(first), int(last) + 1))\n+        else:\n+            cpus.add(int(first))\n+    return cpus\n+\n+\n+class TestCpuMask(LinuxHelperTestCase):\n+    def _test_for_each_cpu(self, func, name):\n+        self.assertEqual(\n+            list(func(self.prog)),\n+            sorted(parse_cpulist((CPU_PATH / name).read_text())),\n+        )\n+\n+    def test_for_each_online_cpu(self):\n+        self._test_for_each_cpu(for_each_online_cpu, \"online\")\n+\n+    def test_for_each_possible_cpu(self):\n+        self._test_for_each_cpu(for_each_possible_cpu, \"possible\")\n+\n+    def test_for_each_present_cpu(self):\n+        self._test_for_each_cpu(for_each_present_cpu, \"present\")\n"}
{"repo": "drgn", "commit": "a57c26ed3230eebc90f3b3bc6755db49af049fd5", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 3c394a96..b10c8755 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -2592,6 +2592,57 @@ class TestTypes(TestCase):\n             ),\n         )\n \n+    def test_qualified_zero_length_array_only_member_old_gcc(self):\n+        # GCC < 9.0.\n+        # struct {\n+        #   const int a[0];\n+        # };\n+        prog = dwarf_program(\n+            test_type_dies(\n+                (\n+                    DwarfDie(\n+                        DW_TAG.structure_type,\n+                        (DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 4),),\n+                        (\n+                            DwarfDie(\n+                                DW_TAG.member,\n+                                (\n+                                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"a\"),\n+                                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                    DwarfDie(\n+                        DW_TAG.const_type, (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 2),)\n+                    ),\n+                    DwarfDie(\n+                        DW_TAG.array_type,\n+                        (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 3),),\n+                        (DwarfDie(DW_TAG.subrange_type, ()),),\n+                    ),\n+                    int_die,\n+                )\n+            )\n+        )\n+        self.assertIdentical(\n+            prog.type(\"TEST\").type,\n+            prog.struct_type(\n+                None,\n+                4,\n+                (\n+                    TypeMember(\n+                        prog.array_type(\n+                            prog.int_type(\"int\", 4, True),\n+                            0,\n+                            qualifiers=Qualifiers.CONST,\n+                        ),\n+                        \"a\",\n+                    ),\n+                ),\n+            ),\n+        )\n+\n     def test_typedef_zero_length_array_only_member(self):\n         prog = dwarf_program(\n             test_type_dies(\n"}
{"repo": "drgn", "commit": "cf9a068820857990286a3990d8973007909f9021", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 5588fc85..c0d04dfa 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -3715,3 +3715,44 @@ class TestProgram(TestCase):\n         )\n         self.assertFalse(dwarf_program(dies)[\"x\"].prog_.flags & ProgramFlags.IS_LIVE)\n         self.assertEqual(dwarf_program(dies)[\"x\"].type_.name, \"int\")\n+\n+    def test_reference_counting_type_member(self):\n+        dies = (\n+            DwarfDie(\n+                DW_TAG.structure_type,\n+                (\n+                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"foo\"),\n+                    DwarfAttrib(DW_AT.byte_size, DW_FORM.data1, 4),\n+                ),\n+                (\n+                    DwarfDie(\n+                        DW_TAG.member,\n+                        (\n+                            DwarfAttrib(DW_AT.name, DW_FORM.string, \"bar\"),\n+                            DwarfAttrib(DW_AT.data_member_location, DW_FORM.data1, 0),\n+                            DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),\n+                        ),\n+                    ),\n+                ),\n+            ),\n+            int_die,\n+        )\n+        self.assertIsNotNone(repr(dwarf_program(dies).type(\"struct foo\").members[0]))\n+\n+    def test_reference_counting_type_parameter(self):\n+        dies = test_type_dies(\n+            (\n+                DwarfDie(\n+                    DW_TAG.subroutine_type,\n+                    (),\n+                    (\n+                        DwarfDie(\n+                            DW_TAG.formal_parameter,\n+                            (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),),\n+                        ),\n+                    ),\n+                ),\n+                int_die,\n+            )\n+        )\n+        self.assertIsNotNone(repr(dwarf_program(dies).type(\"TEST\").type.parameters[0]))\n"}
{"repo": "drgn", "commit": "d7c70949921ec037ea0cc843b20a120e44df3864", "diff": "diff --git a/docs/exts/drgndoc/format.py b/docs/exts/drgndoc/format.py\nindex fec1be9c..4972322f 100644\n--- a/docs/exts/drgndoc/format.py\n+++ b/docs/exts/drgndoc/format.py\n@@ -175,16 +175,15 @@ class _FormatVisitor(NodeVisitor):\n             self._parts.append(\"\\\\\")\n         self._parts.append(\"]\")\n \n-    def visit_Index(\n-        self, node: ast.Index, parent: Optional[ast.AST], sibling: Optional[ast.AST]\n-    ) -> None:\n-        self._visit(node.value, node, None)\n-\n     def visit_Tuple(\n         self, node: ast.Tuple, parent: Optional[ast.AST], sibling: Optional[ast.AST]\n     ) -> None:\n         self._check_ctx_is_load(node)\n-        parens = not isinstance(parent, ast.Index)\n+        parens = (\n+            len(node.elts) == 0\n+            or not isinstance(parent, ast.Subscript)\n+            or node is not parent.slice\n+        )\n         if parens:\n             self._parts.append(\"(\")\n         for i, elt in enumerate(node.elts):\ndiff --git a/docs/exts/drgndoc/parse.py b/docs/exts/drgndoc/parse.py\nindex 0dcb766d..ec0b9c5b 100644\n--- a/docs/exts/drgndoc/parse.py\n+++ b/docs/exts/drgndoc/parse.py\n@@ -7,6 +7,7 @@ import operator\n import os.path\n import stat\n from typing import (\n+    Any,\n     Callable,\n     Dict,\n     Iterable,\n@@ -78,6 +79,10 @@ class _PreTransformer(ast.NodeTransformer):\n     def visit_NameConstant(self, node: ast.NameConstant) -> ast.Constant:\n         return ast.copy_location(ast.Constant(node.value), node)\n \n+    # Get rid of Index nodes, which are deprecated as of Python 3.9.\n+    def visit_Index(self, node: Any) -> Any:\n+        return self.visit(node.value)\n+\n \n # Once we don't care about Python 3.6, we can replace all of this boilerplate\n # with dataclasses.\n"}
{"repo": "drgn", "commit": "e7caa24176c107d4d79e6bd0ec413a23aefa2237", "diff": "diff --git a/tests/helpers/linux/__init__.py b/tests/helpers/linux/__init__.py\nindex 73cff358..409fb657 100644\n--- a/tests/helpers/linux/__init__.py\n+++ b/tests/helpers/linux/__init__.py\n@@ -39,6 +39,14 @@ class LinuxHelperTestCase(unittest.TestCase):\n                     \"(run with env DRGN_RUN_LINUX_HELPER_TESTS=1 to force\"\n                 )\n             else:\n+                # Some of the tests use the loop module. Open loop-control so\n+                # that it is loaded.\n+                try:\n+                    with open(\"/dev/loop-control\", \"r\"):\n+                        pass\n+                except FileNotFoundError:\n+                    pass\n+\n                 prog = drgn.Program()\n                 prog.set_kernel()\n                 try:\ndiff --git a/tests/helpers/linux/test_debug_info.py b/tests/helpers/linux/test_debug_info.py\nnew file mode 100644\nindex 00000000..96648eb0\n--- /dev/null\n+++ b/tests/helpers/linux/test_debug_info.py\n@@ -0,0 +1,49 @@\n+# Copyright (c) Facebook, Inc. and its affiliates.\n+# SPDX-License-Identifier: GPL-3.0+\n+\n+import os\n+\n+import drgn\n+from tests.helpers.linux import LinuxHelperTestCase\n+\n+\n+class TestDebugInfo(LinuxHelperTestCase):\n+    def test_module_debug_info(self):\n+        with open(\"/proc/modules\", \"r\") as f:\n+            for line in f:\n+                if line.startswith(\"loop \"):\n+                    break\n+            else:\n+                self.skipTest(\"loop module is built in or not loaded\")\n+\n+        # An arbitrary symbol that we can use to check that the module debug\n+        # info was loaded.\n+        with open(\"/proc/kallsyms\", \"r\") as f:\n+            for line in f:\n+                tokens = line.split()\n+                if tokens[2] == \"loop_register_transfer\":\n+                    address = int(tokens[0], 16)\n+                    break\n+            else:\n+                self.skipTest(\"loop_register_transfer symbol not found\")\n+\n+        # Test with and without using /proc and /sys.\n+        key = \"DRGN_USE_PROC_AND_SYS_MODULES\"\n+        old_value = os.environ.get(key)\n+        if old_value is None or int(old_value):\n+            new_value = \"0\"\n+        else:\n+            new_value = \"1\"\n+        try:\n+            os.environ[key] = new_value\n+            other_prog = drgn.Program()\n+            other_prog.set_kernel()\n+            other_prog.load_default_debug_info()\n+\n+            for prog in (self.prog, other_prog):\n+                self.assertEqual(prog.symbol(\"loop_register_transfer\").address, address)\n+        finally:\n+            if old_value is None:\n+                del os.environ[key]\n+            else:\n+                os.environ[key] = old_value\n"}
{"repo": "drgn", "commit": "4cbb9b552a161046bdb85b9814efc6c997484c32", "diff": "diff --git a/tests/test_type.py b/tests/test_type.py\nindex 735a395b..84a42f60 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -265,6 +265,20 @@ class TestType(MockProgramTestCase):\n         # One is incomplete.\n         self.assertNotEqual(t, self.prog.struct_type(\"point\"))\n \n+        # Anonymous members with different types.\n+        self.assertNotEqual(\n+            self.prog.struct_type(\n+                \"foo\",\n+                4,\n+                (TypeMember(self.prog.int_type(\"int\", 4, True), None, 0),),\n+            ),\n+            self.prog.struct_type(\n+                \"foo\",\n+                4,\n+                (TypeMember(self.prog.int_type(\"unsigned int\", 4, False), None, 0),),\n+            ),\n+        )\n+\n         self.assertEqual(\n             repr(t),\n             \"prog.struct_type(tag='point', size=8, members=(TypeMember(type=prog.int_type(name='int', size=4, is_signed=True), name='x', bit_offset=0), TypeMember(type=prog.int_type(name='int', size=4, is_signed=True), name='y', bit_offset=32)))\",\n"}
{"repo": "drgn", "commit": "36068a0ea842845e5455b418f40ffd0c91de49d7", "diff": "diff --git a/docs/exts/drgndoc/format.py b/docs/exts/drgndoc/format.py\nindex 489c5702..fec1be9c 100644\n--- a/docs/exts/drgndoc/format.py\n+++ b/docs/exts/drgndoc/format.py\n@@ -190,9 +190,7 @@ class _FormatVisitor(NodeVisitor):\n         for i, elt in enumerate(node.elts):\n             if i > 0:\n                 self._parts.append(\", \")\n-            self._visit(\n-                elt, node, node.elts[i + 1] if i < len(node.elts) - 1 else None,\n-            )\n+            self._visit(elt, node, node.elts[i + 1] if i < len(node.elts) - 1 else None)\n         if len(node.elts) == 1:\n             self._parts.append(\",\")\n         if parens:\n@@ -208,9 +206,7 @@ class _FormatVisitor(NodeVisitor):\n         for i, elt in enumerate(node.elts):\n             if i > 0:\n                 self._parts.append(\", \")\n-            self._visit(\n-                elt, node, node.elts[i + 1] if i < len(node.elts) - 1 else None,\n-            )\n+            self._visit(elt, node, node.elts[i + 1] if i < len(node.elts) - 1 else None)\n         if self._rst:\n             self._parts.append(\"\\\\\")\n         self._parts.append(\"]\")\ndiff --git a/drgn/helpers/linux/fs.py b/drgn/helpers/linux/fs.py\nindex 4ca2b2ec..27a92211 100644\n--- a/drgn/helpers/linux/fs.py\n+++ b/drgn/helpers/linux/fs.py\n@@ -126,7 +126,7 @@ def path_lookup(\n     return Object(\n         mnt.prog_,\n         \"struct path\",\n-        value={\"mnt\": mnt.mnt.address_of_(), \"dentry\": dentry,},\n+        value={\"mnt\": mnt.mnt.address_of_(), \"dentry\": dentry},\n     )\n \n \ndiff --git a/setup.py b/setup.py\nindex f23283ca..1826fa80 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -304,7 +304,7 @@ setup(\n         \"egg_info\": egg_info,\n         \"test\": test,\n     },\n-    entry_points={\"console_scripts\": [\"drgn=drgn.internal.cli:main\"],},\n+    entry_points={\"console_scripts\": [\"drgn=drgn.internal.cli:main\"]},\n     python_requires=\">=3.6\",\n     author=\"Omar Sandoval\",\n     author_email=\"osandov@osandov.com\",\ndiff --git a/tests/__init__.py b/tests/__init__.py\nindex 4e95c412..b9b1aaee 100644\n--- a/tests/__init__.py\n+++ b/tests/__init__.py\n@@ -226,9 +226,9 @@ class MockProgramTestCase(TestCase):\n     def add_memory_segment(self, buf, virt_addr=None, phys_addr=None):\n         if virt_addr is not None:\n             self.prog.add_memory_segment(\n-                virt_addr, len(buf), functools.partial(mock_memory_read, buf),\n+                virt_addr, len(buf), functools.partial(mock_memory_read, buf)\n             )\n         if phys_addr is not None:\n             self.prog.add_memory_segment(\n-                phys_addr, len(buf), functools.partial(mock_memory_read, buf), True,\n+                phys_addr, len(buf), functools.partial(mock_memory_read, buf), True\n             )\ndiff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex 8600f69d..b9dfcc3e 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -210,7 +210,7 @@ def compile_dwarf(dies, little_endian=True, bits=64, *, lang=None):\n     return create_elf_file(\n         ET.EXEC,\n         [\n-            ElfSection(p_type=PT.LOAD, vaddr=0xFFFF0000, data=b\"\",),\n+            ElfSection(p_type=PT.LOAD, vaddr=0xFFFF0000, data=b\"\"),\n             ElfSection(\n                 name=\".debug_abbrev\",\n                 sh_type=SHT.PROGBITS,\n@@ -226,7 +226,7 @@ def compile_dwarf(dies, little_endian=True, bits=64, *, lang=None):\n                 sh_type=SHT.PROGBITS,\n                 data=_compile_debug_line(cu_die, little_endian),\n             ),\n-            ElfSection(name=\".debug_str\", sh_type=SHT.PROGBITS, data=b\"\\0\",),\n+            ElfSection(name=\".debug_str\", sh_type=SHT.PROGBITS, data=b\"\\0\"),\n         ],\n         little_endian=little_endian,\n         bits=bits,\ndiff --git a/tests/elfwriter.py b/tests/elfwriter.py\nindex b96246eb..52a0caaa 100644\n--- a/tests/elfwriter.py\n+++ b/tests/elfwriter.py\n@@ -52,7 +52,7 @@ def create_elf_file(\n         phdr_struct = struct.Struct(endian + \"8I\")\n         e_machine = 3 if little_endian else 8  # EM_386 or EM_MIPS\n \n-    shstrtab = ElfSection(name=\".shstrtab\", sh_type=SHT.STRTAB, data=bytearray(1),)\n+    shstrtab = ElfSection(name=\".shstrtab\", sh_type=SHT.STRTAB, data=bytearray(1))\n     tmp = [shstrtab]\n     tmp.extend(sections)\n     sections = tmp\ndiff --git a/tests/helpers/linux/test_uts.py b/tests/helpers/linux/test_uts.py\nindex 6755b686..0f4db8f9 100644\n--- a/tests/helpers/linux/test_uts.py\n+++ b/tests/helpers/linux/test_uts.py\n@@ -10,12 +10,10 @@ from tests.helpers.linux import LinuxHelperTestCase\n class TestUts(LinuxHelperTestCase):\n     def test_uts_release(self):\n         self.assertEqual(\n-            self.prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release,\n+            self.prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release\n         )\n \n     def test_uts_release_no_debug_info(self):\n         prog = drgn.Program()\n         prog.set_kernel()\n-        self.assertEqual(\n-            prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release,\n-        )\n+        self.assertEqual(prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release)\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex e355e453..1771ff70 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -1958,7 +1958,7 @@ class TestTypes(TestCase):\n             test_type_dies(\n                 (\n                     DwarfDie(\n-                        DW_TAG.typedef, (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),),\n+                        DW_TAG.typedef, (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),)\n                     ),\n                     int_die,\n                 )\n@@ -1975,7 +1975,7 @@ class TestTypes(TestCase):\n         prog = dwarf_program(\n             test_type_dies(\n                 DwarfDie(\n-                    DW_TAG.typedef, (DwarfAttrib(DW_AT.name, DW_FORM.string, \"VOID\"),),\n+                    DW_TAG.typedef, (DwarfAttrib(DW_AT.name, DW_FORM.string, \"VOID\"),)\n                 )\n             )\n         )\n@@ -2196,7 +2196,7 @@ class TestTypes(TestCase):\n             test_type_dies(\n                 (\n                     DwarfDie(\n-                        DW_TAG.array_type, (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),),\n+                        DW_TAG.array_type, (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 1),)\n                     ),\n                     int_die,\n                 )\n@@ -2377,7 +2377,7 @@ class TestTypes(TestCase):\n                     DwarfDie(\n                         DW_TAG.array_type,\n                         (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 3),),\n-                        (DwarfDie(DW_TAG.subrange_type, (),),),\n+                        (DwarfDie(DW_TAG.subrange_type, ()),),\n                     ),\n                     int_die,\n                 )\n@@ -2574,7 +2574,7 @@ class TestTypes(TestCase):\n                     DwarfDie(\n                         DW_TAG.array_type,\n                         (DwarfAttrib(DW_AT.type, DW_FORM.ref4, 2),),\n-                        (DwarfDie(DW_TAG.subrange_type, (),),),\n+                        (DwarfDie(DW_TAG.subrange_type, ()),),\n                     ),\n                     int_die,\n                 )\n@@ -2965,7 +2965,7 @@ class TestTypes(TestCase):\n         # void foo(void)\n         prog = dwarf_program(test_type_dies(DwarfDie(DW_TAG.subroutine_type, ())))\n         self.assertEqual(\n-            prog.type(\"TEST\").type, prog.function_type(prog.void_type(), (), False),\n+            prog.type(\"TEST\").type, prog.function_type(prog.void_type(), (), False)\n         )\n \n     def test_function_unnamed_parameter(self):\n@@ -3369,15 +3369,13 @@ class TestObjects(TestCase):\n                             (\n                                 DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n                                 DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n-                                DwarfAttrib(DW_AT.const_value, form, 1,),\n+                                DwarfAttrib(DW_AT.const_value, form, 1),\n                             ),\n                         ),\n                     )\n                 )\n             )\n-            self.assertEqual(\n-                prog[\"x\"], Object(prog, prog.int_type(\"int\", 4, True), 1),\n-            )\n+            self.assertEqual(prog[\"x\"], Object(prog, prog.int_type(\"int\", 4, True), 1))\n \n     def test_variable_const_unsigned(self):\n         for form in (\n@@ -3403,7 +3401,7 @@ class TestObjects(TestCase):\n                 )\n             )\n             self.assertEqual(\n-                prog[\"x\"], Object(prog, prog.int_type(\"unsigned int\", 4, False), 1),\n+                prog[\"x\"], Object(prog, prog.int_type(\"unsigned int\", 4, False), 1)\n             )\n \n     def test_variable_const_block(self):\n@@ -3438,7 +3436,7 @@ class TestObjects(TestCase):\n         )\n         self.assertEqual(\n             prog[\"p\"],\n-            Object(prog, prog.array_type(prog.int_type(\"int\", 4, True), 2), [1, 2],),\n+            Object(prog, prog.array_type(prog.int_type(\"int\", 4, True), 2), [1, 2]),\n         )\n \n     def test_variable_const_block_too_small(self):\ndiff --git a/tests/test_language_c.py b/tests/test_language_c.py\nindex 0606fbb1..fe409088 100644\n--- a/tests/test_language_c.py\n+++ b/tests/test_language_c.py\n@@ -206,7 +206,7 @@ class TestPrettyPrintTypeName(MockProgramTestCase):\n                     i,\n                     (\n                         TypeParameter(i),\n-                        TypeParameter(self.prog.float_type(\"float\", 4),),\n+                        TypeParameter(self.prog.float_type(\"float\", 4)),\n                     ),\n                     False,\n                 ),\ndiff --git a/tests/test_object.py b/tests/test_object.py\nindex c3fb7550..1180b81c 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -2251,7 +2251,7 @@ class TestGenericOperators(MockProgramTestCase):\n     def setUp(self):\n         super().setUp()\n         self.add_memory_segment(\n-            b\"\".join(i.to_bytes(4, \"little\") for i in range(4)), virt_addr=0xFFFF0000,\n+            b\"\".join(i.to_bytes(4, \"little\") for i in range(4)), virt_addr=0xFFFF0000\n         )\n \n     def test_len(self):\ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex 6ad9d81e..b97c86a3 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -81,7 +81,7 @@ class TestProgram(unittest.TestCase):\n         )\n         self.assertRaisesRegex(LookupError, \"^could not find 'foo'$\", prog.type, \"foo\")\n         self.assertRaisesRegex(\n-            LookupError, \"^could not find 'foo' in 'foo.c'$\", prog.type, \"foo\", \"foo.c\",\n+            LookupError, \"^could not find 'foo' in 'foo.c'$\", prog.type, \"foo\", \"foo.c\"\n         )\n         self.assertRaisesRegex(\n             LookupError, \"^could not find variable 'foo'$\", prog.variable, \"foo\"\n@@ -138,7 +138,7 @@ class TestMemory(TestCase):\n                         self.assertEqual(prog.read_word(0xA0, True), value)\n \n         prog = mock_program(\n-            MOCK_32BIT_PLATFORM, segments=[MockMemorySegment(data, 0xFFFF0000, 0xA0)],\n+            MOCK_32BIT_PLATFORM, segments=[MockMemorySegment(data, 0xFFFF0000, 0xA0)]\n         )\n \n     def test_bad_address(self):\n@@ -521,9 +521,7 @@ class TestTypes(MockProgramTestCase):\n                 self.prog.pointer_type(self.prog.int_type(\"int\", 4, True))\n             ),\n         )\n-        self.assertEqual(\n-            self.prog.type(\"int *((*))\"), self.prog.type(\"int **\"),\n-        )\n+        self.assertEqual(self.prog.type(\"int *((*))\"), self.prog.type(\"int **\"))\n \n     def test_pointer_to_const_pointer(self):\n         self.assertEqual(\n@@ -626,9 +624,7 @@ class TestTypes(MockProgramTestCase):\n                 )\n             ),\n         )\n-        self.assertEqual(\n-            self.prog.type(\"int *((*)[2])\"), self.prog.type(\"int *(*)[2]\"),\n-        )\n+        self.assertEqual(self.prog.type(\"int *((*)[2])\"), self.prog.type(\"int *(*)[2]\"))\n \n     def test_array_of_pointers_to_array(self):\n         self.assertEqual(\n@@ -738,7 +734,7 @@ class TestCoreDump(TestCase):\n         with tempfile.NamedTemporaryFile() as f:\n             f.write(\n                 create_elf_file(\n-                    ET.CORE, [ElfSection(p_type=PT.LOAD, vaddr=0xFFFF0000, data=data,),]\n+                    ET.CORE, [ElfSection(p_type=PT.LOAD, vaddr=0xFFFF0000, data=data)]\n                 )\n             )\n             f.flush()\n@@ -755,7 +751,7 @@ class TestCoreDump(TestCase):\n                     ET.CORE,\n                     [\n                         ElfSection(\n-                            p_type=PT.LOAD, vaddr=0xFFFF0000, paddr=0xA0, data=data,\n+                            p_type=PT.LOAD, vaddr=0xFFFF0000, paddr=0xA0, data=data\n                         ),\n                     ],\n                 )\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex 3510dfd4..735a395b 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -455,7 +455,7 @@ class TestType(MockProgramTestCase):\n                 4,\n                 (\n                     TypeMember(self.prog.int_type(\"int\", 4, True), \"x\"),\n-                    TypeMember(self.prog.int_type(\"unsigned int\", 4, False),),\n+                    TypeMember(self.prog.int_type(\"unsigned int\", 4, False)),\n                 ),\n             ),\n         )\n@@ -1130,7 +1130,7 @@ class TestType(MockProgramTestCase):\n             t,\n             self.prog.function_type(\n                 self.prog.void_type(),\n-                (TypeParameter(self.prog.int_type(\"int\", 4, True),),),\n+                (TypeParameter(self.prog.int_type(\"int\", 4, True)),),\n             ),\n         )\n         # Different number of parameters.\ndiff --git a/vmtest/manage.py b/vmtest/manage.py\nindex 0426279c..3b069af2 100644\n--- a/vmtest/manage.py\n+++ b/vmtest/manage.py\n@@ -296,7 +296,7 @@ class Uploader:\n                     params = {}\n             else:\n                 params = {\n-                    \"cursor\": {\"offset\": offset, \"session_id\": session_id,},\n+                    \"cursor\": {\"offset\": offset, \"session_id\": session_id},\n                 }\n                 if last:\n                     endpoint = \"upload_session/finish\"\ndiff --git a/vmtest/resolver.py b/vmtest/resolver.py\nindex 2bbbaefe..23965d9a 100644\n--- a/vmtest/resolver.py\n+++ b/vmtest/resolver.py\n@@ -53,10 +53,10 @@ class KernelResolver:\n \n     def _resolve_build(self, path: str) -> ResolvedKernel:\n         release = subprocess.check_output(\n-            [\"make\", \"-s\", \"kernelrelease\"], universal_newlines=True, cwd=path,\n+            [\"make\", \"-s\", \"kernelrelease\"], universal_newlines=True, cwd=path\n         ).strip()\n         vmlinuz = subprocess.check_output(\n-            [\"make\", \"-s\", \"image_name\"], universal_newlines=True, cwd=path,\n+            [\"make\", \"-s\", \"image_name\"], universal_newlines=True, cwd=path\n         ).strip()\n         return ResolvedKernel(\n             release=release,\n"}
{"repo": "drgn", "commit": "8c7c80e2f7b400789f7b4fa3c00f0f35272d2286", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 8b50da89..975c1f16 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -71,7 +71,7 @@ from _drgn import (\n     TypeKind,\n     TypeMember,\n     TypeParameter,\n-    _with_libkdumpfile,\n+    _with_libkdumpfile as _with_libkdumpfile,\n     array_type,\n     bool_type,\n     cast,\n@@ -149,11 +149,12 @@ __all__ = (\n )\n \n \n-try:\n+if sys.version_info >= (3, 8):\n     _open_code = io.open_code\n-except AttributeError:\n+else:\n+    from typing import BinaryIO\n \n-    def _open_code(path):\n+    def _open_code(path: str) -> BinaryIO:\n         return open(path, \"rb\")\n \n \ndiff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex de6dd93c..2ac79a07 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -155,7 +155,7 @@ def main() -> None:\n             if not isinstance(e, FileNotFoundError) and not args.quiet:\n                 print(\"could not read history:\", str(e), file=sys.stderr)\n \n-        def write_history_file():\n+        def write_history_file() -> None:\n             try:\n                 readline.write_history_file(histfile)\n             except OSError as e:\n"}
{"repo": "drgn", "commit": "4a3b8fb8e6ad8878ad7f6e70c613ff824e3caaf9", "diff": "diff --git a/docs/exts/drgndoc/docstrings.py b/docs/exts/drgndoc/docstrings.py\nindex a5a6d727..21076d29 100644\n--- a/docs/exts/drgndoc/docstrings.py\n+++ b/docs/exts/drgndoc/docstrings.py\n@@ -42,7 +42,7 @@ for c in range(256):\n     escapes.append(e)\n \n \n-def escape_string(s):\n+def escape_string(s: str) -> str:\n     return \"\".join([escapes[c] for c in s.encode(\"utf-8\")])\n \n \ndiff --git a/docs/exts/drgndoc/ext.py b/docs/exts/drgndoc/ext.py\nindex 7851754b..6acf60f7 100644\n--- a/docs/exts/drgndoc/ext.py\n+++ b/docs/exts/drgndoc/ext.py\n@@ -51,7 +51,7 @@ import sphinx.environment\n import sphinx.util.docutils\n import sphinx.util.logging\n import sphinx.util.nodes\n-from typing import List, cast\n+from typing import Any, Dict, List, cast\n \n from drgndoc.format import Formatter\n from drgndoc.namespace import Namespace, ResolvedNode\n@@ -105,7 +105,7 @@ class DrgnDocDirective(sphinx.util.docutils.SphinxDirective):\n         \"exclude\": docutils.parsers.rst.directives.unchanged,\n     }\n \n-    def run(self) -> List[docutils.nodes.Node]:\n+    def run(self) -> Any:\n         parts = []\n         py_module = self.env.ref_context.get(\"py:module\")\n         if py_module:\n@@ -278,7 +278,7 @@ class DrgnDocDirective(sphinx.util.docutils.SphinxDirective):\n             del self.env.ref_context[\"py:module\"]\n \n \n-def setup(app: sphinx.application.Sphinx) -> dict:\n+def setup(app: sphinx.application.Sphinx) -> Dict[str, Any]:\n     app.connect(\"builder-inited\", drgndoc_init)\n     # List of modules or packages.\n     app.add_config_value(\"drgndoc_paths\", [], \"env\")\ndiff --git a/docs/exts/drgndoc/parse.py b/docs/exts/drgndoc/parse.py\nindex 4b272cfb..178057af 100644\n--- a/docs/exts/drgndoc/parse.py\n+++ b/docs/exts/drgndoc/parse.py\n@@ -24,28 +24,40 @@ from drgndoc.visitor import NodeVisitor\n \n class _PreTransformer(ast.NodeTransformer):\n     # Replace string forward references with the parsed expression.\n-    def _visit_annotation(self, node):\n+    @overload\n+    def _visit_annotation(self, node: ast.expr) -> ast.expr:\n+        ...\n+\n+    @overload\n+    def _visit_annotation(self, node: None) -> None:\n+        ...\n+\n+    def _visit_annotation(self, node: Optional[ast.expr]) -> Optional[ast.expr]:\n         if isinstance(node, ast.Constant) and isinstance(node.value, str):\n-            node = self.visit(ast.parse(node.value, \"<string>\", \"eval\"))\n+            node = self.visit(\n+                cast(ast.Expression, ast.parse(node.value, \"<string>\", \"eval\")).body\n+            )\n         return node\n \n-    def visit_arg(self, node):\n-        node = self.generic_visit(node)\n+    def visit_arg(self, node: ast.arg) -> ast.arg:\n+        node = cast(ast.arg, self.generic_visit(node))\n         node.annotation = self._visit_annotation(node.annotation)\n         return node\n \n-    def visit_FunctionDef(self, node):\n-        node = self.generic_visit(node)\n+    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:\n+        node = cast(ast.FunctionDef, self.generic_visit(node))\n         node.returns = self._visit_annotation(node.returns)\n         return node\n \n-    def visit_AsyncFunctionDef(self, node):\n-        node = self.generic_visit(node)\n+    def visit_AsyncFunctionDef(\n+        self, node: ast.AsyncFunctionDef\n+    ) -> ast.AsyncFunctionDef:\n+        node = cast(ast.AsyncFunctionDef, self.generic_visit(node))\n         node.returns = self._visit_annotation(node.returns)\n         return node\n \n-    def visit_AnnAssign(self, node):\n-        node = self.generic_visit(node)\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> ast.AnnAssign:\n+        node = cast(ast.AnnAssign, self.generic_visit(node))\n         node.annotation = self._visit_annotation(node.annotation)\n         return node\n \n"}
{"repo": "drgn", "commit": "7b08f7682e20d8789faf3a7feacc4afc6ccb5825", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex fb9bb53c..7bf30ba2 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -230,13 +230,13 @@ def execscript(path: str, *args: str) -> None:\n         sys.argv.extend(args)\n \n         with _open_code(path) as f:\n-            code = pkgutil.read_code(f)\n+            code = pkgutil.read_code(f)  # type: ignore[attr-defined]\n         if code is None:\n             with _open_code(path) as f:\n                 code = compile(f.read(), path, \"exec\")\n         module.__spec__ = None\n         module.__file__ = path\n-        module.__cached__ = None\n+        module.__cached__ = None  # type: ignore[attr-defined]\n \n         caller_globals = sys._getframe(1).f_globals\n         caller_special_globals = {\ndiff --git a/drgn/helpers/__init__.py b/drgn/helpers/__init__.py\nindex 518437bc..777238e6 100644\n--- a/drgn/helpers/__init__.py\n+++ b/drgn/helpers/__init__.py\n@@ -23,7 +23,7 @@ useful for scripts or for implementing other helpers.\n \n import enum\n import typing\n-from typing import Container, Iterable\n+from typing import Container, Iterable, List, Tuple\n \n from drgn import Type\n \n@@ -110,9 +110,11 @@ def enum_type_to_class(\n         exclude from the created ``IntEnum``.\n     :param prefix: Prefix to strip from the beginning of enumerator names.\n     \"\"\"\n+    if type.enumerators is None:\n+        raise TypeError(\"enum type is incomplete\")\n     enumerators = [\n         (name[len(prefix) :] if name.startswith(prefix) else name, value)\n         for (name, value) in type.enumerators\n         if name not in exclude\n     ]\n-    return enum.IntEnum(name, enumerators)\n+    return enum.IntEnum(name, enumerators)  # type: ignore  # python/mypy#4865\ndiff --git a/drgn/helpers/linux/__init__.py b/drgn/helpers/linux/__init__.py\nindex a0f61168..d8715ce9 100644\n--- a/drgn/helpers/linux/__init__.py\n+++ b/drgn/helpers/linux/__init__.py\n@@ -35,8 +35,12 @@ import pkgutil\n \n \n __all__ = []\n-for _module_info in pkgutil.iter_modules(__path__, prefix=__name__ + \".\"):\n+for _module_info in pkgutil.iter_modules(\n+    __path__,  # type: ignore[name-defined]  # python/mypy#1422\n+    prefix=__name__ + \".\",\n+):\n     _submodule = importlib.import_module(_module_info.name)\n-    __all__.extend(_submodule.__all__)\n-    for _name in _submodule.__all__:\n+    _submodule_all = getattr(_submodule, \"__all__\", ())\n+    __all__.extend(_submodule_all)\n+    for _name in _submodule_all:\n         globals()[_name] = getattr(_submodule, _name)\ndiff --git a/drgn/helpers/linux/kconfig.py b/drgn/helpers/linux/kconfig.py\nindex 14ddea78..40615229 100644\n--- a/drgn/helpers/linux/kconfig.py\n+++ b/drgn/helpers/linux/kconfig.py\n@@ -52,15 +52,15 @@ def get_kconfig(prog) -> Mapping[str, str]:\n         size = len(kernel_config_data) - 17\n \n     data = prog.read(start, size)\n-    result = {}\n+    kconfig = {}\n     for line in gzip.decompress(data).decode().splitlines():\n         if not line or line.startswith(\"#\"):\n             continue\n         name, _, value = line.partition(\"=\")\n         if value:\n-            result[name] = value\n+            kconfig[name] = value\n \n     # Make result mapping 'immutable', so changes cannot propagate to the cache\n-    result = types.MappingProxyType(result)\n+    result = types.MappingProxyType(kconfig)\n     prog.cache[\"kconfig_map\"] = result\n     return result\n"}
{"repo": "drgn", "commit": "7613dfb178fbf08ce6330e76867a5400903d5977", "diff": "diff --git a/drgn/helpers/__init__.py b/drgn/helpers/__init__.py\nindex 075a6729..518437bc 100644\n--- a/drgn/helpers/__init__.py\n+++ b/drgn/helpers/__init__.py\n@@ -22,6 +22,7 @@ useful for scripts or for implementing other helpers.\n \"\"\"\n \n import enum\n+import typing\n from typing import Container, Iterable\n \n from drgn import Type\n@@ -98,7 +99,7 @@ def escape_ascii_string(\n \n def enum_type_to_class(\n     type: Type, name: str, exclude: Container[str] = (), prefix: str = \"\"\n-) -> enum.IntEnum:\n+) -> typing.Type[enum.IntEnum]:\n     \"\"\"\n     Get an :class:`enum.IntEnum` class from an enumerated :class:`drgn.Type`.\n \n"}
{"repo": "drgn", "commit": "5ac95e491aa136f656d1d8cd03f3f5359a89cb2f", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex 44e3238d..d344e70c 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -44,15 +44,6 @@ def _vmemmap(prog):\n         return Object(prog, \"struct page *\", value=0xFFFFEA0000000000)\n \n \n-def _page_offset(prog):\n-    try:\n-        # KASAN\n-        return prog[\"page_offset_base\"].value_()\n-    except KeyError:\n-        # x86-64\n-        return 0xFFFF880000000000\n-\n-\n def for_each_page(prog):\n     \"\"\"\n     Iterate over all pages in the system.\n@@ -101,7 +92,7 @@ def virt_to_pfn(prog_or_addr, addr=None):\n         addr = prog_or_addr.value_()\n     else:\n         prog = prog_or_addr\n-    return Object(prog, \"unsigned long\", value=(addr - _page_offset(prog)) >> 12)\n+    return Object(prog, \"unsigned long\", value=(addr - prog[\"PAGE_OFFSET\"]) >> 12)\n \n \n def pfn_to_virt(prog_or_pfn, pfn=None):\n@@ -117,7 +108,7 @@ def pfn_to_virt(prog_or_pfn, pfn=None):\n         pfn = prog_or_pfn.value_()\n     else:\n         prog = prog_or_pfn\n-    return Object(prog, \"void *\", value=(pfn << 12) + _page_offset(prog))\n+    return Object(prog, \"void *\", value=(pfn << 12) + prog[\"PAGE_OFFSET\"])\n \n \n def page_to_virt(page):\n"}
{"repo": "drgn", "commit": "9d4b214035f3ac1c4f387c40fde2f668a84e09fa", "diff": "diff --git a/vmtest/manage.py b/vmtest/manage.py\nindex 46d0701d..80b9a1b9 100644\n--- a/vmtest/manage.py\n+++ b/vmtest/manage.py\n@@ -108,6 +108,11 @@ async def get_available_kernel_releases(\n     available = set()\n     while True:\n         async with http_client.post(url, headers=headers, json=params) as resp:\n+            if resp.status == 409 and (await resp.json())[\"error_summary\"].startswith(\n+                \"path/not_found/\"\n+            ):\n+                break\n+            await raise_for_status_body(resp)\n             obj = await resp.json()\n         for entry in obj[\"entries\"]:\n             if entry[\".tag\"] != \"file\":\n"}
{"repo": "drgn", "commit": "79f973007b2df7ecaacca40312a1b46befa7d53a", "diff": "diff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex f3d2ec45..f983c336 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -8,6 +8,7 @@ from drgn import (\n     Language,\n     Object,\n     Program,\n+    ProgramFlags,\n     Qualifiers,\n     TypeEnumerator,\n     TypeMember,\n@@ -2059,3 +2060,28 @@ class TestProgram(unittest.TestCase):\n         self.assertEqual(\n             dwarf_program(dies, lang=DW_LANG.BLISS).language, DEFAULT_LANGUAGE\n         )\n+\n+    def test_reference_counting(self):\n+        # Test that we keep the appropriate objects alive even if we don't have\n+        # an explicit reference (e.g., from a temporary variable).\n+        dies = (\n+            int_die,\n+            DwarfDie(\n+                DW_TAG.variable,\n+                [\n+                    DwarfAttrib(DW_AT.name, DW_FORM.string, \"x\"),\n+                    DwarfAttrib(DW_AT.type, DW_FORM.ref4, 0),\n+                    DwarfAttrib(\n+                        DW_AT.location,\n+                        DW_FORM.exprloc,\n+                        b\"\\x03\\x04\\x03\\x02\\x01\\xff\\xff\\xff\\xff\",\n+                    ),\n+                ],\n+            ),\n+        )\n+        self.assertEqual(dwarf_program(dies)[\"x\"].address_, 0xFFFFFFFF01020304)\n+        self.assertEqual(\n+            dwarf_program(dies)[\"x\"].prog_[\"x\"].address_, 0xFFFFFFFF01020304\n+        )\n+        self.assertFalse(dwarf_program(dies)[\"x\"].prog_.flags & ProgramFlags.IS_LIVE)\n+        self.assertEqual(dwarf_program(dies)[\"x\"].type_.name, \"int\")\n"}
{"repo": "drgn", "commit": "1b7e6839300b572d62d077a9d37dbfa801e8db10", "diff": "diff --git a/setup.py b/setup.py\nindex 48122ced..456c8081 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -119,10 +119,8 @@ class build_ext(_build_ext):\n class egg_info(_egg_info):\n     def run(self):\n         if os.path.exists(\".git\"):\n-            try:\n+            with contextlib.suppress(FileNotFoundError):\n                 os.remove(os.path.join(self.egg_info, \"SOURCES.txt\"))\n-            except FileNotFoundError:\n-                pass\n         super().run()\n \n \n"}
{"repo": "drgn", "commit": "a5cd92f24eb42d86970a614a80cc73a34d6ff9fa", "diff": "diff --git a/tests/helpers/linux/test_uts.py b/tests/helpers/linux/test_uts.py\nindex 45c4fcf8..adb3804d 100644\n--- a/tests/helpers/linux/test_uts.py\n+++ b/tests/helpers/linux/test_uts.py\n@@ -1,5 +1,7 @@\n import os\n \n+import drgn\n+\n from tests.helpers.linux import LinuxHelperTestCase\n \n \n@@ -8,3 +10,10 @@ class TestUts(LinuxHelperTestCase):\n         self.assertEqual(\n             self.prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release,\n         )\n+\n+    def test_uts_release_no_debug_info(self):\n+        prog = drgn.Program()\n+        prog.set_kernel()\n+        self.assertEqual(\n+            prog[\"UTS_RELEASE\"].string_().decode(), os.uname().release,\n+        )\n"}
{"repo": "drgn", "commit": "9de2cc8410223fea80f434cd6fdffc61836f49f6", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 417adc11..5034af40 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -701,13 +701,13 @@ class TestConversions(ObjectTestCase):\n \n         self.assertRaisesRegex(\n             TypeError,\n-            \"cannot convert 'double' to index\",\n+            \"'double' object cannot be interpreted as an integer\",\n             operator.index,\n             Object(self.prog, \"double\", value=9.99),\n         )\n         self.assertRaisesRegex(\n             TypeError,\n-            r\"cannot convert 'int \\[\\]' to index\",\n+            r\"'int \\[\\]' object cannot be interpreted as an integer\",\n             operator.index,\n             Object(self.prog, \"int []\", address=0),\n         )\n"}
{"repo": "drgn", "commit": "b5232d944dd5f2e3c6aceae7d9439fe8c3b5a730", "diff": "diff --git a/tests/helpers/linux/__init__.py b/tests/helpers/linux/__init__.py\nindex df22a57e..44d3789d 100644\n--- a/tests/helpers/linux/__init__.py\n+++ b/tests/helpers/linux/__init__.py\n@@ -42,7 +42,7 @@ class LinuxHelperTestCase(unittest.TestCase):\n                     prog.load_debug_info(main=True)\n                     LinuxHelperTestCase.prog = prog\n                     return\n-                except drgn.MissingDebugInfoError:\n+                except drgn.MissingDebugInfoError as e:\n                     if force_run:\n                         raise\n                     LinuxHelperTestCase.skip_reason = str(e)\n"}
{"repo": "drgn", "commit": "ad82e9623ad8f62e1be2a7684ac9063a2ed477fa", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 74c50c08..fdbc2331 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -52,6 +52,7 @@ from _drgn import (\n     MissingDebugInfoError,\n     NULL,\n     Object,\n+    OutOfBoundsError,\n     Platform,\n     PlatformFlags,\n     PrimitiveType,\n@@ -97,6 +98,7 @@ __all__ = [\n     \"MissingDebugInfoError\",\n     \"NULL\",\n     \"Object\",\n+    \"OutOfBoundsError\",\n     \"Platform\",\n     \"PlatformFlags\",\n     \"PrimitiveType\",\ndiff --git a/tests/test_object.py b/tests/test_object.py\nindex defbae96..417adc11 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -5,6 +5,7 @@ import struct\n from drgn import (\n     FaultError,\n     Object,\n+    OutOfBoundsError,\n     Qualifiers,\n     Type,\n     array_type,\n@@ -559,7 +560,7 @@ class TestValue(ObjectTestCase):\n \n         Object(self.prog, invalid_struct, value={\"a\": 0})\n         self.assertRaisesRegex(\n-            FaultError,\n+            OutOfBoundsError,\n             \"out of bounds of value\",\n             Object,\n             self.prog,\n@@ -567,7 +568,7 @@ class TestValue(ObjectTestCase):\n             value={\"a\": 0, \"b\": 4},\n         )\n         self.assertRaisesRegex(\n-            FaultError,\n+            OutOfBoundsError,\n             \"out of bounds of value\",\n             Object,\n             self.prog,\n@@ -2265,7 +2266,7 @@ class TestGenericOperators(ObjectTestCase):\n         obj = arr.read_()\n         for i in range(4):\n             self.assertEqual(obj[i], Object(self.prog, \"int\", value=i))\n-        self.assertRaisesRegex(FaultError, \"out of bounds\", obj.__getitem__, 4)\n+        self.assertRaisesRegex(OutOfBoundsError, \"out of bounds\", obj.__getitem__, 4)\n         obj = Object(self.prog, \"int\", value=0)\n         self.assertRaises(TypeError, obj.__getitem__, 0)\n \n@@ -2420,7 +2421,7 @@ class TestGenericOperators(ObjectTestCase):\n         obj = Object(\n             self.prog, struct_type(\"foo\", 4, point_type.members), address=0xFFFF0000\n         ).read_()\n-        self.assertRaisesRegex(FaultError, \"out of bounds\", getattr, obj, \"y\")\n+        self.assertRaisesRegex(OutOfBoundsError, \"out of bounds\", getattr, obj, \"y\")\n \n     def test_string(self):\n         prog = mock_program(\n"}
{"repo": "drgn", "commit": "98d2aba95cabdda5ff1a802638919fc5be8f8eb0", "diff": "diff --git a/examples/linux/tcp_sock.py b/examples/linux/tcp_sock.py\nindex c5d49e61..76220c25 100755\n--- a/examples/linux/tcp_sock.py\n+++ b/examples/linux/tcp_sock.py\n@@ -4,6 +4,7 @@ import ipaddress\n import socket\n import struct\n \n+from drgn import cast, container_of\n from drgn.helpers import enum_type_to_class\n from drgn.helpers.linux import (\n     cgroup_path,\n"}
{"repo": "drgn", "commit": "d71b57e3e838586a04cd513e86d4940391248601", "diff": "diff --git a/scripts/vmtest/manage.py b/scripts/vmtest/manage.py\nindex f7c4d70c..e9031bd0 100755\n--- a/scripts/vmtest/manage.py\n+++ b/scripts/vmtest/manage.py\n@@ -175,6 +175,22 @@ async def compress_file(in_path, out_path, *args, **kwds):\n     logger.info('compressed %r in %s', in_path, humanize_duration(elapsed))\n \n \n+def getpwd():\n+    # This is how GCC determines the working directory. See\n+    # https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libiberty/getpwd.c;hb=HEAD\n+    try:\n+        pwd = os.environ['PWD']\n+        if pwd.startswith('/'):\n+            pwdstat = os.stat(pwd)\n+            dotstat = os.stat('.')\n+            if (dotstat.st_ino == pwdstat.st_ino and\n+                    dotstat.st_dev == pwdstat.st_dev):\n+                return pwd\n+    except (KeyError, OSError):\n+        pass\n+    return os.getcwd()\n+\n+\n async def build_kernel(commit, build_dir, log_file):\n     await check_call('git', 'checkout', commit, stdout=log_file,\n                      stderr=asyncio.subprocess.STDOUT)\n@@ -184,8 +200,15 @@ async def build_kernel(commit, build_dir, log_file):\n \n     logger.info('building %s', commit)\n     start = time.monotonic()\n-    kbuild_args = ['KBUILD_BUILD_USER=drgn', 'KBUILD_BUILD_HOST=drgn',\n-                   'O=' + build_dir, '-j', str(multiprocessing.cpu_count())]\n+    cflags = f'-fdebug-prefix-map={os.path.join(getpwd(), build_dir)}='\n+    kbuild_args = [\n+        'KBUILD_BUILD_USER=drgn',\n+        'KBUILD_BUILD_HOST=drgn',\n+        'KAFLAGS=' + cflags,\n+        'KCFLAGS=' + cflags,\n+        'O=' + build_dir,\n+        '-j', str(multiprocessing.cpu_count()),\n+    ]\n     await check_call('make', *kbuild_args, 'olddefconfig', 'all',\n                      stdout=log_file, stderr=asyncio.subprocess.STDOUT)\n     elapsed = time.monotonic() - start\n"}
{"repo": "drgn", "commit": "3239e72e4e4894dc2bbc34afecb82952877617b0", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex 9de2002a..795c32da 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -40,8 +40,10 @@ that package should be considered implementation details and should not\n be used.\n \"\"\"\n \n-import runpy\n+import io\n+import pkgutil\n import sys\n+import types\n \n from _drgn import (\n     Architecture,\n@@ -134,6 +136,25 @@ __all__ = [\n ]\n \n \n+try:\n+    _open_code = io.open_code\n+except AttributeError:\n+    def _open_code(path):\n+        return open(path, 'rb')\n+\n+\n+# From https://docs.python.org/3/reference/import.html#import-related-module-attributes.\n+_special_globals = frozenset([\n+    '__name__',\n+    '__loader__',\n+    '__package__',\n+    '__spec__',\n+    '__path__',\n+    '__file__',\n+    '__cached__',\n+])\n+\n+\n def execscript(path, *args):\n     \"\"\"\n     Execute a script.\n@@ -182,14 +203,49 @@ def execscript(path, *args):\n     :param str \\\\*args: Zero or more additional arguments to pass to the script.\n         This is a :ref:`variable argument list <python:tut-arbitraryargs>`.\n     \"\"\"\n-    old_argv = sys.argv\n-    sys.argv = [path]\n-    sys.argv.extend(args)\n+    # This is based on runpy.run_code, which we can't use because we want to\n+    # update globals even if the script throws an exception.\n+    saved_module = []\n+    try:\n+        saved_module.append(sys.modules['__main__'])\n+    except KeyError:\n+        pass\n+    saved_argv = sys.argv\n     try:\n-        old_globals = sys._getframe(1).f_globals\n-        new_globals = runpy.run_path(path, init_globals=old_globals,\n-                                     run_name='__main__')\n-        old_globals.clear()\n-        old_globals.update(new_globals)\n+        module = types.ModuleType('__main__')\n+        sys.modules['__main__'] = module\n+        sys.argv = [path]\n+        sys.argv.extend(args)\n+\n+        with _open_code(path) as f:\n+            code = pkgutil.read_code(f)\n+        if code is None:\n+            with _open_code(path) as f:\n+                code = compile(f.read(), path, 'exec')\n+        module.__spec__ = None\n+        module.__file__ = path\n+        module.__cached__ = None\n+\n+        caller_globals = sys._getframe(1).f_globals\n+        caller_special_globals = {\n+            name: caller_globals[name] for name in _special_globals\n+            if name in caller_globals\n+        }\n+        for name, value in caller_globals.items():\n+            if name not in _special_globals:\n+                setattr(module, name, value)\n+\n+        try:\n+            exec(code, vars(module))\n+        finally:\n+            caller_globals.clear()\n+            caller_globals.update(caller_special_globals)\n+            for name, value in vars(module).items():\n+                if name not in _special_globals:\n+                    caller_globals[name] = value\n     finally:\n-        sys.argv = old_argv\n+        sys.argv = saved_argv\n+        if saved_module:\n+            sys.modules['__main__'] = saved_module[0]\n+        else:\n+            del sys.modules['__main__']\n"}
{"repo": "drgn", "commit": "1340eb495c305cc1ec070295b8d4913b0cc2af4e", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex 59d7f317..53c6f637 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -64,7 +64,7 @@ def main() -> None:\n     symbol_group = parser.add_argument_group('debugging symbols')\n     symbol_group.add_argument(\n         '-s', '--symbols', metavar='PATH', type=str, action='append',\n-        help='load additional debugging symbols from the given file; this may option may be given more than once')\n+        help='load additional debugging symbols from the given file; this option may be given more than once')\n     default_symbols_group = symbol_group.add_mutually_exclusive_group()\n     default_symbols_group.add_argument(\n         '--main-symbols', dest='default_symbols', action='store_const',\n"}
{"repo": "drgn", "commit": "fef84017d785468192f076fbd17992b6e2780418", "diff": "diff --git a/drgn/helpers/linux/fs.py b/drgn/helpers/linux/fs.py\nindex 7b96a01d..6218473b 100644\n--- a/drgn/helpers/linux/fs.py\n+++ b/drgn/helpers/linux/fs.py\n@@ -42,12 +42,12 @@ def _follow_mount(mnt, dentry):\n     # hasn't changed since v2.6.38, so let's hardcode it for now.\n     DCACHE_MOUNTED = 0x10000\n     while dentry.d_flags & DCACHE_MOUNTED:\n-        for other_mnt in list_for_each_entry_reverse('struct mount',\n-                                                     mnt.mnt_ns.list.address_of_(),\n-                                                     'mnt_list'):\n-            if other_mnt.mnt_mountpoint == dentry:\n-                mnt = other_mnt.read_()\n-                dentry = mnt.mnt.mnt_root.read_()\n+        for mounted in list_for_each_entry_reverse('struct mount',\n+                                                   mnt.mnt_ns.list.address_of_(),\n+                                                   'mnt_list'):\n+            if mounted.mnt_parent == mnt and mounted.mnt_mountpoint == dentry:\n+                mnt = mounted.read_()\n+                dentry = mounted.mnt.mnt_root.read_()\n                 break\n         else:\n             break\n"}
{"repo": "drgn", "commit": "20a7c8c85fd04bddf1b3f790d0932687c37015ca", "diff": "diff --git a/drgn/helpers/linux/fs.py b/drgn/helpers/linux/fs.py\nindex 3990f0fd..7b96a01d 100644\n--- a/drgn/helpers/linux/fs.py\n+++ b/drgn/helpers/linux/fs.py\n@@ -148,18 +148,19 @@ def d_path(path_or_vfsmnt, dentry=None):\n \n     components = []\n     while True:\n-        while True:\n-            d_parent = dentry.d_parent.read_()\n-            if dentry == d_parent:\n+        if dentry == mnt.mnt.mnt_root:\n+            mnt_parent = mnt.mnt_parent.read_()\n+            if mnt == mnt_parent:\n                 break\n-            components.append(dentry.d_name.name.string_())\n-            components.append(b'/')\n-            dentry = d_parent\n-        mnt_parent = mnt.mnt_parent.read_()\n-        if mnt == mnt_parent:\n+            dentry = mnt.mnt_mountpoint.read_()\n+            mnt = mnt_parent\n+            continue\n+        d_parent = dentry.d_parent.read_()\n+        if dentry == d_parent:\n             break\n-        dentry = mnt.mnt_mountpoint\n-        mnt = mnt_parent\n+        components.append(dentry.d_name.name.string_())\n+        components.append(b'/')\n+        dentry = d_parent\n     if components:\n         return b''.join(reversed(components))\n     else:\n"}
{"repo": "drgn", "commit": "5fbe1b1ba9ba985a8a95db4d4bd17e397f5eddcf", "diff": "diff --git a/setup.py b/setup.py\nindex 8118d056..1625fd89 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -1,13 +1,15 @@\n #!/usr/bin/env python3\n \n import contextlib\n-import re\n-import os.path\n from distutils.dir_util import mkpath\n from distutils.file_util import copy_file\n+import os\n+import os.path\n+import re\n from setuptools import setup, find_packages\n-from setuptools.extension import Extension\n from setuptools.command.build_ext import build_ext\n+from setuptools.command.egg_info import egg_info\n+from setuptools.extension import Extension\n import subprocess\n import sys\n \n@@ -81,6 +83,17 @@ class my_build_ext(build_ext):\n             return []\n \n \n+# Work around pypa/setuptools#436.\n+class my_egg_info(egg_info):\n+    def run(self):\n+        if os.path.exists('.git'):\n+            try:\n+                os.remove(os.path.join(self.egg_info, 'SOURCES.txt'))\n+            except FileNotFoundError:\n+                pass\n+        super().run()\n+\n+\n with open('libdrgn/drgn.h.in', 'r') as f:\n     drgn_h = f.read()\n version_major = re.search('^#define DRGN_VERSION_MAJOR ([0-9])+$', drgn_h,\n@@ -100,6 +113,7 @@ setup(\n     ext_modules=[Extension(name='_drgn', sources=[])],\n     cmdclass={\n         'build_ext': my_build_ext,\n+        'egg_info': my_egg_info,\n     },\n     entry_points={\n         'console_scripts': ['drgn=drgn.internal.cli:main'],\n"}
{"repo": "drgn", "commit": "aec6a279aa516fae4b9f7bdc4faea6f2e44e4774", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex da47a8af..abdc3842 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -177,7 +177,7 @@ def execscript(path, *args):\n     'S'\n \n     :param str path: File path of the script.\n-    :param str \\*args: Zero or more additional arguments to pass to the script.\n+    :param str \\\\*args: Zero or more additional arguments to pass to the script.\n         This is a :ref:`variable argument list <python:tut-arbitraryargs>`.\n     \"\"\"\n     old_argv = sys.argv\n"}
{"repo": "drgn", "commit": "63911165f826ada99faf6ee08596faf3167ce1a8", "diff": "diff --git a/drgn/helpers/linux/mm.py b/drgn/helpers/linux/mm.py\nindex ce839811..a91a4308 100644\n--- a/drgn/helpers/linux/mm.py\n+++ b/drgn/helpers/linux/mm.py\n@@ -5,8 +5,9 @@\n Memory Management\n -----------------\n \n-The ``drgn.helpers.linux.mm`` provides helpers for working with the Linux\n-memory management (MM) subsystem. Only x86-64 support is currently implemented.\n+The ``drgn.helpers.linux.mm`` module provides helpers for working with the\n+Linux memory management (MM) subsystem. Only x86-64 support is currently\n+implemented.\n \"\"\"\n \n from drgn import Object, cast\n"}
{"repo": "drgn", "commit": "698991b27bb414283997701c441effdcdef11442", "diff": "diff --git a/drgn/__init__.py b/drgn/__init__.py\nindex ff866a94..9f0e997d 100644\n--- a/drgn/__init__.py\n+++ b/drgn/__init__.py\n@@ -46,7 +46,6 @@ import sys\n from _drgn import (\n     Architecture,\n     FaultError,\n-    FileFormatError,\n     FindObjectFlags,\n     MissingDebugInfoError,\n     NULL,\n@@ -89,7 +88,6 @@ from _drgn import (\n __all__ = [\n     'Architecture',\n     'FaultError',\n-    'FileFormatError',\n     'FindObjectFlags',\n     'MissingDebugInfoError',\n     'NULL',\ndiff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex 265a7c3d..04d06e93 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -94,7 +94,7 @@ def main() -> None:\n     if args.symbols:\n         try:\n             prog.load_debug_info(args.symbols)\n-        except (drgn.FileFormatError, drgn.MissingDebugInfoError, OSError) as e:\n+        except (drgn.MissingDebugInfoError, OSError) as e:\n             if not args.quiet:\n                 print(e, file=sys.stderr)\n \ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex edb142a5..8d11f113 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -3,7 +3,6 @@ import tempfile\n import unittest\n \n from drgn import (\n-    FileFormatError,\n     FindObjectFlags,\n     Object,\n     Program,\n@@ -215,7 +214,7 @@ class TestTypes(unittest.TestCase):\n \n     def test_unknown_tag(self):\n         die = DwarfDie(0x9999, ())\n-        self.assertRaisesRegex(FileFormatError, 'unknown DWARF type tag 0x9999',\n+        self.assertRaisesRegex(Exception, 'unknown DWARF type tag 0x9999',\n                                self.type_from_dwarf, die)\n \n     def test_bad_base_type(self):\n@@ -229,19 +228,19 @@ class TestTypes(unittest.TestCase):\n         )\n \n         byte_size = die.attribs.pop(0)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_base_type has missing or invalid DW_AT_byte_size',\n                                self.type_from_dwarf, die)\n         die.attribs.insert(0, byte_size)\n \n         encoding = die.attribs.pop(1)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_base_type has missing or invalid DW_AT_encoding',\n                                self.type_from_dwarf, die)\n         die.attribs.insert(1, encoding)\n \n         del die.attribs[2]\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_base_type has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, die)\n \n@@ -270,7 +269,7 @@ class TestTypes(unittest.TestCase):\n                 DwarfAttrib(DW_AT.name, DW_FORM.string, 'magic int'),\n             ),\n         )\n-        self.assertRaisesRegex(FileFormatError, 'unknown DWARF encoding',\n+        self.assertRaisesRegex(Exception, 'unknown DWARF encoding',\n                                self.type_from_dwarf, die)\n \n     def test_qualifiers(self):\n@@ -378,37 +377,37 @@ class TestTypes(unittest.TestCase):\n \n         tag = dies[0].attribs.pop(0)\n         dies[0].attribs.insert(0, DwarfAttrib(DW_AT.name, DW_FORM.data1, 0))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_structure_type has invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs[0] = tag\n \n         size = dies[0].attribs.pop(1)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_structure_type has missing or invalid DW_AT_byte_size',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs.insert(1, size)\n \n         name = dies[0].children[0].attribs.pop(0)\n         dies[0].children[0].attribs.insert(0, DwarfAttrib(DW_AT.name, DW_FORM.data1, 0))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_member has invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs[0] = name\n \n         location = dies[0].children[0].attribs[1]\n         dies[0].children[0].attribs[1] = DwarfAttrib(DW_AT.data_member_location, DW_FORM.string, 'foo')\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_member has invalid DW_AT_data_member_location',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs[1] = location\n \n         type_ = dies[0].children[0].attribs.pop(2)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_member is missing DW_AT_type',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs.insert(2, DwarfAttrib(DW_AT.type, DW_FORM.string, 'foo'))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_member has invalid DW_AT_type',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs[2] = type_\n@@ -699,13 +698,13 @@ class TestTypes(unittest.TestCase):\n \n         tag = dies[0].attribs.pop(0)\n         dies[0].attribs.insert(0, DwarfAttrib(DW_AT.name, DW_FORM.data1, 0))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_union_type has invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs[0] = tag\n \n         size = dies[0].attribs.pop(1)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_union_type has missing or invalid DW_AT_byte_size',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs.insert(1, size)\n@@ -827,36 +826,36 @@ class TestTypes(unittest.TestCase):\n                       [('RED', 0), ('GREEN', -1), ('BLUE', -2)]))\n \n         dies[0].attribs.insert(1, DwarfAttrib(DW_AT.type, DW_FORM.ref4, 2))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_AT_type of DW_TAG_enumeration_type is not an integer type',\n                                self.type_from_dwarf, dies)\n         del dies[0].attribs[1]\n \n         size = dies[0].attribs.pop(1)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_enumeration_type has missing or invalid DW_AT_byte_size',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs.insert(1, size)\n \n         tag = dies[0].attribs.pop(0)\n         dies[0].attribs.insert(0, DwarfAttrib(DW_AT.name, DW_FORM.data1, 0))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_enumeration_type has invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n         dies[0].attribs[0] = tag\n \n         name = dies[0].children[0].attribs.pop(0)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_enumerator has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs.insert(0, name)\n \n         const_value = dies[0].children[0].attribs.pop(1)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_enumerator is missing DW_AT_const_value',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs.insert(1, DwarfAttrib(DW_AT.const_value, DW_FORM.string, 'asdf'))\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_enumerator has invalid DW_AT_const_value',\n                                self.type_from_dwarf, dies)\n         dies[0].children[0].attribs[1] = const_value\n@@ -969,7 +968,7 @@ class TestTypes(unittest.TestCase):\n             dies, typedef_type('INT', int_type('int', 4, True)))\n \n         dies[0].attribs.pop(0)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_typedef has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n \n@@ -985,7 +984,7 @@ class TestTypes(unittest.TestCase):\n         self.assertFromDwarf(dies, typedef_type('VOID', void_type()))\n \n         dies[0].attribs.pop(0)\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_typedef has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n \n@@ -1053,7 +1052,7 @@ class TestTypes(unittest.TestCase):\n             array_type(2, array_type(3, array_type(4, int_type('int', 4, True)))))\n \n         del dies[0].attribs[0]\n-        self.assertRaisesRegex(FileFormatError,\n+        self.assertRaisesRegex(Exception,\n                                'DW_TAG_array_type is missing DW_AT_type',\n                                self.type_from_dwarf, dies)\n \n@@ -1694,7 +1693,7 @@ class TestObjects(ObjectTestCase):\n         dies[1].attribs.insert(\n             2, DwarfAttrib(DW_AT.location, DW_FORM.exprloc, b'\\xe0'))\n         prog = dwarf_program(dies)\n-        self.assertRaisesRegex(FileFormatError, 'unimplemented operation',\n+        self.assertRaisesRegex(Exception, 'unimplemented operation',\n                                prog.object, 'x')\n \n     def test_not_found(self):\n"}
{"repo": "drgn", "commit": "b01d1a943fe685ee7453d46d69222931c26dde7a", "diff": "diff --git a/tests/libdrgn.py b/tests/libdrgn.py\nindex cc0036f4..baef332d 100644\n--- a/tests/libdrgn.py\n+++ b/tests/libdrgn.py\n@@ -20,13 +20,13 @@ class _drgn_error(ctypes.Structure):\n     ]\n \n \n-_drgn_pydll.set_drgn_error.restype = ctypes.py_object\n+_drgn_pydll.set_drgn_error.restype = ctypes.c_void_p\n _drgn_pydll.set_drgn_error.argtypes = [ctypes.POINTER(_drgn_error)]\n \n \n def _check_err(err):\n     if err:\n-        return _drgn_pydll.set_drgn_error(err)\n+        _drgn_pydll.set_drgn_error(err)\n \n \n class _path_iterator_component(ctypes.Structure):\n"}
{"repo": "drgn", "commit": "cde021ff4a71ac4c1c6081050e84057a0249a191", "diff": "diff --git a/drgn/helpers/linux/fs.py b/drgn/helpers/linux/fs.py\nindex c12d8cd8..3990f0fd 100644\n--- a/drgn/helpers/linux/fs.py\n+++ b/drgn/helpers/linux/fs.py\n@@ -17,6 +17,7 @@ from drgn.helpers.linux.list import (\n     hlist_empty,\n     hlist_for_each_entry,\n     list_for_each_entry,\n+    list_for_each_entry_reverse,\n )\n \n __all__ = [\n"}
{"repo": "drgn", "commit": "9a10a927b0717941c32bc176514ae1f393ea0282", "diff": "diff --git a/drgn/helpers/linux/block.py b/drgn/helpers/linux/block.py\nindex 4b10d889..9f1a1df9 100644\n--- a/drgn/helpers/linux/block.py\n+++ b/drgn/helpers/linux/block.py\n@@ -47,16 +47,32 @@ def disk_name(disk):\n     return disk.disk_name.string_()\n \n \n+def _for_each_block_device(prog):\n+    try:\n+        class_in_private = prog.cache['knode_class_in_device_private']\n+    except KeyError:\n+        # We need a proper has_member(), but this is fine for now.\n+        class_in_private = any(member[1] == 'knode_class' for member in\n+                               prog.type('struct device_private').members)\n+        prog.cache['knode_class_in_device_private'] = class_in_private\n+    devices = prog['block_class'].p.klist_devices.k_list.address_of_()\n+    if class_in_private:\n+        for device_private in list_for_each_entry('struct device_private', devices,\n+                                                  'knode_class.n_node'):\n+            yield device_private.device\n+    else:\n+        yield from list_for_each_entry('struct device', devices,\n+                                       'knode_class.n_node')\n+\n+\n def for_each_disk(prog):\n     \"\"\"\n     Iterate over all disks in the system.\n \n     :return: Iterator of ``struct gendisk *`` objects.\n     \"\"\"\n-    devices = prog['block_class'].p.klist_devices.k_list.address_of_()\n     disk_type = prog['disk_type'].address_of_()\n-    for device in list_for_each_entry('struct device', devices,\n-                                      'knode_class.n_node'):\n+    for device in _for_each_block_device(prog):\n         if device.type == disk_type:\n             yield container_of(device, 'struct gendisk', 'part0.__dev')\n \n@@ -96,9 +112,7 @@ def for_each_partition(prog):\n \n     :return: Iterator of ``struct hd_struct *`` objects.\n     \"\"\"\n-    devices = prog['block_class'].p.klist_devices.k_list.address_of_()\n-    for device in list_for_each_entry('struct device', devices,\n-                                      'knode_class.n_node'):\n+    for device in _for_each_block_device(prog):\n         yield container_of(device, 'struct hd_struct', '__dev')\n \n \n"}
{"repo": "drgn", "commit": "ca9e641fcb38f9ccc03a882fa92490ff1015b1cd", "diff": "diff --git a/drgn/helpers/linux/cpumask.py b/drgn/helpers/linux/cpumask.py\nindex 27dcaca5..934f77d2 100644\n--- a/drgn/helpers/linux/cpumask.py\n+++ b/drgn/helpers/linux/cpumask.py\n@@ -26,8 +26,8 @@ def for_each_cpu(mask):\n     :rtype: Iterator[int]\n     \"\"\"\n     bits = mask.bits\n-    word_bits = 8 * bits.type_.type.sizeof()\n-    for i in range(bits.type_.size):\n+    word_bits = 8 * bits.type_.type.size\n+    for i in range(bits.type_.length):\n         word = bits[i].value_()\n         for j in range(word_bits):\n             if word & (1 << j):\n"}
{"repo": "drgn", "commit": "1691d5c02b0e219d0fb86f4194452685735d9ba9", "diff": "diff --git a/drgn/helpers/linux/cpumask.py b/drgn/helpers/linux/cpumask.py\nindex 27dcaca5..934f77d2 100644\n--- a/drgn/helpers/linux/cpumask.py\n+++ b/drgn/helpers/linux/cpumask.py\n@@ -26,8 +26,8 @@ def for_each_cpu(mask):\n     :rtype: Iterator[int]\n     \"\"\"\n     bits = mask.bits\n-    word_bits = 8 * bits.type_.type.sizeof()\n-    for i in range(bits.type_.size):\n+    word_bits = 8 * bits.type_.type.size\n+    for i in range(bits.type_.length):\n         word = bits[i].value_()\n         for j in range(word_bits):\n             if word & (1 << j):\n"}
{"repo": "drgn", "commit": "9b563170f83f545f930c3bb91596251a55d22455", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex ed608dfd..bbe9d9f9 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -87,20 +87,16 @@ def main() -> None:\n         prog.set_pid(args.pid or os.getpid())\n     if args.default_symbols:\n         try:\n-            prog.open_default_debug_info()\n+            prog.load_default_debug_info()\n         except drgn.MissingDebugInfoError as e:\n             if not args.quiet:\n                 print(str(e), file=sys.stderr)\n-    for path in (args.symbols or []):\n+    if args.symbols:\n         try:\n-            prog.open_debug_info(path)\n-        except (drgn.FileFormatError, drgn.MissingDebugInfoError) as e:\n-            if not args.quiet:\n-                print(f'{path}: {e}', file=sys.stderr)\n-        except OSError as e:\n+            prog.load_debug_info(args.symbols)\n+        except (drgn.FileFormatError, drgn.MissingDebugInfoError, OSError) as e:\n             if not args.quiet:\n                 print(e, file=sys.stderr)\n-    prog.load_debug_info()\n \n     init_globals: Dict[str, Any] = {'prog': prog}\n     if args.script:\ndiff --git a/tests/test_dwarf.py b/tests/test_dwarf.py\nindex 0a241855..9a0a6c51 100644\n--- a/tests/test_dwarf.py\n+++ b/tests/test_dwarf.py\n@@ -194,8 +194,7 @@ def dwarf_program(dies, little_endian=True, bits=64):\n     with tempfile.NamedTemporaryFile() as f:\n         f.write(compile_dwarf(dies, little_endian, bits))\n         f.flush()\n-        prog.open_debug_info(f.name)\n-    prog.load_debug_info()\n+        prog.load_debug_info([f.name])\n     return prog\n \n \ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex e1fd990e..9fc9e851 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -144,6 +144,9 @@ class TestProgram(unittest.TestCase):\n         self.assertEqual(prog.pointer_type(prog.type('int'), Qualifiers.CONST),\n                          prog.type('int * const'))\n \n+    def test_debug_info(self):\n+        Program().load_debug_info([])\n+\n \n class TestMemory(unittest.TestCase):\n     def test_simple_read(self):\n"}
{"repo": "drgn", "commit": "7282c40a75d4d2e7a846074635b74bd5a7dde533", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 144d6fa3..0bcc0615 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -1324,8 +1324,8 @@ class TestCPretty(ObjectTestCase):\n                 (int_type('int', 4, True), 'baz', 32),\n             )), None, 64),\n         ))\n-        self.assertEqual(str(Object(prog, type_, address=0xffff0000)),\n-                         \"\"\"\\\n+        obj = Object(prog, type_, address=0xffff0000)\n+        expected = \"\"\"\\\n (struct foo){\n \t.point = (struct point){\n \t\t.x = (int)99,\n@@ -1333,7 +1333,38 @@ class TestCPretty(ObjectTestCase):\n \t},\n \t.bar = (int)12345,\n \t.baz = (int)0,\n-}\"\"\")\n+}\"\"\"\n+        self.assertEqual(str(obj), expected)\n+        self.assertEqual(str(obj.read_()), expected)\n+\n+        segment = ((99).to_bytes(8, 'little') +\n+                   (-1).to_bytes(8, 'little', signed=True) +\n+                   (12345).to_bytes(8, 'little', signed=True) +\n+                   (0).to_bytes(8, 'little', signed=True))\n+        prog = mock_program(8, 'little', segments=[\n+            MockMemorySegment(segment, virt_addr=0xffff0000),\n+        ])\n+\n+        type_ = struct_type('foo', 32, (\n+            (struct_type('long_point', 16, (\n+                (int_type('long', 8, True), 'x'),\n+                (int_type('long', 8, True), 'y', 64),\n+            )), 'point'),\n+            (int_type('long', 8, True), 'bar', 128),\n+            (int_type('long', 8, True), 'baz', 192),\n+        ))\n+        obj = Object(prog, type_, address=0xffff0000)\n+        expected = \"\"\"\\\n+(struct foo){\n+\t.point = (struct long_point){\n+\t\t.x = (long)99,\n+\t\t.y = (long)-1,\n+\t},\n+\t.bar = (long)12345,\n+\t.baz = (long)0,\n+}\"\"\"\n+        self.assertEqual(str(obj), expected)\n+        self.assertEqual(str(obj.read_()), expected)\n \n         type_ = struct_type('foo', 0, ())\n         self.assertEqual(str(Object(prog, type_, address=0)), '(struct foo){}')\n"}
{"repo": "drgn", "commit": "97f5cf70c6538fc359992c11cdb155b2afce5e81", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex a85998c9..144d6fa3 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -890,6 +890,23 @@ class TestCCommonRealType(ObjectTestCase):\n \n \n class TestCOperators(ObjectTestCase):\n+    def test_cast_array(self):\n+        obj = Object(self.prog, 'int []', address=0xffff0000)\n+        self.assertEqual(cast('int *', obj),\n+                         Object(self.prog, 'int *', value=0xffff0000))\n+        self.assertEqual(cast('void *', obj),\n+                         Object(self.prog, 'void *', value=0xffff0000))\n+        self.assertEqual(cast('unsigned long', obj),\n+                         Object(self.prog, 'unsigned long', value=0xffff0000))\n+        self.assertRaisesRegex(TypeError, r\"cannot convert 'int \\*' to 'int \\[2]'\",\n+                               cast, 'int [2]', obj)\n+\n+    def test_cast_function(self):\n+        func = Object(self.prog,\n+                      function_type(void_type(), (), False), address=0xffff0000)\n+        self.assertEqual(cast('void *', func),\n+                         Object(self.prog, 'void *', value=0xffff0000))\n+\n     def _test_arithmetic(self, op, lhs, rhs, result, integral=True,\n                          floating_point=False):\n         if integral:\n"}
{"repo": "drgn", "commit": "73090f6128b6f049ebd23ca794314c660588c137", "diff": "diff --git a/tests/test_object.py b/tests/test_object.py\nindex 45a04e1b..46f5aeef 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -1662,6 +1662,11 @@ class TestGenericOperators(ObjectTestCase):\n                                \"cannot convert 'struct point' to 'enum color'\",\n                                cast, color_type, obj)\n \n+    def test_cast_invalid(self):\n+        obj = Object(self.prog, 'int', value=1)\n+        self.assertRaisesRegex(TypeError, 'cannot cast to void type', cast,\n+                               'void', obj)\n+\n     def test_reinterpret_reference(self):\n         obj = Object(self.prog, 'int', address=0xffff0000)\n         self.assertEqual(reinterpret('int', obj), obj)\n"}
{"repo": "drgn", "commit": "435640faf62ba07a77b58c4f94e70e842f4c9e01", "diff": "diff --git a/drgn/helpers/linux/block.py b/drgn/helpers/linux/block.py\nindex 42794fdf..4b10d889 100644\n--- a/drgn/helpers/linux/block.py\n+++ b/drgn/helpers/linux/block.py\n@@ -10,7 +10,7 @@ Linux block layer, including disks (``struct gendisk``) and partitions\n (``struct hd_struct``).\n \"\"\"\n \n-from drgn import Object, container_of\n+from drgn import container_of\n from drgn.helpers import escape_string\n from drgn.helpers.linux.device import MAJOR, MINOR, MKDEV\n from drgn.helpers.linux.list import list_for_each_entry\ndiff --git a/drgn/helpers/linux/fs.py b/drgn/helpers/linux/fs.py\nindex 096b746c..e4fea12a 100644\n--- a/drgn/helpers/linux/fs.py\n+++ b/drgn/helpers/linux/fs.py\n@@ -11,7 +11,7 @@ Linux virtual filesystem (VFS) layer, including mounts, dentries, and inodes.\n \n import os\n \n-from drgn import Object, Program, container_of\n+from drgn import Program, container_of\n from drgn.helpers import escape_string\n from drgn.helpers.linux.list import hlist_for_each_entry, list_for_each_entry\n \ndiff --git a/drgn/helpers/linux/rbtree.py b/drgn/helpers/linux/rbtree.py\nindex 57eccfbc..0d078921 100644\n--- a/drgn/helpers/linux/rbtree.py\n+++ b/drgn/helpers/linux/rbtree.py\n@@ -9,7 +9,7 @@ The ``drgn.helpers.linux.rbtree`` module provides helpers for working with\n red-black trees from :linux:`include/linux/rbtree.h`.\n \"\"\"\n \n-from drgn import Object, container_of\n+from drgn import Object, NULL, container_of\n \n \n __all__ = [\ndiff --git a/libdrgn/build-aux/gen_docstrings.py b/libdrgn/build-aux/gen_docstrings.py\nindex 7435ed49..b86b781f 100644\n--- a/libdrgn/build-aux/gen_docstrings.py\n+++ b/libdrgn/build-aux/gen_docstrings.py\n@@ -17,7 +17,6 @@ def parse_rst(input_file):\n         SimpleNamespace(name='', state='CONTENT', lines=None,\n                         directive_indentation='', content_indentation='')\n     ]\n-    state = None\n     for line in input_file:\n         line = line.rstrip()\n         indentation = re.match(r'\\s*', line).group()\ndiff --git a/setup.py b/setup.py\nindex 2c0ef03c..06d8e6b6 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -75,7 +75,7 @@ class my_sdist(sdist):\n         # pypa/setuptools#436 or the autotools output being out of date),\n         # require the repository to be clean (no unknown or ignored files).\n         # This check can be disabled with --force.\n-        if not self.force and subprocess.check_output(['git', 'clean', '-dnx']):\n+        if (not self.force and subprocess.check_output(['git', 'clean', '-dnx'])):\n             raise DistutilsSetupError('repository has untracked or ignored files; '\n                                       'please run git clean -dfx or use --force')\n         super().run()\ndiff --git a/tests/dwarfwriter.py b/tests/dwarfwriter.py\nindex 1d76a82f..6f04e449 100644\n--- a/tests/dwarfwriter.py\n+++ b/tests/dwarfwriter.py\n@@ -117,9 +117,9 @@ def _compile_debug_line(buf, cu_die, little_endian):\n     offset = len(buf)\n     byteorder = 'little' if little_endian else 'big'\n \n-    buf.extend(b'\\0\\0\\0\\0') # unit_length\n+    buf.extend(b'\\0\\0\\0\\0')  # unit_length\n     buf.extend((4).to_bytes(2, byteorder))  # version\n-    buf.extend(b'\\0\\0\\0\\0') # header_length\n+    buf.extend(b'\\0\\0\\0\\0')  # header_length\n     buf.append(1)  # minimum_instruction_length\n     buf.append(1)  # maximum_operations_per_instruction\n     buf.append(1)  # default_is_stmt\ndiff --git a/tests/libdrgn.py b/tests/libdrgn.py\nindex 0d788793..0a2d4e99 100644\n--- a/tests/libdrgn.py\n+++ b/tests/libdrgn.py\n@@ -8,7 +8,7 @@ import drgn\n from drgn.internal.mock import MockType\n from tests import _drgn_pydll, _drgn_cdll\n from tests.libelf import _Elf, Elf\n-from tests.libdw import _Dwarf_Die, Die, Dwarf\n+from tests.libdw import _Dwarf_Die, Die\n \n \n class _drgn_error(ctypes.Structure):\n@@ -382,7 +382,6 @@ def _partial_object_wrap(pobj, parent):\n                              little_endian=pobj.little_endian)\n \n \n-\n class _drgn_object_index(ctypes.Structure):\n     pass\n \ndiff --git a/tests/test_dwarf_object_index.py b/tests/test_dwarf_object_index.py\nindex 5db65eb2..46f08ac2 100644\n--- a/tests/test_dwarf_object_index.py\n+++ b/tests/test_dwarf_object_index.py\n@@ -1,4 +1,3 @@\n-import copy\n import unittest\n \n from drgn import (\n@@ -6,9 +5,8 @@ from drgn import (\n     FileFormatError,\n     function_type,\n     int_type,\n-    Type,\n )\n-from tests.dwarf import DW_AT, DW_ATE, DW_FORM, DW_TAG\n+from tests.dwarf import DW_AT, DW_FORM, DW_TAG\n from tests.dwarfwriter import compile_dwarf, DwarfDie, DwarfAttrib\n from tests.libdrgn import (\n     DwarfIndex,\n@@ -19,7 +17,6 @@ from tests.libdrgn import (\n )\n import tests.libelf as libelf\n from tests.test_dwarf_type_index import int_die, unsigned_int_die\n-from tests.test_type_index import color_type\n \n \n class TestDwarfObjectIndex(unittest.TestCase):\ndiff --git a/tests/test_dwarf_type_index.py b/tests/test_dwarf_type_index.py\nindex 2d346ee9..11a6ff8f 100644\n--- a/tests/test_dwarf_type_index.py\n+++ b/tests/test_dwarf_type_index.py\n@@ -3,7 +3,6 @@ import unittest\n \n from drgn import (\n     array_type,\n-    bool_type,\n     complex_type,\n     enum_type,\n     FileFormatError,\n@@ -202,6 +201,7 @@ base_type_dies += (DwarfDie(\n     ),\n ),)\n \n+\n class TestDwarfTypeIndex(unittest.TestCase):\n     @staticmethod\n     def type_index_and_elf(dies, little_endian=True, bits=64):\n@@ -982,7 +982,7 @@ class TestDwarfTypeIndex(unittest.TestCase):\n         self.assertFromDwarf(\n             dies, typedef_type('INT', int_type('int', 4, True)))\n \n-        name = dies[0].attribs.pop(0)\n+        dies[0].attribs.pop(0)\n         self.assertRaisesRegex(FileFormatError,\n                                'DW_TAG_typedef has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\n@@ -998,7 +998,7 @@ class TestDwarfTypeIndex(unittest.TestCase):\n         ]\n         self.assertFromDwarf(dies, typedef_type('VOID', void_type()))\n \n-        name = dies[0].attribs.pop(0)\n+        dies[0].attribs.pop(0)\n         self.assertRaisesRegex(FileFormatError,\n                                'DW_TAG_typedef has missing or invalid DW_AT_name',\n                                self.type_from_dwarf, dies)\ndiff --git a/tests/test_object.py b/tests/test_object.py\nindex 4986ba4e..45a04e1b 100644\n--- a/tests/test_object.py\n+++ b/tests/test_object.py\n@@ -55,11 +55,11 @@ class ObjectTestCase(unittest.TestCase):\n             exc_a = exc_b = False\n             try:\n                 value_a = a.value_()\n-            except Exception as e:\n+            except Exception:\n                 exc_a = True\n             try:\n                 value_b = b.value_()\n-            except Exception as e:\n+            except Exception:\n                 exc_b = True\n             if exc_a and not exc_b:\n                 raise self.failureException(msg or f'exception raised while reading {a!r}')\n@@ -594,6 +594,7 @@ class TestInvalidBitField(ObjectTestCase):\n                                'bit field size is larger than type size',\n                                Object, self.prog, 'unsigned int', address=0,\n                                bit_field_size=64)\n+\n     def test_float(self):\n         self.assertRaisesRegex(ValueError, 'bit field must be integer',\n                                Object, self.prog, 'float', value=0,\n@@ -1532,7 +1533,6 @@ class TestCPretty(ObjectTestCase):\n         self.assertEqual(str(Object(self.prog, 'int [0]', address=0)),\n                          '(int [0]){}')\n \n-\n     def test_array_zeroes(self):\n         segment = bytearray(16)\n         prog = mock_program(8, 'little', segments=[\n@@ -1773,7 +1773,7 @@ class TestGenericOperators(ObjectTestCase):\n             Object(prog, 'int *', value=0xffff0000),\n         ]\n         for obj in strings:\n-                self.assertEqual(obj.string_(), b'hello')\n+            self.assertEqual(obj.string_(), b'hello')\n \n         self.assertRaisesRegex(TypeError, 'must be an array or pointer',\n                                Object(prog, 'int', value=1).string_)\ndiff --git a/tests/test_serialize.py b/tests/test_serialize.py\nindex 3b1c08fd..fb0046a7 100644\n--- a/tests/test_serialize.py\n+++ b/tests/test_serialize.py\n@@ -48,7 +48,6 @@ class TestSerialize(unittest.TestCase):\n         for bit_size in range(1, 65):\n             value = VALUE & ((1 << bit_size) - 1)\n             for bit_offset in range(8):\n-                size = (bit_offset + bit_size + 7) // 8\n                 for little_endian in [True, False]:\n                     expected0, expected1 = py_serialize_bits(value, bit_offset,\n                                                              bit_size,\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex fc96a71a..c29b6378 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -1,6 +1,5 @@\n import unittest\n \n-import drgn\n from drgn import (\n     array_type,\n     bool_type,\n@@ -99,7 +98,6 @@ class TestType(unittest.TestCase):\n                                complex_type, 'double _Complex', 16,\n                                float_type('double', 8, Qualifiers.CONST))\n \n-\n     def test_struct(self):\n         t = struct_type('point', 8, (\n             (int_type('int', 4, True), 'x', 0),\n"}
{"repo": "drgn", "commit": "772254af3ffbf9c2cd750d677d401bfc10a2d648", "diff": "diff --git a/examples/linux/fs_inodes.py b/examples/linux/fs_inodes.py\nindex ef42dca8..0c5fae22 100755\n--- a/examples/linux/fs_inodes.py\n+++ b/examples/linux/fs_inodes.py\n@@ -13,13 +13,16 @@ else:\n     path = sys.argv[1]\n \n mnt = None\n-for src, dst, fstype, mnt in for_each_mount(prog, dst=path):\n+for mnt in for_each_mount(prog, dst=path):\n     pass\n if mnt is None:\n     sys.exit(f'No filesystem mounted at {path}')\n \n sb = mnt.mnt.mnt_sb\n \n-start = time.monotonic()\n-print(sum(1 for _ in list_for_each_entry('struct inode', sb.s_inodes.address_of_(), 'i_sb_list')))\n-print(time.monotonic() - start)\n+for inode in list_for_each_entry('struct inode', sb.s_inodes.address_of_(),\n+                                 'i_sb_list'):\n+    try:\n+        print(os.fsdecode(inode_path(inode)))\n+    except ValueError:\n+        continue\n"}
{"repo": "drgn", "commit": "908e289eb84aacdab55471f2815f7856f4272b5a", "diff": "diff --git a/drgn/internal/cli.py b/drgn/internal/cli.py\nindex de5f0b64..8efe9808 100644\n--- a/drgn/internal/cli.py\n+++ b/drgn/internal/cli.py\n@@ -7,6 +7,7 @@ import argparse\n import builtins\n import code\n import importlib\n+import os\n import os.path\n import runpy\n import shutil\n@@ -66,8 +67,8 @@ def main() -> None:\n         prog = drgn.program_from_core_dump(args.core, verbose)\n     elif args.kernel:\n         prog = drgn.program_from_kernel(verbose)\n-    elif args.pid is not None:\n-        prog = drgn.program_from_pid(args.pid)\n+    else:\n+        prog = drgn.program_from_pid(args.pid or os.getpid())\n \n     init_globals: Dict[str, Any] = {'prog': prog}\n     if args.script:\n"}
{"repo": "drgn", "commit": "2addd9414cfede89bb5e8fc5c51fc7b92efdefdf", "diff": "diff --git a/drgn/helpers/kernel/list.py b/drgn/helpers/kernel/list.py\nindex abbc42d1..e3263d88 100644\n--- a/drgn/helpers/kernel/list.py\n+++ b/drgn/helpers/kernel/list.py\n@@ -52,7 +52,7 @@ def list_for_each(head):\n     Return an iterator over all of the nodes in a list.\n     \"\"\"\n     head = read_once(head)\n-    pos = head.read_once(next)\n+    pos = read_once(head.next)\n     while pos != head:\n         yield pos\n         pos = read_once(pos.next)\n"}
{"repo": "drgn", "commit": "032a2a6dfa83b365dbae39fe8c563b6c39aca6a3", "diff": "diff --git a/drgn/internal/dwarfvariableindex.py b/drgn/internal/dwarfvariableindex.py\nindex b28a8979..89ed3274 100644\n--- a/drgn/internal/dwarfvariableindex.py\n+++ b/drgn/internal/dwarfvariableindex.py\n@@ -37,9 +37,9 @@ class DwarfVariableIndex(VariableIndex):\n                 except DwarfAttribNotFoundError:\n                     continue\n         if filename is None:\n-            raise ValueError(f'could not find {name!r}')\n+            raise KeyError(f'could not find {name!r}')\n         else:\n-            raise ValueError(f'could not find {name!r} in {filename!r}')\n+            raise KeyError(f'could not find {name!r} in {filename!r}')\n \n     def _find_variable_address(self, name: str, die: Die) -> int:\n         raise NotImplementedError()\ndiff --git a/drgn/internal/kernelvariableindex.py b/drgn/internal/kernelvariableindex.py\nindex 427995b0..48affaf1 100644\n--- a/drgn/internal/kernelvariableindex.py\n+++ b/drgn/internal/kernelvariableindex.py\n@@ -47,12 +47,12 @@ class KernelVariableIndex(DwarfVariableIndex):\n             if mod.name.string_() == module_name:\n                 break\n         else:\n-            raise ValueError(f'{module_name.decode()} is not loaded')\n+            raise KeyError(f'{module_name.decode()} is not loaded')\n         for sym in elf_file.symbols[name]:\n             if sym.st_value == address:\n                 break\n         else:\n-            raise ValueError(f'Could not find {name} symbol')\n+            raise KeyError(f'Could not find {name} symbol')\n         section_name = elf_file.shdrs[sym.st_shndx].name.encode()\n         mod_sects = mod.sect_attrs.attrs\n         for i in range(mod.sect_attrs.nsections):\n@@ -60,4 +60,4 @@ class KernelVariableIndex(DwarfVariableIndex):\n             if attr.name.string_() == section_name:\n                 return address + attr.address.value_()\n         else:\n-            raise ValueError(f'Could not find module section {section_name.decode()}')\n+            raise KeyError(f'Could not find module section {section_name.decode()}')\ndiff --git a/drgn/internal/userspacevariableindex.py b/drgn/internal/userspacevariableindex.py\nindex 3496d2da..dd05b781 100644\n--- a/drgn/internal/userspacevariableindex.py\n+++ b/drgn/internal/userspacevariableindex.py\n@@ -35,7 +35,7 @@ class UserspaceVariableIndex(DwarfVariableIndex):\n             if phdr.p_vaddr <= address < phdr.p_vaddr + phdr.p_memsz:\n                 break\n         else:\n-            raise ValueError(f'Could not find segment containing {name}')\n+            raise KeyError(f'Could not find segment containing {name}')\n         file_offset = phdr.p_offset + address - phdr.p_vaddr\n \n         for mapping in self._file_mappings:\n@@ -45,4 +45,4 @@ class UserspaceVariableIndex(DwarfVariableIndex):\n                     mapping.file_offset + mapping_size):\n                 return mapping.start + file_offset - mapping.file_offset\n         else:\n-            raise ValueError(f'Could not find file mapping containing {name}')\n+            raise KeyError(f'Could not find file mapping containing {name}')\n"}
{"repo": "drgn", "commit": "0e9ca182bcc3fdd0d35495b5f3ff0725640fcece", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 944a6a3b..52b66dc2 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -539,7 +539,7 @@ class ProgramObject:\n     def __index__(self) -> int:\n         if not self._real_type.is_integer():\n             raise TypeError(f'cannot convert {self.type_.name!r} to index')\n-        return self.value_()\n+        return int(self.value_())\n \n     def __round__(self, ndigits: Optional[int] = None) -> Union[int, 'ProgramObject']:\n         if not self._real_type.is_arithmetic():\ndiff --git a/drgn/type.py b/drgn/type.py\nindex 9c6d98a2..71e293b6 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -173,8 +173,8 @@ class Type:\n     def is_integer(self) -> bool:\n         \"\"\"\n         Return whether this type is an integer type. This is true for instances\n-        of IntType, BitFieldType, and TypedefType if the underlying type is one\n-        of those.\n+        of IntType, EnumType, BitFieldType, and TypedefType if the underlying\n+        type is one of those.\n         \"\"\"\n         return False\n \n@@ -864,6 +864,9 @@ class EnumType(Type):\n     def is_arithmetic(self) -> bool:\n         return True\n \n+    def is_integer(self) -> bool:\n+        return True\n+\n     def _read(self, reader: CoreReader, address: int) -> Union[enum.IntEnum, int]:\n         if self.type is None or self.enum is None:\n             raise ValueError(\"can't read incomplete type\")\ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex 06056312..ee8948c0 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -5,7 +5,7 @@ import tempfile\n from drgn.internal.corereader import CoreReader\n from drgn.program import Program, ProgramObject\n from drgn.type import IntType, StructType, TypedefType\n-from tests.test_type import point_type\n+from tests.test_type import color_type, point_type\n from tests.test_typeindex import TypeIndexTestCase, TYPES\n \n \n@@ -254,6 +254,11 @@ class TestProgramObject(TypeIndexTestCase):\n         self.assertEqual(struct_obj.member_('address_'),\n                          self.program.object(TYPES['unsigned long'],\n                                              address=0xffff0000))\n+    def test_enum(self):\n+        enum_obj = self.program.object(color_type, value=0)\n+        self.assertEqual(enum_obj.value_(), color_type.enum.RED)\n+        self.assertIsInstance(enum_obj.value_(), color_type.enum)\n+        self.assertEqual([1, 2, 3][enum_obj], 1)\n \n     def test_relational(self):\n         one = self.program.object(TYPES['int'], value=1)\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex f71f4701..34d1fd87 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -368,6 +368,8 @@ enum {\n         type_ = EnumType('foo', None, None)\n         self.assertEqual(str(type_), 'enum foo')\n         self.assertRaises(ValueError, type_.sizeof)\n+        self.assertTrue(type_.is_arithmetic())\n+        self.assertTrue(type_.is_integer())\n \n     def test_pointer(self):\n         type_ = PointerType(pointer_size, IntType('int', 4, True))\n"}
{"repo": "drgn", "commit": "5fa8217302c33c309d89df1563234ae2244f1af7", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 0409662d..944a6a3b 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -109,7 +109,7 @@ class ProgramObject:\n         try:\n             return self.member_(name)\n         except ValueError as e:\n-            if e.args == ('not a struct or union',):\n+            if len(e.args) == 1 and 'struct or union' in e.args[0]:\n                 raise AttributeError(f'{self.__class__.__name__!r} object has no attribute {name!r}') from None\n             elif e.args and 'has no member' in e.args[0]:\n                 raise AttributeError(e.args[0]) from None\n@@ -118,7 +118,7 @@ class ProgramObject:\n \n     def __len__(self) -> int:\n         if not isinstance(self._real_type, ArrayType) or self._real_type.size is None:\n-            raise ValueError(f'{str(self.type_.type_name())!r} has no len()')\n+            raise ValueError(f'{self.type_.name!r} has no len()')\n         return self._real_type.size\n \n     def __getitem__(self, idx: Any) -> 'ProgramObject':\n@@ -140,13 +140,13 @@ class ProgramObject:\n             # Duplicated here to work around mypy issue #4864.\n             type_ = self._real_type.type\n         else:\n-            raise ValueError('not an array or pointer')\n+            raise ValueError(f'subscripted value must be an array or pointer, not {self.type_.name!r}')\n         offset = i * type_.sizeof()\n         return ProgramObject(self.prog_, type_, address=address + offset)\n \n     def __iter__(self) -> Iterable['ProgramObject']:\n         if not isinstance(self._real_type, ArrayType) or self._real_type.size is None:\n-            raise ValueError(f'{str(self.type_.type_name())!r} is not iterable')\n+            raise ValueError(f'{self.type_.name!r} is not iterable')\n         assert self.address_ is not None  # Array rvalues are not allowed\n         type_ = self._real_type.type\n         for i in range(self._real_type.size):\n@@ -154,9 +154,7 @@ class ProgramObject:\n             yield ProgramObject(self.prog_, type_, address=address)\n \n     def __repr__(self) -> str:\n-        parts = [\n-            'ProgramObject(type=<', str(self.type_.type_name()), '>'\n-        ]\n+        parts = ['ProgramObject(type=<', self.type_.name, '>']\n         if self._value is not None:\n             parts.append(', value=')\n             if isinstance(self._real_type, PointerType):\n@@ -216,7 +214,7 @@ class ProgramObject:\n             return self.prog_._reader.read_c_string(\n                 self.address_, maxsize=self._real_type.size or -1)\n         else:\n-            raise ValueError('not an array or pointer')\n+            raise ValueError(f'string_() value must be an array or pointer, not {self.type_.name!r}')\n \n     def member_(self, name: str) -> 'ProgramObject':\n         \"\"\"\n@@ -238,7 +236,7 @@ class ProgramObject:\n             # mypy doesn't understand the except AttributeError.\n             member_type, offset = type_.member(name)  # type: ignore\n         except AttributeError:\n-            raise ValueError('not a struct or union')\n+            raise ValueError(f'member access must be on a struct or union, not {self.type_.name!r}') from None\n         return ProgramObject(self.prog_, member_type, address=address + offset)\n \n     def cast_(self, type: Union[str, Type, TypeName]) -> 'ProgramObject':\n@@ -276,12 +274,12 @@ class ProgramObject:\n             type = self.prog_.type(type)\n         self_real_type = self._real_type\n         if not isinstance(self_real_type, PointerType):\n-            raise ValueError('container_of is only valid on pointers')\n+            raise ValueError(f'container_of_() value must be a pointer, not {self._real_type.name!r}')\n         try:\n             # mypy doesn't understand the except AttributeError.\n             offset = type.real_type().offsetof(member)  # type: ignore\n         except AttributeError:\n-            raise ValueError('container_of is only valid with struct or union types')\n+            raise ValueError(f'container_of_() type must be a struct or union type, not {type.name!r}')\n         return ProgramObject(self.prog_,\n                              PointerType(self_real_type.size, type,\n                                          self_real_type.qualifiers),\n@@ -299,7 +297,7 @@ class ProgramObject:\n                         integer: bool = False) -> 'ProgramObject':\n         if ((integer and not self._real_type.is_integer()) or\n                 (not integer and not self._real_type.is_arithmetic())):\n-            raise TypeError(f\"invalid operand to unary {op_name} ('{self.type_}')\")\n+            raise TypeError(f'invalid operand to unary {op_name} ({self.type_.name!r})')\n         type_ = self.type_.operand_type()\n         if self._real_type.is_integer():\n             type_ = self.prog_._type_index._integer_promotions(type_)\n@@ -337,7 +335,7 @@ class ProgramObject:\n                              lhs: Any, rhs: Any) -> 'ProgramObject':\n         lhs, lhs_type, rhs, rhs_type = self._binary_operands(lhs, rhs)\n         if not lhs_type.is_arithmetic() or not rhs_type.is_arithmetic():\n-            raise TypeError(f\"invalid operands to binary {op_name} ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary {op_name} ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         type_, lhs, rhs = self._usual_arithmetic_conversions(lhs, lhs_type,\n@@ -348,7 +346,7 @@ class ProgramObject:\n                           lhs: Any, rhs: Any) -> 'ProgramObject':\n         lhs, lhs_type, rhs, rhs_type = self._binary_operands(lhs, rhs)\n         if not lhs_type.is_integer() or not rhs_type.is_integer():\n-            raise TypeError(f\"invalid operands to binary {op_name} ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary {op_name} ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         type_, lhs, rhs = self._usual_arithmetic_conversions(lhs, lhs_type,\n@@ -359,7 +357,7 @@ class ProgramObject:\n                         lhs: Any, rhs: Any) -> 'ProgramObject':\n         lhs, lhs_type, rhs, rhs_type = self._binary_operands(lhs, rhs)\n         if not lhs_type.is_integer() or not rhs_type.is_integer():\n-            raise TypeError(f\"invalid operands to binary {op_name} ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary {op_name} ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         lhs_type = self.prog_._type_index._integer_promotions(lhs_type)\n@@ -374,7 +372,7 @@ class ProgramObject:\n         if ((lhs_pointer != rhs_pointer) or\n                 (not lhs_pointer and\n                  (not lhs_type.is_arithmetic() or not rhs_type.is_arithmetic()))):\n-            raise TypeError(f\"invalid operands to binary {op_name} ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary {op_name} ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         if not lhs_pointer:\n@@ -391,7 +389,7 @@ class ProgramObject:\n                 (rhs_pointer and not lhs_type.is_integer()) or\n                 (not lhs_pointer and not rhs_pointer and\n                  (not lhs_type.is_arithmetic() or not rhs_type.is_arithmetic()))):\n-            raise TypeError(f\"invalid operands to binary + ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary + ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         if lhs_pointer:\n@@ -420,7 +418,7 @@ class ProgramObject:\n                 (rhs_pointer and not lhs_pointer) or\n                 (not lhs_pointer and not rhs_pointer and\n                  (not lhs_type.is_arithmetic() or not rhs_type.is_arithmetic()))):\n-            raise TypeError(f\"invalid operands to binary - ('{lhs_type}' and '{rhs_type}')\")\n+            raise TypeError(f'invalid operands to binary - ({lhs_type.name!r} and {rhs_type.name!r})')\n         lhs_type = lhs_type.operand_type()\n         rhs_type = rhs_type.operand_type()\n         if lhs_pointer and rhs_pointer:\n@@ -516,7 +514,7 @@ class ProgramObject:\n     def __bool__(self) -> bool:\n         if (not self._real_type.is_arithmetic() and\n                 not self._real_type.is_pointer_operand()):\n-            raise TypeError(f\"invalid operand to bool() ('{self.type_}')\")\n+            raise TypeError(f'invalid operand to bool() ({self.type_.name!r})')\n         return bool(self.value_())\n \n     def __neg__(self) -> 'ProgramObject':\n@@ -530,22 +528,22 @@ class ProgramObject:\n \n     def __int__(self) -> int:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't convert {self.type_} to int\")\n+            raise TypeError(f'cannot convert {self.type_.name!r} to int')\n         return int(self.value_())\n \n     def __float__(self) -> float:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't convert {self.type_} to float\")\n+            raise TypeError(f'cannot convert {self.type_.name!r} to float')\n         return float(self.value_())\n \n     def __index__(self) -> int:\n         if not self._real_type.is_integer():\n-            raise TypeError(f\"can't convert {self.type_} to index\")\n+            raise TypeError(f'cannot convert {self.type_.name!r} to index')\n         return self.value_()\n \n     def __round__(self, ndigits: Optional[int] = None) -> Union[int, 'ProgramObject']:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't round {self.type_}\")\n+            raise TypeError(f'cannot round {self.type_.name!r}')\n         if ndigits is None:\n             return round(self.value_())\n         return ProgramObject(self.prog_, self.type_,\n@@ -553,17 +551,17 @@ class ProgramObject:\n \n     def __trunc__(self) -> int:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't round {self.type_}\")\n+            raise TypeError(f'cannot round {self.type_.name!r}')\n         return math.trunc(self.value_())\n \n     def __floor__(self) -> int:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't round {self.type_}\")\n+            raise TypeError(f'cannot round {self.type_.name!r}')\n         return math.floor(self.value_())\n \n     def __ceil__(self) -> int:\n         if not self._real_type.is_arithmetic():\n-            raise TypeError(f\"can't round {self.type_}\")\n+            raise TypeError(f'cannot round {self.type_.name!r}')\n         return math.ceil(self.value_())\n \n \ndiff --git a/drgn/type.py b/drgn/type.py\nindex 9f56e903..9c6d98a2 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -91,6 +91,11 @@ class Type:\n             struct dentry *dentry;\n     }\n \n+    A Type has an unqualififed name.\n+\n+    >>> prog['jiffies'].type_.name\n+    'unsigned long'\n+\n     A Type can have qualifiers as is the case in C.\n \n     >>> prog['jiffies'].type_.qualifiers\n@@ -99,6 +104,8 @@ class Type:\n     There are several Type subclasses representing more specific types.\n     \"\"\"\n \n+    name: str\n+\n     def __init__(self, qualifiers: Iterable[str] = frozenset()) -> None:\n         self.qualifiers = frozenset(qualifiers)\n \n@@ -181,7 +188,7 @@ class Type:\n \n     def _convert(self, value: Any) -> Any:\n         \"\"\"Return the given value converted to a valid value of this type.\"\"\"\n-        raise TypeError(f'cannot convert to {self}')\n+        raise TypeError(f'cannot convert to {self.name!r}')\n \n     def _read(self, reader: CoreReader, address: int) -> Any:\n         \"\"\"\n@@ -209,6 +216,8 @@ class VoidType(Type):\n     more information.\n     \"\"\"\n \n+    name = 'void'\n+\n     def type_name(self) -> VoidTypeName:\n         return VoidTypeName(self.qualifiers)\n \n@@ -328,7 +337,7 @@ class IntType(ArithmeticType):\n         try:\n             value = value.__int__()\n         except AttributeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name!r}') from None\n         return _int_convert(value, 8 * self.size, self.signed)\n \n \n@@ -356,7 +365,7 @@ class BoolType(IntType):\n         try:\n             return bool(value + 0)\n         except TypeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name!r}') from None\n \n     def _pretty(self, value: Any, *, cast: bool = True, columns: int = 0,\n                 one_line_columns: Optional[int] = None,\n@@ -388,14 +397,14 @@ class FloatType(ArithmeticType):\n         try:\n             value = value.__float__()\n         except AttributeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name!r}') from None\n         if self.size == 4:\n             # Python doesn't have a native float32 type.\n             return struct.unpack('f', struct.pack('f', value))[0]\n         elif self.size == 8:\n             return value\n         else:\n-            raise ValueError(f\"can't convert to float of size {self.size}\")\n+            raise ValueError(f'cannot convert to float of size {self.size}')\n \n \n class BitFieldType(Type):\n@@ -440,6 +449,10 @@ class BitFieldType(Type):\n         ]\n         return ''.join(parts)\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return f'{self.type.name} : {self.bit_size}'\n+\n     def type_name(self) -> TypeName:\n         raise ValueError(\"can't get type name of bit field\")\n \n@@ -475,7 +488,7 @@ class BitFieldType(Type):\n         try:\n             value = value.__int__()\n         except AttributeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name}') from None\n         return _int_convert(value, self.bit_size, self._int_type.signed)\n \n     def _read(self, reader: CoreReader, address: int) -> int:\n@@ -706,6 +719,10 @@ class StructType(CompoundType):\n     }\n     \"\"\"\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return 'struct ' + (self.tag or '<anonymous>')\n+\n     def type_name(self) -> StructTypeName:\n         return StructTypeName(self.tag, self.qualifiers)\n \n@@ -734,6 +751,10 @@ class UnionType(CompoundType):\n     }\n     \"\"\"\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return 'union ' + (self.tag or '<anonymous>')\n+\n     def type_name(self) -> UnionTypeName:\n         return UnionTypeName(self.tag, self.qualifiers)\n \n@@ -783,8 +804,7 @@ class EnumType(Type):\n         if enumerators is None:\n             self.enum = None\n         else:\n-            self.enum = enum.IntEnum(tag or '', enumerators)  # type: ignore\n-                                                              # mypy issue #4865.\n+            self.enum = enum.IntEnum(tag or '', enumerators)  # type: ignore  # mypy issue #4865\n \n     def __repr__(self) -> str:\n         parts = [\n@@ -812,6 +832,10 @@ class EnumType(Type):\n             parts.append('}')\n         return ''.join(parts)\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return 'enum ' + (self.tag or '<anonymous>')\n+\n     def type_name(self) -> EnumTypeName:\n         return EnumTypeName(self.tag, self.qualifiers)\n \n@@ -870,11 +894,11 @@ class EnumType(Type):\n \n     def _convert(self, value: Any) -> Union[enum.IntEnum, int]:\n         if self.type is None or self.enum is None:\n-            raise ValueError(\"can't convert to incomplete enum type\")\n+            raise ValueError('cannot convert to incomplete enum type')\n         try:\n             value = self.type._convert(value)\n         except TypeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name!r}') from None\n         try:\n             return self.enum(value)\n         except ValueError:\n@@ -1016,6 +1040,10 @@ class PointerType(Type):\n         parts.append(')')\n         return ''.join(parts)\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return self.type_name().declaration('')\n+\n     def type_name(self) -> PointerTypeName:\n         return PointerTypeName(self.type.type_name(), self.qualifiers)\n \n@@ -1069,7 +1097,7 @@ class PointerType(Type):\n         try:\n             return value & ((1 << (8 * self.size)) - 1)\n         except TypeError:\n-            raise TypeError(f'cannot convert to {self}') from None\n+            raise TypeError(f'cannot convert to {self.name!r}') from None\n \n \n class ArrayType(Type):\n@@ -1098,6 +1126,10 @@ class ArrayType(Type):\n     def __repr__(self) -> str:\n         return f'{self.__class__.__name__}({self.type!r}, {self.size!r}, {self.pointer_size!r})'\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return self.type_name().declaration('')\n+\n     def type_name(self) -> ArrayTypeName:\n         return ArrayTypeName(self.type.type_name(), self.size)\n \n@@ -1271,6 +1303,10 @@ class FunctionType(Type):\n         ]\n         return ''.join(parts)\n \n+    @property\n+    def name(self) -> str:  # type: ignore  # mypy issue 4125\n+        return self.type_name().declaration('')\n+\n     def type_name(self) -> TypeName:\n         if self.parameters is None:\n             parameters = None\ndiff --git a/drgn/typeindex.py b/drgn/typeindex.py\nindex fb5f765c..f95cc523 100644\n--- a/drgn/typeindex.py\n+++ b/drgn/typeindex.py\n@@ -183,7 +183,7 @@ class TypeIndex:\n         elif isinstance(value, numbers.Real):\n             return self.find('double')\n         else:\n-            raise TypeError()\n+            raise TypeError(f'cannot create {type(value).__name__} literal')\n \n     def _integer_promotions(self, type_: Type) -> Type:\n         # Integer promotions are performed on types whose integer conversion\n"}
{"repo": "drgn", "commit": "03fd5eeed4edbd73623a0208e096b7301247162f", "diff": "diff --git a/drgn/lib.py b/drgn/lib.py\nindex 690b8837..8f47e0ed 100644\n--- a/drgn/lib.py\n+++ b/drgn/lib.py\n@@ -94,8 +94,8 @@ def _get_fallback_vmcoreinfo() -> Dict[str, Any]:\n             elf_symbol = elf_file.symbols['_stext'][0].st_value\n         except (KeyError, IndexError):\n             raise ValueError('could not find _stext symbol in vmlinux') from None\n-    with open('/proc/kallsyms', 'r') as f:\n-        kallsyms = f.read()\n+    with open('/proc/kallsyms', 'r') as kallsyms_file:\n+        kallsyms = kallsyms_file.read()\n     kallsyms_match = re.search(r'^([0-9a-fA-F]+) . _stext$', kallsyms,\n                                re.MULTILINE)\n     if not kallsyms_match:\n"}
{"repo": "drgn", "commit": "6f14d820242fdbb05ed7c111dfc5195b53c67f7b", "diff": "diff --git a/drgn/internal/memberdesignator.py b/drgn/internal/memberdesignator.py\nindex 00df9779..cb03bb28 100644\n--- a/drgn/internal/memberdesignator.py\n+++ b/drgn/internal/memberdesignator.py\n@@ -66,7 +66,7 @@ def parse_member_designator(string: str) -> List[Tuple[str, Union[str, int]]]:\n             if token.kind == 'RBRACKET':\n                 state = _State.RBRACKET\n             else:\n-                raise ValueError(\"expected '.' or '[' after identifier\")\n-        else:\n+                raise ValueError(\"expected ']' after number\")\n+        else:  # pragma: no cover\n             assert False\n     return designator\ndiff --git a/tests/test_memberdesignator.py b/tests/test_memberdesignator.py\nindex eebeec9d..0c088c0b 100644\n--- a/tests/test_memberdesignator.py\n+++ b/tests/test_memberdesignator.py\n@@ -52,3 +52,7 @@ class TestParseMemberDesignator(unittest.TestCase):\n     def test_double_rbracket(self):\n         self.assertRaisesRegex(ValueError, r\"^expected '\\.' or '\\[' after ']'$\",\n                                parse_member_designator, 'foo[0]]')\n+\n+    def test_missing_rbracket(self):\n+        self.assertRaisesRegex(ValueError, r\"^expected ']' after number$\",\n+                               parse_member_designator, 'foo[0')\n"}
{"repo": "drgn", "commit": "a69a743f553ecce118d484ca7a110be8885fff66", "diff": "diff --git a/tests/test_type.py b/tests/test_type.py\nindex ac70011a..bf7aa2fb 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -79,7 +79,7 @@ color_type = EnumType('color', IntType('unsigned int', 4, False), [\n     ('GREEN', 1),\n     ('BLUE', 2)\n ])\n-const_anonymous_color_type = EnumType(None, IntType('unsigned int', 4, False), [\n+const_anonymous_color_type = EnumType(None, IntType('int', 4, True), [\n     ('RED', 0),\n     ('GREEN', -1),\n     ('BLUE', -2)\n"}
{"repo": "drgn", "commit": "a4ecbff27f988e078e7bdb125c1800dfd62485d4", "diff": "diff --git a/drgn/lib.py b/drgn/lib.py\nindex ccf8d169..7f6b807f 100644\n--- a/drgn/lib.py\n+++ b/drgn/lib.py\n@@ -177,7 +177,7 @@ def program(core: Optional[str] = None, pid: Optional[int] = None,\n             elif file_mappings is None:\n                 raise ValueError('core dump has no NT_FILE or VMCOREINFO note')\n             type_index_ = type_index({mapping.path for mapping in file_mappings},\n-                                    verbose)\n+                                     verbose)\n             variable_index = UserspaceVariableIndex(cast(DwarfTypeIndex, type_index_),\n                                                     file_mappings)\n \ndiff --git a/drgn/program.py b/drgn/program.py\nindex a2097ae0..6bb54dcb 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -678,7 +678,7 @@ class Program:\n         return self._type_index.find(name, filename)\n \n     def variable(self, name: str,\n-                   filename: Optional[str] = None) -> ProgramObject:\n+                 filename: Optional[str] = None) -> ProgramObject:\n         \"\"\"\n         Return a ProgramObject representing the variable or enumerator with the\n         given name.\n"}
{"repo": "drgn", "commit": "f22ff38b286f6c584a259833a1eb8889c423671c", "diff": "diff --git a/drgn/elf.py b/drgn/elf.py\nindex 5470b824..25fb4b47 100644\n--- a/drgn/elf.py\n+++ b/drgn/elf.py\n@@ -377,7 +377,7 @@ class ElfFile:\n                 else:\n                     name = b''\n                 if descsz:\n-                    desc = buf[off:off + descsz - 1]\n+                    desc = buf[off:off + descsz]\n                     off += (descsz + 3) & ~3\n                 else:\n                     desc = b''\n@@ -516,12 +516,10 @@ class ElfFile:\n         i = header_size + struct.calcsize(fmt) * count\n         list = []\n         for start, end, offset in struct.iter_unpack('=QQQ', data[header_size:i]):\n-            if i >= len(data):\n-                raise ElfFormatError('invalid NT_FILE note')\n             try:\n                 j = data.index(b'\\0', i)\n             except ValueError:\n-                j = len(data)\n+                raise ElfFormatError('invalid NT_FILE note')\n             path = os.fsdecode(data[i:j])\n             i = j + 1\n             list.append(FileMapping(path, start, end, page_size * offset))\n"}
{"repo": "drgn", "commit": "7613fe0e36dac1e51dc906281dc7fafb782c1989", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 95758d63..b8811e43 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -10,16 +10,7 @@ import operator\n from typing import cast, Any, Callable, Iterable, Optional, Tuple, Union\n \n from drgn.corereader import CoreReader\n-from drgn.type import (\n-    ArithmeticType,\n-    BitFieldType,\n-    ArrayType,\n-    CompoundType,\n-    IntType,\n-    PointerType,\n-    Type,\n-    TypedefType,\n-)\n+from drgn.type import ArrayType, CompoundType, IntType, PointerType, Type\n from drgn.typename import TypeName\n from drgn.typeindex import TypeIndex\n from drgn.util import c_string\n@@ -536,8 +527,8 @@ class ProgramObject:\n         return self._relational_operator(operator.ge, '>=', other)\n \n     def __bool__(self) -> bool:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType,\n-                                            PointerType)):\n+        if (not self._real_type.is_arithmetic() and\n+                not self._real_type.is_pointer()):\n             raise TypeError(f\"invalid operand to bool() ('{self.type_}')\")\n         return bool(self.value_())\n \n@@ -551,22 +542,22 @@ class ProgramObject:\n         return self._unary_operator(operator.invert, '~', True)\n \n     def __int__(self) -> int:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't convert {self.type_} to int\")\n         return int(self.value_())\n \n     def __float__(self) -> float:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't convert {self.type_} to float\")\n         return float(self.value_())\n \n     def __index__(self) -> int:\n-        if not isinstance(self._real_type, (IntType, BitFieldType)):\n+        if not self._real_type.is_integer():\n             raise TypeError(f\"can't convert {self.type_} to index\")\n         return self.value_()\n \n     def __round__(self, ndigits: Optional[int] = None) -> Union[int, 'ProgramObject']:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't round {self.type_}\")\n         if ndigits is None:\n             return round(self.value_())\n@@ -574,17 +565,17 @@ class ProgramObject:\n                              value=round(self.value_(), ndigits))\n \n     def __trunc__(self) -> int:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't round {self.type_}\")\n         return math.trunc(self.value_())\n \n     def __floor__(self) -> int:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't round {self.type_}\")\n         return math.floor(self.value_())\n \n     def __ceil__(self) -> int:\n-        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+        if not self._real_type.is_arithmetic():\n             raise TypeError(f\"can't round {self.type_}\")\n         return math.ceil(self.value_())\n \n"}
{"repo": "drgn", "commit": "0190467ee6846e598148de007b85b444bdf0dee8", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 4f9255cb..fd0d61dc 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -20,7 +20,8 @@ from drgn.elf import ElfFile, ET_CORE, PT_LOAD\n from drgn.kernelvariableindex import KernelVariableIndex\n from drgn.program import Program, ProgramObject\n from drgn.type import Type\n-from drgn.typeindex import DwarfTypeIndex\n+from drgn.typeindex import DwarfTypeIndex, TypeIndex\n+from drgn.variableindex import VariableIndex\n \n \n def displayhook(value: Any) -> None:\n@@ -51,7 +52,7 @@ def find_vmlinux(release: str) -> str:\n         if os.path.exists(path):\n             return path\n     else:\n-        raise ValueError()\n+        raise ValueError('could not find vmlinux file')\n \n \n def find_modules(release: str) -> List[str]:\n@@ -99,6 +100,34 @@ def parse_vmcoreinfo(data: bytes) -> Dict[str, Any]:\n     return fields\n \n \n+def index_kernel(vmcoreinfo: Dict[str, Any],\n+                 verbose: bool) -> Tuple[TypeIndex, VariableIndex]:\n+    vmlinux = find_vmlinux(vmcoreinfo['OSRELEASE'])\n+    modules = find_modules(vmcoreinfo['OSRELEASE'])\n+    if not modules and verbose:\n+        print('Could not find kernel modules; continuing anyways',\n+              file=sys.stderr)\n+    dwarf_index = DwarfIndex(vmlinux, *modules)\n+    indexed_files = dwarf_index.files\n+    if len(indexed_files) < len(modules) + 1:\n+        if vmlinux not in indexed_files:\n+            raise ValueError('vmlinux does not have debugging symbols')\n+        elif verbose:\n+            missing = set(modules) - set(indexed_files)\n+            num_missing = len(missing)\n+            print(f\"Missing symbols for {num_missing} module{'' if num_missing == 1 else 's'}:\",\n+                  file=sys.stderr)\n+            for i, m in enumerate(sorted(missing)):\n+                if i == 5:\n+                    print('...', file=sys.stderr)\n+                    break\n+                print(m, file=sys.stderr)\n+    type_index = DwarfTypeIndex(dwarf_index)\n+    variable_index = KernelVariableIndex(type_index,\n+                                         vmcoreinfo.get('KERNELOFFSET', 0))\n+    return type_index, variable_index\n+\n+\n def main() -> None:\n     python_version = '.'.join(str(v) for v in sys.version_info[:3])\n     version = f'drgn {drgn.__version__} (using Python {python_version})'\n@@ -110,9 +139,6 @@ def main() -> None:\n     parser.add_argument(\n         '-c', '--core', metavar='PATH', type=str,\n         help='use the given core file (default: /proc/kcore in kernel mode)')\n-    parser.add_argument(\n-        '-e', '--executable', metavar='PATH', type=str,\n-        help='use the given executable file')\n     parser.add_argument(\n         'script', metavar='ARG', type=str, nargs='*',\n         help='script to execute instead of running in interactive mode')\n@@ -144,26 +170,15 @@ def main() -> None:\n                     break\n             else:\n                 sys.exit('Could not find VMCOREINFO note; not a kernel vmcore?')\n-        vmcoreinfo = parse_vmcoreinfo(vmcoreinfo_data)\n \n-        release = vmcoreinfo['OSRELEASE']\n-        if args.executable is None:\n-            try:\n-                args.executable = find_vmlinux(release)\n-            except ValueError:\n-                sys.exit('Could not find vmlinux file; install the proper debuginfo package or use --executable')\n+        vmcoreinfo = parse_vmcoreinfo(vmcoreinfo_data)\n+        type_index, variable_index = index_kernel(vmcoreinfo,\n+                                                  verbose=not args.script)\n \n-        modules = find_modules(release)\n-        if not modules and not args.script:\n-            print('Could not find kernel modules; continuing anyways',\n-                  file=sys.stderr)\n-        dwarf_index = DwarfIndex(args.executable, *modules)\n-        type_index = DwarfTypeIndex(dwarf_index)\n-        variable_index = KernelVariableIndex(type_index,\n-                                             vmcoreinfo.get('KERNELOFFSET', 0))\n         prog = Program(reader=core_reader, type_index=type_index,\n                        variable_index=variable_index)\n-        variable_index.set_program(prog)\n+        if isinstance(variable_index, KernelVariableIndex):\n+            variable_index.set_program(prog)\n \n         init_globals: Dict[str, Any] = {'drgn': drgn, 'prog': prog}\n         if args.script:\n"}
{"repo": "drgn", "commit": "06064fa988e613d425834c7a0078fbd5b363db4a", "diff": "diff --git a/drgn/elf.py b/drgn/elf.py\nindex d012abfd..398df9d1 100644\n--- a/drgn/elf.py\n+++ b/drgn/elf.py\n@@ -253,7 +253,7 @@ class ElfFile:\n             else:\n                 section_name = ''\n             # mypy claims 'Too many arguments for \"Elf_Shdr\"'\n-            shdrs.append(Elf_Shdr(*raw_shdr, section_name)) # type: ignore\n+            shdrs.append(Elf_Shdr(*raw_shdr, section_name))  # type: ignore\n         return shdrs\n \n     @property\n"}
{"repo": "drgn", "commit": "8bca8f264cba9f39e9d6dd1265636aa04f222172", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex ecfccb38..359050bc 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -107,7 +107,6 @@ class Type:\n     def __repr__(self) -> str:\n         parts = [self.__class__.__name__, '(']\n         if self.qualifiers:\n-            parts.append(', ')\n             parts.append(repr(self.qualifiers))\n         parts.append(')')\n         return ''.join(parts)\n"}
{"repo": "drgn", "commit": "80cb79adf6cb26a79a27f880430811fbaefd3d2f", "diff": "diff --git a/drgn/helpers/kernel/fs.py b/drgn/helpers/kernel/fs.py\nindex 2594829e..b3c15b2a 100644\n--- a/drgn/helpers/kernel/fs.py\n+++ b/drgn/helpers/kernel/fs.py\n@@ -23,7 +23,7 @@ __all__ = [\n ]\n \n \n-def d_path(path_or_mnt, dentry=None):\n+def d_path(path_or_vfsmnt, dentry=None):\n     \"\"\"\n     char *d_path(struct path *)\n     char *d_path(struct vfsmount *, struct dentry *)\n@@ -31,13 +31,14 @@ def d_path(path_or_mnt, dentry=None):\n     Return the full path of a dentry given a struct path or a mount and a\n     dentry.\n     \"\"\"\n-    type_name = str(path_or_mnt.type_.type_name())\n+    type_name = str(path_or_vfsmnt.type_.type_name())\n     if type_name == 'struct path' or type_name == 'struct path *':\n-        mnt = path_or_mnt.mnt.read_once_()\n-        dentry = path_or_mnt.dentry.read_once_()\n+        vfsmnt = path_or_vfsmnt.mnt\n+        dentry = path_or_vfsmnt.dentry.read_once_()\n     else:\n-        mnt = path_or_mnt.read_once_()\n+        vfsmnt = path_or_vfsmnt\n         dentry = dentry.read_once_()\n+    mnt = vfsmnt.container_of_('struct mount', 'mnt')\n \n     components = []\n     while True:\n@@ -48,10 +49,10 @@ def d_path(path_or_mnt, dentry=None):\n             components.append(dentry.d_name.name.string_())\n             components.append(b'/')\n             dentry = d_parent\n-        dentry = mnt.mnt_mountpoint\n         mnt_parent = mnt.mnt_parent.read_once_()\n         if mnt == mnt_parent:\n             break\n+        dentry = mnt.mnt_mountpoint\n         mnt = mnt_parent\n     if components:\n         return b''.join(reversed(components))\n@@ -129,7 +130,7 @@ def for_each_mount(prog_or_ns, src=None, dst=None, fstype=None):\n         mnt_src = mnt.mnt_devname.string_()\n         if src is not None and mnt_src != src:\n             continue\n-        mnt_dst = d_path(mnt, mnt.mnt.mnt_root)\n+        mnt_dst = d_path(mnt.mnt.address_of_(), mnt.mnt.mnt_root)\n         if dst is not None and mnt_dst != dst:\n             continue\n         sb = mnt.mnt.mnt_sb.read_once_()\n"}
{"repo": "drgn", "commit": "32974c3c984b0c2184f38f17875752d3829f5519", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 3dac5dd8..bf8ac57e 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -108,6 +108,7 @@ def main() -> None:\n         symbols = parse_symbol_file(f)\n \n     core_reader = CoreReader('/proc/kcore')\n+\n     def lookup_variable(name: str) -> Tuple[int, Type]:\n         address = symbols[name][-1]\n         dwarf_type = dwarf_index.find(name, DW_TAG.variable).type()\ndiff --git a/drgn/memberdesignator.py b/drgn/memberdesignator.py\nindex 03c74c41..148d62ec 100644\n--- a/drgn/memberdesignator.py\n+++ b/drgn/memberdesignator.py\n@@ -18,7 +18,6 @@ class _State(enum.IntEnum):\n     RBRACKET = 5\n \n \n-\n _TOKEN_REGEX = re.compile('|'.join('(?P<%s>%s)' % pair for pair in [\n     ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'),\n     ('NUMBER',     r'(?:0x)?[0-9]+'),\ndiff --git a/drgn/type.py b/drgn/type.py\nindex 505fbefa..ecfccb38 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -723,7 +723,7 @@ class EnumType(Type):\n     def __init__(self, name: Optional[str], type: Optional[IntType],\n                  enumerators: Optional[List[Tuple[str, int]]],\n                  qualifiers: FrozenSet[str] = frozenset()) -> None:\n-        if type is None != enumerators is None:\n+        if (type is None) != (enumerators is None):\n             raise ValueError('incomplete enum type must not have type or enumerators')\n         super().__init__(qualifiers)\n         self.name = name\n@@ -922,7 +922,7 @@ class PointerType(Type):\n         super().__init__(qualifiers)\n         self.size = size\n         self.type = type\n-        setattr(self, 'read',_INT_READ[size, False])\n+        setattr(self, 'read', _INT_READ[size, False])\n \n     def __repr__(self) -> str:\n         parts = [\ndiff --git a/drgn/typename.py b/drgn/typename.py\nindex 8fd6a610..4243027e 100644\n--- a/drgn/typename.py\n+++ b/drgn/typename.py\n@@ -212,7 +212,7 @@ class _TypeNameParser:\n             elif size is not None:\n                 raise _TypeNameParser._specifier_error(size, specifier)\n             if (data_type is not None and data_type != 'int' and\n-                  (data_type != 'double' or specifier != 'long')):\n+                    (data_type != 'double' or specifier != 'long')):\n                 raise _TypeNameParser._specifier_error(data_type, specifier)\n             specifiers['size'] = specifier\n         elif specifier == 'signed' or specifier == 'unsigned':\n@@ -256,7 +256,7 @@ class _TypeNameParser:\n             # First, the sign specifier. \"signed\" is the default for \"int\", so\n             # omit it.\n             if ('sign' in specifiers and\n-                (specifiers['sign'] != 'signed' or data_type != 'int')):\n+                    (specifiers['sign'] != 'signed' or data_type != 'int')):\n                 parts.append(specifiers['sign'])\n             # Then, the size specifier.\n             if 'size' in specifiers:\n@@ -348,7 +348,7 @@ class _TypeNameParser:\n             self._lexer.pop()\n             token2 = self._lexer.peek()\n             if (token2.kind == 'ASTERISK' or token2.kind == 'LPAREN' or\n-                token2.kind == 'LBRACKET'):\n+                    token2.kind == 'LBRACKET'):\n                 type_name, inner_type = self._parse_abstract_declarator(type_name)\n                 if self._lexer.pop().kind != 'RPAREN':\n                     raise ValueError(\"expected ')'\")\n"}
{"repo": "drgn", "commit": "a7448f4ce6f5728181e414acc4642d1c33e41eb4", "diff": "diff --git a/drgn/cli.py b/drgn/cli.py\nindex 0c1e97e9..3dac5dd8 100644\n--- a/drgn/cli.py\n+++ b/drgn/cli.py\n@@ -25,7 +25,7 @@ from drgn.util import parse_symbol_file\n def displayhook(value: Any) -> None:\n     if value is None:\n         return\n-    builtins._ = None\n+    setattr(builtins, '_', None)\n     text = str(value) if isinstance(value, (ProgramObject, Type)) else repr(value)\n     try:\n         sys.stdout.write(text)\n@@ -37,7 +37,7 @@ def displayhook(value: Any) -> None:\n             text = encoded.decode(sys.stdout.encoding, 'strict')\n             sys.stdout.write(text)\n     sys.stdout.write('\\n')\n-    builtins._ = value\n+    setattr(builtins, '_', value)\n \n \n def find_vmlinux(release: str) -> str:\n"}
{"repo": "drgn", "commit": "52052959aeed84c831a7c3538fa4d26233ddf321", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 091dddff..5ae8f6a1 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -114,8 +114,10 @@ class ProgramObject:\n         except ValueError as e:\n             if e.args == ('not a struct or union',):\n                 raise AttributeError(f'{self.__class__.__name__!r} object has no attribute {name!r}') from None\n+            elif e.args and 'has no member' in e.args[0]:\n+                raise AttributeError(e.args[0]) from None\n             else:\n-                raise AttributeError(*e.args) from None\n+                raise\n \n     def __len__(self) -> int:\n         if not isinstance(self._real_type, ArrayType) or self._real_type.size is None:\n"}
{"repo": "drgn", "commit": "de5bb2c887ac3947e045f40e108f8d1a027aec5c", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex bb517c30..c5104118 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -101,7 +101,7 @@ class ProgramObject:\n         return attrs\n \n     def __getattr__(self, name: str) -> 'ProgramObject':\n-        \"\"\"Implement self.name. Shortcurt for self.member_(name).\"\"\"\n+        \"\"\"Implement self.name. Shortcut for self.member_(name).\"\"\"\n         if isinstance(self._real_type, PointerType):\n             type_ = self._real_type.type\n         else:\n"}
{"repo": "drgn", "commit": "467fc66ef3a5d277408f9575b9ee5cd14ac4f5c0", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex 7cf2d303..d0b0704c 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -549,7 +549,7 @@ class CompoundType(Type):\n             real_type = type_.real_type()\n             if op == '.':\n                 if not isinstance(real_type, CompoundType):\n-                    raise ValueError('{str(type_.type_name())!r} is not a struct or union')\n+                    raise ValueError(f'{str(type_.type_name())!r} is not a struct or union')\n                 try:\n                     member_offset, type_thunk = real_type._members_by_name[cast(str, value)]\n                 except KeyError:\n@@ -558,7 +558,7 @@ class CompoundType(Type):\n                 offset += member_offset\n             else:  # op == '[]'\n                 if not isinstance(real_type, ArrayType):\n-                    raise ValueError('{str(type_.type_name())!r} is not an array')\n+                    raise ValueError(f'{str(type_.type_name())!r} is not an array')\n                 type_ = real_type.type\n                 offset += cast(int, value) * type_.sizeof()\n         return type_, offset\n"}
{"repo": "drgn", "commit": "e327aef8603ba25690e1f68c2ccc0a59f367b4a4", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 8c9b67ee..bb517c30 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -529,17 +529,28 @@ class ProgramObject:\n             raise TypeError(f\"can't convert {self.type_} to index\")\n         return self.value_()\n \n-    def __round__(self, ndigits: Optional[int] = None) -> Union[int, float]:\n-        return round(self.__float__(), ndigits)\n+    def __round__(self, ndigits: Optional[int] = None) -> Union[int, 'ProgramObject']:\n+        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+            raise TypeError(f\"can't round {self.type_}\")\n+        if ndigits is None:\n+            return round(self.value_())\n+        return ProgramObject(self.program_, self.type_, None,\n+                             round(self.value_(), ndigits))\n \n     def __trunc__(self) -> int:\n-        return math.trunc(self.__float__())\n+        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+            raise TypeError(f\"can't round {self.type_}\")\n+        return math.trunc(self.value_())\n \n     def __floor__(self) -> int:\n-        return math.floor(self.__float__())\n+        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+            raise TypeError(f\"can't round {self.type_}\")\n+        return math.floor(self.value_())\n \n     def __ceil__(self) -> int:\n-        return math.ceil(self.__float__())\n+        if not isinstance(self._real_type, (ArithmeticType, BitFieldType)):\n+            raise TypeError(f\"can't round {self.type_}\")\n+        return math.ceil(self.value_())\n \n \n class Program:\ndiff --git a/tests/test_program.py b/tests/test_program.py\nindex 10be8642..2c87a4fa 100644\n--- a/tests/test_program.py\n+++ b/tests/test_program.py\n@@ -77,6 +77,7 @@ class TestProgramObject(TypeIndexTestCase):\n             self.assertEqual(float(obj), 1.0)\n             self.assertEqual(obj.__index__(), 1)\n             self.assertEqual(round(obj), 1)\n+            self.assertEqual(round(obj, 0), ProgramObject(self.program, obj.type_, None, obj.value_()))\n             self.assertEqual(math.trunc(obj), 1)\n             self.assertEqual(math.floor(obj), 1)\n             self.assertEqual(math.ceil(obj), 1)\n@@ -96,7 +97,8 @@ class TestProgramObject(TypeIndexTestCase):\n         self.assertEqual(float(obj), 1.5)\n         self.assertRaises(TypeError, obj.__index__)\n         self.assertEqual(round(obj), 2)\n-        self.assertEqual(round(obj, 1), 1.5)\n+        self.assertEqual(round(obj, 0), ProgramObject(self.program, TYPES['double'], None, 2))\n+        self.assertEqual(round(obj, 1), ProgramObject(self.program, TYPES['double'], None, 1.5))\n         self.assertEqual(math.trunc(obj), 1)\n         self.assertEqual(math.floor(obj), 1)\n         self.assertEqual(math.ceil(obj), 2)\n"}
{"repo": "drgn", "commit": "3d5af98a903b0f8074e5f0067061da8d267bb47c", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex f70998c3..e3eedbef 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -412,10 +412,11 @@ _TypeThunk = Callable[[], Type]\n class CompoundType(Type):\n     \"\"\"\n     A CompoundType represents a type with members. It has a name, a size,\n-    members, and qualifiers. See help(Type) for more information.\n+    members, and qualifiers. The name may be None, which indicates an anonymous\n+    type. See help(Type) for more information.\n     \"\"\"\n \n-    def __init__(self, name: str, size: int,\n+    def __init__(self, name: Optional[str], size: Optional[int],\n                  members: Optional[List[Tuple[str, int, _TypeThunk]]],\n                  qualifiers: FrozenSet[str] = frozenset()) -> None:\n         super().__init__(qualifiers)\n@@ -490,6 +491,8 @@ class CompoundType(Type):\n         return self.size\n \n     def read(self, buffer: bytes, offset: int = 0) -> Dict:\n+        if self.size is None:\n+            raise ValueError(\"can't read incomplete type\")\n         if len(buffer) - offset < self.size:\n             raise ValueError(f'buffer must be at least {self.size} bytes')\n         return OrderedDict([\n@@ -672,7 +675,7 @@ class EnumType(Type):\n \n     def read(self, buffer: bytes, offset: int = 0) -> Union[enum.IntEnum, int]:\n         if self.type is None or self.enum is None:\n-            raise ValueError(\"can't read incomplete enum type\")\n+            raise ValueError(\"can't read incomplete type\")\n         value = self.type.read(buffer, offset)\n         try:\n             return self.enum(value)\ndiff --git a/drgn/typeindex.py b/drgn/typeindex.py\nindex f7dff6d7..ba1a7a7e 100644\n--- a/drgn/typeindex.py\n+++ b/drgn/typeindex.py\n@@ -465,6 +465,8 @@ class DwarfTypeIndex(TypeIndex):\n             tag = DW_TAG.typedef\n         else:\n             assert False\n+        if type_name.name is None:\n+            raise ValueError(\"can't find anonymous type\")\n         if dwarf_type is None:\n             dwarf_type = self._dwarf_index.find(type_name.name, tag)\n         return self.find_dwarf_type(dwarf_type, type_name.qualifiers)\ndiff --git a/drgn/typename.py b/drgn/typename.py\nindex de9bd110..df2540dd 100644\n--- a/drgn/typename.py\n+++ b/drgn/typename.py\n@@ -16,7 +16,7 @@ from typing import (\n \n \n class TypeName:\n-    def __init__(self, name: str,\n+    def __init__(self, name: Optional[str],\n                  qualifiers: FrozenSet[str] = frozenset()) -> None:\n         self.name = name\n         self.qualifiers = qualifiers\n@@ -34,6 +34,7 @@ class TypeName:\n \n     def declaration(self, name: str) -> str:\n         parts = sorted(self.qualifiers)\n+        assert self.name is not None\n         parts.append(self.name)\n         if name:\n             parts.append(name)\n@@ -46,14 +47,18 @@ class VoidTypeName(TypeName):\n \n \n class BasicTypeName(TypeName):\n-    pass\n+    name: str\n+\n+    def __init__(self, name: str,\n+                 qualifiers: FrozenSet[str] = frozenset()) -> None:\n+        super().__init__(name, qualifiers)\n \n \n-def _tagged_declaration(keyword: str, tag: str, name: str,\n+def _tagged_declaration(keyword: str, tag: Optional[str], name: str,\n                         qualifiers: FrozenSet[str]) -> str:\n     parts = sorted(qualifiers)\n     parts.append(keyword)\n-    if tag:\n+    if tag is not None:\n         parts.append(tag)\n     if name:\n         parts.append(name)\n"}
{"repo": "drgn", "commit": "90ca412a3357b8531682e06c07b0133beb907ec4", "diff": "diff --git a/drgn/typeindex.py b/drgn/typeindex.py\nindex 610a256e..f7dff6d7 100644\n--- a/drgn/typeindex.py\n+++ b/drgn/typeindex.py\n@@ -4,7 +4,17 @@\n import functools\n import itertools\n import numbers\n-from typing import Any, Dict, FrozenSet, List, Optional, Tuple, Union, overload\n+from typing import (\n+    Any,\n+    Dict,\n+    FrozenSet,\n+    List,\n+    Optional,\n+    Tuple,\n+    Union,\n+    cast,\n+    overload,\n+)\n \n from drgn.dwarf import (\n     Die,\n@@ -45,10 +55,6 @@ from drgn.typename import (\n )\n \n \n-_IntegerOperandType = Union[IntType, BitFieldType, EnumType, TypedefType]\n-_RealOperandType = Union[ArithmeticType, BitFieldType, EnumType, TypedefType]\n-\n-\n _INTEGER_CONVERSION_RANKS = {\n     '_Bool': 0,\n     'char': 1,\n@@ -243,16 +249,19 @@ class TypeIndex:\n         else:\n             raise TypeError()\n \n-    def integer_promotions(self, type_: _IntegerOperandType) -> _IntegerOperandType:\n+    def integer_promotions(self, type_: Type) -> Type:\n         # Integer promotions are performed on types whose integer conversion\n         # rank is less than or equal to the rank of int and unsigned int and\n         # bit-fields. GCC and Clang always convert enums to their compatible\n         # type.\n \n+        if not isinstance(type_, (IntType, BitFieldType, EnumType, TypedefType)):\n+            return type_\n+\n         real_type = type_.real_type()\n \n         if not isinstance(real_type, (IntType, BitFieldType, EnumType)):\n-            raise ValueError('cannot promote non-integer type')\n+            return type_\n \n         if isinstance(real_type, BitFieldType):\n             int_type = self.find_type('int')\n@@ -291,11 +300,14 @@ class TypeIndex:\n         assert isinstance(unsigned_int_type, IntType)\n         return unsigned_int_type\n \n-    def common_real_type(self, type1: _RealOperandType,\n-                         type2: _RealOperandType) -> _RealOperandType:\n+    def common_real_type(self, type1: Type, type2: Type) -> Type:\n         real_type1 = type1.real_type()\n         real_type2 = type2.real_type()\n \n+        if (not isinstance(real_type1, (ArithmeticType, BitFieldType, EnumType)) or\n+                not isinstance(real_type2, (ArithmeticType, BitFieldType, EnumType))):\n+            raise TypeError('operands must have real types')\n+\n         float1 = real_type1.name if isinstance(real_type1, FloatType) else None\n         float2 = real_type2.name if isinstance(real_type2, FloatType) else None\n         if float1 is not None or float2 is not None:\n@@ -316,18 +328,14 @@ class TypeIndex:\n                 return type2\n             raise ValueError('unknown floating-point types')\n \n-        assert isinstance(type1, (IntType, BitFieldType, EnumType, TypedefType))\n-        assert isinstance(type2, (IntType, BitFieldType, EnumType, TypedefType))\n-\n         # Otherwise, the integer promotions are performed before applying the\n         # following rules.\n-        type1 = self.integer_promotions(type1)\n-        type2 = self.integer_promotions(type2)\n-        real_type1 = type1.real_type()\n-        real_type2 = type2.real_type()\n-\n-        assert isinstance(real_type1, (IntType, BitFieldType))\n-        assert isinstance(real_type2, (IntType, BitFieldType))\n+        type1 = cast(Union[IntType, BitFieldType, TypedefType],\n+                     self.integer_promotions(type1))\n+        type2 = cast(Union[IntType, BitFieldType, TypedefType],\n+                     self.integer_promotions(type2))\n+        real_type1 = cast(Union[IntType, BitFieldType], type1.real_type())\n+        real_type2 = cast(Union[IntType, BitFieldType], type2.real_type())\n \n         # If both operands have the same type, then no further conversions are\n         # needed.\n@@ -377,8 +385,9 @@ class TypeIndex:\n         if not signed2 and rank2 >= rank1:\n             return type2\n \n-        assert isinstance(real_type1, (IntType, BitFieldType))\n-        assert isinstance(real_type2, (IntType, BitFieldType))\n+        # Not sure why mypy needs to be reminded here.\n+        real_type1 = cast(Union[IntType, BitFieldType], real_type1)\n+        real_type2 = cast(Union[IntType, BitFieldType], real_type2)\n \n         # Otherwise, if the type of the operand with signed integer type can\n         # represent all of the values of the type of the operand with unsigned\ndiff --git a/tests/test_typeindex.py b/tests/test_typeindex.py\nindex d55b531c..48abacfb 100644\n--- a/tests/test_typeindex.py\n+++ b/tests/test_typeindex.py\n@@ -294,6 +294,10 @@ class TestTypeIndexIntegerPromotions(TypeIndexTestCase):\n         type_ = TypedefType('LONG', TYPES['long'])\n         self.assertPromotes(type_, type_)\n \n+    def test_other(self):\n+        self.assertPromotes(TYPES['float'], TYPES['float'])\n+        self.assertPromotes(TYPES['double'], TYPES['double'])\n+\n \n class TestTypeIndexCommonRealType(TypeIndexTestCase):\n     def assertCommon(self, type1, type2, expected_type):\n"}
{"repo": "drgn", "commit": "10cf1097b5521bdd0d2fe64ec99e601846253940", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 57dc1d6d..8c9b67ee 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -144,7 +144,7 @@ class ProgramObject:\n     def __iter__(self) -> Iterable['ProgramObject']:\n         if not isinstance(self._real_type, ArrayType) or self._real_type.size is None:\n             raise ValueError(f'{str(self.type_.type_name())!r} is not iterable')\n-        address = self.address_\n+        assert self.address_ is not None  # Array rvalues are not allowed\n         type_ = self._real_type.type\n         for i in range(self._real_type.size):\n             address = self.address_ + i * type_.sizeof()\n@@ -197,6 +197,7 @@ class ProgramObject:\n         if isinstance(self._real_type, PointerType):\n             addresses: Iterable[int] = itertools.count(self.value_())\n         elif isinstance(self._real_type, ArrayType):\n+            assert self.address_ is not None  # Array rvalues are not allowed\n             if self._real_type.size is None:\n                 addresses = itertools.count(self.address_)\n             else:\n"}
{"repo": "drgn", "commit": "6e208005a2d0dd79829411e2775310b3ef79971d", "diff": "diff --git a/drgn/typeindex.py b/drgn/typeindex.py\nindex b69a7342..610a256e 100644\n--- a/drgn/typeindex.py\n+++ b/drgn/typeindex.py\n@@ -4,7 +4,7 @@\n import functools\n import itertools\n import numbers\n-from typing import Any, Dict, FrozenSet, List, Optional, Tuple, Union\n+from typing import Any, Dict, FrozenSet, List, Optional, Tuple, Union, overload\n \n from drgn.dwarf import (\n     Die,\n@@ -101,18 +101,20 @@ def _can_represent_all_values(type1: Union[IntType, BitFieldType],\n         return False\n \n \n+@overload\n+def _corresponding_unsigned_type(type_: IntType) -> IntType: ...\n+@overload\n+def _corresponding_unsigned_type(type_: BitFieldType) -> BitFieldType: ...\n def _corresponding_unsigned_type(type_: Union[IntType, BitFieldType]) -> Union[IntType, BitFieldType]:\n     if isinstance(type_, BitFieldType):\n         if type_.type.signed:\n             underlying_type = _corresponding_unsigned_type(type_.type)\n-            assert isinstance(underlying_type, IntType)\n             return BitFieldType(underlying_type, None, type_.bit_size)\n         else:\n             return type_\n     elif isinstance(type_, BoolType):\n         return type_\n     else:\n-        assert isinstance(type_, IntType)\n         if type_.signed:\n             return IntType('unsigned ' + type_.name, type_.size, False)\n         else:\n@@ -154,6 +156,27 @@ class TypeIndex:\n             pass\n         return self.find_type('long')\n \n+    @overload\n+    def operand_type(self, type_: VoidType) -> VoidType: ...\n+    @overload\n+    def operand_type(self, type_: BoolType) -> BoolType: ...\n+    @overload\n+    def operand_type(self, type_: IntType) -> IntType: ...\n+    @overload\n+    def operand_type(self, type_: FloatType) -> FloatType: ...\n+    @overload\n+    def operand_type(self, type_: BitFieldType) -> BitFieldType: ...\n+    @overload\n+    def operand_type(self, type_: EnumType) -> EnumType: ...\n+    @overload\n+    def operand_type(self, type_: StructType) -> StructType: ...\n+    @overload\n+    def operand_type(self, type_: UnionType) -> UnionType: ...\n+    @overload\n+    def operand_type(self, type_: Union[PointerType, ArrayType, FunctionType]) -> PointerType:\n+        ...\n+    @overload\n+    def operand_type(self, type_: Type) -> Type: ...\n     def operand_type(self, type_: Type) -> Type:\n         if isinstance(type_, VoidType):\n             if type_.qualifiers:\n@@ -161,10 +184,6 @@ class TypeIndex:\n         elif isinstance(type_, BoolType):\n             if type_.qualifiers:\n                 return BoolType(type_.name, type_.size)\n-        elif isinstance(type_, EnumType):\n-            if type_.qualifiers:\n-                return EnumType(type_.name, type_.type,\n-                                None if type_.enum is None else type_.enum.__members__)\n         elif isinstance(type_, IntType):\n             if type_.qualifiers:\n                 return IntType(type_.name, type_.size, type_.signed)\n@@ -173,9 +192,12 @@ class TypeIndex:\n                 return FloatType(type_.name, type_.size)\n         elif isinstance(type_, BitFieldType):\n             if type_.type.qualifiers:\n-                type2 = self.operand_type(type_.type)\n-                assert isinstance(type2, IntType)\n-                return BitFieldType(type2, type_.bit_offset, type_.bit_size)\n+                int_type = self.operand_type(type_.type)\n+                return BitFieldType(int_type, type_.bit_offset, type_.bit_size)\n+        elif isinstance(type_, EnumType):\n+            if type_.qualifiers:\n+                return EnumType(type_.name, type_.type,\n+                                None if type_.enum is None else type_.enum.__members__)\n         elif isinstance(type_, StructType):\n             if type_.qualifiers:\n                 return StructType(type_.name, type_.size, type_._members)\n@@ -464,6 +486,8 @@ class DwarfTypeIndex(TypeIndex):\n             except (DwarfAttribNotFoundError, ValueError):\n                 pass\n \n+        name: Optional[str]\n+        size: Optional[int]\n         if dwarf_type.tag == DW_TAG.base_type:\n             encoding = dwarf_type.find_constant(DW_AT.encoding)\n             name = str(parse_type_name(dwarf_type.name()))\n@@ -517,23 +541,24 @@ class DwarfTypeIndex(TypeIndex):\n                 return UnionType(name, size, members, qualifiers)  # type: ignore\n                                                                    # mypy issue #1484\n         elif dwarf_type.tag == DW_TAG.enumeration_type:\n+            try:\n+                name = dwarf_type.name()\n+            except DwarfAttribNotFoundError:\n+                name = None\n             if dwarf_type.find_flag(DW_AT.declaration):\n-                int_type = None\n-                enumerators = None\n+                return EnumType(name, None, None, qualifiers)\n             else:\n                 int_type = self.find_dwarf_type(dwarf_type.type())\n+                if not isinstance(int_type, IntType):\n+                    raise DwarfFormatError('enum compatible type is not an integer type')\n                 enumerators = []\n                 for child in dwarf_type.children():\n                     if child.tag != DW_TAG.enumerator:\n                         continue\n-                    name = child.name()\n-                    value = child.find_constant(DW_AT.const_value)\n-                    enumerators.append((name, value))\n-            try:\n-                name = dwarf_type.name()\n-            except DwarfAttribNotFoundError:\n-                name = None\n-            return EnumType(name, int_type, enumerators, qualifiers)\n+                    enumerator_name = child.name()\n+                    enumerator_value = child.find_constant(DW_AT.const_value)\n+                    enumerators.append((enumerator_name, enumerator_value))\n+                return EnumType(name, int_type, enumerators, qualifiers)\n         elif dwarf_type.tag == DW_TAG.typedef:\n             return TypedefType(dwarf_type.name(),\n                                self.find_dwarf_type(dwarf_type.type()),\n@@ -556,7 +581,8 @@ class DwarfTypeIndex(TypeIndex):\n                     except DwarfAttribNotFoundError:\n                         size = None\n                     type_ = ArrayType(type_, size)\n-            assert isinstance(type_, ArrayType)\n+            if not isinstance(type_, ArrayType):\n+                raise DwarfFormatError('array type does not have any subranges')\n             return type_\n         elif dwarf_type.tag == DW_TAG.subroutine_type:\n             try:\n@@ -571,7 +597,7 @@ class DwarfTypeIndex(TypeIndex):\n                         raise DwarfFormatError('formal parameter after unspecified parameters')\n                     parameter_type = self.find_dwarf_type(child.type())\n                     try:\n-                        parameter_name = child.name()\n+                        parameter_name: Optional[str] = child.name()\n                     except DwarfAttribNotFoundError:\n                         parameter_name = None\n                     parameters.append((parameter_type, parameter_name))\n"}
{"repo": "drgn", "commit": "333b78217230546732be506c304a640d5aeb1b99", "diff": "diff --git a/drgn/dwarf.py b/drgn/dwarf.py\nindex 2b3418be..043b054a 100644\n--- a/drgn/dwarf.py\n+++ b/drgn/dwarf.py\n@@ -717,7 +717,9 @@ class CompilationUnit:\n             reader.offset = self.die_offset()\n         else:\n             reader.offset = self.offset + offset\n-        return _parse_die(reader, self, False)\n+        die = _parse_die(reader, self, False)\n+        assert die is not None\n+        return die\n \n \n class DieAttrib(NamedTuple):\n@@ -961,7 +963,7 @@ def _parse_die(reader: _Reader, cu: CompilationUnit,\n                jump_to_sibling: bool) -> Optional[Die]:\n     offset = reader.offset\n     code = reader.read_uleb128()\n-    if code == 0:\n+    if jump_to_sibling and code == 0:\n         return None\n     try:\n         decl = cu.abbrev_table[code]\n@@ -980,12 +982,14 @@ def _parse_die(reader: _Reader, cu: CompilationUnit,\n     length = reader.offset - offset\n \n     if not decl.children:\n-        children: List[Die] = []\n-    elif jump_to_sibling and sibling == 0:\n+        children: Optional[List[Die]] = []\n+    elif jump_to_sibling and sibling is None:\n         children = _parse_die_siblings(reader, cu)\n     else:\n         children = None\n-        if jump_to_sibling:\n+        # sibling is not None is always True here if jump_to_sibling is True,\n+        # but mypy isn't smart enough to figure that out so we spell it out.\n+        if jump_to_sibling and sibling is not None:\n             assert isinstance(sibling.value, int)\n             if sibling.form == DW_FORM.ref_addr:\n                 reader.offset = sibling.value\n"}
{"repo": "drgn", "commit": "80df521452ba5c7401f02bf1a4ab40a5fe8f8eae", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex 9b022981..12a8fff0 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -363,7 +363,11 @@ class BitFieldType(Type):\n \n     def sizeof(self) -> int:\n         # Not really, but for convenience.\n-        return (self.bit_offset + self.bit_size + 7) // 8\n+        if self.bit_offset is None:\n+            bit_offset = 0\n+        else:\n+            bit_offset = self.bit_offset\n+        return (bit_offset + self.bit_size + 7) // 8\n \n     def read(self, buffer: bytes, offset: int = 0) -> int:\n         if len(buffer) - offset < self.sizeof():\n@@ -681,13 +685,13 @@ class EnumType(IntType):\n             parts = ['(', str(self.type_name()), ')']\n         else:\n             parts = []\n-        if not isinstance(value, self.enum):\n+        if self.enum is not None and not isinstance(value, self.enum):\n             value = int(value)\n             try:\n                 value = self.enum(value)\n             except ValueError:\n                 pass\n-        if isinstance(value, self.enum):\n+        if self.enum is not None and isinstance(value, self.enum):\n             parts.append(value._name_)\n         else:\n             parts.append(str(value))\n@@ -697,10 +701,12 @@ class EnumType(IntType):\n         if not isinstance(value, numbers.Real):\n             raise TypeError(f'cannot convert to {self}')\n         value = _int_convert(math.trunc(value), 8 * self.size, self.signed)\n-        try:\n-            return self.enum(value)\n-        except ValueError:\n-            return value\n+        if self.enum is not None:\n+            try:\n+                value = self.enum(value)\n+            except ValueError:\n+                pass\n+        return value\n \n \n class TypedefType(Type):\n"}
{"repo": "drgn", "commit": "07bcded124eca5bacac10ac9f0ce1309ab4e2427", "diff": "diff --git a/drgn/typename.py b/drgn/typename.py\nindex 998e2142..de9bd110 100644\n--- a/drgn/typename.py\n+++ b/drgn/typename.py\n@@ -180,7 +180,7 @@ _TOKEN_REGEX = re.compile('|'.join('(?P<%s>%s)' % pair for pair in [\n \n class _Token(NamedTuple):\n     kind: str\n-    value: Union[str, int]\n+    value: Union[str, int, None]\n \n \n class _TypeNameLexer:\n@@ -404,7 +404,7 @@ class _TypeNameParser:\n                 if token.kind == 'NUMBER':\n                     self._lexer.pop()\n                     assert isinstance(token.value, int)\n-                    size = token.value\n+                    size: Optional[int] = token.value\n                 else:\n                     size = None\n                 if inner_type is None:\n"}
{"repo": "drgn", "commit": "9f325f5fdc3a52829795aa6e3409f4ea4c0e9b8e", "diff": "diff --git a/drgn/typeindex.py b/drgn/typeindex.py\nindex 4e9e2361..39817b09 100644\n--- a/drgn/typeindex.py\n+++ b/drgn/typeindex.py\n@@ -139,8 +139,10 @@ class TypeIndex:\n         if isinstance(value, bool):\n             return self.find_type('_Bool')\n         elif isinstance(value, numbers.Integral):\n+            value = int(value)\n             for type_name in ['int', 'long', 'long long']:\n                 type_ = self.find_type(type_name)\n+                assert isinstance(type_, IntType)\n                 if -(1 << (8 * type_.size - 1)) <= value < (1 << (8 * type_.size - 1)):\n                     return type_\n                 elif 0 <= value < (1 << 8 * type_.size):\n"}
{"repo": "drgn", "commit": "d7236962db83ef93e4aa9d8f40796772b7b866c7", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex feec0ad6..270d1f43 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -272,6 +272,9 @@ class BoolType(IntType):\n                  qualifiers: FrozenSet[str] = frozenset()) -> None:\n         super().__init__(name, size, False, qualifiers)\n \n+    def __repr__(self) -> str:\n+        return ArithmeticType.__repr__(self)\n+\n     def read(self, buffer: bytes, offset: int = 0) -> bool:\n         if len(buffer) - offset < self.size:\n             raise ValueError(f'buffer must be at least {self.size} bytes')\n"}
{"repo": "drgn", "commit": "c3dbe939ad3658c78f5807f8e01604a34bf89973", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex 08031055..cfa26ea9 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -268,7 +268,7 @@ class Program:\n         \"\"\"\n         return self.variable(name)\n \n-    def object(self, address: int, type: Union[str, Type, TypeName],\n+    def object(self, address: Optional[int], type: Union[str, Type, TypeName],\n                value: Any = None) -> ProgramObject:\n         \"\"\"\n         Return a ProgramObject with the given address of the given type. The\n"}
{"repo": "drgn", "commit": "322b35259b0833290da3ad8684c10889371ef36b", "diff": "diff --git a/drgn/program.py b/drgn/program.py\nindex e8d152e4..abaaa53c 100644\n--- a/drgn/program.py\n+++ b/drgn/program.py\n@@ -81,7 +81,13 @@ class ProgramObject:\n         return attrs\n \n     def __getattr__(self, name: str) -> 'ProgramObject':\n-        \"\"\"Implement self.name. Shortcurt for self.member_(name)\"\"\"\n+        \"\"\"Implement self.name. Shortcurt for self.member_(name).\"\"\"\n+        if isinstance(self._real_type, PointerType):\n+            type_ = self._real_type.type\n+        else:\n+            type_ = self._real_type\n+        if not isinstance(type_, CompoundType):\n+            raise AttributeError(f'{self.__class__.__name__!r} object has no attribute {name!r}')\n         try:\n             return self.member_(name)\n         except ValueError as e:\n"}
{"repo": "drgn", "commit": "e38ddba9c6f8eb816ffff9e72fd6d909bf7087d1", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex c278e8d1..129cf71c 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -779,8 +779,7 @@ class ArrayType(Type):\n             if elements:\n                 parts.append('\\n')\n                 for element in reversed(elements):\n-                    parts.append('\\t')\n-                    parts.append(element)\n+                    parts.append(re.sub('^', '\\t', element, flags=re.MULTILINE))\n                     parts.append(',\\n')\n             parts.append('}')\n         return ''.join(parts)\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex 83c18820..3c3f23e3 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -460,6 +460,30 @@ enum {\n         type_ = ArrayType(ArrayType(IntType('int', 4, True), 2), None)\n         self.assertEqual(str(type_), 'int [][2]')\n \n+    def test_array_of_structs(self):\n+        type_ = ArrayType(point_type, 2)\n+        self.assertEqual(str(type_), 'struct point [2]')\n+        self.assertEqual(type_.sizeof(), 16)\n+        buffer = ((1).to_bytes(4, sys.byteorder, signed=True) +\n+                  (2).to_bytes(4, sys.byteorder, signed=True) +\n+                  (3).to_bytes(4, sys.byteorder, signed=True) +\n+                  (4).to_bytes(4, sys.byteorder, signed=True))\n+        self.assertEqual(type_.read(buffer), [\n+            OrderedDict([('x', 1), ('y', 2)]),\n+            OrderedDict([('x', 3), ('y', 4)]),\n+        ])\n+        self.assertEqual(type_.read_pretty(buffer), \"\"\"\\\n+(struct point [2]){\n+\t{\n+\t\t.x = (int)1,\n+\t\t.y = (int)2,\n+\t},\n+\t{\n+\t\t.x = (int)3,\n+\t\t.y = (int)4,\n+\t},\n+}\"\"\")\n+\n \n class TestFromDwarfType(unittest.TestCase):\n     def setUp(self):\n"}
{"repo": "drgn", "commit": "226bdd20d680c1c761c0cdbf7990781eb51e4d66", "diff": "diff --git a/drgn/coredump.py b/drgn/coredump.py\nindex 6df93087..8ac4abb5 100644\n--- a/drgn/coredump.py\n+++ b/drgn/coredump.py\n@@ -164,9 +164,9 @@ class CoredumpObject:\n         if not isinstance(type, Type):\n             type = self.coredump_.type(type)\n         if not isinstance(type, CompoundType):\n-            raise ValueError('containerof is only valid with struct or union types')\n+            raise ValueError('container_of is only valid with struct or union types')\n         if not isinstance(self._real_type, PointerType):\n-            raise ValueError('containerof is only valid on pointers')\n+            raise ValueError('container_of is only valid on pointers')\n         address = self.value_() - type.offsetof(member)\n         return CoredumpObject(self.coredump_, address, type)\n \n"}
{"repo": "drgn", "commit": "a63fbdb975d9e2b19d3114b0cff897dc6e9c3d34", "diff": "diff --git a/drgn/coredump.py b/drgn/coredump.py\nindex cd74bf72..0aab81e3 100644\n--- a/drgn/coredump.py\n+++ b/drgn/coredump.py\n@@ -43,7 +43,10 @@ class CoredumpObject:\n \n     def __getattr__(self, name: str) -> 'CoredumpObject':\n         \"\"\"Implement self.name. Shortcurt for self.member_(name)\"\"\"\n-        return self.member_(name)\n+        try:\n+            return self.member_(name)\n+        except ValueError as e:\n+            raise AttributeError(*e.args) from None\n \n     def __getitem__(self, idx: Any) -> 'CoredumpObject':\n         \"\"\"\n@@ -135,7 +138,7 @@ class CoredumpObject:\n             address = self.address_\n             type_ = self._real_type\n         if not isinstance(type_, CompoundType):\n-            raise AttributeError()\n+            raise ValueError('not a struct or union')\n         member_type = type_.typeof(name)\n         offset = type_.offsetof(name)\n         return CoredumpObject(self.coredump_, address + offset, member_type)\ndiff --git a/drgn/type.py b/drgn/type.py\nindex 24b16d18..99cb6f3c 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -352,10 +352,16 @@ class CompoundType(Type):\n         return list(self._members_by_name)\n \n     def offsetof(self, member: str) -> int:\n-        return self._members_by_name[member][0]\n+        try:\n+            return self._members_by_name[member][0]\n+        except KeyError:\n+            raise ValueError(f'{str(self.type_name())!r} has no member {member!r}') from None\n \n     def typeof(self, member: str) -> Type:\n-        return self._members_by_name[member][1]()\n+        try:\n+            return self._members_by_name[member][1]()\n+        except KeyError:\n+            raise ValueError(f'{str(self.type_name())!r} has no member {member!r}') from None\n \n \n class StructType(CompoundType):\n"}
{"repo": "drgn", "commit": "7ebda948c662fd705d6dee3039feebc826123555", "diff": "diff --git a/tests/test_leb128.py b/tests/test_leb128.py\nnew file mode 100644\nindex 00000000..270d5287\n--- /dev/null\n+++ b/tests/test_leb128.py\n@@ -0,0 +1,96 @@\n+from drgn.dwarf import parse_sleb128, parse_uleb128\n+import unittest\n+\n+\n+\"\"\"\n+def encode_uleb128(value):\n+    encoded = bytearray()\n+    while True:\n+        byte = value & 0x7f\n+        value >>= 7\n+        if value:\n+            byte |= 0x80\n+        encoded.append(byte)\n+        if not value:\n+            return encoded\n+\"\"\"\n+\n+\n+class TestLeb128(unittest.TestCase):\n+    def test_negative_offset(self):\n+        with self.assertRaises(EOFError):\n+            parse_uleb128(b'', -1)\n+        with self.assertRaises(EOFError):\n+            parse_sleb128(b'', -1)\n+\n+    def test_truncated(self):\n+        cases = [\n+            b'',\n+            b'\\x80',\n+        ]\n+        for case in cases:\n+            with self.subTest(case=case, signed=False), \\\n+                    self.assertRaises(EOFError):\n+                parse_uleb128(case)\n+            with self.subTest(case=case, signed=True), \\\n+                    self.assertRaises(EOFError):\n+                parse_sleb128(case)\n+\n+    def test_uleb128(self):\n+        self.assertEqual(parse_uleb128(b'\\x00'), 0)\n+        self.assertEqual(parse_uleb128(b'\\x02'), 2)\n+        self.assertEqual(parse_uleb128(b'\\x7f'), 127)\n+        self.assertEqual(parse_uleb128(b'\\x80\\x01'), 128)\n+        self.assertEqual(parse_uleb128(b'\\x81\\x01'), 129)\n+        self.assertEqual(parse_uleb128(b'\\x82\\x01'), 130)\n+        self.assertEqual(parse_uleb128(b'\\xb9\\x64'), 12857)\n+        self.assertEqual(parse_uleb128(b'\\xbf\\x84\\x3d'), 999999)\n+        self.assertEqual(parse_uleb128(b'\\x95\\x9a\\xef\\x3a'), 123456789)\n+        self.assertEqual(parse_uleb128(b'\\xff\\xff\\xff\\xff\\x0f'), 0xffffffff)\n+        self.assertEqual(parse_uleb128(b'\\x90\\xf1\\xd9\\xa2\\xa3\\x02'), 0x1234567890)\n+        self.assertEqual(parse_uleb128(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x7f'),\n+                         2**63 - 1)\n+        self.assertEqual(parse_uleb128(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00'),\n+                         2**63 - 1)\n+        self.assertEqual(parse_uleb128(b'\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x01'),\n+                         2**63)\n+        self.assertEqual(parse_uleb128(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x01'),\n+                         2**64 - 1)\n+\n+    def test_uleb128_overflow(self):\n+        cases = [\n+            b'\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x02',  # 2**64\n+            b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x03',  # 2**65 - 1\n+            b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x03',  # 2**72 - 1\n+        ]\n+        for encoded in cases:\n+            with self.subTest(encoded=encoded), self.assertRaises(OverflowError):\n+                parse_uleb128(encoded)\n+\n+    def test_sleb128(self):\n+        self.assertEqual(parse_sleb128(b'\\x00'), 0)\n+        self.assertEqual(parse_sleb128(b'\\x02'), 2)\n+        self.assertEqual(parse_sleb128(b'\\x7e'), -2)\n+        self.assertEqual(parse_sleb128(b'\\xff\\x00'), 127)\n+        self.assertEqual(parse_sleb128(b'\\x81\\x7f'), -127)\n+        self.assertEqual(parse_sleb128(b'\\x80\\x01'), 128)\n+        self.assertEqual(parse_sleb128(b'\\x80\\x7f'), -128)\n+        self.assertEqual(parse_sleb128(b'\\x81\\x01'), 129)\n+        self.assertEqual(parse_sleb128(b'\\xff\\x7e'), -129)\n+        self.assertEqual(parse_sleb128(b'\\xff\\xff\\xff\\xff\\x07'), 2**31 - 1)\n+        self.assertEqual(parse_sleb128(b'\\x80\\x80\\x80\\x80\\x78'), -2**31)\n+        self.assertEqual(parse_sleb128(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00'),\n+                         2**63 - 1)\n+        self.assertEqual(parse_sleb128(b'\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x7f'),\n+                         -2**63)\n+        self.assertEqual(parse_sleb128(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x7f'),\n+                         -1)\n+\n+    def test_sleb128_overflow(self):\n+        cases = [\n+            b'\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x01',  # 2**63\n+            b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x01',  # 2**64 - 1\n+        ]\n+        for encoded in cases:\n+            with self.subTest(encoded=encoded), self.assertRaises(OverflowError):\n+                parse_sleb128(encoded)\ndiff --git a/tool/dump.py b/tool/dump.py\nindex d29423fe..167ecad2 100644\n--- a/tool/dump.py\n+++ b/tool/dump.py\n@@ -1,7 +1,7 @@\n from drgn.dwarf import (\n     Die, DwarfAttribNotFoundError, DwarfFile, DwarfFile,\n     DW_AT, DW_FORM, DW_LNE, DW_LNS, DW_OP, DW_TAG,\n-    LineNumberProgram, parse_uleb128, parse_sleb128,\n+    LineNumberProgram, parse_uleb128_and_offset, parse_sleb128_and_offset,\n )\n import fnmatch\n import os.path\n@@ -138,10 +138,10 @@ def dump_expression(value, address_size: int, is_64_bit: bool, *, indent: int=0)\n             offset += 8\n             print(hex(const))\n         elif opcode == DW_OP.constu:\n-            const, offset = parse_uleb128(value, offset)\n+            const, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(const))\n         elif opcode == DW_OP.consts:\n-            const, offset = parse_sleb128(value, offset)\n+            const, offset = parse_sleb128_and_offset(value, offset)\n             print(hex(const))\n         elif (opcode == DW_OP.dup or\n               opcode == DW_OP.drop or\n@@ -165,7 +165,7 @@ def dump_expression(value, address_size: int, is_64_bit: bool, *, indent: int=0)\n               opcode == DW_OP.plus):\n             print()\n         elif opcode == DW_OP.plus_uconst:\n-            addend, offset = parse_uleb128(value, offset)\n+            addend, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(addend))\n         elif (opcode == DW_OP.shl or\n               opcode == DW_OP.shr or\n@@ -194,20 +194,20 @@ def dump_expression(value, address_size: int, is_64_bit: bool, *, indent: int=0)\n         elif DW_OP.reg0 <= opcode <= DW_OP.reg31:\n             print()\n         elif DW_OP.breg0 <= opcode <= DW_OP.breg31:\n-            reg_offset, offset = parse_sleb128(value, offset)\n+            reg_offset, offset = parse_sleb128_and_offset(value, offset)\n             print(hex(reg_offset))\n         elif opcode == DW_OP.regx:\n-            register, offset = parse_uleb128(value, offset)\n+            register, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(register))\n         elif opcode == DW_OP.fbreg:\n-            reg_offset, offset = parse_sleb128(value, offset)\n+            reg_offset, offset = parse_sleb128_and_offset(value, offset)\n             print(hex(reg_offset))\n         elif opcode == DW_OP.bregx:\n-            register, offset = parse_uleb128(value, offset)\n-            reg_offset, offset = parse_sleb128(value, offset)\n+            register, offset = parse_uleb128_and_offset(value, offset)\n+            reg_offset, offset = parse_sleb128_and_offset(value, offset)\n             print(hex(register), hex(reg_offset))\n         elif opcode == DW_OP.piece:\n-            size, offset = parse_uleb128(value, offset)\n+            size, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(size))\n         elif opcode == DW_OP.deref_size:\n             print(hex(value[offset]))\n@@ -235,11 +235,11 @@ def dump_expression(value, address_size: int, is_64_bit: bool, *, indent: int=0)\n               opcode == DW_OP.call_frame_cfa):\n             print()\n         elif opcode == DW_OP.bit_piece:\n-            piece_size, offset = parse_uleb128(value, offset)\n-            piece_offset, offset = parse_uleb128(value, offset)\n+            piece_size, offset = parse_uleb128_and_offset(value, offset)\n+            piece_offset, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(piece_size), hex(piece_offset))\n         elif opcode == DW_OP.implicit_value:\n-            size, offset = parse_uleb128(value, offset)\n+            size, offset = parse_uleb128_and_offset(value, offset)\n             print(hex(size), repr(value[offset:offset + size])[1:])\n             offset += size\n         elif opcode == DW_OP.stack_value:\n@@ -287,7 +287,7 @@ def dump_lnp_ops(lnp: LineNumberProgram, *, indent: int=0):\n         opcode = lnp.dwarf_file.mmap[offset]\n         offset += 1\n         if opcode == 0:\n-            length, offset = parse_uleb128(lnp.dwarf_file.mmap, offset)\n+            length, offset = parse_uleb128_and_offset(lnp.dwarf_file.mmap, offset)\n             opcode = lnp.dwarf_file.mmap[offset]\n             length -= 1\n             offset += 1\n@@ -304,7 +304,7 @@ def dump_lnp_ops(lnp: LineNumberProgram, *, indent: int=0):\n             else:\n                 args = []\n                 for i in range(lnp.standard_opcode_lengths[opcode - 1]):\n-                    arg, offset = parse_uleb128(lnp.dwarf_file.mmap, offset)\n+                    arg, offset = parse_uleb128_and_offset(lnp.dwarf_file.mmap, offset)\n                     args.append(arg)\n             if len(args) > 2:\n                 print(f'{prefix}  {DW_LNS.str(opcode)} {args}')\n"}
{"repo": "drgn", "commit": "97d578aa615c4881b1082f15156fd470b847784b", "diff": "diff --git a/drgn/cli/__main__.py b/drgn/cli/__main__.py\nindex f968455f..7ce777f4 100644\n--- a/drgn/cli/__main__.py\n+++ b/drgn/cli/__main__.py\n@@ -1,20 +1,97 @@\n+import code\n import argparse\n+import glob\n+import os.path\n+import platform\n+import runpy\n+import sys\n \n-import drgn.cli.dump\n+from drgn.coredump import Coredump\n+from drgn.dwarf import DwarfFile, DwarfIndex\n+from drgn.util import parse_symbol_file\n+\n+\n+def find_vmlinux(release):\n+    paths = [\n+        f'/usr/lib/debug/lib/modules/{release}/vmlinux',\n+        f'/boot/vmlinux-{release}',\n+        f'/lib/modules/{release}/build/vmlinux',\n+    ]\n+    for path in paths:\n+        if os.path.exists(path):\n+            return path\n+    else:\n+        raise ValueError()\n+\n+\n+def find_modules(release):\n+    patterns = [\n+        f'/usr/lib/debug/lib/modules/{release}/kernel/**/*.ko.debug',\n+        f'/lib/modules/{release}/kernel/**/*.ko',\n+    ]\n+    for pattern in patterns:\n+        paths = glob.glob(pattern, recursive=True)\n+        if paths:\n+            return paths\n+    else:\n+        return []\n \n \n def main():\n     parser = argparse.ArgumentParser(prog='drgn')\n+    parser.add_argument(\n+        '-k', '--kernel', action='store_true',\n+        help='debug the kernel instead of a userspace program')\n+    parser.add_argument(\n+        '-e', '--executable', metavar='PATH', type=str,\n+        help='use the given executable file')\n+    parser.add_argument(\n+        'script', metavar='ARG', type=str, nargs='*',\n+        help='script to execute instead of running an interactive shell')\n+\n+    args = parser.parse_args()\n \n-    subparsers = parser.add_subparsers(\n-        title='command', description='command to run', dest='command')\n-    subparsers.required = True\n+    if not args.kernel:\n+        sys.exit('Only --kernel mode is currently implemented')\n \n-    drgn.cli.dump.register(subparsers)\n+    release = platform.release()\n \n-    args = parser.parse_args()\n-    args.func(args)\n+    if args.executable is None:\n+        try:\n+            args.executable = find_vmlinux(release)\n+        except ValueError:\n+            sys.exit('Could not find vmlinux file; install the proper debuginfo package or use --executable')\n+\n+    paths = find_modules(release)\n+    if not paths and not args.script:\n+        print('Could not find kernel modules; continuing anyways',\n+              file=sys.stderr)\n+    paths.append(args.executable)\n+\n+    if not args.script:\n+        print('Reading symbols...')\n+    dwarf_index = DwarfIndex()\n+    for path in paths:\n+        with open(path, 'rb') as f:\n+            dwarf_file = DwarfFile.from_file(f)\n+            for cu in dwarf_file.cu_headers():\n+                dwarf_index.index_cu(cu)\n+\n+    with open('/proc/kallsyms', 'r') as f:\n+        symbols = parse_symbol_file(f)\n \n+    with open('/proc/kcore', 'rb') as core_file:\n+        core = Coredump(core_file, dwarf_index, symbols)\n+        if args.script:\n+            sys.argv = args.script\n+            runpy.run_path(args.script[0], init_globals={'core': core},\n+                           run_name='__main__')\n+        else:\n+            code.interact(banner='', exitmsg='', local={\n+                'core': core,\n+                '__name__': '__name__',\n+                '__doc__': None,\n+            })\n \n if __name__ == '__main__':\n     main()\ndiff --git a/drgn/coredump.py b/drgn/coredump.py\nindex 9b71853f..b55c001c 100644\n--- a/drgn/coredump.py\n+++ b/drgn/coredump.py\n@@ -1,4 +1,3 @@\n-from drgn.dwarf import DwarfFile, DwarfIndex\n from drgn.elf import ElfFile\n from drgn.type import (\n     ArrayType,\n@@ -7,7 +6,6 @@ from drgn.type import (\n     TypeFactory,\n )\n from drgn.typename import TypeName\n-from drgn.util import parse_symbol_file\n import itertools\n import os\n \n@@ -100,17 +98,12 @@ class CoredumpObject:\n \n \n class Coredump:\n-    def __init__(self, core_file, program_file, symbols=None):\n+    def __init__(self, core_file, dwarf_index, symbols):\n         self._core_file = core_file\n         self._core_elf_file = ElfFile(core_file)\n-        self._program_file = program_file\n-        self._program_dwarf_file = DwarfFile.from_file(program_file)\n-        self.symbols = symbols\n-\n-        self._dwarf_index = DwarfIndex()\n-        for cu in self._program_dwarf_file.cu_headers():\n-            self._dwarf_index.index_cu(cu)\n+        self._dwarf_index = dwarf_index\n         self._type_factory = TypeFactory(self._dwarf_index)\n+        self._symbols = symbols\n \n     def read(self, address, size):\n         for phdr in self._core_elf_file.phdrs():\n@@ -122,16 +115,7 @@ class Coredump:\n                         phdr.p_offset + address - phdr.p_vaddr)\n \n     def __getitem__(self, key):\n-        address = self.symbols[key][-1]\n+        address = self._symbols[key][-1]\n         dwarf_type = self._dwarf_index.find_variable(key).type()\n         type_ = self._type_factory.from_dwarf_type(dwarf_type)\n         return CoredumpObject(self, address, type_)\n-\n-\n-def kcore(vmlinux_path):\n-    # TODO: cleanup\n-    core_file = open('/proc/kcore', 'rb')\n-    program_file = open(vmlinux_path, 'rb')\n-    with open('/proc/kallsyms', 'r') as f:\n-        symbols = parse_symbol_file(f)\n-    return Coredump(core_file, program_file, symbols)\ndiff --git a/drgn/tool/__init__.py b/drgn/tool/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/drgn/tool/__main__.py b/drgn/tool/__main__.py\nnew file mode 100644\nindex 00000000..f834eaf6\n--- /dev/null\n+++ b/drgn/tool/__main__.py\n@@ -0,0 +1,20 @@\n+import argparse\n+\n+import drgn.tool.dump\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(prog='drgntool')\n+\n+    subparsers = parser.add_subparsers(\n+        title='command', description='command to run', dest='command')\n+    subparsers.required = True\n+\n+    drgn.tool.dump.register(subparsers)\n+\n+    args = parser.parse_args()\n+    args.func(args)\n+\n+\n+if __name__ == '__main__':\n+    main()\ndiff --git a/drgn/cli/dump.py b/drgn/tool/dump.py\nsimilarity index 100%\nrename from drgn/cli/dump.py\nrename to drgn/tool/dump.py\n"}
{"repo": "drgn", "commit": "a7309d2a157173622b036a2f30a70e13fe73a75c", "diff": "diff --git a/drgn/elf.py b/drgn/elf.py\ndeleted file mode 100644\nindex 228a72e2..00000000\n--- a/drgn/elf.py\n+++ /dev/null\n@@ -1,855 +0,0 @@\n-from collections import namedtuple, OrderedDict\n-import struct\n-from types import SimpleNamespace\n-import zlib\n-\n-\n-# Automatically generated from elf.h\n-EI_NIDENT = (16)\n-EI_MAG0 = 0\n-ELFMAG0 = 0x7f\n-EI_MAG1 = 1\n-ELFMAG1 = 0x45\n-EI_MAG2 = 2\n-ELFMAG2 = 0x4c\n-EI_MAG3 = 3\n-ELFMAG3 = 0x46\n-ELFMAG = b'\\177ELF'\n-EI_CLASS = 4\n-ELFCLASSNONE = 0\n-ELFCLASS32 = 1\n-ELFCLASS64 = 2\n-ELFCLASSNUM = 3\n-EI_DATA = 5\n-ELFDATANONE = 0\n-ELFDATA2LSB = 1\n-ELFDATA2MSB = 2\n-ELFDATANUM = 3\n-EI_VERSION = 6\n-EI_OSABI = 7\n-ELFOSABI_NONE = 0\n-ELFOSABI_SYSV = 0\n-ELFOSABI_HPUX = 1\n-ELFOSABI_NETBSD = 2\n-ELFOSABI_GNU = 3\n-ELFOSABI_LINUX = ELFOSABI_GNU\n-ELFOSABI_SOLARIS = 6\n-ELFOSABI_AIX = 7\n-ELFOSABI_IRIX = 8\n-ELFOSABI_FREEBSD = 9\n-ELFOSABI_TRU64 = 10\n-ELFOSABI_MODESTO = 11\n-ELFOSABI_OPENBSD = 12\n-ELFOSABI_ARM_AEABI = 64\n-ELFOSABI_ARM = 97\n-ELFOSABI_STANDALONE = 255\n-EI_ABIVERSION = 8\n-EI_PAD = 9\n-ET_NONE = 0\n-ET_REL = 1\n-ET_EXEC = 2\n-ET_DYN = 3\n-ET_CORE = 4\n-ET_NUM = 5\n-ET_LOOS = 0xfe00\n-ET_HIOS = 0xfeff\n-ET_LOPROC = 0xff00\n-ET_HIPROC = 0xffff\n-EM_NONE = 0\n-EM_M32 = 1\n-EM_SPARC = 2\n-EM_386 = 3\n-EM_68K = 4\n-EM_88K = 5\n-EM_IAMCU = 6\n-EM_860 = 7\n-EM_MIPS = 8\n-EM_S370 = 9\n-EM_MIPS_RS3_LE = 10\n-EM_PARISC = 15\n-EM_VPP500 = 17\n-EM_SPARC32PLUS = 18\n-EM_960 = 19\n-EM_PPC = 20\n-EM_PPC64 = 21\n-EM_S390 = 22\n-EM_SPU = 23\n-EM_V800 = 36\n-EM_FR20 = 37\n-EM_RH32 = 38\n-EM_RCE = 39\n-EM_ARM = 40\n-EM_FAKE_ALPHA = 41\n-EM_SH = 42\n-EM_SPARCV9 = 43\n-EM_TRICORE = 44\n-EM_ARC = 45\n-EM_H8_300 = 46\n-EM_H8_300H = 47\n-EM_H8S = 48\n-EM_H8_500 = 49\n-EM_IA_64 = 50\n-EM_MIPS_X = 51\n-EM_COLDFIRE = 52\n-EM_68HC12 = 53\n-EM_MMA = 54\n-EM_PCP = 55\n-EM_NCPU = 56\n-EM_NDR1 = 57\n-EM_STARCORE = 58\n-EM_ME16 = 59\n-EM_ST100 = 60\n-EM_TINYJ = 61\n-EM_X86_64 = 62\n-EM_PDSP = 63\n-EM_PDP10 = 64\n-EM_PDP11 = 65\n-EM_FX66 = 66\n-EM_ST9PLUS = 67\n-EM_ST7 = 68\n-EM_68HC16 = 69\n-EM_68HC11 = 70\n-EM_68HC08 = 71\n-EM_68HC05 = 72\n-EM_SVX = 73\n-EM_ST19 = 74\n-EM_VAX = 75\n-EM_CRIS = 76\n-EM_JAVELIN = 77\n-EM_FIREPATH = 78\n-EM_ZSP = 79\n-EM_MMIX = 80\n-EM_HUANY = 81\n-EM_PRISM = 82\n-EM_AVR = 83\n-EM_FR30 = 84\n-EM_D10V = 85\n-EM_D30V = 86\n-EM_V850 = 87\n-EM_M32R = 88\n-EM_MN10300 = 89\n-EM_MN10200 = 90\n-EM_PJ = 91\n-EM_OPENRISC = 92\n-EM_ARC_COMPACT = 93\n-EM_XTENSA = 94\n-EM_VIDEOCORE = 95\n-EM_TMM_GPP = 96\n-EM_NS32K = 97\n-EM_TPC = 98\n-EM_SNP1K = 99\n-EM_ST200 = 100\n-EM_IP2K = 101\n-EM_MAX = 102\n-EM_CR = 103\n-EM_F2MC16 = 104\n-EM_MSP430 = 105\n-EM_BLACKFIN = 106\n-EM_SE_C33 = 107\n-EM_SEP = 108\n-EM_ARCA = 109\n-EM_UNICORE = 110\n-EM_EXCESS = 111\n-EM_DXP = 112\n-EM_ALTERA_NIOS2 = 113\n-EM_CRX = 114\n-EM_XGATE = 115\n-EM_C166 = 116\n-EM_M16C = 117\n-EM_DSPIC30F = 118\n-EM_CE = 119\n-EM_M32C = 120\n-EM_TSK3000 = 131\n-EM_RS08 = 132\n-EM_SHARC = 133\n-EM_ECOG2 = 134\n-EM_SCORE7 = 135\n-EM_DSP24 = 136\n-EM_VIDEOCORE3 = 137\n-EM_LATTICEMICO32 = 138\n-EM_SE_C17 = 139\n-EM_TI_C6000 = 140\n-EM_TI_C2000 = 141\n-EM_TI_C5500 = 142\n-EM_TI_ARP32 = 143\n-EM_TI_PRU = 144\n-EM_MMDSP_PLUS = 160\n-EM_CYPRESS_M8C = 161\n-EM_R32C = 162\n-EM_TRIMEDIA = 163\n-EM_QDSP6 = 164\n-EM_8051 = 165\n-EM_STXP7X = 166\n-EM_NDS32 = 167\n-EM_ECOG1X = 168\n-EM_MAXQ30 = 169\n-EM_XIMO16 = 170\n-EM_MANIK = 171\n-EM_CRAYNV2 = 172\n-EM_RX = 173\n-EM_METAG = 174\n-EM_MCST_ELBRUS = 175\n-EM_ECOG16 = 176\n-EM_CR16 = 177\n-EM_ETPU = 178\n-EM_SLE9X = 179\n-EM_L10M = 180\n-EM_K10M = 181\n-EM_AARCH64 = 183\n-EM_AVR32 = 185\n-EM_STM8 = 186\n-EM_TILE64 = 187\n-EM_TILEPRO = 188\n-EM_MICROBLAZE = 189\n-EM_CUDA = 190\n-EM_TILEGX = 191\n-EM_CLOUDSHIELD = 192\n-EM_COREA_1ST = 193\n-EM_COREA_2ND = 194\n-EM_ARC_COMPACT2 = 195\n-EM_OPEN8 = 196\n-EM_RL78 = 197\n-EM_VIDEOCORE5 = 198\n-EM_78KOR = 199\n-EM_56800EX = 200\n-EM_BA1 = 201\n-EM_BA2 = 202\n-EM_XCORE = 203\n-EM_MCHP_PIC = 204\n-EM_KM32 = 210\n-EM_KMX32 = 211\n-EM_EMX16 = 212\n-EM_EMX8 = 213\n-EM_KVARC = 214\n-EM_CDP = 215\n-EM_COGE = 216\n-EM_COOL = 217\n-EM_NORC = 218\n-EM_CSR_KALIMBA = 219\n-EM_Z80 = 220\n-EM_VISIUM = 221\n-EM_FT32 = 222\n-EM_MOXIE = 223\n-EM_AMDGPU = 224\n-EM_RISCV = 243\n-EM_BPF = 247\n-EM_NUM = 248\n-EM_ARC_A5 = EM_ARC_COMPACT\n-EM_ALPHA = 0x9026\n-EV_NONE = 0\n-EV_CURRENT = 1\n-EV_NUM = 2\n-SHN_UNDEF = 0\n-SHN_LORESERVE = 0xff00\n-SHN_LOPROC = 0xff00\n-SHN_BEFORE = 0xff00\n-SHN_AFTER = 0xff01\n-SHN_HIPROC = 0xff1f\n-SHN_LOOS = 0xff20\n-SHN_HIOS = 0xff3f\n-SHN_ABS = 0xfff1\n-SHN_COMMON = 0xfff2\n-SHN_XINDEX = 0xffff\n-SHN_HIRESERVE = 0xffff\n-SHT_NULL = 0\n-SHT_PROGBITS = 1\n-SHT_SYMTAB = 2\n-SHT_STRTAB = 3\n-SHT_RELA = 4\n-SHT_HASH = 5\n-SHT_DYNAMIC = 6\n-SHT_NOTE = 7\n-SHT_NOBITS = 8\n-SHT_REL = 9\n-SHT_SHLIB = 10\n-SHT_DYNSYM = 11\n-SHT_INIT_ARRAY = 14\n-SHT_FINI_ARRAY = 15\n-SHT_PREINIT_ARRAY = 16\n-SHT_GROUP = 17\n-SHT_SYMTAB_SHNDX = 18\n-SHT_NUM = 19\n-SHT_LOOS = 0x60000000\n-SHT_GNU_ATTRIBUTES = 0x6ffffff5\n-SHT_GNU_HASH = 0x6ffffff6\n-SHT_GNU_LIBLIST = 0x6ffffff7\n-SHT_CHECKSUM = 0x6ffffff8\n-SHT_LOSUNW = 0x6ffffffa\n-SHT_SUNW_move = 0x6ffffffa\n-SHT_SUNW_COMDAT = 0x6ffffffb\n-SHT_SUNW_syminfo = 0x6ffffffc\n-SHT_GNU_verdef = 0x6ffffffd\n-SHT_GNU_verneed = 0x6ffffffe\n-SHT_GNU_versym = 0x6fffffff\n-SHT_HISUNW = 0x6fffffff\n-SHT_HIOS = 0x6fffffff\n-SHT_LOPROC = 0x70000000\n-SHT_HIPROC = 0x7fffffff\n-SHT_LOUSER = 0x80000000\n-SHT_HIUSER = 0x8fffffff\n-SHF_WRITE = (1 << 0)\n-SHF_ALLOC = (1 << 1)\n-SHF_EXECINSTR = (1 << 2)\n-SHF_MERGE = (1 << 4)\n-SHF_STRINGS = (1 << 5)\n-SHF_INFO_LINK = (1 << 6)\n-SHF_LINK_ORDER = (1 << 7)\n-SHF_OS_NONCONFORMING = (1 << 8)\n-SHF_GROUP = (1 << 9)\n-SHF_TLS = (1 << 10)\n-SHF_COMPRESSED = (1 << 11)\n-SHF_MASKOS = 0x0ff00000\n-SHF_MASKPROC = 0xf0000000\n-SHF_ORDERED = (1 << 30)\n-SHF_EXCLUDE = (1 << 31)\n-ELFCOMPRESS_ZLIB = 1\n-ELFCOMPRESS_LOOS = 0x60000000\n-ELFCOMPRESS_HIOS = 0x6fffffff\n-ELFCOMPRESS_LOPROC = 0x70000000\n-ELFCOMPRESS_HIPROC = 0x7fffffff\n-GRP_COMDAT = 0x1\n-STB_LOCAL = 0\n-STB_GLOBAL = 1\n-STB_WEAK = 2\n-STB_NUM = 3\n-STB_LOOS = 10\n-STB_GNU_UNIQUE = 10\n-STB_HIOS = 12\n-STB_LOPROC = 13\n-STB_HIPROC = 15\n-STT_NOTYPE = 0\n-STT_OBJECT = 1\n-STT_FUNC = 2\n-STT_SECTION = 3\n-STT_FILE = 4\n-STT_COMMON = 5\n-STT_TLS = 6\n-STT_NUM = 7\n-STT_LOOS = 10\n-STT_GNU_IFUNC = 10\n-STT_HIOS = 12\n-STT_LOPROC = 13\n-STT_HIPROC = 15\n-STV_DEFAULT = 0\n-STV_INTERNAL = 1\n-STV_HIDDEN = 2\n-STV_PROTECTED = 3\n-PT_NULL = 0\n-PT_LOAD = 1\n-PT_DYNAMIC = 2\n-PT_INTERP = 3\n-PT_NOTE = 4\n-PT_SHLIB = 5\n-PT_PHDR = 6\n-PT_TLS = 7\n-PT_NUM = 8\n-PT_LOOS = 0x60000000\n-PT_GNU_EH_FRAME = 0x6474e550\n-PT_GNU_STACK = 0x6474e551\n-PT_GNU_RELRO = 0x6474e552\n-PT_LOSUNW = 0x6ffffffa\n-PT_SUNWBSS = 0x6ffffffa\n-PT_SUNWSTACK = 0x6ffffffb\n-PT_HISUNW = 0x6fffffff\n-PT_HIOS = 0x6fffffff\n-PT_LOPROC = 0x70000000\n-PT_HIPROC = 0x7fffffff\n-PF_X = (1 << 0)\n-PF_W = (1 << 1)\n-PF_R = (1 << 2)\n-PF_MASKOS = 0x0ff00000\n-PF_MASKPROC = 0xf0000000\n-DT_NULL = 0\n-DT_NEEDED = 1\n-DT_PLTRELSZ = 2\n-DT_PLTGOT = 3\n-DT_HASH = 4\n-DT_STRTAB = 5\n-DT_SYMTAB = 6\n-DT_RELA = 7\n-DT_RELASZ = 8\n-DT_RELAENT = 9\n-DT_STRSZ = 10\n-DT_SYMENT = 11\n-DT_INIT = 12\n-DT_FINI = 13\n-DT_SONAME = 14\n-DT_RPATH = 15\n-DT_SYMBOLIC = 16\n-DT_REL = 17\n-DT_RELSZ = 18\n-DT_RELENT = 19\n-DT_PLTREL = 20\n-DT_DEBUG = 21\n-DT_TEXTREL = 22\n-DT_JMPREL = 23\n-DT_BIND_NOW = 24\n-DT_INIT_ARRAY = 25\n-DT_FINI_ARRAY = 26\n-DT_INIT_ARRAYSZ = 27\n-DT_FINI_ARRAYSZ = 28\n-DT_RUNPATH = 29\n-DT_FLAGS = 30\n-DT_ENCODING = 32\n-DT_PREINIT_ARRAY = 32\n-DT_PREINIT_ARRAYSZ = 33\n-DT_NUM = 34\n-DT_LOOS = 0x6000000d\n-DT_HIOS = 0x6ffff000\n-DT_LOPROC = 0x70000000\n-DT_HIPROC = 0x7fffffff\n-DT_PROCNUM = 0x36\n-DT_VALRNGLO = 0x6ffffd00\n-DT_GNU_PRELINKED = 0x6ffffdf5\n-DT_GNU_CONFLICTSZ = 0x6ffffdf6\n-DT_GNU_LIBLISTSZ = 0x6ffffdf7\n-DT_CHECKSUM = 0x6ffffdf8\n-DT_PLTPADSZ = 0x6ffffdf9\n-DT_MOVEENT = 0x6ffffdfa\n-DT_MOVESZ = 0x6ffffdfb\n-DT_FEATURE_1 = 0x6ffffdfc\n-DT_POSFLAG_1 = 0x6ffffdfd\n-DT_SYMINSZ = 0x6ffffdfe\n-DT_SYMINENT = 0x6ffffdff\n-DT_VALRNGHI = 0x6ffffdff\n-DT_VALNUM = 12\n-DT_ADDRRNGLO = 0x6ffffe00\n-DT_GNU_HASH = 0x6ffffef5\n-DT_TLSDESC_PLT = 0x6ffffef6\n-DT_TLSDESC_GOT = 0x6ffffef7\n-DT_GNU_CONFLICT = 0x6ffffef8\n-DT_GNU_LIBLIST = 0x6ffffef9\n-DT_CONFIG = 0x6ffffefa\n-DT_DEPAUDIT = 0x6ffffefb\n-DT_AUDIT = 0x6ffffefc\n-DT_PLTPAD = 0x6ffffefd\n-DT_MOVETAB = 0x6ffffefe\n-DT_SYMINFO = 0x6ffffeff\n-DT_ADDRRNGHI = 0x6ffffeff\n-DT_ADDRNUM = 11\n-DT_VERSYM = 0x6ffffff0\n-DT_RELACOUNT = 0x6ffffff9\n-DT_RELCOUNT = 0x6ffffffa\n-DT_FLAGS_1 = 0x6ffffffb\n-DT_VERDEF = 0x6ffffffc\n-DT_VERDEFNUM = 0x6ffffffd\n-DT_VERNEED = 0x6ffffffe\n-DT_VERNEEDNUM = 0x6fffffff\n-DT_VERSIONTAGNUM = 16\n-DT_AUXILIARY = 0x7ffffffd\n-DT_FILTER = 0x7fffffff\n-DT_EXTRANUM = 3\n-STT_SPARC_REGISTER = 13\n-DT_SPARC_REGISTER = 0x70000001\n-DT_SPARC_NUM = 2\n-SHN_MIPS_ACOMMON = 0xff00\n-SHN_MIPS_TEXT = 0xff01\n-SHN_MIPS_DATA = 0xff02\n-SHN_MIPS_SCOMMON = 0xff03\n-SHN_MIPS_SUNDEFINED = 0xff04\n-SHT_MIPS_LIBLIST = 0x70000000\n-SHT_MIPS_MSYM = 0x70000001\n-SHT_MIPS_CONFLICT = 0x70000002\n-SHT_MIPS_GPTAB = 0x70000003\n-SHT_MIPS_UCODE = 0x70000004\n-SHT_MIPS_DEBUG = 0x70000005\n-SHT_MIPS_REGINFO = 0x70000006\n-SHT_MIPS_PACKAGE = 0x70000007\n-SHT_MIPS_PACKSYM = 0x70000008\n-SHT_MIPS_RELD = 0x70000009\n-SHT_MIPS_IFACE = 0x7000000b\n-SHT_MIPS_CONTENT = 0x7000000c\n-SHT_MIPS_OPTIONS = 0x7000000d\n-SHT_MIPS_SHDR = 0x70000010\n-SHT_MIPS_FDESC = 0x70000011\n-SHT_MIPS_EXTSYM = 0x70000012\n-SHT_MIPS_DENSE = 0x70000013\n-SHT_MIPS_PDESC = 0x70000014\n-SHT_MIPS_LOCSYM = 0x70000015\n-SHT_MIPS_AUXSYM = 0x70000016\n-SHT_MIPS_OPTSYM = 0x70000017\n-SHT_MIPS_LOCSTR = 0x70000018\n-SHT_MIPS_LINE = 0x70000019\n-SHT_MIPS_RFDESC = 0x7000001a\n-SHT_MIPS_DELTASYM = 0x7000001b\n-SHT_MIPS_DELTAINST = 0x7000001c\n-SHT_MIPS_DELTACLASS = 0x7000001d\n-SHT_MIPS_DWARF = 0x7000001e\n-SHT_MIPS_DELTADECL = 0x7000001f\n-SHT_MIPS_SYMBOL_LIB = 0x70000020\n-SHT_MIPS_EVENTS = 0x70000021\n-SHT_MIPS_TRANSLATE = 0x70000022\n-SHT_MIPS_PIXIE = 0x70000023\n-SHT_MIPS_XLATE = 0x70000024\n-SHT_MIPS_XLATE_DEBUG = 0x70000025\n-SHT_MIPS_WHIRL = 0x70000026\n-SHT_MIPS_EH_REGION = 0x70000027\n-SHT_MIPS_XLATE_OLD = 0x70000028\n-SHT_MIPS_PDR_EXCEPTION = 0x70000029\n-SHF_MIPS_GPREL = 0x10000000\n-SHF_MIPS_MERGE = 0x20000000\n-SHF_MIPS_ADDR = 0x40000000\n-SHF_MIPS_STRINGS = 0x80000000\n-SHF_MIPS_NOSTRIP = 0x08000000\n-SHF_MIPS_LOCAL = 0x04000000\n-SHF_MIPS_NAMES = 0x02000000\n-SHF_MIPS_NODUPE = 0x01000000\n-STB_MIPS_SPLIT_COMMON = 13\n-PT_MIPS_REGINFO = 0x70000000\n-PT_MIPS_RTPROC = 0x70000001\n-PT_MIPS_OPTIONS = 0x70000002\n-PT_MIPS_ABIFLAGS = 0x70000003\n-PF_MIPS_LOCAL = 0x10000000\n-DT_MIPS_RLD_VERSION = 0x70000001\n-DT_MIPS_TIME_STAMP = 0x70000002\n-DT_MIPS_ICHECKSUM = 0x70000003\n-DT_MIPS_IVERSION = 0x70000004\n-DT_MIPS_FLAGS = 0x70000005\n-DT_MIPS_BASE_ADDRESS = 0x70000006\n-DT_MIPS_MSYM = 0x70000007\n-DT_MIPS_CONFLICT = 0x70000008\n-DT_MIPS_LIBLIST = 0x70000009\n-DT_MIPS_LOCAL_GOTNO = 0x7000000a\n-DT_MIPS_CONFLICTNO = 0x7000000b\n-DT_MIPS_LIBLISTNO = 0x70000010\n-DT_MIPS_SYMTABNO = 0x70000011\n-DT_MIPS_UNREFEXTNO = 0x70000012\n-DT_MIPS_GOTSYM = 0x70000013\n-DT_MIPS_HIPAGENO = 0x70000014\n-DT_MIPS_RLD_MAP = 0x70000016\n-DT_MIPS_DELTA_CLASS = 0x70000017\n-DT_MIPS_DELTA_CLASS_NO = 0x70000018\n-DT_MIPS_DELTA_INSTANCE = 0x70000019\n-DT_MIPS_DELTA_INSTANCE_NO = 0x7000001a\n-DT_MIPS_DELTA_RELOC = 0x7000001b\n-DT_MIPS_DELTA_RELOC_NO = 0x7000001c\n-DT_MIPS_DELTA_SYM = 0x7000001d\n-DT_MIPS_DELTA_SYM_NO = 0x7000001e\n-DT_MIPS_DELTA_CLASSSYM = 0x70000020\n-DT_MIPS_DELTA_CLASSSYM_NO = 0x70000021\n-DT_MIPS_CXX_FLAGS = 0x70000022\n-DT_MIPS_PIXIE_INIT = 0x70000023\n-DT_MIPS_SYMBOL_LIB = 0x70000024\n-DT_MIPS_LOCALPAGE_GOTIDX = 0x70000025\n-DT_MIPS_LOCAL_GOTIDX = 0x70000026\n-DT_MIPS_HIDDEN_GOTIDX = 0x70000027\n-DT_MIPS_PROTECTED_GOTIDX = 0x70000028\n-DT_MIPS_OPTIONS = 0x70000029\n-DT_MIPS_INTERFACE = 0x7000002a\n-DT_MIPS_DYNSTR_ALIGN = 0x7000002b\n-DT_MIPS_INTERFACE_SIZE = 0x7000002c\n-DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002d\n-DT_MIPS_PERF_SUFFIX = 0x7000002e\n-DT_MIPS_COMPACT_SIZE = 0x7000002f\n-DT_MIPS_GP_VALUE = 0x70000030\n-DT_MIPS_AUX_DYNAMIC = 0x70000031\n-DT_MIPS_PLTGOT = 0x70000032\n-DT_MIPS_RWPLT = 0x70000034\n-DT_MIPS_RLD_MAP_REL = 0x70000035\n-DT_MIPS_NUM = 0x36\n-SHN_PARISC_ANSI_COMMON = 0xff00\n-SHN_PARISC_HUGE_COMMON = 0xff01\n-SHT_PARISC_EXT = 0x70000000\n-SHT_PARISC_UNWIND = 0x70000001\n-SHT_PARISC_DOC = 0x70000002\n-SHF_PARISC_SHORT = 0x20000000\n-SHF_PARISC_HUGE = 0x40000000\n-SHF_PARISC_SBP = 0x80000000\n-STT_PARISC_MILLICODE = 13\n-STT_HP_OPAQUE = (STT_LOOS + 0x1)\n-STT_HP_STUB = (STT_LOOS + 0x2)\n-PT_HP_TLS = (PT_LOOS + 0x0)\n-PT_HP_CORE_NONE = (PT_LOOS + 0x1)\n-PT_HP_CORE_VERSION = (PT_LOOS + 0x2)\n-PT_HP_CORE_KERNEL = (PT_LOOS + 0x3)\n-PT_HP_CORE_COMM = (PT_LOOS + 0x4)\n-PT_HP_CORE_PROC = (PT_LOOS + 0x5)\n-PT_HP_CORE_LOADABLE = (PT_LOOS + 0x6)\n-PT_HP_CORE_STACK = (PT_LOOS + 0x7)\n-PT_HP_CORE_SHM = (PT_LOOS + 0x8)\n-PT_HP_CORE_MMF = (PT_LOOS + 0x9)\n-PT_HP_PARALLEL = (PT_LOOS + 0x10)\n-PT_HP_FASTBIND = (PT_LOOS + 0x11)\n-PT_HP_OPT_ANNOT = (PT_LOOS + 0x12)\n-PT_HP_HSL_ANNOT = (PT_LOOS + 0x13)\n-PT_HP_STACK = (PT_LOOS + 0x14)\n-PT_PARISC_ARCHEXT = 0x70000000\n-PT_PARISC_UNWIND = 0x70000001\n-PF_PARISC_SBP = 0x08000000\n-PF_HP_PAGE_SIZE = 0x00100000\n-PF_HP_FAR_SHARED = 0x00200000\n-PF_HP_NEAR_SHARED = 0x00400000\n-PF_HP_CODE = 0x01000000\n-PF_HP_MODIFY = 0x02000000\n-PF_HP_LAZYSWAP = 0x04000000\n-PF_HP_SBP = 0x08000000\n-SHT_ALPHA_DEBUG = 0x70000001\n-SHT_ALPHA_REGINFO = 0x70000002\n-SHF_ALPHA_GPREL = 0x10000000\n-DT_ALPHA_PLTRO = (DT_LOPROC + 0)\n-DT_ALPHA_NUM = 1\n-DT_PPC_GOT = (DT_LOPROC + 0)\n-DT_PPC_OPT = (DT_LOPROC + 1)\n-DT_PPC_NUM = 2\n-DT_PPC64_GLINK = (DT_LOPROC + 0)\n-DT_PPC64_OPD = (DT_LOPROC + 1)\n-DT_PPC64_OPDSZ = (DT_LOPROC + 2)\n-DT_PPC64_OPT = (DT_LOPROC + 3)\n-DT_PPC64_NUM = 4\n-STT_ARM_TFUNC = STT_LOPROC\n-STT_ARM_16BIT = STT_HIPROC\n-SHF_ARM_ENTRYSECT = 0x10000000\n-SHF_ARM_COMDEF = 0x80000000\n-PF_ARM_SB = 0x10000000\n-PF_ARM_PI = 0x20000000\n-PF_ARM_ABS = 0x40000000\n-PT_ARM_EXIDX = (PT_LOPROC + 1)\n-SHT_ARM_EXIDX = (SHT_LOPROC + 1)\n-SHT_ARM_PREEMPTMAP = (SHT_LOPROC + 2)\n-SHT_ARM_ATTRIBUTES = (SHT_LOPROC + 3)\n-PT_IA_64_ARCHEXT = (PT_LOPROC + 0)\n-PT_IA_64_UNWIND = (PT_LOPROC + 1)\n-PT_IA_64_HP_OPT_ANOT = (PT_LOOS + 0x12)\n-PT_IA_64_HP_HSL_ANOT = (PT_LOOS + 0x13)\n-PT_IA_64_HP_STACK = (PT_LOOS + 0x14)\n-PF_IA_64_NORECOV = 0x80000000\n-SHT_IA_64_EXT = (SHT_LOPROC + 0)\n-SHT_IA_64_UNWIND = (SHT_LOPROC + 1)\n-SHF_IA_64_SHORT = 0x10000000\n-SHF_IA_64_NORECOV = 0x20000000\n-DT_IA_64_PLT_RESERVE = (DT_LOPROC + 0)\n-DT_IA_64_NUM = 1\n-DT_NIOS2_GP = 0x70000002\n-\n-\n-Elf_Ehdr = namedtuple('Elf_Ehdr', [\n-    'e_ident',\n-    'e_type',\n-    'e_machine',\n-    'e_version',\n-    'e_entry',\n-    'e_phoff',\n-    'e_shoff',\n-    'e_flags',\n-    'e_ehsize',\n-    'e_phentsize',\n-    'e_phnum',\n-    'e_shentsize',\n-    'e_shnum',\n-    'e_shstrndx',\n-])\n-\n-\n-Elf_Shdr = namedtuple('Elf_Shdr', [\n-    'sh_name',\n-    'sh_type',\n-    'sh_flags',\n-    'sh_addr',\n-    'sh_offset',\n-    'sh_size',\n-    'sh_link',\n-    'sh_info',\n-    'sh_addralign',\n-    'sh_entsize',\n-])\n-\n-\n-Elf_Sym = namedtuple('Elf_Sym', [\n-    'st_name',\n-    'st_info',\n-    'st_other',\n-    'st_shndx',\n-    'st_value',\n-    'st_size',\n-])\n-\n-\n-Elf_Phdr = namedtuple('Elf_Phdr', [\n-    'p_type',\n-    'p_flags',\n-    'p_offset',\n-    'p_vaddr',\n-    'p_paddr',\n-    'p_filesz',\n-    'p_memsz',\n-    'p_align',\n-])\n-\n-\n-class ElfFile:\n-    def __init__(self, file):\n-        self.file = file\n-        self._ehdr = None\n-        self._shdrs = None\n-        self._shstrtab_shdr = None\n-        self._shdrs_by_name = None\n-        self._phdrs = None\n-        self._symbols = None\n-        self._symbols_by_name = None\n-\n-    def ehdr(self):\n-        if self._ehdr is None:\n-            self.file.seek(0)\n-            buf = self.file.read(64)  # sizeof(struct Elf64_Ehdr)\n-\n-            if (buf[EI_MAG0] != ELFMAG0 or buf[EI_MAG1] != ELFMAG1 or\n-                buf[EI_MAG2] != ELFMAG2 or buf[EI_MAG3] != ELFMAG3):\n-                raise ValueError('not an ELF file')\n-\n-            if buf[EI_VERSION] != EV_CURRENT:\n-                raise ValueError('ELF version is not EV_CURRENT')\n-\n-            if buf[EI_DATA] == ELFDATA2LSB:\n-                fmt = '<'\n-            elif buf[EI_DATA] == ELFDATA2MSB:\n-                fmt = '>'\n-            else:\n-                raise ValueError(f'unknown ELF data encoding {buf[EI_DATA]}')\n-\n-            if buf[EI_CLASS] == ELFCLASS64:\n-                fmt += '16sHHLQQQLHHHHHH'\n-            elif buf[EI_CLASS] == ELFCLASS32:\n-                raise NotImplementedError('32-bit ELF is not implemented')\n-            else:\n-                raise ValueError(f'unknown ELF class {buf[EI_CLASS]}')\n-            self._ehdr = Elf_Ehdr._make(struct.unpack_from(fmt, buf))\n-        return self._ehdr\n-\n-    def shdrs(self):\n-        if self._shdrs is None:\n-            ehdr = self.ehdr()\n-            self.file.seek(ehdr.e_shoff)\n-            # TODO: e_shnum == 0\n-            buf = self.file.read(ehdr.e_shnum * ehdr.e_shentsize)\n-\n-            if ehdr.e_ident[EI_DATA] == ELFDATA2LSB:\n-                fmt = '<'\n-            else:\n-                fmt = '>'\n-\n-            if ehdr.e_ident[EI_CLASS] == ELFCLASS64:\n-                fmt += 'LLQQQQLLQQ'\n-            else:\n-                assert False\n-            self._shdrs = [Elf_Shdr._make(x) for x in struct.iter_unpack(fmt, buf)]\n-        return self._shdrs\n-\n-    def shstrtab_shdr(self):\n-        if self._shstrtab_shdr is None:\n-            ehdr = self.ehdr()\n-            shdrs = self.shdrs()\n-            if ehdr.e_shstrndx == SHN_UNDEF:\n-                raise ValueError('no string table index in ELF header')\n-            elif ehdr.e_shstrndx == SHN_XINDEX:\n-                shdr = shdrs[shdrs[0].sh_link]\n-            else:\n-                if ehdr.e_shstrndx >= SHN_LORESERVE:\n-                    raise ValueError('invalid string table index in ELF header')\n-                shdr = shdrs[ehdr.e_shstrndx]\n-            if shdr.sh_type != SHT_STRTAB or shdr.sh_size == 0:\n-                raise ValueError('invalid string table section')\n-            self._shstrtab_shdr = shdr\n-        return self._shstrtab_shdr\n-\n-    def shdrs_by_name(self):\n-        if self._shdrs_by_name is None:\n-            shstrtab_shdr = self.shstrtab_shdr()\n-            self.file.seek(shstrtab_shdr.sh_offset)\n-            shstrtab = self.file.read(shstrtab_shdr.sh_size)\n-            shdrs = self.shdrs()\n-            shdrs_by_name = {}\n-            for shdr in shdrs:\n-                if not shdr.sh_name:\n-                    continue\n-                end = shstrtab.index(b'\\0', shdr.sh_name)\n-                name = shstrtab[shdr.sh_name:end].decode()\n-                if name in shdrs_by_name:\n-                    raise ValueError(f'duplicate section name {name!r}')\n-                shdrs_by_name[name] = shdr\n-            self._shdrs_by_name = shdrs_by_name\n-        return self._shdrs_by_name\n-\n-    def shdr(self, name):\n-        return self.shdrs_by_name()[name]\n-\n-    def phdrs(self):\n-        if self._phdrs is None:\n-            ehdr = self.ehdr()\n-            self.file.seek(ehdr.e_phoff)\n-            buf = self.file.read(ehdr.e_phnum * ehdr.e_phentsize)\n-\n-            if ehdr.e_ident[EI_DATA] == ELFDATA2LSB:\n-                fmt = '<'\n-            else:\n-                fmt = '>'\n-\n-            if ehdr.e_ident[EI_CLASS] == ELFCLASS64:\n-                fmt += 'LLQQQQQQ'\n-            else:\n-                assert False\n-            self._phdrs = [Elf_Phdr._make(x) for x in struct.iter_unpack(fmt, buf)]\n-        return self._phdrs\n-\n-    def symbols(self):\n-        if self._symbols is None:\n-            ehdr = self.ehdr()\n-            shdr = self.shdr('.symtab')\n-            self.file.seek(shdr.sh_offset)\n-            buf = self.file.read(shdr.sh_size)\n-\n-            if ehdr.e_ident[EI_DATA] == ELFDATA2LSB:\n-                fmt = '<'\n-            else:\n-                fmt = '>'\n-\n-            if ehdr.e_ident[EI_CLASS] == ELFCLASS64:\n-                fmt += 'LBBHQQ'\n-            else:\n-                assert False\n-            self._symbols = [Elf_Sym._make(x) for x in struct.iter_unpack(fmt, buf)]\n-        return self._symbols\n-\n-    def symbols_by_name(self):\n-        if self._symbols_by_name is None:\n-            strtab_shdr = self.shdr('.strtab')\n-            self.file.seek(strtab_shdr.sh_offset)\n-            strtab = self.file.read(strtab_shdr.sh_size)\n-            symbols = self.symbols()\n-            symbols_by_name = {}\n-            for symbol in symbols_by_name:\n-                if symbol.st_name:\n-                    end = strtab.index(b'\\0', symbol.st_name)\n-                    name = strtab[symbol.st_name:end].decode()\n-                else:\n-                    name = ''\n-                try:\n-                    symbols_by_name[name].append(symbol)\n-                except KeyError:\n-                    symbols_by_name[name] = [symbol]\n-            self._symbols_by_name = symbols_by_name\n-        return self._symbols_by_name\n-\n-    def read_section(self, shdr):\n-        ehdr = self.ehdr()\n-        self.file.seek(shdr.sh_offset)\n-        if shdr.sh_flags & SHF_COMPRESSED:\n-            if ehdr.e_ident[EI_DATA] == ELFDATA2LSB:\n-                fmt = '<'\n-            else:\n-                fmt = '>'\n-\n-            if ehdr.e_ident[EI_CLASS] == ELFCLASS64:\n-                fmt += 'LxxxxQQ'\n-                ch_size = 24\n-            else:\n-                assert False\n-            buf = self.file.read(struct.calcsize(fmt))\n-            ch_type, ch_size, ch_addralign = struct.unpack(fmt, buf)\n-            buf = self.file.read(shdr.sh_size - len(buf))\n-            if ch_type == ELFCOMPRESS_ZLIB:\n-                buf = zlib.decompress(buf)\n-            else:\n-                raise NotImplementedError(f'unknown compression type {ch_type}')\n-        else:\n-            buf = self.file.read(shdr.sh_size)\n-        return buf\ndiff --git a/generate_elf_constants.py b/generate_elf_constants.py\nindex d816547c..a776886d 100755\n--- a/generate_elf_constants.py\n+++ b/generate_elf_constants.py\n@@ -17,6 +17,7 @@ constant_prefixes = [\n     'GRP_',\n     'PF_',\n     'PT_',\n+    'R_X86_64',\n     'SHF_',\n     'SHN_',\n     'SHT_',\n@@ -35,16 +36,16 @@ if __name__ == '__main__':\n                          elf_h, re.MULTILINE)\n \n     print('# Automatically generated from elf.h')\n+    print('cdef enum:')\n     for constant, value in matches:\n         if value.startswith(\"'\"):\n             assert len(value) == 3 and value.endswith(\"'\")\n             value = hex(ord(value[1]))\n         elif value.startswith('\"'):\n-            assert value.endswith('\"')\n-            value = \"b'\" + value[1:-1] + \"'\"\n+            continue\n         if constant == 'DT_PROCNUM':\n             value = next(match[1] for match in matches if match[0] == value)\n         # Special case for SHF_EXCLUDE.\n-        if value == '(1U << 31)':\n-            value = '(1 << 31)'\n-        print(f'{constant} = {value}')\n+        # if value == '(1U << 31)':\n+            # value = '(1 << 31)'\n+        print(f'    {constant} = {value}')\ndiff --git a/setup.py b/setup.py\nindex 427da2b9..fd37b8b7 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -12,6 +12,12 @@ extensions = [\n             'drgn/dwarf.pyx',\n         ],\n     ),\n+    Extension(\n+        name='drgn.elf',\n+        sources=[\n+            'drgn/elf.pyx',\n+        ],\n+    ),\n ]\n \n setup(\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex cf6d6de8..95dab08f 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -425,14 +425,14 @@ class TestFromDwarfType(unittest.TestCase):\n         self.tmp_dir.cleanup()\n \n     def compile_type(self, decl):\n-        program_path = os.path.join(self.tmp_dir.name, 'test')\n-        source_path = program_path + '.c'\n+        object_path = os.path.join(self.tmp_dir.name, 'test')\n+        source_path = object_path + '.c'\n         with open(source_path, 'w') as f:\n             f.write(decl)\n             f.write(';\\nint main(void) { return 0; }\\n')\n-        subprocess.check_call(['gcc', '-g', '-o', program_path, source_path])\n-        with open(program_path, 'rb') as program_file:\n-            dwarf_file = DwarfFile.from_file(program_file)\n+        subprocess.check_call(['gcc', '-g', '-c', '-o', object_path, source_path])\n+        with open(object_path, 'rb') as object_file:\n+            dwarf_file = DwarfFile.from_file(object_file)\n             dwarf_index = DwarfIndex()\n             for cu in dwarf_file.cu_headers():\n                 dwarf_index.index_cu(cu)\n@@ -653,8 +653,8 @@ class TestFromTypeString(unittest.TestCase):\n     @classmethod\n     def setUpClass(cls):\n         with tempfile.TemporaryDirectory() as tmp_dir:\n-            program_path = os.path.join(tmp_dir, 'test')\n-            source_path = program_path + '.c'\n+            object_path = os.path.join(tmp_dir, 'test')\n+            source_path = object_path + '.c'\n             with open(source_path, 'w') as f:\n                 f.write(\"\"\"\\\n int i;\n@@ -683,9 +683,9 @@ int main(void)\n \treturn 0;\n }\n \"\"\")\n-            subprocess.check_call(['gcc', '-g', '-o', program_path, source_path])\n-            cls.program_file = open(program_path, 'rb')\n-            dwarf_file = DwarfFile.from_file(cls.program_file)\n+            subprocess.check_call(['gcc', '-g', '-c', '-o', object_path, source_path])\n+            cls.object_file = open(object_path, 'rb')\n+            dwarf_file = DwarfFile.from_file(cls.object_file)\n             dwarf_index = DwarfIndex()\n             for cu in dwarf_file.cu_headers():\n                 dwarf_index.index_cu(cu)\n@@ -693,8 +693,8 @@ int main(void)\n \n     @classmethod\n     def tearDownClass(cls):\n-        if hasattr(cls, 'program_file'):\n-            cls.program_file.close()\n+        if hasattr(cls, 'object_file'):\n+            cls.object_file.close()\n \n     def test_void_type(self):\n         self.assertEqual(self.type_factory.from_type_string('void'),\n"}
{"repo": "drgn", "commit": "aa4d5852b3be506342a7eab7f73a3de23c1f79f9", "diff": "diff --git a/drgn/type.py b/drgn/type.py\nindex 223c60a0..92848037 100644\n--- a/drgn/type.py\n+++ b/drgn/type.py\n@@ -522,8 +522,8 @@ class ArrayType(Type):\n         if len(buffer) - offset < size:\n             raise ValueError(f'buffer must be at least {size} bytes')\n         return [\n-            self.type.read(buffer, element_offset)\n-            for element_offset in range(offset, offset + size, element_size)\n+            self.type.read(buffer, offset + i * element_size)\n+            for i in range(self.size)\n         ]\n \n     def format(self, buffer, offset=0, *, cast=True):\n@@ -536,10 +536,12 @@ class ArrayType(Type):\n         else:\n             element_size = self.type.sizeof()\n             size = self.size * element_size\n+            if len(buffer) - offset < size:\n+                raise ValueError(f'buffer must be at least {size} bytes')\n             elements = []\n             format_element = False\n-            for element_offset in range(offset + size - element_size,\n-                                        offset - element_size, -element_size):\n+            for i in range(self.size - 1, -1, -1):\n+                element_offset = offset + i * element_size\n                 if not format_element:\n                     for byte_offset in range(element_offset,\n                                              element_offset + element_size):\ndiff --git a/tests/test_type.py b/tests/test_type.py\nindex 2e6368f0..63d89a64 100644\n--- a/tests/test_type.py\n+++ b/tests/test_type.py\n@@ -44,7 +44,6 @@ line_segment_type = StructType('line_segment', 16, [\n pointer_size = ctypes.sizeof(ctypes.c_void_p)\n \n \n-\n class TestType(unittest.TestCase):\n     def test_void(self):\n         type_ = VoidType()\n@@ -392,6 +391,7 @@ enum {\n \t-1,\n }\"\"\")\n         self.assertRaises(ValueError, type_.read, buffer, 3)\n+        self.assertRaises(ValueError, type_.format, buffer, 3)\n \n         type_ = ArrayType(ArrayType(IntType('int', 4, True), 3), 2)\n         self.assertEqual(str(type_), 'int [2][3]')\n@@ -399,6 +399,14 @@ enum {\n         type_ = ArrayType(ArrayType(ArrayType(IntType('int', 4, True), 4), 3), 2)\n         self.assertEqual(str(type_), 'int [2][3][4]')\n \n+    def test_array_with_empty_element(self):\n+        type_ = ArrayType(StructType('empty', 0, []), 2)\n+        self.assertEqual(str(type_), 'struct empty [2]')\n+        self.assertEqual(type_.sizeof(), 0)\n+        self.assertEqual(type_.read(b''), [OrderedDict(), OrderedDict()])\n+        self.assertEqual(type_.format(b''), '(struct empty [2]){}')\n+        self.assertRaises(ValueError, type_.format, b'', 1)\n+\n     def test_incomplete_array(self):\n         type_ = ArrayType(IntType('int', 4, True), None)\n         self.assertEqual(str(type_), 'int []')\n"}
{"repo": "drgn", "commit": "0013015f2c057f0a9db429a74ab0d5cc79720b79", "diff": "diff --git a/drgn/cli/dump.py b/drgn/cli/dump.py\nindex 6b7e9fa6..17f68902 100644\n--- a/drgn/cli/dump.py\n+++ b/drgn/cli/dump.py\n@@ -1,5 +1,7 @@\n-import drgn.dwarf\n-from drgn.dwarf import DwarfProgram, parse_uleb128, parse_sleb128\n+from drgn.dwarf import (\n+    Die, DwarfAttribNotFoundError, DwarfProgram, DwarfProgram,\n+    LineNumberProgram, LineNumberRow, parse_uleb128, parse_sleb128,\n+)\n from drgn.dwarfdefs import *\n import fnmatch\n import os.path\n@@ -19,13 +21,13 @@ def dump_cu(cu, name=None, *, indent=0):\n     print(f'{prefix}  is_64_bit = {cu.is_64_bit}')\n \n \n-def dump_die(die: drgn.dwarf.Die, *, indent: int=0, recurse: bool=False,\n+def dump_die(die: Die, *, indent: int=0, recurse: bool=False,\n              location: bool=False) -> None:\n     prefix = ' ' * indent\n     print(f'{prefix}<{die.offset}> {tag_name(die.tag)}', end='')\n     try:\n         name = die.name()\n-    except ValueError:\n+    except DwarfAttribNotFoundError:\n         print()\n     else:\n         print(f' ({name!r})')\n@@ -245,7 +247,7 @@ def dump_expression(value, address_size: int, is_64_bit: bool, *, indent: int=0)\n             raise ValueError(f'unknown opcode {op_name(opcode)}')\n \n \n-def dump_lnp(lnp: drgn.dwarf.LineNumberProgram, *, indent: int=0):\n+def dump_lnp(lnp: LineNumberProgram, *, indent: int=0):\n     prefix = ' ' * indent\n     print(f'{prefix}<{lnp.offset}> line number program')\n     print(f'{prefix}  unit_length = {lnp.unit_length}')\n@@ -275,7 +277,7 @@ def dump_lnp(lnp: drgn.dwarf.LineNumberProgram, *, indent: int=0):\n     dump_lnp_ops(lnp, indent=indent + 2)\n \n \n-def dump_lnp_ops(lnp: drgn.dwarf.LineNumberProgram, *, indent: int=0):\n+def dump_lnp_ops(lnp: LineNumberProgram, *, indent: int=0):\n     prefix = ' ' * indent\n     print(f'{prefix}opcodes = {{')\n     offset = lnp.program.debug_line.sh_offset + lnp.program_offset()\ndiff --git a/drgn/cli/probe.py b/drgn/cli/probe.py\nindex ddf334e0..7a19b22a 100644\n--- a/drgn/cli/probe.py\n+++ b/drgn/cli/probe.py\n@@ -1,6 +1,9 @@\n from copy import copy\n from drgn.arch import DWARF_REG_TO_FETCHARG\n-from drgn.dwarf import DwarfProgram, CompilationUnitHeader, Die, LineNumberRow\n+from drgn.dwarf import (\n+    CompilationUnitHeader, Die, DwarfAttribNotFoundError,\n+    DwarfLocationNotFoundError, DwarfProgram, LineNumberRow,\n+)\n from drgn.dwarfdefs import *\n from drgn.ftrace import Kprobe, FtraceInstance\n import re\n@@ -61,7 +64,7 @@ def find_subprogram_by_name(program: DwarfProgram, name: str) -> DiePath:\n             path.append(children, i)\n             return path\n     else:\n-        raise ValueError('subprogram not found')\n+        raise ValueError(f'could not find {name!r}')\n \n \n def find_cu_by_name(program: DwarfProgram, filename: str) -> CompilationUnitHeader:\n@@ -206,9 +209,12 @@ def cmd_probe(args):\n             var_type = unqualified_type(resolved_var.type())\n             fetcharg_type = dwarf_to_fetcharg_type(var_type)\n \n-            # TODO: catch no location (optimized out), or not available at that\n-            # location.\n-            var_location = resolved_var.location(probe_addr)\n+            try:\n+                var_location = resolved_var.location(probe_addr)\n+            except DwarfAttribNotFoundError:\n+                raise ValueError(f'{var!r} was optimized out')\n+            except DwarfLocationNotFoundError:\n+                raise ValueError(f'{var!r} is not available at the given location')\n             fetcharg_location = dwarf_to_fetcharg_location(var_location)\n \n             if fetcharg_type == 'string':\n"}
{"repo": "voltron", "commit": "9f09c3f20bdf19e116e4e0b2558a4afb2d506a5d", "diff": "diff --git a/voltron/dbg.py b/voltron/dbg.py\nindex ceb1939..4d92f5b 100644\n--- a/voltron/dbg.py\n+++ b/voltron/dbg.py\n@@ -124,7 +124,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except Exception as e:\n             log.error(\"Exception checking if target exists: {} {}\".format(type(e), e))\n             return False\n@@ -138,7 +138,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except:\n             return False\n         return target['state'] != \"invalid\"\n@@ -151,7 +151,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except:\n             raise NoSuchTargetException()\n         return target['state'] == \"running\"\n@@ -204,7 +204,7 @@ class DebuggerAdaptor(object):\n         \"\"\"\n         Disassemble with capstone.\n         \"\"\"\n-        target = self._target(target_id)\n+        target = self.target(target_id)\n         if not address:\n             pc_name, address = self.pc()\n \n"}
{"repo": "voltron", "commit": "e82bf244fa5c8ea292d96683a822523138c61641", "diff": "diff --git a/voltron/__main__.py b/voltron/__main__.py\nindex 5d6a810..3bdfa40 100644\n--- a/voltron/__main__.py\n+++ b/voltron/__main__.py\n@@ -1,3 +1,10 @@\n-from .main import main\n+try:\n+    # for some reason the relative import doesn't work in VSCode's\n+    # interactive debugger, but this does but I'm not sure if there's a\n+    # chance a different voltron could be somewhere in sys.path, so\n+    # let's try the relative import first\n+    from .main import main\n+except ImportError:\n+    from voltron.main import main\n \n main()\n"}
{"repo": "voltron", "commit": "ff902379f5676fe614db0e7bdc6a59a4d4ee9a22", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 69c58f9..7438539 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -573,8 +573,10 @@ if HAVE_LLDB:\n                     output = self.adaptor.command('target stop-hook add -o \\'voltron stopped\\'')\n                     try:\n                         # hahaha this sucks\n-                        self.hook_idx = int(res.GetOutput().strip().split()[2][1:])\n-                    except:\n+                        log.debug(\"Saving hook index for unregistering.\")\n+                        self.hook_idx = int(output.split()[2][1:])\n+                    except Exception as e:\n+                        log.warning(f\"Exception when saving hook index for unregistering. {e}\")\n                         pass\n                 self.registered = True\n                 if not quiet:\n"}
{"repo": "voltron", "commit": "7030c7f486c3c24264f4dd387ff40cc0f3ab77b5", "diff": "diff --git a/voltron/plugins/view/disasm.py b/voltron/plugins/view/disasm.py\nindex c4cc90c..5a2d50a 100644\n--- a/voltron/plugins/view/disasm.py\n+++ b/voltron/plugins/view/disasm.py\n@@ -50,9 +50,10 @@ class DisasmView(TerminalView):\n             try:\n                 host = 'capstone' if self.args.use_capstone else res.host\n                 lexer = get_lexer_by_name('{}_{}'.format(host, res.flavor))\n-                disasm = pygments.highlight(disasm, lexer, pygments.formatters.get_formatter_by_name(\n-                                            self.config.format.pygments_formatter,\n-                                            style=self.config.format.pygments_style))\n+                formatter = pygments.formatters.get_formatter_by_name(\n+                    self.config.format.pygments_formatter,\n+                    style=self.config.format.pygments_style)\n+                disasm = pygments.highlight(disasm, lexer, formatter)\n             except Exception as e:\n                 log.warning('Failed to highlight disasm: ' + str(e))\n                 log.info(self.config.format)\n"}
{"repo": "voltron", "commit": "44caf3e318bf9adc889ad2f1ee61e94472ceccc6", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 75c7d1c..e862a43 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -331,7 +331,7 @@ if HAVE_LLDB:\n             `count` is the number of instructions to disassemble.\n             \"\"\"\n             # make sure we have an address\n-            if address == None:\n+            if address is None:\n                 pc_name, address = self.program_counter(target_id=target_id)\n \n             # disassemble\n@@ -464,12 +464,12 @@ if HAVE_LLDB:\n                 locations = []\n \n                 for j in range(0, b.GetNumLocations()):\n-                    l = b.GetLocationAtIndex(j)\n+                    loc = b.GetLocationAtIndex(j)\n                     s.Clear()\n-                    l.GetAddress().GetDescription(s)\n+                    loc.GetAddress().GetDescription(s)\n                     desc = s.GetData()\n                     locations.append({\n-                        'address':  l.GetLoadAddress(),\n+                        'address':  loc.GetLoadAddress(),\n                         'name':     desc\n                     })\n \n@@ -541,7 +541,6 @@ if HAVE_LLDB:\n             # register the invocation as a command script handler thing\n             self.host.HandleCommand(\"command script add -f voltron.commands.{} {}\".format(name, name))\n \n-\n     class LLDBCommand(DebuggerCommand):\n         \"\"\"\n         Debugger command class for LLDB\n@@ -587,7 +586,6 @@ if HAVE_LLDB:\n             self.adaptor.command('target stop-hook delete {}'.format(self.hook_idx if self.hook_idx else ''))\n             self.registered = False\n \n-\n     class LLDBAdaptorPlugin(DebuggerAdaptorPlugin):\n         host = 'lldb'\n         adaptor_class = LLDBAdaptor\n"}
{"repo": "voltron", "commit": "ba413dcbc1914c511d03e1d95f3663a91daf349a", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex f22f375..351a0ea 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -15,7 +15,8 @@ import six\n import voltron\n from flask import Flask, Response, make_response, redirect, render_template, request\n from werkzeug.serving import BaseWSGIServer, ThreadedWSGIServer, WSGIRequestHandler\n-from werkzeug.wsgi import DispatcherMiddleware, SharedDataMiddleware\n+from werkzeug.middleware.dispatcher import DispatcherMiddleware\n+from werkzeug.middleware.shared_data import SharedDataMiddleware\n from requests import ConnectionError\n \n \n"}
{"repo": "voltron", "commit": "f1ae7ba55917e3b4f1f956b8c66e14e82eaec4ce", "diff": "diff --git a/voltron/dbg.py b/voltron/dbg.py\nindex ceb1939..4d92f5b 100644\n--- a/voltron/dbg.py\n+++ b/voltron/dbg.py\n@@ -124,7 +124,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except Exception as e:\n             log.error(\"Exception checking if target exists: {} {}\".format(type(e), e))\n             return False\n@@ -138,7 +138,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except:\n             return False\n         return target['state'] != \"invalid\"\n@@ -151,7 +151,7 @@ class DebuggerAdaptor(object):\n         `target_id` is a target ID (or None for the first target)\n         \"\"\"\n         try:\n-            target = self._target(target_id=target_id)\n+            target = self.target(target_id=target_id)\n         except:\n             raise NoSuchTargetException()\n         return target['state'] == \"running\"\n@@ -204,7 +204,7 @@ class DebuggerAdaptor(object):\n         \"\"\"\n         Disassemble with capstone.\n         \"\"\"\n-        target = self._target(target_id)\n+        target = self.target(target_id)\n         if not address:\n             pc_name, address = self.pc()\n \n"}
{"repo": "voltron", "commit": "bcf25d957657414d025ff488889cdef8d4fcae06", "diff": "diff --git a/voltron/plugins/api/__init__.py b/voltron/plugins/api/__init__.py\nindex e69de29..4c109a3 100644\n--- a/voltron/plugins/api/__init__.py\n+++ b/voltron/plugins/api/__init__.py\n@@ -0,0 +1,2 @@\n+if not hasattr(__builtins__, \"xrange\"):\n+    xrange = range\n"}
{"repo": "voltron", "commit": "46855ea6b181787028a00ba2d4e1f456b6a84318", "diff": "diff --git a/voltron/plugins/api/__init__.py b/voltron/plugins/api/__init__.py\nindex e69de29..4c109a3 100644\n--- a/voltron/plugins/api/__init__.py\n+++ b/voltron/plugins/api/__init__.py\n@@ -0,0 +1,2 @@\n+if not hasattr(__builtins__, \"xrange\"):\n+    xrange = range\n"}
{"repo": "voltron", "commit": "81fddbfeee4ad7e74e2eb67266c9b1b3d043390a", "diff": "diff --git a/voltron/plugins/view/memstride.py b/voltron/plugins/view/memstride.py\nindex 6ee2d2e..1371885 100644\n--- a/voltron/plugins/view/memstride.py\n+++ b/voltron/plugins/view/memstride.py\n@@ -33,24 +33,20 @@ class MemoryStrideView(TerminalView):\n \n \n     async = True\n+    prev_last_memory = None\n     last_memory = None\n     last_address = 0\n     last_length = 0\n-    view_style = {'hex_or_dec':'hex', 'word_size':4, 'unsigned':True}\n+    view_style = {'hex_or_dec':'hex', 'word_size':4, 'unsigned':False}\n \n     @classmethod\n     def configure_subparser(cls, subparsers):\n         sp = subparsers.add_parser('memorystride', help='display a chunk of memory', aliases=('ms', 'mems','memstride'))\n         VoltronView.add_generic_arguments(sp)\n         group = sp.add_mutually_exclusive_group(required=False)\n-        group.add_argument('--deref', '-d', action='store_true',\n-                           help='display the data in a column one CPU word wide and dereference any valid pointers',\n-                           default=False)\n         group.add_argument('--bytes', '-b', action='store', type=int, help='bytes per line (default 16)', default=16)\n-        group.add_argument('--words', '-w', action='store', type=int, help='machine words per line', default=0)\n-        group.add_argument('--stride', '-s', action='store', type=int, help='bytes between lines (default 128)', default=128)\n-        group.add_argument('--rows', '-o', action='store', type=int, help='Lines to print (default 32)', default=32)\n-        group.add_argument('--max', action='store', type=int, help='Lines to print (default 0)', default=0)\n+        sp.add_argument('--stride', '-s', action='store', type=int, help='bytes between lines (default 128)', default=128)\n+        sp.add_argument('--max', action='store', type=int, help='Lines to print (default 0)', default=0)\n         sp.add_argument('--reverse', '-v', action='store_true', help='reverse the output', default=False)\n         sp.add_argument('--track', '-t', action='store_true', help='track and highlight changes', default=True)\n         sp.add_argument('--no-track', '-T', action='store_false', help='don\\'t track and highlight changes')\n@@ -83,11 +79,15 @@ class MemoryStrideView(TerminalView):\n                     addr = int(self.args.address, 10)\n                 except:\n                     addr = int(self.args.address, 16)\n+            # force address be 4-byte aligned\n+            addr = int(addr/4)*4\n             args = {'address': addr}\n+\n         else:\n             args = {'register': 'sp'}\n \n-        args['words'] = self.args.stride*self.args.rows\n+\n+        args['length'] = self.args.stride*height\n         args['offset'] = self.scroll_offset*self.args.stride if self.args.reverse else -self.scroll_offset*self.args.stride\n         if self.args.max:\n             args['length'] = self.args.max\n@@ -95,7 +95,7 @@ class MemoryStrideView(TerminalView):\n         # get memory and target info\n         return [\n             api_request('targets'),\n-            api_request('memory', deref=self.args.deref is True, **args)\n+            api_request('memory', deref=False, **args)\n         ]\n \n     def generate_tokens(self, results):\n@@ -106,9 +106,11 @@ class MemoryStrideView(TerminalView):\n \n         if m_res and m_res.is_success:\n             bytes_per_chunk = self.args.stride\n-            row_len = self.args.words*self.view_style['word_size'] if self.args.words else self.args.bytes\n+            row_len = self.args.bytes\n             m_res.memory = binascii.unhexlify(m_res.memory)\n-            read_bytes = min(self.args.max, m_res.bytes)\n+            read_bytes = m_res.bytes\n+            if(self.args.max):\n+                read_bytes = min(self.args.max, m_res.bytes)\n             for c in range(0, read_bytes, bytes_per_chunk):\n                 chunk = m_res.memory[c:c + row_len]\n                 yield (Name.Label, self.format_address(m_res.address + c, size=target['addr_size'], pad=False))\n@@ -116,7 +118,6 @@ class MemoryStrideView(TerminalView):\n \n                 # Hex bytes\n                 byte_array = []\n-                #raw_byte_array = []\n                 for i, x in enumerate(six.iterbytes(chunk)):\n                     n = \"%02X\" % x\n                     token = Text if x else Comment #Set color white or teal\n@@ -127,7 +128,6 @@ class MemoryStrideView(TerminalView):\n                             if x != six.indexbytes(self.last_memory, byte_addr - self.last_address):\n                                 token = Error #Set color to red\n                     byte_array.append((token, n))\n-                    #raw_byte_array.append(x)\n \n \n                 byte_array_words = [byte_array[i:i+ self.view_style['word_size']] for i in range(0, row_len, self.view_style['word_size'])]\n@@ -185,9 +185,6 @@ class MemoryStrideView(TerminalView):\n         if t_res and t_res.is_success and len(t_res.targets) > 0:\n             target = t_res.targets[0]\n \n-            if self.args.deref or self.args.words:\n-                self.args.bytes = target['addr_size']\n-\n             f = pygments.formatters.get_formatter_by_name(self.config.format.pygments_formatter,\n                                                           style=self.config.format.pygments_style)\n \n@@ -202,6 +199,8 @@ class MemoryStrideView(TerminalView):\n \n             # Store the memory\n             if self.args.track:\n+                #Annoying hack so viewing changes still see deltas\n+                self.prev_last_memory = self.last_memory\n                 self.last_address = m_res.address\n                 self.last_memory = m_res.memory\n                 self.last_length = m_res.bytes\n@@ -209,7 +208,7 @@ class MemoryStrideView(TerminalView):\n             self.body = self.colour(\"Failed to get targets\", 'red')\n \n         if not self.title:\n-            self.title = \"[memory]\"\n+            self.title = \"[memoryStride (\" + str(self.args.stride) + \") ]\"\n \n         super(MemoryStrideView, self).render(results)\n \n@@ -245,12 +244,17 @@ class MemoryStrideView(TerminalView):\n         except:\n             raise\n \n-    #@requires_async\n+    def kybd_update(self):\n+        # Annoying hack so viewing changes still see deltas\n+        self.last_memory = self.prev_last_memory\n+        self.client.update()\n+\n+    @requires_async\n     def toggle_signed(self):\n         self.view_style['unsigned'] = not self.view_style['unsigned']\n-        self.client.update()\n+        self.kybd_update()\n \n-    #@requires_async\n+    @requires_async\n     def toggle_length(self):\n         x = int(math.log(self.view_style['word_size'], 2))\n         x = (x+1)%4\n@@ -259,37 +263,35 @@ class MemoryStrideView(TerminalView):\n         if self.args.bytes % self.view_style['word_size'] != 0:\n             # force bytes to be an even multiple of the word_size\n             self.args.bytes &= ~(self.view_style['word_size'] - 1)\n-        self.client.update()\n+        self.kybd_update()\n \n     @requires_async\n     def dec_mode(self):\n         self.view_style['hex_or_dec'] = 'dec'\n-        self.client.update()\n+        self.kybd_update()\n \n     @requires_async\n     def hex_mode(self):\n         self.view_style['hex_or_dec'] = 'hex'\n-        self.client.update()\n+        self.kybd_update()\n \n     @requires_async\n     def inc_row_len(self):\n-        if self.args.words:\n-            self.args.words += 1\n-        else:\n-            self.args.bytes += self.view_style['word_size']\n-            #force bytes to be an even multiple of the word_size\n-            self.args.bytes &= ~(self.view_style['word_size']-1)\n-        self.client.update()\n+        x = self.args.bytes + self.view_style['word_size']\n+        #force bytes to be an even multiple of the word_size\n+        x &= ~(self.view_style['word_size']-1)\n+        if x <= self.args.stride:\n+            self.args.bytes = x\n+        self.kybd_update()\n \n     @requires_async\n     def dec_row_len(self):\n-        if self.args.words:\n-            self.args.words -= 1\n-        else:\n-            self.args.bytes -= self.view_style['word_size']\n-            #force bytes to be an even multiple of the word_size\n-            self.args.bytes &= ~(self.view_style['word_size']-1)\n-        self.client.update()\n+        x = self.args.bytes - self.view_style['word_size']\n+        #force bytes to be an even multiple of the word_size\n+        x &= ~(self.view_style['word_size']-1)\n+        if x > 0:\n+            self.args.bytes = x\n+        self.kybd_update()\n \n \n class MemoryStrideViewPlugin(ViewPlugin):\n"}
{"repo": "voltron", "commit": "889d19a000a8977abbf55e4f35cbb3ba2c2fef3b", "diff": "diff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex b638223..c40dea0 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -2,6 +2,7 @@ import voltron\n import logging\n import six\n import struct\n+import binascii\n \n from voltron.api import *\n \n@@ -108,7 +109,9 @@ class APIMemoryRequest(APIRequest):\n \n             res = APIMemoryResponse()\n             res.address = addr\n-            res.memory = six.u(memory)\n+            #don't use six.u since it processes escape sequences ie... breaks if we have 0x5C 0x37 in memory\n+            #res.memory = six.u(memory)\n+            res.memory = binascii.hexlify(memory)\n             res.bytes = len(memory)\n             res.deref = deref\n         except TargetBusyException:\ndiff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex 09e4d65..8c8d467 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -1,5 +1,6 @@\n import logging\n import six\n+import binascii\n import pygments\n import pygments.formatters\n from pygments.token import *\n@@ -83,6 +84,7 @@ class MemoryView(TerminalView):\n \n         if m_res and m_res.is_success:\n             bytes_per_chunk = self.args.words*target['addr_size'] if self.args.words else self.args.bytes\n+            m_res.memory = binascii.unhexlify(m_res.memory)\n             for c in range(0, m_res.bytes, bytes_per_chunk):\n                 chunk = m_res.memory[c:c + bytes_per_chunk]\n                 yield (Name.Label, self.format_address(m_res.address + c, size=target['addr_size'], pad=False))\n@@ -94,8 +96,11 @@ class MemoryView(TerminalView):\n                     n = \"%02X\" % x\n                     token = Text if x else Comment\n                     if self.args.track and self.last_memory and self.last_address == m_res.address:\n-                        if x != six.indexbytes(self.last_memory, c + i):\n-                            token = Error\n+                        try:\n+                            if x != six.indexbytes(self.last_memory, c + i):\n+                                token = Error\n+                        except:\n+                            pass\n                     byte_array.append((token, n))\n \n                 if self.args.words:\n"}
{"repo": "voltron", "commit": "524634d1e36b22bf93d823a6eafa65c125bda845", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 3938466..a4a0a4a 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -415,7 +415,7 @@ class RegisterView (TerminalView):\n         sp.add_argument('--fpu', '-p', dest=\"sections\", action='append_const', const=\"fpu\", help='show fpu registers')\n         sp.add_argument('--no-fpu', '-P', dest=\"sections\", action='append_const', const=\"no_fpu\",\n                         help='hide fpu registers')\n-        sp.add_argument('--hide-info', '-I',dest=\"hide_info\", action='store_true', help='show info (pointer derefs, ascii) for registers',\n+        sp.add_argument('--hide-info', '-I',dest=\"hide_info\", action='store_true', help='hide extra info (pointer derefs, ascii) for registers',\n                         default=False)\n \n     def __init__(self, *args, **kwargs):\n"}
{"repo": "voltron", "commit": "a1e17d9f9a580bd83a6932dac2a8cdc36f77462d", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 4ca0649..3938466 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -415,8 +415,8 @@ class RegisterView (TerminalView):\n         sp.add_argument('--fpu', '-p', dest=\"sections\", action='append_const', const=\"fpu\", help='show fpu registers')\n         sp.add_argument('--no-fpu', '-P', dest=\"sections\", action='append_const', const=\"no_fpu\",\n                         help='hide fpu registers')\n-        sp.add_argument('--info', '-i', action='store_true', help='show info (pointer derefs, ascii) for registers',\n-                        default=True)\n+        sp.add_argument('--hide-info', '-I',dest=\"hide_info\", action='store_true', help='show info (pointer derefs, ascii) for registers',\n+                        default=False)\n \n     def __init__(self, *args, **kwargs):\n         super(RegisterView, self).__init__(*args, **kwargs)\n@@ -528,7 +528,7 @@ class RegisterView (TerminalView):\n                         formatted[fmt['format_name']] = formatted_reg\n \n                     # Format the info\n-                    if self.args.info:\n+                    if not self.args.hide_info:\n                         info = \"\"\n                         try:\n                             l = {2: 'H', 4: 'L', 8: 'Q'}[t_res.targets[0]['addr_size']]\n"}
{"repo": "voltron", "commit": "cd11d2f93bc3e06524cb9ab151510734dbaa4008", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 144316c..4dd8ec8 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -395,7 +395,8 @@ if HAVE_LLDB:\n                 ci = self.host.GetCommandInterpreter()\n                 ci.HandleCommand(str(command), res, False)\n                 if res.Succeeded():\n-                    return res.GetOutput().strip()\n+                    output = res.GetOutput()\n+                    return output.strip() if output else \"\"\n                 else:\n                     raise Exception(res.GetError().strip())\n             else:\n"}
{"repo": "voltron", "commit": "a31be40707765bfa38f84bc8a6e63cf770b16ae8", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 144316c..316fc3f 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -395,7 +395,8 @@ if HAVE_LLDB:\n                 ci = self.host.GetCommandInterpreter()\n                 ci.HandleCommand(str(command), res, False)\n                 if res.Succeeded():\n-                    return res.GetOutput().strip()\n+                    output = res.GetOutput()\n+                    return output.strip() if output else None\n                 else:\n                     raise Exception(res.GetError().strip())\n             else:\n"}
{"repo": "voltron", "commit": "e155681615a05fc3949c601a3cb957d8236a11d0", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 0cf8cf2..41b69fa 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -34,20 +34,24 @@ if HAVE_GDB:\n                 class Invocation(object):\n                     def __call__(killme):\n                         # when the invocation is called, we call the function and stick the result into the queue\n-                        log.debug(\"calling invocation {}({}, {})\".format(func, args, kwargs))\n-                        res = func(self, *args, **kwargs)\n-                        log.debug(\"got res = {}\".format(res))\n+                        try:\n+                            res = func(self, *args, **kwargs)\n+                        except Exception as e:\n+                            # if we got an exception, just queue that instead\n+                            res = e\n                         q.put(res)\n-                        log.debug(\"pushed\")\n \n                 # post this invocation to be called on the main thread at the next opportunity\n                 gdb.post_event(Invocation())\n \n                 # now we wait until there's something in the queue, which indicates that the invocation has run and return\n                 # the result that was pushed onto the queue by the invocation\n-                log.debug(\"waiting for queue\")\n                 res = q.get()\n-                log.debug(\"returning\")\n+\n+                # if we got an exception back from the posted event, raise it\n+                if isinstance(res, Exception):\n+                    raise res\n+\n                 return res\n             else:\n                 return func(self, *args, **kwargs)\n"}
{"repo": "voltron", "commit": "668990394e91e9ff474a05f09c774197b557c71d", "diff": "diff --git a/voltron/plugins/view/command.py b/voltron/plugins/view/command.py\nindex 36f94bb..d60e233 100644\n--- a/voltron/plugins/view/command.py\n+++ b/voltron/plugins/view/command.py\n@@ -1,9 +1,7 @@\n import logging\n \n-try:\n-    from pygments.lexers import get_lexer_by_name\n-except:\n-    get_lexer_by_name = None\n+import pygments\n+from pygments.lexers import get_lexer_by_name\n \n from voltron.view import *\n from voltron.plugin import *\n"}
{"repo": "voltron", "commit": "76ae765b7eaed2853aa6b46e4e21eb7cf98e1e59", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex a58d0c4..9b62f0a 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -512,7 +512,7 @@ class RegisterView (TerminalView):\n                     else:\n                         token = Text\n                         if self.last_regs is None or self.last_regs is not None and val != self.last_regs[reg]:\n-                            token = Generic.Error\n+                            token = Error\n                         formatted_reg = val\n                         if fmt['value_format'] != None and isinstance(formatted_reg, NumberType):\n                             formatted_reg = fmt['value_format'].format(formatted_reg)\n@@ -610,7 +610,7 @@ class RegisterView (TerminalView):\n             log.debug(\"Flag {} value {} (for flags 0x{})\".format(flag, values[flag], val))\n             formatted[flag] = str.upper(flag) if values[flag] else flag\n             if self.last_flags is not None and self.last_flags[flag] != values[flag]:\n-                token = Generic.Error\n+                token = Error\n             else:\n                 token = Text\n             formatted[flag] = self.f(token, formatted[flag])\n@@ -739,7 +739,7 @@ class RegisterView (TerminalView):\n \n         # Colour\n         if j is not None:\n-            jump = self.f(Generic.Error, jump)\n+            jump = self.f(Error, jump)\n         else:\n             jump = self.f(Text, jump)\n \ndiff --git a/voltron/styles.py b/voltron/styles.py\nindex 89c932f..4ff9165 100644\n--- a/voltron/styles.py\n+++ b/voltron/styles.py\n@@ -1,5 +1,5 @@\n from pygments.style import Style\n-from pygments.token import Token, Comment, Name, Keyword, Generic, Number, Operator, String, Punctuation\n+from pygments.token import Token, Comment, Name, Keyword, Generic, Number, Operator, String, Punctuation, Error\n \n BASE03 = '#002b36'\n BASE02 = '#073642'\n@@ -95,4 +95,6 @@ class VolarizedStyle(Style):\n \n         Token: BASE1,\n         Token.Other: ORANGE,\n+\n+        Error: RED\n     }\n"}
{"repo": "voltron", "commit": "d7ea398b5d38dfda08f9ba6defa1e2ae79b5ee56", "diff": "diff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex 8514e43..b638223 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -65,7 +65,7 @@ class APIMemoryRequest(APIRequest):\n             if self.address:\n                 addr = self.address\n             elif self.command:\n-                output = voltron.debugger.command(self.args.command)\n+                output = voltron.debugger.command(self.command)\n                 if output:\n                     for item in reversed(output.split()):\n                         log.debug(\"checking item: {}\".format(item))\n"}
{"repo": "voltron", "commit": "594f1454924131d2e20e284ce18f474e4b0c66d6", "diff": "diff --git a/voltron/entry.py b/voltron/entry.py\nindex e384d2b..2f108e1 100644\n--- a/voltron/entry.py\n+++ b/voltron/entry.py\n@@ -98,6 +98,9 @@ try:\n         voltron.debugger = plugin.adaptor_class(*args)\n         voltron.command = plugin.command_class(*args)\n \n+        # register command plugins now that we have a debugger host loaded\n+        pm.register_command_plugins()\n+\n         # create and start the voltron server\n         voltron.server = Server()\n         if host != \"gdb\":\ndiff --git a/voltron/plugin.py b/voltron/plugin.py\nindex ac70786..5088c76 100644\n--- a/voltron/plugin.py\n+++ b/voltron/plugin.py\n@@ -32,6 +32,11 @@ class PluginManager(object):\n         for p in voltron.env.plugins:\n             self.register_plugin(p)\n \n+    def register_command_plugins(self):\n+        for p in voltron.env.plugins:\n+            if issubclass(p, CommandPlugin):\n+                self.register_plugin(p)\n+\n     @property\n     def api_plugins(self):\n         return self._api_plugins\n@@ -291,6 +296,10 @@ class CommandPlugin(VoltronPlugin):\n     name = None\n \n \n+class VoltronCommand(object):\n+    pass\n+\n+\n #\n # Shared plugin manager and convenience methods\n #\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 0eef988..144316c 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -519,9 +519,10 @@ if HAVE_LLDB:\n \n             # method invocation creator\n             def create_invocation(obj):\n-                def invoke(debugger, command, result, env_dict):\n+                @staticmethod\n+                def invoker(debugger, command, result, env_dict):\n                     obj.invoke(*command.split())\n-                return invoke\n+                return invoker\n \n             # store the invocation in `voltron.commands` to pass to LLDB\n             setattr(voltron.commands, name, create_invocation(cls()))\n"}
{"repo": "voltron", "commit": "0762851bcb37373b8dd6a64a93ddfaedc76a179c", "diff": "diff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex 1809217..59f0534 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -25,7 +25,7 @@ class MemoryView(TerminalView):\n         group.add_argument('--bytes', '-b', action='store', type=int, help='bytes per line (default 16)', default=16)\n         sp.add_argument('--reverse', '-v', action='store_true', help='reverse the output', default=False)\n         sp.add_argument('--track', '-t', action='store_true', help='track and highlight changes', default=True)\n-        sp.add_argument('--no-track', '-T', action='store_false', help='track and highlight changes')\n+        sp.add_argument('--no-track', '-T', action='store_false', help='don\\'t track and highlight changes')\n         group = sp.add_mutually_exclusive_group(required=False)\n         group.add_argument('--address', '-a', action='store',\n                            help='address (in hex or decimal) from which to start reading memory')\n@@ -169,7 +169,7 @@ class StackView(MemoryView):\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=StackView)\n         sp.add_argument('--track', '-t', action='store_true', help='track and highlight changes', default=True)\n-        sp.add_argument('--no-track', '-T', action='store_false', help='track and highlight changes')\n+        sp.add_argument('--no-track', '-T', action='store_false', help='don\\'t track and highlight changes')\n \n     def build_requests(self):\n         self.args.reverse = True\n"}
{"repo": "voltron", "commit": "f25eb055a14cf63d6a20b32459bc4fc28d6bb0c6", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 496f17e..1235481 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -406,13 +406,13 @@ class RegisterView (TerminalView):\n         sp.add_argument('--general', '-g', dest=\"sections\", action='append_const', const=\"general\",\n                         help='show general registers')\n         sp.add_argument('--no-general', '-G', dest=\"sections\", action='append_const', const=\"no_general\",\n-                        help='show general registers')\n+                        help='hide general registers')\n         sp.add_argument('--sse', '-s', dest=\"sections\", action='append_const', const=\"sse\", help='show sse registers')\n         sp.add_argument('--no-sse', '-S', dest=\"sections\", action='append_const', const=\"no_sse\",\n-                        help='show sse registers')\n+                        help='hide sse registers')\n         sp.add_argument('--fpu', '-p', dest=\"sections\", action='append_const', const=\"fpu\", help='show fpu registers')\n         sp.add_argument('--no-fpu', '-P', dest=\"sections\", action='append_const', const=\"no_fpu\",\n-                        help='show fpu registers')\n+                        help='hide fpu registers')\n         sp.add_argument('--info', '-i', action='store_true', help='show info (pointer derefs, ascii) for registers',\n                         default=False)\n \n"}
{"repo": "voltron", "commit": "630f5e075b192418a616fcd85d17801b30d5777d", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 9e7ba33..0a43304 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -356,7 +356,7 @@ if HAVE_GDB:\n             breakpoints = []\n \n             # hahahahaha GDB sucks so much\n-            for b in gdb.breakpoints():\n+            for b in (gdb.breakpoints() or ()):\n                 try:\n                     if b.location.startswith('*'):\n                         addr = int(b.location[1:], 16)\n"}
{"repo": "voltron", "commit": "3777db96f93b4fde5272b6625fefd438e0623179", "diff": "diff --git a/voltron/entry.py b/voltron/entry.py\nindex b993eb4..e384d2b 100644\n--- a/voltron/entry.py\n+++ b/voltron/entry.py\n@@ -106,10 +106,11 @@ try:\n         print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n         if host == 'lldb' and not voltron.command.registered:\n             print(\"Run `voltron init` after you load a target.\")\n-\n except Exception as e:\n     import traceback\n-    msg = \"An error occurred while loading Voltron:\\n\\n{}\".format(traceback.format_exc())\n+    msg = (\"An error occurred while loading Voltron:\\n\\n{}\"\n+           \"\\nPlease ensure Voltron is installed correctly per the documentation: \"\n+           \"https://github.com/snare/voltron/wiki/Installation\").format(traceback.format_exc())\n     if blessed:\n         msg = blessed.Terminal().bold_red(msg)\n     if log:\n"}
{"repo": "voltron", "commit": "3583ebbbf5a72201b83d46dd22307cbacfa04670", "diff": "diff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex dd0abc4..8028216 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -53,9 +53,10 @@ class MemoryView(TerminalView):\n             args = {'address': addr}\n         if self.args.deref:\n             args['words'] = height\n+            args['offset'] = self.scroll_offset if self.args.reverse else -self.scroll_offset\n         else:\n             args['length'] = height * self.args.bytes\n-        args['offset'] = self.scroll_offset if self.args.reverse else -self.scroll_offset\n+            args['offset'] = self.scroll_offset * self.args.bytes if self.args.reverse else -self.scroll_offset * self.args.bytes\n \n         # get memory and target info\n         return [\n"}
{"repo": "voltron", "commit": "abf6ecd149a4b5f1ea304cb1e1ced81c08d6394a", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 6fb61d6..bb4a811 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -17,7 +17,7 @@ from flask import Flask, Response, make_response, redirect, render_template, req\n from werkzeug.serving import BaseWSGIServer, ThreadedWSGIServer, WSGIRequestHandler\n from werkzeug.wsgi import DispatcherMiddleware, SharedDataMiddleware\n \n-import pysigset\n+# import pysigset\n \n from .api import *\n from .plugin import *\n@@ -145,13 +145,13 @@ class Server(object):\n         )\n \n         def run_listener(name, cls, arg):\n-            with pysigset.suspended_signals(signal.SIGCHLD):\n-                log.debug(\"Starting listener for {} socket on {}\".format(name, str(arg)))\n-                s = cls(*arg)\n-                t = threading.Thread(target=s.serve_forever)\n-                t.start()\n-                self.threads.append(t)\n-                self.listeners.append(s)\n+            # with pysigset.suspended_signals(signal.SIGCHLD):\n+            log.debug(\"Starting listener for {} socket on {}\".format(name, str(arg)))\n+            s = cls(*arg)\n+            t = threading.Thread(target=s.serve_forever)\n+            t.start()\n+            self.threads.append(t)\n+            self.listeners.append(s)\n \n         if voltron.config.server.listen.tcp:\n             run_listener('tcp', ThreadedVoltronWSGIServer, list(voltron.config.server.listen.tcp) + [self.app])\n"}
{"repo": "voltron", "commit": "2e9c2eff54f62d6017483abbe18e8e9d39a32a40", "diff": "diff --git a/setup.py b/setup.py\nindex c7cb212..25f43ea 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -10,7 +10,8 @@ requirements = [\n     'pygments',\n     'requests',\n     'requests_unixsocket',\n-    'six'\n+    'six',\n+    'pysigset'\n ]\n if sys.platform == 'win32':\n     requirements.append('cursor')\ndiff --git a/voltron/core.py b/voltron/core.py\nindex 4751657..6fb61d6 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -1,31 +1,32 @@\n-import os\n-import sys\n import errno\n-import logging\n-import socket\n-import select\n-import threading\n+import json\n import logging\n import logging.config\n-import json\n-try:\n-    import requests_unixsocket as requests\n-except:\n-    import requests\n-import threading\n+import os\n import os.path\n import pkgutil\n+import select\n+import signal\n+import socket\n+import sys\n+import threading\n \n-from werkzeug.serving import WSGIRequestHandler, BaseWSGIServer, ThreadedWSGIServer\n-from werkzeug.wsgi import SharedDataMiddleware, DispatcherMiddleware\n+import six\n+import voltron\n+from flask import Flask, Response, make_response, redirect, render_template, request\n+from werkzeug.serving import BaseWSGIServer, ThreadedWSGIServer, WSGIRequestHandler\n+from werkzeug.wsgi import DispatcherMiddleware, SharedDataMiddleware\n \n-from flask import Flask, request, Response, render_template, make_response, redirect\n+import pysigset\n \n-import voltron\n from .api import *\n from .plugin import *\n \n-import six\n+try:\n+    import requests_unixsocket as requests\n+except:\n+    import requests\n+\n if six.PY2:\n     if sys.platform == 'win32':\n         from SocketServer import ThreadingMixIn\n@@ -144,12 +145,13 @@ class Server(object):\n         )\n \n         def run_listener(name, cls, arg):\n-            log.debug(\"Starting listener for {} socket on {}\".format(name, str(arg)))\n-            s = cls(*arg)\n-            t = threading.Thread(target=s.serve_forever)\n-            t.start()\n-            self.threads.append(t)\n-            self.listeners.append(s)\n+            with pysigset.suspended_signals(signal.SIGCHLD):\n+                log.debug(\"Starting listener for {} socket on {}\".format(name, str(arg)))\n+                s = cls(*arg)\n+                t = threading.Thread(target=s.serve_forever)\n+                t.start()\n+                self.threads.append(t)\n+                self.listeners.append(s)\n \n         if voltron.config.server.listen.tcp:\n             run_listener('tcp', ThreadedVoltronWSGIServer, list(voltron.config.server.listen.tcp) + [self.app])\n"}
{"repo": "voltron", "commit": "fee9881756a9fa3620bf02b35b2984e8800c6b10", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex a5b59d2..9e7ba33 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -273,7 +273,7 @@ if HAVE_GDB:\n                     mem = gdb.selected_inferior().read_memory(addr, self.get_addr_size())\n                     # log.debug(\"read mem: {}\".format(mem))\n                     (ptr,) = struct.unpack(fmt, mem)\n-                    if ptr in chain:\n+                    if ptr in [x[1] for x in chain]:\n                         break\n                     chain.append(('pointer', addr))\n                     addr = ptr\n"}
{"repo": "voltron", "commit": "e50fd6862c921d3bfb091170761f248793184b33", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex d5bb5a5..d564730 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -425,7 +425,9 @@ class RegisterView (TerminalView):\n                             d = self.format_deref(r_res.deref[reg][1:])\n                             if d:\n                                 info += arrow + d\n-                        except KeyError, IndexError:\n+                        except KeyError:\n+                            pass\n+                        except IndexError:\n                             pass\n                     else:\n                         info = ''\n"}
{"repo": "voltron", "commit": "a2959f5c7f85b16b9495f6ee08271ac94f1239fa", "diff": "diff --git a/voltron/api.py b/voltron/api.py\nindex 03c0b46..965f9ce 100644\n--- a/voltron/api.py\n+++ b/voltron/api.py\n@@ -427,6 +427,6 @@ class APIEmptyResponseErrorResponse(APIGenericErrorResponse):\n     message = \"Empty response\"\n \n \n-class APIServerExitedErrorResponse(APIGenericErrorResponse):\n+class APIServerNotRunningErrorResponse(APIGenericErrorResponse):\n     code = 0x1009\n-    message = \"Server exited\"\n+    message = \"Server is not running\"\ndiff --git a/voltron/core.py b/voltron/core.py\nindex 384cf81..099914e 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -167,7 +167,9 @@ class Server(object):\n         Stop the server.\n         \"\"\"\n         log.debug(\"Stopping listeners\")\n+        self.queue_lock.acquire()\n         for s in self.listeners:\n+            log.debug(\"Stopping {}\".format(s))\n             s.shutdown()\n             s.socket.close()\n         self.cancel_queue()\n@@ -176,60 +178,64 @@ class Server(object):\n         self.listeners = []\n         self.threads = []\n         self.is_running = False\n+        self.queue_lock.release()\n         log.debug(\"Listeners stopped and threads joined\")\n \n     def handle_request(self, data):\n         req = None\n         res = None\n \n-        # make sure we have a debugger, or we're gonna have a bad time\n-        if voltron.debugger:\n-            # parse incoming request with the top level APIRequest class so we can determine the request type\n-            try:\n-                req = APIRequest(data=data)\n-            except Exception as e:\n-                req = None\n-                log.exception(\"Exception raised while parsing API request: {} {}\".format(type(e), e))\n-\n-            if req:\n-                # instantiate the request class\n+        if self.is_running:\n+            # make sure we have a debugger, or we're gonna have a bad time\n+            if voltron.debugger:\n+                # parse incoming request with the top level APIRequest class so we can determine the request type\n                 try:\n-                    log.debug(\"data = {}\".format(data))\n-                    req = api_request(req.request, data=data)\n+                    req = APIRequest(data=data)\n                 except Exception as e:\n-                    log.exception(\"Exception raised while creating API request: {} {}\".format(type(e), e))\n                     req = None\n-                if not req:\n-                    res = APIPluginNotFoundErrorResponse()\n+                    log.exception(\"Exception raised while parsing API request: {} {}\".format(type(e), e))\n+\n+                if req:\n+                    # instantiate the request class\n+                    try:\n+                        log.debug(\"data = {}\".format(data))\n+                        req = api_request(req.request, data=data)\n+                    except Exception as e:\n+                        log.exception(\"Exception raised while creating API request: {} {}\".format(type(e), e))\n+                        req = None\n+                    if not req:\n+                        res = APIPluginNotFoundErrorResponse()\n+                else:\n+                    res = APIInvalidRequestErrorResponse()\n             else:\n-                res = APIInvalidRequestErrorResponse()\n-        else:\n-            res = APIDebuggerNotPresentErrorResponse()\n+                res = APIDebuggerNotPresentErrorResponse()\n \n-        if not res:\n-            # no errors so far, queue the request and wait\n-            if req and req.block:\n-                self.queue_lock.acquire()\n-                self.queue.append(req)\n-                self.queue_lock.release()\n-\n-                # When this returns the request will have been processed by the dispatch_queue method on the main\n-                # thread (or timed out). We have to do it this way because GDB sucks.\n-                req.wait()\n-\n-                if req.timed_out:\n-                    res = APITimedOutErrorResponse()\n-                else:\n-                    res = req.response\n+            if not res:\n+                # no errors so far, queue the request and wait\n+                if req and req.block:\n+                    self.queue_lock.acquire()\n+                    self.queue.append(req)\n+                    self.queue_lock.release()\n \n-                # Remove the request from the queue\n-                self.queue_lock.acquire()\n-                if req in self.queue:\n-                    self.queue.remove(req)\n-                self.queue_lock.release()\n-            else:\n-                # non-blocking, dispatch request straight away\n-                res = self.dispatch_request(req)\n+                    # When this returns the request will have been processed by the dispatch_queue method on the main\n+                    # thread (or timed out). We have to do it this way because GDB sucks.\n+                    req.wait()\n+\n+                    if req.timed_out:\n+                        res = APITimedOutErrorResponse()\n+                    else:\n+                        res = req.response\n+\n+                    # Remove the request from the queue\n+                    self.queue_lock.acquire()\n+                    if req in self.queue:\n+                        self.queue.remove(req)\n+                    self.queue_lock.release()\n+                else:\n+                    # non-blocking, dispatch request straight away\n+                    res = self.dispatch_request(req)\n+        else:\n+            res = APIServerNotRunningErrorResponse()\n \n         return res\n \n@@ -237,13 +243,11 @@ class Server(object):\n         \"\"\"\n         Cancel all requests in the queue so we can exit.\n         \"\"\"\n-        self.queue_lock.acquire()\n         q = list(self.queue)\n         self.queue = []\n-        self.queue_lock.release()\n         log.debug(\"Canceling requests: {}\".format(q))\n         for req in q:\n-            req.response = APIServerExitedErrorResponse()\n+            req.response = APIServerNotRunningErrorResponse()\n         for req in q:\n             req.signal()\n \n@@ -296,12 +300,25 @@ class VoltronWSGIServer(BaseWSGIServer):\n \n     This just needs to exist so we can swallow errors when clients disconnect.\n     \"\"\"\n+    clients = []\n+\n     def finish_request(self, *args):\n+        self.clients.append(args[0])\n+        log.debug(\"finish_request({})\".format(args))\n         try:\n             super(VoltronWSGIServer, self).finish_request(*args)\n         except socket.error as e:\n             log.error(\"Error in finish_request: {}\".format(e))\n \n+    def shutdown(self):\n+        super(VoltronWSGIServer, self).shutdown()\n+        for c in self.clients:\n+            try:\n+                c.shutdown(socket.SHUT_RD)\n+                c.close()\n+            except:\n+                pass\n+\n \n class ThreadedVoltronWSGIServer(ThreadingMixIn, VoltronWSGIServer):\n     \"\"\"\ndiff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 4dfb525..5d7ff58 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -319,7 +319,9 @@ class RegisterView (TerminalView):\n         if t_res.timed_out:\n             return\n \n-        if t_res and t_res.is_error or t_res is None or t_res and len(t_res.targets) == 0:\n+        if t_res and t_res.is_error:\n+            error = t_res.message\n+        elif t_res is None or t_res and len(t_res.targets) == 0:\n             error = \"No such target\"\n         else:\n             arch = t_res.targets[0]['arch']\n"}
{"repo": "voltron", "commit": "3ced980707fec29530ea5969e373b5353894b9ba", "diff": "diff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex 052e13b..3518aeb 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -42,7 +42,14 @@ class MemoryView (TerminalView):\n         elif self.args.command:\n             args = {'command': self.args.command}\n         else:\n-            args = {'address': self.args.address}\n+            if self.args.address.startswith('0x'):\n+                addr = int(self.args.address, 16)\n+            else:\n+                try:\n+                    addr = int(self.args.address, 10)\n+                except:\n+                    addr = int(self.args.address, 16)\n+            args = {'address': addr}\n         if self.args.deref:\n             args['words'] = height\n         else:\n"}
{"repo": "voltron", "commit": "705013a8e4d7afea56f3e6d91001ec5e946f1136", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 5127284..a5b59d2 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -299,7 +299,10 @@ if HAVE_GDB:\n                             mem = gdb.selected_inferior().read_memory(addr + i, 1)\n                             if ord(mem[0]) == 0 or ord(mem[0]) > 127:\n                                 break\n-                            a.append(str(mem))\n+                            if isinstance(mem, memoryview):\n+                                a.append(mem.tobytes().decode('latin1'))\n+                            else:\n+                                a.append(str(mem))\n                         chain.append(('string', ''.join(a)))\n \n             log.debug(\"chain: {}\".format(chain))\n"}
{"repo": "voltron", "commit": "cb43eac6879e29fe5a4c0261800263d4899cbfee", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 3095b0b..9676edf 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -284,6 +284,8 @@ class VoltronWSGIServer(BaseWSGIServer):\n \n     This just needs to exist so we can swallow errors when clients disconnect.\n     \"\"\"\n+    host = 'localhost'\n+\n     def finish_request(self, *args):\n         try:\n             super(VoltronWSGIServer, self).finish_request(*args)\n"}
{"repo": "voltron", "commit": "cb4d6ae7018b7178d51dedac3deb25f53c68b842", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex de2cab3..3095b0b 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -14,6 +14,7 @@ except:\n     import requests\n import threading\n import os.path\n+import pkgutil\n \n from werkzeug.serving import WSGIRequestHandler, BaseWSGIServer, ThreadedWSGIServer\n from werkzeug.wsgi import SharedDataMiddleware, DispatcherMiddleware\n@@ -43,6 +44,16 @@ try:\n except:\n     ui_app = None\n \n+\n+def get_loader(name):\n+    try:\n+        return orig_get_loader(name)\n+    except AttributeError:\n+        pass\n+orig_get_loader = pkgutil.get_loader\n+pkgutil.get_loader = get_loader\n+\n+\n # make sure we use HTTP 1.1 for keep-alive\n WSGIRequestHandler.protocol_version = \"HTTP/1.1\"\n \n"}
{"repo": "voltron", "commit": "ba8ec23a36410a3b0883ddab73129de140da1638", "diff": "diff --git a/setup.py b/setup.py\nindex 7dc290f..3f4d05c 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -16,7 +16,7 @@ if sys.platform == 'win32':\n \n setup(\n     name=\"voltron\",\n-    version=\"0.1.1\",\n+    version=\"0.1.2\",\n     author=\"snare\",\n     author_email=\"snare@ho.ax\",\n     description=(\"A debugger UI\"),\n"}
{"repo": "voltron", "commit": "2f6cad7faae7ed78450eee8941382de4bf176481", "diff": "diff --git a/voltron/entry.py b/voltron/entry.py\nindex 49e96f2..0a02a5e 100644\n--- a/voltron/entry.py\n+++ b/voltron/entry.py\n@@ -65,6 +65,9 @@ try:\n     try:\n         import lldb\n         host = \"lldb\"\n+\n+        def invoke(*args):\n+            voltron.command._invoke(*args)\n     except ImportError:\n         pass\n     try:\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex d08bc56..ccc1015 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -509,8 +509,8 @@ if HAVE_LLDB:\n         Debugger command class for LLDB\n         \"\"\"\n         @staticmethod\n-        def _invoke(debugger, command, result, dict):\n-            voltron.command.invoke(debugger, command, result, dict)\n+        def _invoke(debugger, command, *args):\n+            voltron.command.handle_command(command)\n \n         def __init__(self):\n             super(LLDBCommand, self).__init__()\n@@ -520,7 +520,7 @@ if HAVE_LLDB:\n \n             # install the voltron command handler\n             self.adaptor.command(\"script import voltron\")\n-            self.adaptor.command('command script add -f voltron.command._invoke voltron')\n+            self.adaptor.command('command script add -f entry.invoke voltron')\n \n             # try to register hooks automatically, as this works on new LLDB versions\n             self.register_hooks(True)\n"}
{"repo": "voltron", "commit": "bcefffe4fecf7da7670797f5bc13b26c9e715ad5", "diff": "diff --git a/voltron/entry.py b/voltron/entry.py\nindex 8c9cc4e..49e96f2 100644\n--- a/voltron/entry.py\n+++ b/voltron/entry.py\n@@ -24,23 +24,14 @@ WinDbg/CDB (via PyKD):\n log = None\n \n try:\n+    # fix path if it's clobbered by brew\n     import sys\n     if sys.platform == 'darwin':\n-        sys.path = [p for p in sys.path if 'Cellar' not in p]\n-\n-        new_path = ['/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old',\n-                    '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload']\n-\n-        for p in new_path:\n-            if p not in sys.path:\n-                sys.path.append(p)\n+        py_base = '/System/Library/Frameworks/Python.framework/Versions/2.7/'\n+        new_path = ['lib/python27.zip', 'lib/python2.7', 'lib/python2.7/plat-darwin', 'lib/python2.7/plat-mac',\n+                    'lib/python2.7/plat-mac/lib-scriptpackages', 'Extras/lib/python', 'lib/python2.7/lib-tk',\n+                    'lib/python2.7/lib-old', 'lib/python2.7/lib-dynload']\n+        sys.path = [p for p in sys.path if 'Cellar' not in p] + [py_base + p for p in new_path]\n except:\n     pass\n \n"}
{"repo": "voltron", "commit": "1ed8b7eba34866f358c0173d1215f2db156e7535", "diff": "diff --git a/voltron/dbg.py b/voltron/dbg.py\nindex 5827ca8..5258997 100644\n--- a/voltron/dbg.py\n+++ b/voltron/dbg.py\n@@ -224,7 +224,8 @@ class DebuggerCommand (object):\n     \"\"\"\n     The `voltron` command in the debugger.\n     \"\"\"\n-    def __init__(self):\n+    def __init__(self, *args, **kwargs):\n+        super(DebuggerCommand, self).__init__(*args, **kwargs)\n         self.adaptor = voltron.debugger\n \n     def handle_command(self, command):\ndiff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 9e2a805..59d3675 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -584,9 +584,7 @@ if HAVE_GDB:\n         \"\"\"\n         def __init__(self):\n             super(GDBCommand, self).__init__(\"voltron\", gdb.COMMAND_NONE, gdb.COMPLETE_NONE)\n-\n             self.adaptor = voltron.debugger\n-\n             self.registered = False\n \n         def invoke(self, arg, from_tty):\n@@ -603,6 +601,7 @@ if HAVE_GDB:\n                 gdb.events.stop.disconnect(self.stop_handler)\n                 gdb.events.exited.disconnect(self.stop_and_exit_handler)\n                 gdb.events.cont.disconnect(self.cont_handler)\n+                self.registered = False\n \n         def stop_handler(self, event):\n             self.adaptor.update_state()\n"}
{"repo": "voltron", "commit": "817bdb2444a0530d23cd21d0081d1590262ca4af", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex febc03a..5ac5908 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -393,7 +393,7 @@ if HAVE_LLDB:\n             if command:\n                 res = lldb.SBCommandReturnObject()\n                 ci = self.host.GetCommandInterpreter()\n-                ci.HandleCommand(str(command), res)\n+                ci.HandleCommand(str(command), res, False)\n                 if res.Succeeded():\n                     return res.GetOutput().strip()\n                 else:\n"}
{"repo": "voltron", "commit": "37f695659927eed05036e7992b1842916761e0ee", "diff": "diff --git a/examples/angularview/angularview.py b/examples/angularview/angularview.py\nindex 56476b9..d173e12 100644\n--- a/examples/angularview/angularview.py\n+++ b/examples/angularview/angularview.py\n@@ -21,7 +21,7 @@ class FormatDisassemblyRequest(APIRequest):\n             res = FormatDisassemblyResponse(\n                 disassembly=pygments.highlight(self.disassembly.strip(), LLDBIntelLexer(), pygments.formatters.HtmlFormatter()))\n         except Exception as e:\n-            msg = \"Exception formatting disassembly: {}\".format(e)\n+            msg = \"Exception formatting disassembly: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/core.py b/voltron/core.py\nindex 15da555..56f6c97 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -250,7 +250,7 @@ class Server(object):\n             try:\n                 res = req.dispatch()\n             except Exception as e:\n-                msg = \"Exception raised while dispatching request: {}\".format(e)\n+                msg = \"Exception raised while dispatching request: {}\".format(repr(e))\n                 log.exception(msg)\n                 res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/breakpoints.py b/voltron/plugins/api/breakpoints.py\nindex 88755e4..0ba69b5 100644\n--- a/voltron/plugins/api/breakpoints.py\n+++ b/voltron/plugins/api/breakpoints.py\n@@ -29,7 +29,7 @@ class APIBreakpointsRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting breakpoints: {}\".format(e)\n+            msg = \"Exception getting breakpoints: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/command.py b/voltron/plugins/api/command.py\nindex 9d04631..bf26a24 100644\n--- a/voltron/plugins/api/command.py\n+++ b/voltron/plugins/api/command.py\n@@ -30,7 +30,7 @@ class APICommandRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception executing debugger command: {}\".format(e)\n+            msg = \"Exception executing debugger command: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/dereference.py b/voltron/plugins/api/dereference.py\nindex cc2fb6c..3ffeda9 100644\n--- a/voltron/plugins/api/dereference.py\n+++ b/voltron/plugins/api/dereference.py\n@@ -31,7 +31,7 @@ class APIDerefRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception dereferencing pointer: {}\".format(e)\n+            msg = \"Exception dereferencing pointer: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex ab1fbce..51bb708 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -104,7 +104,7 @@ class APIMemoryRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting memory from debugger: {}\".format(e)\n+            msg = \"Exception getting memory from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/registers.py b/voltron/plugins/api/registers.py\nindex d1a273c..697d41f 100644\n--- a/voltron/plugins/api/registers.py\n+++ b/voltron/plugins/api/registers.py\n@@ -43,7 +43,7 @@ class APIRegistersRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting registers from debugger: {}\".format(e)\n+            msg = \"Exception getting registers from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/targets.py b/voltron/plugins/api/targets.py\nindex 0ee205f..2ed63a2 100644\n--- a/voltron/plugins/api/targets.py\n+++ b/voltron/plugins/api/targets.py\n@@ -26,7 +26,7 @@ class APITargetsRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting targets from debugger: {}\".format(e)\n+            msg = \"Exception getting targets from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n"}
{"repo": "voltron", "commit": "ab87fc30a3b55b94dc9105b710ce70d2f6be4225", "diff": "diff --git a/examples/angularview/angularview.py b/examples/angularview/angularview.py\nindex 56476b9..d173e12 100644\n--- a/examples/angularview/angularview.py\n+++ b/examples/angularview/angularview.py\n@@ -21,7 +21,7 @@ class FormatDisassemblyRequest(APIRequest):\n             res = FormatDisassemblyResponse(\n                 disassembly=pygments.highlight(self.disassembly.strip(), LLDBIntelLexer(), pygments.formatters.HtmlFormatter()))\n         except Exception as e:\n-            msg = \"Exception formatting disassembly: {}\".format(e)\n+            msg = \"Exception formatting disassembly: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/core.py b/voltron/core.py\nindex 15da555..56f6c97 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -250,7 +250,7 @@ class Server(object):\n             try:\n                 res = req.dispatch()\n             except Exception as e:\n-                msg = \"Exception raised while dispatching request: {}\".format(e)\n+                msg = \"Exception raised while dispatching request: {}\".format(repr(e))\n                 log.exception(msg)\n                 res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/breakpoints.py b/voltron/plugins/api/breakpoints.py\nindex 88755e4..0ba69b5 100644\n--- a/voltron/plugins/api/breakpoints.py\n+++ b/voltron/plugins/api/breakpoints.py\n@@ -29,7 +29,7 @@ class APIBreakpointsRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting breakpoints: {}\".format(e)\n+            msg = \"Exception getting breakpoints: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/command.py b/voltron/plugins/api/command.py\nindex 9d04631..bf26a24 100644\n--- a/voltron/plugins/api/command.py\n+++ b/voltron/plugins/api/command.py\n@@ -30,7 +30,7 @@ class APICommandRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception executing debugger command: {}\".format(e)\n+            msg = \"Exception executing debugger command: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/dereference.py b/voltron/plugins/api/dereference.py\nindex cc2fb6c..3ffeda9 100644\n--- a/voltron/plugins/api/dereference.py\n+++ b/voltron/plugins/api/dereference.py\n@@ -31,7 +31,7 @@ class APIDerefRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception dereferencing pointer: {}\".format(e)\n+            msg = \"Exception dereferencing pointer: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex ab1fbce..51bb708 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -104,7 +104,7 @@ class APIMemoryRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting memory from debugger: {}\".format(e)\n+            msg = \"Exception getting memory from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/registers.py b/voltron/plugins/api/registers.py\nindex d1a273c..697d41f 100644\n--- a/voltron/plugins/api/registers.py\n+++ b/voltron/plugins/api/registers.py\n@@ -43,7 +43,7 @@ class APIRegistersRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting registers from debugger: {}\".format(e)\n+            msg = \"Exception getting registers from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \ndiff --git a/voltron/plugins/api/targets.py b/voltron/plugins/api/targets.py\nindex 0ee205f..2ed63a2 100644\n--- a/voltron/plugins/api/targets.py\n+++ b/voltron/plugins/api/targets.py\n@@ -26,7 +26,7 @@ class APITargetsRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception getting targets from debugger: {}\".format(e)\n+            msg = \"Exception getting targets from debugger: {}\".format(repr(e))\n             log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n"}
{"repo": "voltron", "commit": "21a78ea7c045c0e0ced53aa30c7908c841d7e8f5", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 73b17e9..b8f042c 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -9,6 +9,7 @@ import signal\n import time\n import argparse\n import traceback\n+import subprocess\n from requests import ConnectionError\n from blessed import Terminal\n \n"}
{"repo": "voltron", "commit": "d3089eaef6773c6207cdbad5ec5111bcb6e5d49f", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 56bfc95..04dc8c1 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -26,7 +26,7 @@ else:\n from werkzeug.serving import WSGIRequestHandler, BaseWSGIServer, ThreadedWSGIServer\n from werkzeug.wsgi import SharedDataMiddleware, DispatcherMiddleware\n \n-from flask import Flask, request, Response, render_template, make_response\n+from flask import Flask, request, Response, render_template, make_response, redirect\n \n import voltron\n from .api import *\n"}
{"repo": "voltron", "commit": "84d925df7d6860e087bfdea675129709a275eb9e", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex ef8544b..c74dad3 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -167,6 +167,7 @@ class Server(object):\n         log.debug(\"Dispatching requests: {}\".format(self.queue))\n         for req in self.queue:\n             req.response = self.dispatch_request(req)\n+        for req in self.queue:\n             req.signal()\n \n     def dispatch_request(self, req):\n"}
{"repo": "voltron", "commit": "ab3ff9b1d9563a19c23f2553c791ae3537cd5b96", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex f17613c..d313ab8 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -115,6 +115,7 @@ try:\n                 # start the server\n                 self.server = Server()\n                 self.server.start()\n+                voltron.server = self.server\n \n                 self.hook_idx = None\n \n"}
{"repo": "voltron", "commit": "a9cc84f9681ff1fda28f316c70d932af6f54b187", "diff": "diff --git a/voltron/main.py b/voltron/main.py\nindex 53436db..a3a91a1 100644\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -23,7 +23,7 @@ def main(debugger=None):\n     parser = argparse.ArgumentParser()\n     parser.register('action', 'parsers', AliasedSubParsersAction)\n     parser.add_argument('--debug', '-d', action='store_true', help='print debug logging')\n-    parser.add_argument('-o', action='append', help='override config variable')\n+    parser.add_argument('-o', action='append', help='override config variable', default=[])\n     top_level_sp = parser.add_subparsers(title='subcommands', description='valid subcommands', dest='subcommand')\n     top_level_sp.required = True\n     view_parser = top_level_sp.add_parser('view', help='display a view', aliases=('v'))\n"}
{"repo": "voltron", "commit": "1128cdc30db376f25e127af03d34b88fd3da28ee", "diff": "diff --git a/examples/angularview/angularview.py b/examples/angularview/angularview.py\nindex 25f42da..56476b9 100644\n--- a/examples/angularview/angularview.py\n+++ b/examples/angularview/angularview.py\n@@ -2,50 +2,37 @@ import logging\n import pygments\n from voltron.plugin import *\n from voltron.lexers import *\n+from voltron.api import *\n \n from flask import *\n \n log = logging.getLogger('api')\n \n-app = Flask(__name__)\n \n-lexers = {\n-    'lldb_intel': LLDBIntelLexer\n-}\n-\n-@app.route('/')\n-def root():\n-    return redirect(\"static\", code=302)\n-\n-\n-@app.route(\"/api/request\", methods=['POST'])\n-def handle_post():\n-    res = app.server.handle_request(request.data.decode('UTF-8'))\n-    res.formatted = format_disasm(res)\n-    return Response(str(res), status=200, mimetype='application/json')\n+class AngularViewPlugin(WebPlugin):\n+    name = 'angularview'\n \n \n-def format_disasm(response):\n-    \"\"\"\n-    Format\n-    \"\"\"\n-    formatted = None\n+class FormatDisassemblyRequest(APIRequest):\n+    _fields = {'disassembly': True}\n \n-    try:\n-        lexer_id = '{}_{}'.format(response.host, response.flavor)\n-        log.debug(\"lexer: {}\".format(lexer_id))\n-        lexer = lexers[lexer_id]()\n-    except:\n-        lexer = None\n+    def dispatch(self):\n+        try:\n+            res = FormatDisassemblyResponse(\n+                disassembly=pygments.highlight(self.disassembly.strip(), LLDBIntelLexer(), pygments.formatters.HtmlFormatter()))\n+        except Exception as e:\n+            msg = \"Exception formatting disassembly: {}\".format(e)\n+            log.exception(msg)\n+            res = APIGenericErrorResponse(msg)\n \n-    if lexer:\n-        formatted = pygments.highlight(response.disassembly.strip(), lexer, pygments.formatters.HtmlFormatter())\n+        return res\n \n-    log.debug(formatted)\n \n-    return formatted\n+class FormatDisassemblyResponse(APIResponse):\n+    _fields = {'disassembly': True}\n \n \n-class AngularViewPlugin(WebPlugin):\n-    name = 'angularview'\n-    app = app\n+class FormatDisassemblyPlugin(APIPlugin):\n+    request = \"format_disasm\"\n+    request_class = FormatDisassemblyRequest\n+    response_class = FormatDisassemblyResponse\n"}
{"repo": "voltron", "commit": "43f09e6605b680290cf3b56106696ab4d6772ebf", "diff": "diff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex 4c12aca..ab1fbce 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -88,8 +88,6 @@ class APIMemoryRequest(APIRequest):\n                 fmt = ('<' if target['byte_order'] == 'little' else '>') + {2: 'H', 4: 'L', 8: 'Q'}[target['addr_size']]\n                 deref = []\n                 for chunk in zip(*[six.iterbytes(memory)]*target['addr_size']):\n-                    log.debug(chunk)\n-                    log.debug(fmt)\n                     chunk = ''.join([six.unichr(x) for x in chunk]).encode('latin1')\n                     try:\n                         deref.append(voltron.debugger.dereference(pointer=list(struct.unpack(fmt, chunk))[0]))\n"}
{"repo": "voltron", "commit": "a0a0a92e6cf1e2f0f288c46d75c66ec74e0b08be", "diff": "diff --git a/setup.py b/setup.py\nindex 8758811..426a5c3 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -9,7 +9,7 @@ setup(\n     license=\"Buy snare a beer\",\n     keywords=\"voltron gdb lldb\",\n     url=\"https://github.com/snarez/voltron\",\n-    packages=find_packages(),\n+    packages=['voltron'],\n     install_requires=['scruffington', 'flask', 'blessed', 'pygments', 'requests_unixsocket'],\n     data_files=['dbgentry.py'],\n     package_data={'voltron': ['config/*']},\n"}
{"repo": "voltron", "commit": "a2e77e528cb24ad69b0c34373a62020441b176f1", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 2b98a7e..655a7fd 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -130,9 +130,7 @@ class Server(object):\n                 self.queue.append(req)\n \n                 # When this returns the request will have been processed by the dispatch_queue method on the main\n-                # thread (or timed out). We have to do it this way because GDB sucks. dispatch_queue will remove\n-                # dispatched requests from the queue, but each client connection's thread will have a reference to\n-                # the relevant request here waiting.\n+                # thread (or timed out). We have to do it this way because GDB sucks.\n                 req.wait()\n \n                 if req.timed_out:\n"}
{"repo": "voltron", "commit": "12ab6179d44d2358a6f61abfe04e40bf3f556463", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex abd8586..bd175fe 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -268,7 +268,7 @@ if HAVE_GDB:\n             while True:\n                 try:\n                     mem = gdb.selected_inferior().read_memory(addr, self.get_addr_size())\n-                    log.debug(\"read mem: {}\".format(mem))\n+                    # log.debug(\"read mem: {}\".format(mem))\n                     (ptr,) = struct.unpack(fmt, mem)\n                     if ptr in chain:\n                         break\n"}
{"repo": "voltron", "commit": "16673ed3148c3b2f47c8ef7c685b8bba16b668e5", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex d44225a..cc0e69d 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -8,8 +8,10 @@ import threading\n import logging\n import logging.config\n import json\n-import requests\n-import requests_unixsocket\n+try:\n+    import requests_unixsocket as requests\n+except:\n+    import requests\n import threading\n import os.path\n \n@@ -67,7 +69,7 @@ class Server(object):\n             self.listeners.append(s)\n \n         if voltron.config.server.listen.tcp:\n-            run_listener('tcp', ThreadedWSGIServer, list(voltron.config.server.listen.tcp) + [app])\n+            run_listener('tcp', ThreadedVoltronWSGIServer, list(voltron.config.server.listen.tcp) + [app])\n \n         if voltron.config.server.listen.domain:\n             path = os.path.expanduser(str(voltron.config.server.listen.domain))\n@@ -86,8 +88,11 @@ class Server(object):\n         log.debug(\"Stopping listeners\")\n         for s in self.listeners:\n             s.shutdown()\n+            s.socket.close()\n         for t in self.threads:\n             t.join()\n+        self.listeners = []\n+        self.threads = []\n         self.is_running = False\n \n     def handle_request(self, data):\n@@ -176,7 +181,27 @@ class Server(object):\n         return res\n \n \n-class UnixWSGIServer(UnixStreamServer, BaseWSGIServer):\n+class VoltronWSGIServer(BaseWSGIServer):\n+    \"\"\"\n+    Custom version of the werkzeug WSGI server.\n+\n+    This just needs to exist so we can swallow errors when clients disconnect.\n+    \"\"\"\n+    def finish_request(self, *args):\n+        try:\n+            super(VoltronWSGIServer, self).finish_request(*args)\n+        except socket.error as e:\n+            log.error(\"Error in finish_request: {}\".format(e))\n+\n+\n+class ThreadedVoltronWSGIServer(ThreadingMixIn, VoltronWSGIServer):\n+    \"\"\"\n+    Threaded WSGI server to replace werkzeug's\n+    \"\"\"\n+    pass\n+\n+\n+class UnixWSGIServer(UnixStreamServer, VoltronWSGIServer):\n     \"\"\"\n     A subclass of BaseWSGIServer that does sane things with Unix domain sockets.\n     \"\"\"\n@@ -240,11 +265,15 @@ class ClientThread(threading.Thread):\n     def __init__(self, client, request, *args, **kwargs):\n         self.request = request\n         self.response = None\n+        self.exception = None\n         self.client = client\n         super(ClientThread, self).__init__(*args, **kwargs)\n \n     def run(self):\n-        self.response = self.client.send_request(self.request)\n+        try:\n+            self.response = self.client.send_request(self.request)\n+        except Exception as e:\n+            self.exception = e\n \n \n class Client(object):\n@@ -255,7 +284,7 @@ class Client(object):\n         \"\"\"\n         Initialise a new client\n         \"\"\"\n-        self.session = requests_unixsocket.Session()\n+        self.session = requests.Session()\n         if url:\n             self.url = url\n         elif sockfile:\n@@ -322,6 +351,9 @@ class Client(object):\n             t.start()\n         for t in threads:\n             t.join()\n+        exceptions = [t.exception for t in threads if t.exception]\n+        if len(exceptions):\n+            raise exceptions[0]\n         return [t.response for t in threads]\n \n     def create_request(self, request_type, *args, **kwargs):\n"}
{"repo": "voltron", "commit": "575b7888da22413610b336eea92f9dcf81aafaa1", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex fd00d1e..35140cc 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -9,6 +9,7 @@ import signal\n import time\n import argparse\n import traceback\n+from requests import ConnectionError\n from blessed import Terminal\n \n try:\n@@ -245,7 +246,7 @@ class VoltronView (object):\n                         res = self.client.perform_request('version', block=True)\n                         if res.is_success:\n                             done = True\n-            except requests.ConnectionError as e:\n+            except ConnectionError as e:\n                 # what the hell, requests? a message is a message, not a fucking nested error object\n                 try:\n                     msg = e.message.args[1].strerror\n"}
{"repo": "voltron", "commit": "5fed97ae492a2bdb2563387947cfa23790ddb877", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex b3a59e4..525a298 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -304,28 +304,25 @@ class RegisterView (TerminalView):\n         t_res, d_res, r_res = self.client.send_requests(api_request('targets', block=self.block),\n                                                         api_request('disassemble', count=1, block=self.block),\n                                                         api_request('registers', block=self.block))\n-        if t_res.is_error:\n-            error = \"Failed getting targets: {}\".format(t_res.message)\n+        if t_res and t_res.is_error or t_res is None or t_res and len(t_res.targets) == 0:\n+            error = \"No such target\"\n         else:\n-            if len(t_res.targets) == 0:\n-                error = \"No such target\"\n-            else:\n-                arch = t_res.targets[0]['arch']\n-                self.curr_arch = arch\n+            arch = t_res.targets[0]['arch']\n+            self.curr_arch = arch\n \n-                # ensure the architecture is supported\n-                if arch not in self.FORMAT_INFO:\n-                    error = \"Architecture '{}' not supported\".format(arch)\n-                else:\n-                    # get next instruction\n-                    try:\n-                        self.curr_inst = d_res.disassembly.strip().split('\\n')[-1].split(':')[1].strip()\n-                    except:\n-                        self.curr_inst = None\n-\n-                    # get registers for target\n-                    if r_res.is_error:\n-                        error = r_res.message\n+            # ensure the architecture is supported\n+            if arch not in self.FORMAT_INFO:\n+                error = \"Architecture '{}' not supported\".format(arch)\n+            else:\n+                # get next instruction\n+                try:\n+                    self.curr_inst = d_res.disassembly.strip().split('\\n')[-1].split(':')[1].strip()\n+                except:\n+                    self.curr_inst = None\n+\n+                # get registers for target\n+                if r_res.is_error:\n+                    error = r_res.message\n \n         # if everything is ok, render the view\n         if not error:\n"}
{"repo": "voltron", "commit": "9f8ac84a2089a90b9fbafeada941ad12c3e40484", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 2596527..fd00d1e 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -8,6 +8,7 @@ import re\n import signal\n import time\n import argparse\n+import traceback\n from blessed import Terminal\n \n try:\n@@ -89,7 +90,6 @@ class AnsiString(object):\n                     else:\n                         chars.extend(list(chunk))\n \n-\n         # roll up ansi sequences\n         ansi = []\n         for char in chars:\n@@ -246,9 +246,17 @@ class VoltronView (object):\n                         if res.is_success:\n                             done = True\n             except requests.ConnectionError as e:\n-                import traceback;traceback.print_exc()\n+                # what the hell, requests? a message is a message, not a fucking nested error object\n+                try:\n+                    msg = e.message.args[1].strerror\n+                except:\n+                    try:\n+                        msg = e.message.args[0]\n+                    except:\n+                        msg = str(e)\n+                traceback.print_exc()\n                 # if we're not connected, render an error and try again in a second\n-                self.do_render(error='Error: {}'.format(e.message))\n+                self.do_render(error='Error: {}'.format(msg))\n                 self.server_version = None\n                 time.sleep(1)\n \n"}
{"repo": "voltron", "commit": "80c075d1447e9dd24a6e700b08a977b8269cdc90", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 435eb49..a933e62 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -471,12 +471,18 @@ if HAVE_GDB:\n                 vals['eflags'] = 'N/A'\n \n             # Get SSE registers\n-            sse = self.get_registers_sse(8)\n-            vals = dict(list(vals.items()) + list(sse.items()))\n+            try:\n+                sse = self.get_registers_sse(8)\n+                vals = dict(list(vals.items()) + list(sse.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get SSE registers\")\n \n             # Get FPU registers\n-            fpu = self.get_registers_fpu()\n-            vals = dict(list(vals.items()) + list(fpu.items()))\n+            try:\n+                fpu = self.get_registers_fpu()\n+                vals = dict(list(vals.items()) + list(fpu.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get SSE registers\")\n \n             return vals\n \n"}
{"repo": "voltron", "commit": "ec43a5463c6296a3c8fc2ab5ff08df10a4d26258", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 435eb49..a933e62 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -471,12 +471,18 @@ if HAVE_GDB:\n                 vals['eflags'] = 'N/A'\n \n             # Get SSE registers\n-            sse = self.get_registers_sse(8)\n-            vals = dict(list(vals.items()) + list(sse.items()))\n+            try:\n+                sse = self.get_registers_sse(8)\n+                vals = dict(list(vals.items()) + list(sse.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get SSE registers\")\n \n             # Get FPU registers\n-            fpu = self.get_registers_fpu()\n-            vals = dict(list(vals.items()) + list(fpu.items()))\n+            try:\n+                fpu = self.get_registers_fpu()\n+                vals = dict(list(vals.items()) + list(fpu.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get SSE registers\")\n \n             return vals\n \n"}
{"repo": "voltron", "commit": "89bd8497e4d97c0592d479bb1a7e0c5516ab1105", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex df953ed..3e2180b 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -290,11 +290,12 @@ class RegisterView (TerminalView):\n         if self.args.orientation != None:\n             self.config.orientation = self.args.orientation\n         if self.args.sections != None:\n-            a = filter(lambda x: 'no_'+x not in self.args.sections and not x.startswith('no_'), self.config.sections + self.args.sections)\n-            self.config.sections = []\n+            a = filter(lambda x: 'no_'+x not in self.args.sections and not x.startswith('no_'), list(self.config.sections) + self.args.sections)\n+            config_sections = []\n             for sec in a:\n-                if sec not in self.config.sections:\n-                    self.config.sections.append(sec)\n+                if sec not in config_sections:\n+                    config_sections.append(sec)\n+            self.config.sections = config_sections\n \n     def render(self):\n         error = None\n"}
{"repo": "voltron", "commit": "32e455d9bf0ccb8e6bfbcfa1ca18c8f65a363b4d", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex b333cd1..e4b8a4d 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -206,9 +206,8 @@ try:\n \n             def cont_handler(self, event):\n                 log.debug('Inferior continued')\n-                if self.server == None:\n+                if self.server == None or self.server.is_running == False:\n                     self.server = Server()\n-                if self.server.is_running == False\n                     self.server.start()\n \n \n"}
{"repo": "voltron", "commit": "fe61cf13df58f903b9bf734caf6c904cb3425547", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 71f0afd..88b47aa 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -208,6 +208,7 @@ try:\n                 log.debug('Inferior continued')\n                 if self.server == None:\n                     self.server = Server()\n+                if self.server.is_running == False\n                     self.server.start()\n \n \ndiff --git a/voltron/core.py b/voltron/core.py\nindex 2ebbe74..ff50a33 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -45,6 +45,8 @@ class Server(object):\n         self.d_exit_out, self.d_exit_in = os.pipe()\n         self.t_exit_out, self.t_exit_in = os.pipe()\n \n+        self.is_running = False\n+\n     def start(self):\n         listen = voltron.config['server']['listen']\n         if listen['domain']:\n@@ -61,6 +63,7 @@ class Server(object):\n             voltron.http.app.server = self\n             self.h_thread = HTTPServerThread(self, self.clients, host, port)\n             self.h_thread.start()\n+        self.is_running = True\n \n     def stop(self):\n         # terminate the server thread by writing some data to the exit pipe\n@@ -76,6 +79,7 @@ class Server(object):\n         if self.h_thread:\n             log.debug(\"Stopping HTTP server\")\n             self.h_thread.stop()\n+        self.is_running = False\n         log.debug(\"Finished stopping server threads\")\n \n     def client_summary(self):\n"}
{"repo": "voltron", "commit": "1b8553a6abf333fc1b4484370f2ab0d1ea2a14c9", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 71f0afd..88b47aa 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -208,6 +208,7 @@ try:\n                 log.debug('Inferior continued')\n                 if self.server == None:\n                     self.server = Server()\n+                if self.server.is_running == False\n                     self.server.start()\n \n \ndiff --git a/voltron/core.py b/voltron/core.py\nindex 2ebbe74..ff50a33 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -45,6 +45,8 @@ class Server(object):\n         self.d_exit_out, self.d_exit_in = os.pipe()\n         self.t_exit_out, self.t_exit_in = os.pipe()\n \n+        self.is_running = False\n+\n     def start(self):\n         listen = voltron.config['server']['listen']\n         if listen['domain']:\n@@ -61,6 +63,7 @@ class Server(object):\n             voltron.http.app.server = self\n             self.h_thread = HTTPServerThread(self, self.clients, host, port)\n             self.h_thread.start()\n+        self.is_running = True\n \n     def stop(self):\n         # terminate the server thread by writing some data to the exit pipe\n@@ -76,6 +79,7 @@ class Server(object):\n         if self.h_thread:\n             log.debug(\"Stopping HTTP server\")\n             self.h_thread.stop()\n+        self.is_running = False\n         log.debug(\"Finished stopping server threads\")\n \n     def client_summary(self):\n"}
{"repo": "voltron", "commit": "34e13d191b979a7313cba2b3f4d9bfcc9759d433", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 71f0afd..3abaf9c 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -200,7 +200,7 @@ try:\n                 self.server.stop()\n                 \n             def stop_and_exit_handler(self, event):\n-                log.debug('Infreior stopped and exited in one handle')\n+                log.debug('Inferior stopped and exited')\n                 self.stop_handler(event)\n                 self.exit_handler(event)\n \n"}
{"repo": "voltron", "commit": "b6a369a54b5de353cb8df9fed54b66445852f8d7", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 1cd77c4..435eb49 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -275,6 +275,7 @@ if HAVE_GDB:\n                     chain.append(('pointer', addr))\n                     addr = ptr\n                 except gdb.MemoryError:\n+                    log.exception(\"Dereferencing pointer 0x{:X}\".format(addr))\n                     break\n \n             # get some info for the last pointer\n"}
{"repo": "voltron", "commit": "5c57a6b8f5c7807ff151f446cac48a29e8dae512", "diff": "diff --git a/voltron/api.py b/voltron/api.py\nindex bd7f34f..b3f531e 100644\n--- a/voltron/api.py\n+++ b/voltron/api.py\n@@ -173,7 +173,7 @@ class APIMessage(object):\n             if hasattr(self, field):\n                 # base64 encode the field for transmission if necessary\n                 if field in self._encode_fields:\n-                    d['data'][field] = str(base64.b64encode(bytes(getattr(self, field))))\n+                    d['data'][field] = base64.b64encode(bytes(getattr(self, field))).decode('UTF-8')\n                 else:\n                     d['data'][field] = getattr(self, field)\n \n"}
{"repo": "voltron", "commit": "20d8570fa1be2989fa4c745efa096e51a79a14c9", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex bda3251..1cd77c4 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -433,12 +433,18 @@ if HAVE_GDB:\n                 vals['rflags'] = 'N/A'\n \n             # Get SSE registers\n-            sse = self.get_registers_sse(16)\n-            vals = dict(list(vals.items()) + list(sse.items()))\n+            try:\n+                sse = self.get_registers_sse(16)\n+                vals = dict(list(vals.items()) + list(sse.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get SSE registers\")\n \n             # Get FPU registers\n-            fpu = self.get_registers_fpu()\n-            vals = dict(list(vals.items()) + list(fpu.items()))\n+            try:\n+                fpu = self.get_registers_fpu()\n+                vals = dict(list(vals.items()) + list(fpu.items()))\n+            except gdb.error:\n+                log.exception(\"Failed to get FPU registers\")\n \n             return vals\n \n@@ -481,7 +487,7 @@ if HAVE_GDB:\n             # the old way of doing this randomly crashed gdb or threw a python exception\n             regs = {}\n             for line in gdb.execute('info all-registers', to_string=True).split('\\n'):\n-                m = re.match('^(xmm\\d+)\\s.*uint128 = (0x[0-9a-f]+)\\}', line)\n+                m = re.match('^([xyz]mm\\d+)\\s.*uint128 = (0x[0-9a-f]+)\\}', line)\n                 if m:\n                     regs[m.group(1)] = int(m.group(2), 16)\n             return regs\n"}
{"repo": "voltron", "commit": "97ac02b8f8b05c5a619e155b5c196e95ca9fedf6", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex e4e39a3..2f0af3e 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -136,9 +136,9 @@ class VoltronView (object):\n     @classmethod\n     def configure_subparser(cls, subparsers):\n         if hasattr(cls._plugin, 'aliases'):\n-            sp = subparsers.add_parser(cls.view_type, aliases=cls._plugin.aliases)\n+            sp = subparsers.add_parser(cls.view_type, aliases=cls._plugin.aliases, help='{} view'.format(cls.view_type))\n         else:\n-            sp = subparsers.add_parser(cls.view_type)\n+            sp = subparsers.add_parser(cls.view_type, help='{} view'.format(cls.view_type))\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=cls)\n \n"}
{"repo": "voltron", "commit": "5b088990677addd0edad58b393057c3b694f4ccc", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 6be0f03..e4e39a3 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -168,9 +168,6 @@ class VoltronView (object):\n         if self.args.footer != None:\n             self.config.footer.show = self.args.footer\n \n-        # Initialise window\n-        self.init_window()\n-\n         # Setup a SIGWINCH handler so we do reasonable things on resize\n         signal.signal(signal.SIGWINCH, self.sigwinch_handler)\n \n@@ -200,6 +197,9 @@ class VoltronView (object):\n     def setup(self):\n         log.debug('Base view class setup')\n \n+    def cleanup(self):\n+        log.debug('Base view class cleanup')\n+\n     def run(self):\n         res = None\n         os.system('clear')\n@@ -242,6 +242,11 @@ class VoltronView (object):\n \n \n class TerminalView (VoltronView):\n+    def __init__(self, *a, **kw):\n+        # Initialise window\n+        self.init_window()\n+        super(TerminalView, self).__init__(*a, **kw)\n+\n     def init_window(self):\n         # Hide cursor\n         os.system('tput civis')\n@@ -364,4 +369,4 @@ def merge(d1, d2):\n             merge(v1, d2[k1])\n         else:\n             d2[k1] = v1\n-    return d2\n\\ No newline at end of file\n+    return d2\n"}
{"repo": "voltron", "commit": "943c82516450710cd92d3330d4d46954cc0ac660", "diff": "diff --git a/voltron/console.py b/voltron/console.py\nindex 87b7922..e2e2bd3 100644\n--- a/voltron/console.py\n+++ b/voltron/console.py\n@@ -6,21 +6,38 @@ import sys\n import lldb\n import rl\n import logging\n+import threading\n from rl import completer, generator, completion\n \n+import voltron\n from .core import *\n from .colour import *\n \n VERSION = 'voltron-0.1'\n BANNER = \"{version} (based on {lldb_version})\"\n \n-log = logging.getLogger(__name__)\n+log = logging.getLogger('console')\n+\n+\n+class EventListener(threading.Thread):\n+    def __init__(self, debugger):\n+        super(EventListener, self).__init__()\n+        self.debugger = debugger\n+\n+    def run(self):\n+        print(\"thing\")\n+        self.listener = self.debugger.GetListener()\n+        event = lldb.SBEvent()\n+        self.listener.WaitForEvent(10, event)\n+        print(event)\n+\n \n class Console(object):\n     @classmethod\n     def configure_subparser(cls, subparsers):\n         sp = subparsers.add_parser('console', help='voltron debugger console', aliases=('c'))\n         sp.set_defaults(func=Console)\n+        sp.add_argument('file', help='binary to load', nargs='?')\n \n     def __init__(self, args={}, loaded_config={}):\n         self.args = args\n@@ -35,18 +52,25 @@ class Console(object):\n         self.lastbuf = None\n \n         # set up plugin manager\n-        self.pm = PluginManager()\n+        self.pm = voltron.plugin.pm\n+\n+        # set up an lldb adaptor and set it as the package-wide adaptor\n+        self.adaptor = self.pm.debugger_plugin_for_host('lldb').adaptor_class()\n+        voltron.debugger = self.adaptor\n+        self.debugger = self.adaptor.host\n \n-        # set up debugger\n-        plugin = self.pm.debugger_plugin_for_host('lldb')\n-        self.adaptor = plugin.adaptor_class()\n-        self.dbg = self.adaptor.host\n+        # register plugins now that we have a debugger\n+        self.pm.register_plugins()\n \n         # set up lldb command interpreter\n         self.ci = self.adaptor.host.GetCommandInterpreter()\n \n+        # set up listener\n+        self.listener = EventListener(self.debugger)\n+        self.listener.start()\n+\n         # set up voltron server\n-        self.server = Server(debugger=self.adaptor)\n+        self.server = Server()\n         self.server.start()\n \n         # set up voltron console command\n@@ -72,7 +96,7 @@ class Console(object):\n             rl.readline.write_history_file(voltron.env['history'])\n \n     def print_banner(self):\n-        d = {'version': VERSION, 'lldb_version': self.dbg.GetVersionString()}\n+        d = {'version': VERSION, 'lldb_version': self.debugger.GetVersionString()}\n         print(BANNER.format(**d))\n \n     def update_prompt(self):\ndiff --git a/voltron/core.py b/voltron/core.py\nindex 4544fa5..04aaf9c 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -90,14 +90,14 @@ class Server(object):\n                 req = APIRequest(data=data)\n             except Exception as e:\n                 req = None\n-                log.error(\"Exception raised while parsing API request: {} {}\".format(type(e), e))\n+                log.exception(\"Exception raised while parsing API request: {} {}\".format(type(e), e))\n \n             if req:\n                 # instantiate the request class\n                 try:\n                     req = api_request(req.request, data=data)\n                 except Exception as e:\n-                    log.error(\"Exception raised while creating API request: {} {}\".format(type(e), e))\n+                    log.exception(\"Exception raised while creating API request: {} {}\".format(type(e), e))\n                     req = None\n                 if not req:\n                     res = APIPluginNotFoundErrorResponse()\n@@ -148,7 +148,7 @@ class Server(object):\n                 res = req.dispatch()\n             except Exception as e:\n                 msg = \"Exception raised while dispatching request: {}\".format(e)\n-                log.error(msg)\n+                log.exception(msg)\n                 res = APIGenericErrorResponse(msg)\n \n         log.debug(\"Response: {}\".format(str(res)))\n@@ -226,7 +226,7 @@ class ServerThread(threading.Thread):\n                         data = fd.recv_request()\n                         self.server.handle_request(data, fd)\n                     except Exception as e:\n-                        log.error(\"Exception raised while handling request: {} {}\".format(type(e), str(e)))\n+                        log.exception(\"Exception raised while handling request: {} {}\".format(type(e), str(e)))\n                         self.purge_client(fd)\n \n         # clean up\n@@ -416,7 +416,7 @@ class Client(object):\n                         # didn't find a plugin, just return the generic APIResponse we already generated\n                         res = generic_response\n             except Exception as e:\n-                log.error('Exception parsing message: ' + str(e))\n+                log.exception('Exception parsing message: ' + str(e))\n                 log.error('Invalid message: ' + data)\n         else:\n             raise SocketDisconnected(\"socket closed\")\n@@ -490,7 +490,7 @@ class ServerSocket(BaseSocket):\n             try:\n                 return ClientSocket(sock)\n             except Exception as e:\n-                log.error(\"Exception handling accept: \" + str(e))\n+                log.exception(\"Exception handling accept: \" + str(e))\n \n \n class ClientSocket(BaseSocket):\ndiff --git a/voltron/main.py b/voltron/main.py\nindex af95229..7edc5ef 100644\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -48,7 +48,7 @@ def main(debugger=None):\n     try:\n         inst.run()\n     except Exception as e:\n-        log.error(\"Exception running module {}: {}\".format(inst.__class__.__name__, traceback.format_exc()))\n+        log.exception(\"Exception running module {}: {}\".format(inst.__class__.__name__, traceback.format_exc()))\n         print(\"Encountered an exception while running the view '{}':\\n{}\".format(inst.__class__.__name__, traceback.format_exc()))\n     except KeyboardInterrupt:\n         suppress_exit_log = True\ndiff --git a/voltron/plugins/api/breakpoints.py b/voltron/plugins/api/breakpoints.py\nindex 8f8834d..88755e4 100644\n--- a/voltron/plugins/api/breakpoints.py\n+++ b/voltron/plugins/api/breakpoints.py\n@@ -30,7 +30,7 @@ class APIBreakpointsRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n             msg = \"Exception getting breakpoints: {}\".format(e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\ndiff --git a/voltron/plugins/api/command.py b/voltron/plugins/api/command.py\nindex 0b5ee6a..9d04631 100644\n--- a/voltron/plugins/api/command.py\n+++ b/voltron/plugins/api/command.py\n@@ -31,7 +31,7 @@ class APICommandRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n             msg = \"Exception executing debugger command: {}\".format(e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\ndiff --git a/voltron/plugins/api/dereference.py b/voltron/plugins/api/dereference.py\nindex 4d8d956..cc2fb6c 100644\n--- a/voltron/plugins/api/dereference.py\n+++ b/voltron/plugins/api/dereference.py\n@@ -31,8 +31,8 @@ class APIDerefRequest(APIRequest):\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n-            msg = \"Exception executing debugger command: {}\".format(e)\n-            log.error(msg)\n+            msg = \"Exception dereferencing pointer: {}\".format(e)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\ndiff --git a/voltron/plugins/api/disassemble.py b/voltron/plugins/api/disassemble.py\nindex 0893c2f..4d535c5 100644\n--- a/voltron/plugins/api/disassemble.py\n+++ b/voltron/plugins/api/disassemble.py\n@@ -52,7 +52,7 @@ class APIDisassembleRequest(APIRequest):\n             res = APITargetBusyErrorResponse()\n         except Exception as e:\n             msg = \"Unhandled exception {} disassembling: {}\".format(type(e), e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIErrorResponse(code=0, message=msg)\n \n         return res\ndiff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex 8ddd158..c615d3e 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -49,7 +49,7 @@ class APIMemoryRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n             msg = \"Exception getting memory from debugger: {}\".format(e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\ndiff --git a/voltron/plugins/api/registers.py b/voltron/plugins/api/registers.py\nindex 10d4e8d..fba45f0 100644\n--- a/voltron/plugins/api/registers.py\n+++ b/voltron/plugins/api/registers.py\n@@ -46,7 +46,7 @@ class APIRegistersRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n             msg = \"Exception getting registers from debugger: {}\".format(e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\ndiff --git a/voltron/plugins/api/stack.py b/voltron/plugins/api/stack.py\nindex ca6d2db..a73c582 100644\n--- a/voltron/plugins/api/stack.py\n+++ b/voltron/plugins/api/stack.py\n@@ -47,7 +47,7 @@ class APIStackRequest(APIRequest):\n             res = APITargetBusyErrorResponse()\n         except Exception as e:\n             msg = \"Unhandled exception {} reading stack: {}\".format(type(e), e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIErrorResponse(code=0, message=msg)\n \n         return res\ndiff --git a/voltron/plugins/api/targets.py b/voltron/plugins/api/targets.py\nindex 681ae11..0ee205f 100644\n--- a/voltron/plugins/api/targets.py\n+++ b/voltron/plugins/api/targets.py\n@@ -27,7 +27,7 @@ class APITargetsRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except Exception as e:\n             msg = \"Exception getting targets from debugger: {}\".format(e)\n-            log.error(msg)\n+            log.exception(msg)\n             res = APIGenericErrorResponse(msg)\n \n         return res\n"}
{"repo": "voltron", "commit": "32603248b4b71a88c0f941ea26aa15da3f4738db", "diff": "diff --git a/voltron/dbg.py b/voltron/dbg.py\nindex a60d32f..350fad9 100644\n--- a/voltron/dbg.py\n+++ b/voltron/dbg.py\n@@ -77,7 +77,7 @@ class DebuggerAdaptor(object):\n         \"armv7\":    {\"pc\": \"pc\", \"sp\": \"sp\"},\n         \"armv7s\":   {\"pc\": \"pc\", \"sp\": \"sp\"},\n         \"arm64\":    {\"pc\": \"pc\", \"sp\": \"sp\"},\n-        \"powerpc\":    {\"pc\": \"pc\", \"sp\": \"r1\"},\n+        \"powerpc\":  {\"pc\": \"pc\", \"sp\": \"r1\"},\n     }\n \n     def target_exists(self, target_id=0):\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 78bceee..a2da5ee 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -94,6 +94,8 @@ if HAVE_LLDB:\n                 d[\"arch\"], _, _ = self.normalize_triple(t.triple)\n             except:\n                 d[\"arch\"] = None\n+            if d[\"arch\"] == 'i386':\n+                d[\"arch\"] = 'x86'\n             d[\"byte_order\"] = 'little' if t.byte_order == lldb.eByteOrderLittle else 'big'\n             d[\"addr_size\"] = t.addr_size\n \n@@ -182,7 +184,7 @@ if HAVE_LLDB:\n                     registers.remove('sp')\n                     registers.append(self.reg_names[t_info['arch']]['sp'])\n             else:\n-                raise Exception(\"Unsupported architecture: {}\".format(target['arch']))\n+                raise Exception(\"Unsupported architecture: {}\".format(t_info['arch']))\n \n             # get the registers\n             log.warn(\"thing: {}\".format(registers))\ndiff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 28c91df..00615f4 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -310,7 +310,7 @@ class RegisterView (TerminalView):\n \n                 # ensure the architecture is supported\n                 if arch not in self.FORMAT_INFO:\n-                    error = \"Archiecture '{}' not supported\".format(arch)\n+                    error = \"Architecture '{}' not supported\".format(arch)\n                 else:\n                     # get next instruction\n                     res = self.client.perform_request('disassemble', count=1)\n"}
{"repo": "voltron", "commit": "fab5dc52b5c31006b9ef1f945ce4ee3d9073ba35", "diff": "diff --git a/voltron/debugger.py b/voltron/dbg.py\nsimilarity index 100%\nrename from voltron/debugger.py\nrename to voltron/dbg.py\ndiff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex c704b0d..c540295 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -7,7 +7,7 @@ import struct\n \n from voltron.api import *\n from voltron.plugin import *\n-from voltron.debugger import *\n+from voltron.dbg import *\n \n try:\n     import gdb\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex c5c7b17..78bceee 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -7,7 +7,7 @@ from collections import namedtuple\n \n from voltron.api import *\n from voltron.plugin import *\n-from voltron.debugger import *\n+from voltron.dbg import *\n \n try:\n     import lldb\ndiff --git a/voltron/plugins/debugger/dbg_vdb.py b/voltron/plugins/debugger/dbg_vdb.py\nindex cacc214..8a6846d 100644\n--- a/voltron/plugins/debugger/dbg_vdb.py\n+++ b/voltron/plugins/debugger/dbg_vdb.py\n@@ -9,7 +9,7 @@ import threading\n \n from voltron.api import *\n from voltron.plugin import *\n-from voltron.debugger import *\n+from voltron.dbg import *\n \n try:\n     import vdb\n"}
{"repo": "voltron", "commit": "a55b0261af7342390f184a0125065048d99e4a23", "diff": "diff --git a/tests/api_message_tests.py b/tests/api_message_tests.py\nindex 154195e..6c79c5f 100644\n--- a/tests/api_message_tests.py\n+++ b/tests/api_message_tests.py\n@@ -160,7 +160,7 @@ def test_test_request_validation_succeed_with_data():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert not exception\n     assert msg.count == 16\n@@ -171,7 +171,7 @@ def test_test_request_validation_succeed_by_assign():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert not exception\n     assert msg.count == 16\n@@ -185,7 +185,7 @@ def test_test_response_validation_fail():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert exception\n \n@@ -194,7 +194,7 @@ def test_test_response_validation_fail_with_param():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert exception\n \n@@ -203,7 +203,7 @@ def test_test_response_validation_succeed_with_param():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert not exception\n \n@@ -212,7 +212,7 @@ def test_test_response_validation_succeed_with_data():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         exception = True\n     assert not exception\n \n@@ -222,7 +222,7 @@ def test_test_response_validation_succeed_by_assign():\n     exception = False\n     try:\n         msg.validate()\n-    except MissingFieldError, e:\n+    except MissingFieldError as e:\n         print str(e)\n         exception = True\n     assert not exception\ndiff --git a/voltron/core.py b/voltron/core.py\nindex 380a5ba..4544fa5 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -88,7 +88,7 @@ class Server(object):\n             # parse incoming request with the top level APIRequest class so we can determine the request type\n             try:\n                 req = APIRequest(data=data)\n-            except Exception, e:\n+            except Exception as e:\n                 req = None\n                 log.error(\"Exception raised while parsing API request: {} {}\".format(type(e), e))\n \n@@ -96,7 +96,7 @@ class Server(object):\n                 # instantiate the request class\n                 try:\n                     req = api_request(req.request, data=data)\n-                except Exception, e:\n+                except Exception as e:\n                     log.error(\"Exception raised while creating API request: {} {}\".format(type(e), e))\n                     req = None\n                 if not req:\n@@ -139,14 +139,14 @@ class Server(object):\n         res = None\n         try:\n             req.validate()\n-        except MissingFieldError, e:\n+        except MissingFieldError as e:\n             res = APIMissingFieldErrorResponse(str(e))\n \n         # dispatch the request\n         if not res:\n             try:\n                 res = req.dispatch()\n-            except Exception, e:\n+            except Exception as e:\n                 msg = \"Exception raised while dispatching request: {}\".format(e)\n                 log.error(msg)\n                 res = APIGenericErrorResponse(msg)\n@@ -225,7 +225,7 @@ class ServerThread(threading.Thread):\n                     try:\n                         data = fd.recv_request()\n                         self.server.handle_request(data, fd)\n-                    except Exception, e:\n+                    except Exception as e:\n                         log.error(\"Exception raised while handling request: {} {}\".format(type(e), str(e)))\n                         self.purge_client(fd)\n \ndiff --git a/voltron/debugger.py b/voltron/debugger.py\nindex b201a4a..a60d32f 100644\n--- a/voltron/debugger.py\n+++ b/voltron/debugger.py\n@@ -62,7 +62,7 @@ def lock_host(func, *args, **kwargs):\n         try:\n             res = func(self, *args, **kwargs)\n             self.host_lock.release()\n-        except Exception, e:\n+        except Exception as e:\n             self.host_lock.release()\n             raise e\n         return res\n@@ -89,7 +89,7 @@ class DebuggerAdaptor(object):\n         \"\"\"\n         try:\n             target = self._target(target_id=target_id)\n-        except Exception, e:\n+        except Exception as e:\n             log.error(\"Exception checking if target exists: {} {}\".format(type(e), e))\n             return False\n         return target != None\ndiff --git a/voltron/plugins/api/breakpoints.py b/voltron/plugins/api/breakpoints.py\nindex 063a1c4..8f8834d 100644\n--- a/voltron/plugins/api/breakpoints.py\n+++ b/voltron/plugins/api/breakpoints.py\n@@ -28,7 +28,7 @@ class APIBreakpointsRequest(APIRequest):\n             res = APIBreakpointsResponse(breakpoints=bps)\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception getting breakpoints: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/api/command.py b/voltron/plugins/api/command.py\nindex 85c9f92..0b5ee6a 100644\n--- a/voltron/plugins/api/command.py\n+++ b/voltron/plugins/api/command.py\n@@ -29,7 +29,7 @@ class APICommandRequest(APIRequest):\n             res.output = output\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception executing debugger command: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/api/dereference.py b/voltron/plugins/api/dereference.py\nindex 5a5ef5b..4d8d956 100644\n--- a/voltron/plugins/api/dereference.py\n+++ b/voltron/plugins/api/dereference.py\n@@ -30,7 +30,7 @@ class APIDerefRequest(APIRequest):\n             res.output = output\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception executing debugger command: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/api/disassemble.py b/voltron/plugins/api/disassemble.py\nindex a8393a1..0893c2f 100644\n--- a/voltron/plugins/api/disassemble.py\n+++ b/voltron/plugins/api/disassemble.py\n@@ -50,7 +50,7 @@ class APIDisassembleRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except TargetBusyException:\n             res = APITargetBusyErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Unhandled exception {} disassembling: {}\".format(type(e), e)\n             log.error(msg)\n             res = APIErrorResponse(code=0, message=msg)\ndiff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex 3747b88..8ddd158 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -47,7 +47,7 @@ class APIMemoryRequest(APIRequest):\n             res = APITargetBusyErrorResponse()\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception getting memory from debugger: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/api/registers.py b/voltron/plugins/api/registers.py\nindex ceca54f..10d4e8d 100644\n--- a/voltron/plugins/api/registers.py\n+++ b/voltron/plugins/api/registers.py\n@@ -44,7 +44,7 @@ class APIRegistersRequest(APIRequest):\n             res = APITargetBusyErrorResponse()\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception getting registers from debugger: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/api/stack.py b/voltron/plugins/api/stack.py\nindex efd4b9b..ca6d2db 100644\n--- a/voltron/plugins/api/stack.py\n+++ b/voltron/plugins/api/stack.py\n@@ -45,7 +45,7 @@ class APIStackRequest(APIRequest):\n             res = APINoSuchTargetErrorResponse()\n         except TargetBusyException:\n             res = APITargetBusyErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Unhandled exception {} reading stack: {}\".format(type(e), e)\n             log.error(msg)\n             res = APIErrorResponse(code=0, message=msg)\ndiff --git a/voltron/plugins/api/targets.py b/voltron/plugins/api/targets.py\nindex 5be9317..681ae11 100644\n--- a/voltron/plugins/api/targets.py\n+++ b/voltron/plugins/api/targets.py\n@@ -25,7 +25,7 @@ class APITargetsRequest(APIRequest):\n             res.targets = voltron.debugger.targets()\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n-        except Exception, e:\n+        except Exception as e:\n             msg = \"Exception getting targets from debugger: {}\".format(e)\n             log.error(msg)\n             res = APIGenericErrorResponse(msg)\ndiff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex af5c773..c704b0d 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -336,7 +336,7 @@ if HAVE_GDB:\n                         state = \"invalid\"\n                     elif \"stopped\" in output:\n                         state = \"stopped\"\n-                except gdb.error, e:\n+                except gdb.error as e:\n                     if 'Selected thread is running.' == str(e):\n                         state = \"running\"\n             else:\ndiff --git a/voltron/view.py b/voltron/view.py\nindex 6c2acc9..6be0f03 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -217,7 +217,7 @@ class VoltronView (object):\n                 # wait for the debugger to stop again\n                 wait_req = api_request('wait')\n                 res = self.client.send_request(wait_req)\n-            except socket.error, e:\n+            except socket.error as e:\n                 import traceback;traceback.print_exc()\n                 # if we're not connected, render an error and try again in a second\n                 self.do_render(error='Error: {}'.format(e.strerror))\n@@ -279,7 +279,7 @@ class TerminalView (VoltronView):\n             if self.config.footer.show:\n                 print('\\n' + self.format_header_footer(self.config.footer), end='')\n             sys.stdout.flush()\n-        except IOError, e:\n+        except IOError as e:\n             # if we get an EINTR while printing, just do it again\n             if e.errno == socket.EINTR:\n                 self.do_render()\n"}
{"repo": "voltron", "commit": "3513fbe25761f2e3e2006536eeb85565f706c536", "diff": "diff --git a/setup.py b/setup.py\nindex 21a6087..2d66582 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -18,5 +18,5 @@ setup(\n         'console_scripts': ['voltron = voltron:main']\n     },\n     zip_safe = False,\n-    dependency_links = [\"https://github.com/snarez/scruffy/tarball/v0.2#egg=scruffy\"]\n+    dependency_links = [\"https://github.com/snarez/scruffy/tarball/v0.2.1#egg=scruffy\"]\n )\n"}
{"repo": "voltron", "commit": "6386212b1e37c744d6bec4cb806ba4a783d7c9da", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 669973b..380a5ba 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -347,8 +347,12 @@ class Client(object):\n         \"\"\"\n         Connect to the server\n         \"\"\"\n-        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n-        self.sock.connect(voltron.env['sock'])\n+        try:\n+            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n+            self.sock.connect(voltron.env['sock'])\n+        except Exception as e:\n+            self.sock = None\n+            raise\n \n     def send_request(self, request):\n         \"\"\"\n@@ -371,13 +375,15 @@ class Client(object):\n             try:\n                 res = self.sock.sendall(data)\n                 break\n-            except socket.error, e:\n+            except socket.error as e:\n                 if e.errno == socket.EINTR:\n                     continue\n                 else:\n+                    self.sock = None\n                     raise\n         if res != None:\n             log.error(\"Failed to send request: {}\".format(request))\n+            self.sock = None\n             raise SocketDisconnected(\"socket closed\")\n \n         # receive response data\n@@ -385,7 +391,7 @@ class Client(object):\n             try:\n                 data = self.sock.recv(READ_MAX)\n                 break\n-            except socket.error, e:\n+            except socket.error as e:\n                 if e.errno == socket.EINTR:\n                     continue\n                 else:\ndiff --git a/voltron/view.py b/voltron/view.py\nindex 011b68c..1f93c83 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -199,33 +199,27 @@ class VoltronView (object):\n     def run(self):\n         res = None\n         os.system('clear')\n-        try:\n-            while True:\n-                try:\n-                    # Connect to server\n-                    if not self.client.is_connected:\n-                        self.client.connect()\n-\n-                    # If this is the first iteration (ie. we were just launched and the debugger is already stopped),\n-                    # or we got a valid response on the last iteration, render\n-                    if res == None or hasattr(res, 'state') and res.state == 'stopped':\n-                        self.render()\n-\n-                    # wait for the debugger to stop again\n-                    wait_req = api_request('wait')\n-                    res = self.client.send_request(wait_req)\n-                except socket.error, e:\n-                    # if this was an interrupted syscall exception we were probably SIGWINCHed, so retry straight away\n-                    if e.errno != socket.EINTR:\n-                        # if we're not connected, render an error and try again in a second\n-                        self.do_render(error='Error: {}'.format(e.strerror))\n-                        time.sleep(1)\n-        except SocketDisconnected as e:\n-            if self.should_reconnect():\n-                log.debug(\"Restarting process: \" + str(type(e)))\n-                self.reexec()\n-            else:\n-                raise\n+        while True:\n+            try:\n+                # Connect to server\n+                if not self.client.is_connected:\n+                    self.client.connect()\n+\n+                # If this is the first iteration (ie. we were just launched and the debugger is already stopped),\n+                # or we got a valid response on the last iteration, render\n+                if res == None or hasattr(res, 'state') and res.state == 'stopped':\n+                    self.render()\n+\n+                # wait for the debugger to stop again\n+                wait_req = api_request('wait')\n+                res = self.client.send_request(wait_req)\n+            except socket.error, e:\n+                import traceback;traceback.print_exc()\n+                # if we're not connected, render an error and try again in a second\n+                self.do_render(error='Error: {}'.format(e.strerror))\n+                time.sleep(1)\n+            except SocketDisconnected as e:\n+                pass\n \n     def render(self):\n         log.warning('Might wanna implement render() in this view eh')\n@@ -239,10 +233,6 @@ class VoltronView (object):\n         except:\n             return True\n \n-    def reexec(self):\n-        # Instead of trying to reset internal state, just exec ourselves again\n-        os.execv(sys.argv[0], sys.argv)\n-\n     def sigwinch_handler(self, sig, stack):\n         pass\n \n"}
{"repo": "voltron", "commit": "f189d6b89ca8c2a5bca1dd53bd0114a0aa15dd52", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 46b9318..7db3553 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -178,10 +178,10 @@ class VoltronView (object):\n                     wait_req = api_request('wait')\n                     res = self.client.send_request(wait_req)\n                 except socket.error, e:\n-                    # if we're not connected, render an error and try again in a second\n-                    self.do_render(error='Error connecting to server: {}'.format(e.strerror))\n                     # if this was an interrupted syscall exception we were probably SIGWINCHed, so retry straight away\n                     if e.errno != socket.EINTR:\n+                        # if we're not connected, render an error and try again in a second\n+                        self.do_render(error='Error: {}'.format(e.strerror))\n                         time.sleep(1)\n         except SocketDisconnected as e:\n             if self.should_reconnect():\n@@ -207,7 +207,7 @@ class VoltronView (object):\n         os.execv(sys.argv[0], sys.argv)\n \n     def sigwinch_handler(self, sig, stack):\n-        self.render()\n+        pass\n \n \n class TerminalView (VoltronView):\n@@ -233,17 +233,28 @@ class TerminalView (VoltronView):\n         if error:\n             self.body = self.colour(error, 'red')\n \n+        # Refresh the formatted body\n+        self.fmt_body = self.body\n+\n         # Pad and truncate the body\n         self.pad_body()\n         self.truncate_body()\n \n         # Print the header, body and footer\n-        if self.config['header']['show']:\n-            print(self.format_header())\n-        print(self.body, end='')\n-        if self.config['footer']['show']:\n-            print('\\n' + self.format_footer(), end='')\n-        sys.stdout.flush()\n+        try:\n+            if self.config['header']['show']:\n+                print(self.format_header())\n+            print(self.fmt_body, end='')\n+            if self.config['footer']['show']:\n+                print('\\n' + self.format_footer(), end='')\n+            sys.stdout.flush()\n+        except IOError, e:\n+            # if we get an EINTR while printing, just do it again\n+            if e.errno == socket.EINTR:\n+                self.do_render()\n+\n+    def sigwinch_handler(self, sig, stack):\n+        self.do_render()\n \n     def window_size(self):\n         height, width = os.popen('stty size').read().split()\n@@ -313,35 +324,27 @@ class TerminalView (VoltronView):\n \n     def pad_body(self):\n         height, width = self.window_size()\n-\n-        # Split body into lines\n-        lines = self.body.split('\\n')\n-\n-        # Subtract lines (including wrapped lines)\n-        pad = self.body_height()\n-        for line in lines:\n-            line = ''.join(re.split('\\033\\[\\d+m', line))\n-            (n, rem) = divmod(len(line), width)\n-            if rem > 0: n += 1\n-            pad -= n\n-\n-        # If we have too much data for the view, too bad\n+        lines = self.fmt_body.split('\\n')\n+        pad = self.body_height() - len(lines)\n         if pad < 0:\n             pad = 0\n-\n-        self.body += int(pad)*'\\n'\n+        self.fmt_body += int(pad)*'\\n'\n \n     def truncate_body(self):\n         height, width = self.window_size()\n \n+        # truncate lines horizontally\n         lines = []\n-        for line in self.body.split('\\n'):\n+        for line in self.fmt_body.split('\\n'):\n             s = AnsiString(line)\n             if len(s) > width:\n                 line = s[:width-1] + self.colour('>', 'red')\n             lines.append(line)\n \n-        self.body = '\\n'.join(lines)\n+        # truncate body vertically\n+        lines = lines[:self.body_height()]\n+\n+        self.fmt_body = '\\n'.join(lines)\n \n \n def merge(d1, d2):\n"}
{"repo": "voltron", "commit": "97e99e9233c7b8fe2023dc2dbb2b7dab06ed123d", "diff": "diff --git a/voltron/plugins/view/backtrace.py b/voltron/plugins/view/backtrace.py\nindex 07db3f2..9e83911 100644\n--- a/voltron/plugins/view/backtrace.py\n+++ b/voltron/plugins/view/backtrace.py\n@@ -16,7 +16,7 @@ class BacktraceView (TerminalView):\n         req = api_request('command')\n         req.command = \"bt\"\n         res = self.client.send_request(req)\n-        if res.is_success:\n+        if res and res.is_success:\n             # Get the command output\n             self.body = res.output\n         else:\ndiff --git a/voltron/plugins/view/command.py b/voltron/plugins/view/command.py\nindex f498eac..3fff629 100644\n--- a/voltron/plugins/view/command.py\n+++ b/voltron/plugins/view/command.py\n@@ -26,7 +26,7 @@ class CommandView (TerminalView):\n         req = api_request('command')\n         req.command = self.config['cmd']\n         res = self.client.send_request(req)\n-        if res.is_success:\n+        if res and res.is_success:\n             # Get the command output\n             self.body = res.output\n         else:\ndiff --git a/voltron/plugins/view/disasm.py b/voltron/plugins/view/disasm.py\nindex d65561d..91457a7 100644\n--- a/voltron/plugins/view/disasm.py\n+++ b/voltron/plugins/view/disasm.py\n@@ -14,7 +14,7 @@ class DisasmView (TerminalView):\n         req = api_request('disassemble')\n         req.count = self.body_height()\n         res = self.client.send_request(req)\n-        if res.is_success:\n+        if res and res.is_success:\n             # Get the disasm\n             disasm = res.disassembly\n             disasm = '\\n'.join(disasm.split('\\n')[:self.body_height()])\ndiff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex 3a598fa..eabb78c 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -34,7 +34,7 @@ class MemoryView (TerminalView):\n         # get info about target\n         target = None\n         res = self.client.perform_request('targets')\n-        if res.is_success and len(res.targets) > 0:\n+        if res and res.is_success and len(res.targets) > 0:\n             target = res.targets[0]\n \n         if target and self.args.deref:\n@@ -63,13 +63,13 @@ class MemoryView (TerminalView):\n             addr = int(self.args.address, 16)\n         elif self.args.register:\n             res = self.client.perform_request('registers', registers=[self.args.register])\n-            if res.is_success:\n+            if res and res.is_success:\n                 addr = res.registers.values()[0]\n \n         # read memory\n         if addr != None:\n             res = self.client.perform_request('memory', address=addr, length=self.body_height()*self.args.bytes)\n-            if res.is_success:\n+            if res and res.is_success:\n \n                 lines = []\n                 for c in range(0, res.bytes, self.args.bytes):\ndiff --git a/voltron/view.py b/voltron/view.py\nindex bc6947f..46b9318 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -131,7 +131,7 @@ class VoltronView (object):\n         self.init_window()\n \n         # Setup a SIGWINCH handler so we do reasonable things on resize\n-        # signal.signal(signal.SIGWINCH, lambda sig, stack: self.render())\n+        signal.signal(signal.SIGWINCH, self.sigwinch_handler)\n \n     def build_config(self):\n         # Start with all_views config\n@@ -180,7 +180,9 @@ class VoltronView (object):\n                 except socket.error, e:\n                     # if we're not connected, render an error and try again in a second\n                     self.do_render(error='Error connecting to server: {}'.format(e.strerror))\n-                    time.sleep(1)\n+                    # if this was an interrupted syscall exception we were probably SIGWINCHed, so retry straight away\n+                    if e.errno != socket.EINTR:\n+                        time.sleep(1)\n         except SocketDisconnected as e:\n             if self.should_reconnect():\n                 log.debug(\"Restarting process: \" + str(type(e)))\n@@ -204,6 +206,9 @@ class VoltronView (object):\n         # Instead of trying to reset internal state, just exec ourselves again\n         os.execv(sys.argv[0], sys.argv)\n \n+    def sigwinch_handler(self, sig, stack):\n+        self.render()\n+\n \n class TerminalView (VoltronView):\n     def init_window(self):\n"}
{"repo": "voltron", "commit": "8a3eeff9ef990a89b4a60af43fe98f4fd005f42c", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex f39a198..2633e55 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -65,10 +65,10 @@ try:\n                     print(\"Debug logging is currently \" + enabled)\n             elif 'init' in command:\n                 self.register_hooks()\n-            elif 'stopped' in command:\n+            elif 'stopped' in command or 'update' in command:\n                 self.adaptor.update_state()\n             else:\n-                print(\"Usage: voltron <status|debug>\")\n+                print(\"Usage: voltron <init|status|debug|update>\")\n \n         def status(self):\n             if self.server != None:\n"}
{"repo": "voltron", "commit": "4c73b7fb2adc3b5e2d232f7c6aa5205ca1cc11c2", "diff": "diff --git a/tests/frontend_tests.py b/tests/frontend_tests.py\nindex b090aad..33915b1 100644\n--- a/tests/frontend_tests.py\n+++ b/tests/frontend_tests.py\n@@ -63,7 +63,7 @@ def setup():\n \n def teardown():\n     server.stop()\n-    time.sleep(2)\n+    time.sleep(5)\n \n def test_state_no_target():\n     req = api_request('state')\ndiff --git a/tests/gdb_cli_tests.py b/tests/gdb_cli_tests.py\nindex 1177b30..9d69dd4 100644\n--- a/tests/gdb_cli_tests.py\n+++ b/tests/gdb_cli_tests.py\n@@ -48,7 +48,6 @@ def setup():\n def teardown():\n     read_data()\n     p.terminate(True)\n-    time.sleep(3)\n \n def start_debugger(do_break=True):\n     global p, client\n@@ -99,8 +98,6 @@ def test_version():\n \n def test_registers():\n     global registers\n-    restart_debugger()\n-    time.sleep(1)\n     read_data()\n     res = client.perform_request('registers')\n     registers = res.registers\n@@ -109,38 +106,21 @@ def test_registers():\n     assert registers['rip'] != 0\n \n def test_memory():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('memory', address=registers['rip'], length=0x40)\n     assert res.status == 'success'\n     assert len(res.memory) > 0\n \n def test_state_stopped():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('state')\n     assert res.is_success\n     assert res.state == \"stopped\"\n \n-# def test_state_invalid():\n-#     restart_debugger()\n-#     p.sendline(\"continue\")\n-#     read_data()\n-#     time.sleep(1)\n-#     res = client.perform_request('state')\n-#     assert res.is_success\n-#     assert res.state == \"invalid\"\n-\n def test_wait_timeout():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('wait', timeout=2)\n     assert res.is_error\n     assert res.code == 0x1004\n \n def test_targets():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('targets')\n     assert res.is_success\n     assert res.targets[0]['state'] == \"stopped\"\n@@ -149,23 +129,17 @@ def test_targets():\n     assert res.targets[0]['file'].endswith('tests/inferior')\n \n def test_stack():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('stack', length=0x40)\n     assert res.status == 'success'\n     assert len(res.memory) > 0\n \n def test_command():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('command', command=\"info reg\")\n     assert res.status == 'success'\n     assert len(res.output) > 0\n     assert 'rax' in res.output\n \n def test_disassemble():\n-    restart_debugger()\n-    time.sleep(1)\n     res = client.perform_request('disassemble', count=0x20)\n     assert res.status == 'success'\n     assert len(res.disassembly) > 0\n"}
{"repo": "voltron", "commit": "7c9768ea31fd13dc1de782bbfa2b1ac9871b71cb", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex e508aee..d5f2cdc 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -148,7 +148,7 @@ class Server(object):\n             except Exception, e:\n                 msg = \"Exception raised while dispatching request: {}\".format(e)\n                 log.error(msg)\n-                res = APIGenericErrorResponse(message=msg)\n+                res = APIGenericErrorResponse(msg)\n \n         log.debug(\"Response: {}\".format(str(res)))\n \ndiff --git a/voltron/plugins/api/command.py b/voltron/plugins/api/command.py\nindex 5aa6d24..85c9f92 100644\n--- a/voltron/plugins/api/command.py\n+++ b/voltron/plugins/api/command.py\n@@ -32,8 +32,7 @@ class APICommandRequest(APIRequest):\n         except Exception, e:\n             msg = \"Exception executing debugger command: {}\".format(e)\n             log.error(msg)\n-            res = APIGenericErrorResponse()\n-            res.message = msg\n+            res = APIGenericErrorResponse(msg)\n \n         return res\n \ndiff --git a/voltron/plugins/api/dereference.py b/voltron/plugins/api/dereference.py\nindex 7146203..5a5ef5b 100644\n--- a/voltron/plugins/api/dereference.py\n+++ b/voltron/plugins/api/dereference.py\n@@ -33,8 +33,7 @@ class APIDerefRequest(APIRequest):\n         except Exception, e:\n             msg = \"Exception executing debugger command: {}\".format(e)\n             log.error(msg)\n-            res = APIGenericErrorResponse()\n-            res.message = msg\n+            res = APIGenericErrorResponse(msg)\n \n         return res\n \ndiff --git a/voltron/plugins/api/memory.py b/voltron/plugins/api/memory.py\nindex 187d6f9..3747b88 100644\n--- a/voltron/plugins/api/memory.py\n+++ b/voltron/plugins/api/memory.py\n@@ -50,8 +50,7 @@ class APIMemoryRequest(APIRequest):\n         except Exception, e:\n             msg = \"Exception getting memory from debugger: {}\".format(e)\n             log.error(msg)\n-            res = APIGenericErrorResponse()\n-            res.error_message = msg\n+            res = APIGenericErrorResponse(msg)\n \n         return res\n \ndiff --git a/voltron/plugins/api/registers.py b/voltron/plugins/api/registers.py\nindex 74d6ba3..ceca54f 100644\n--- a/voltron/plugins/api/registers.py\n+++ b/voltron/plugins/api/registers.py\n@@ -47,8 +47,7 @@ class APIRegistersRequest(APIRequest):\n         except Exception, e:\n             msg = \"Exception getting registers from debugger: {}\".format(e)\n             log.error(msg)\n-            res = APIGenericErrorResponse()\n-            res.error_message = msg\n+            res = APIGenericErrorResponse(msg)\n \n         return res\n \ndiff --git a/voltron/plugins/api/targets.py b/voltron/plugins/api/targets.py\nindex e87ff61..5be9317 100644\n--- a/voltron/plugins/api/targets.py\n+++ b/voltron/plugins/api/targets.py\n@@ -28,8 +28,7 @@ class APITargetsRequest(APIRequest):\n         except Exception, e:\n             msg = \"Exception getting targets from debugger: {}\".format(e)\n             log.error(msg)\n-            res = APIGenericErrorResponse()\n-            res.error_message = msg\n+            res = APIGenericErrorResponse(msg)\n \n         return res\n \n"}
{"repo": "voltron", "commit": "3bff94cc87ea97cb1e38e2483d0238d7d11ab856", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 26d2575..f39a198 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -42,12 +42,6 @@ try:\n     else:\n         in_vdb = False\n \n-    if sum([1 for c in [in_gdb, in_lldb, in_vdb] if c]) > 1:\n-        print(\"in gdb: %s\" % in_gdb)\n-        print(\"in lldb: %s\" % in_lldb)\n-        print(\"in vdb: %s\" % in_vdb)\n-        raise RuntimeError(\"Too many debugging environments detected!\")\n-\n     voltron.setup_env()\n     log = voltron.setup_logging('debugger')\n \n"}
{"repo": "voltron", "commit": "510be47fa42e4891d9593d8e1b793439023531b9", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 9becad1..26d2575 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -17,6 +17,37 @@ try:\n     except ImportError:\n         in_gdb = False\n \n+    if \"vtrace\" in locals():\n+        in_vdb = True\n+\n+        import os\n+        import sys\n+\n+        def parent_directory(the_path):\n+            return os.path.abspath(os.path.join(the_path, os.pardir))\n+\n+        def add_vdb_to_path(vtrace):\n+            sys.path.append(parent_directory(parent_directory(vtrace.__file__)))\n+\n+        # don't pass over this line!\n+        # in order for the *VDB adaptor plugin* (not this file) to import\n+        #  vdb stuff, the import path must be updated.\n+        # this is it.\n+        #\n+        # since atm vdb imports everything relatively\n+        #   (typically its not installed), then we use this\n+        #   hack to extract the package that's in use.\n+        add_vdb_to_path(vtrace)\n+        import vtrace\n+    else:\n+        in_vdb = False\n+\n+    if sum([1 for c in [in_gdb, in_lldb, in_vdb] if c]) > 1:\n+        print(\"in gdb: %s\" % in_gdb)\n+        print(\"in lldb: %s\" % in_lldb)\n+        print(\"in vdb: %s\" % in_vdb)\n+        raise RuntimeError(\"Too many debugging environments detected!\")\n+\n     voltron.setup_env()\n     log = voltron.setup_logging('debugger')\n \n@@ -181,6 +212,73 @@ try:\n             print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n \n \n+    if in_vdb:\n+        class VoltronVDBCommand(VoltronCommand, vtrace.Notifier):\n+            \"\"\"\n+            Debugger command class for VDB\n+            \"\"\"\n+            def __init__(self, vdb, vtrace):\n+                \"\"\"\n+                vdb is the debugger instance\n+                vtrace is the vtrace module?\n+                \"\"\"\n+                super(VoltronCommand, self).__init__()\n+                self._vdb = vdb\n+                self._vtrace = vtrace\n+\n+                self.pm = PluginManager()\n+\n+                self.adaptor = self.pm.debugger_plugin_for_host('vdb').adaptor_class(self._vdb, self._vtrace)\n+                voltron.debugger = self.adaptor\n+\n+                self.server = Server()\n+                self.server.start()\n+\n+            def invoke(self, arg, from_tty):\n+                self.handle_command(arg)\n+\n+            def register_hooks(self):\n+                self._vdb.registerNotifier(vtrace.NOTIFY_ALL, self)\n+\n+            def unregister_hooks(self):\n+                self._vdb.deregisterNotifier(vtrace.NOTIFY_ALL, self)\n+\n+            def notify(self, event, trace):\n+                if event == self._vtrace.NOTIFY_DETACH:\n+                    self.exit_handler(event)\n+                elif event == self._vtrace.NOTIFY_EXIT:\n+                    self.exit_handler(event)\n+                elif event == self._vtrace.NOTIFY_BREAK:\n+                    self.stop_handler(event)\n+                elif event == self._vtrace.NOTIFY_STEP:\n+                    self.stop_handler(event)\n+                elif event == self._vtrace.NOTIFY_CONTINUE:\n+                    self.cont_handler(event)\n+\n+            def stop_handler(self, event):\n+                self.adaptor.update_state()\n+                log.debug('Inferior stopped')\n+\n+            def exit_handler(self, event):\n+                log.debug('Inferior exited')\n+                self.server.stop()\n+                # vdb doesn't signal STOP/BREAK on exit, so we\n+                #   clear an outstanding Wait requests\n+                self.adaptor.update_state()\n+\n+            def cont_handler(self, event):\n+                log.debug('Inferior continued')\n+\n+\n+        # wb: i have no idea if this __name__ test is actually correct\n+        # but __builtin__ is its value when run from vdbbin\n+        if __name__ == \"__builtin__\":\n+            log.debug('Initialising VDB command')\n+            inst = VoltronVDBCommand(db, vtrace)\n+            inst.register_hooks()\n+            print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n+\n+\n except Exception, e:\n     msg = \"Exception {} raised while loading Voltron: {}\".format(type(e), str(e))\n     if blessed:\ndiff --git a/voltron/lexers.py b/voltron/lexers.py\nindex 3ee0c9d..9eb9445 100644\n--- a/voltron/lexers.py\n+++ b/voltron/lexers.py\n@@ -80,7 +80,91 @@ class LLDBIntelLexer(RegexLexer):\n     }\n \n \n+class VDBIntelLexer(RegexLexer):\n+    \"\"\"\n+    For Nasm (Intel) disassembly from VDB.\n+\n+    Based on the LLDBIntelLexer above.\n+    major difference is the raw instruction hex after the instruction address.\n+\n+    example:\n+      rip     0x000000000056eb4f: 4885ff            test rdi,rdi ;0x7f4f8740ca50,0x7f4f8740ca50\n+              0x000000000056eb52: 740f              jz 0x0056eb63\n+    \"\"\"\n+    name = 'VDBIntel'\n+    aliases = ['vdb_intel']\n+    filenames = []\n+    mimetypes = []\n+\n+    space = r'[ \\t]+'\n+    identifier = r'[<a-z$._?][\\w$.?#@~\\+>]*'\n+    hexn = r'(?:0[xX][0-9a-f]+|$0[0-9a-f]*|[0-9]+[0-9a-f]*h)'  # hex number\n+    hexr = r'(?:[0-9a-f]+)'  # hex raw (no leader/trailer)\n+    octn = r'[0-7]+q'\n+    binn = r'[01]+b'\n+    decn = r'[0-9]+'\n+    floatn = decn + r'\\.e?' + decn\n+    string = r'\"(\\\\\"|[^\"\\n])*\"|' + r\"'(\\\\'|[^'\\n])*'|\" + r\"`(\\\\`|[^`\\n])*`\"\n+    register = (r'r[0-9]+[bwd]{0,1}|'\n+                r'[a-d][lh]|[er]?[a-d]x|[er]?[sbi]p|[er]?[sd]i|[c-gs]s|st[0-7]|'\n+                r'mm[0-7]|cr[0-4]|dr[0-367]|tr[3-7]|.mm\\d*')\n+    wordop = r'seg|wrt|strict'\n+    type = r'byte|[dq]?word|ptr'\n+\n+    flags = re.IGNORECASE | re.MULTILINE\n+    tokens = {\n+        'root': [\n+            (r'^(%s)(%s)(%s)(: )(%s)(%s)' % (register, space, hexn, hexr, space),\n+             bygroups(Name.Builtin, Text, Name.Label, Text, Number.Hex, Text),\n+             \"instruction\"),\n+            (r'^(%s)(%s)(: )(%s)(%s)' % (space, hexn, hexr, space),\n+             bygroups(Text, Name.Label, Text, Number.Hex, Text),\n+             \"instruction\"),\n+         ],\n+        'instruction': [\n+            (space, Text),\n+            (r\"(rep[a-z]*)( )\", bygroups(Name.Function, Text)),\n+            (r\"(%s)\" % identifier, Name.Function, (\"#pop\", \"instruction-args\")),\n+        ],\n+        'instruction-args': [\n+            (space, Text),\n+            (string, String),\n+            (hexn, Number.Hex),\n+            (octn, Number.Oct),\n+            (binn, Number.Bin),\n+            (floatn, Number.Float),\n+            (decn, Number.Integer),\n+            include('punctuation'),\n+            (register, Name.Builtin),\n+            (identifier, Name.Variable),\n+            (r'[\\r\\n]+', Text, '#pop'),\n+            (r';', Text, (\"#pop\", 'comment')),\n+        ],\n+        'comment': [\n+            (space, Text),\n+            (string, Comment.Single),\n+            (hexn, Number.Hex),\n+            (octn, Number.Oct),\n+            (binn, Number.Bin),\n+            (floatn, Number.Float),\n+            (decn, Number.Integer),\n+            include('punctuation'),\n+            (register, Name.Builtin),\n+            (identifier, Name.Variable),\n+            (r'[\\r\\n]+', Text, '#pop'),\n+        ],\n+       'punctuation': [\n+            (r'[,():\\[\\]]+', Punctuation),\n+            (r'[&|^<>+*/%~-]+', Operator),\n+            (r'[$]+', Keyword.Constant),\n+            (wordop, Operator.Word),\n+            (type, Keyword.Type)\n+        ],\n+    }\n+\n+\n all_lexers = {\n     'lldb_intel': LLDBIntelLexer,\n-    'gdb_intel': LLDBIntelLexer\n+    'gdb_intel': LLDBIntelLexer,\n+    'vdb_intel': VDBIntelLexer,\n }\ndiff --git a/voltron/plugins/debugger/dbg_vdb.py b/voltron/plugins/debugger/dbg_vdb.py\nnew file mode 100644\nindex 0000000..cacc214\n--- /dev/null\n+++ b/voltron/plugins/debugger/dbg_vdb.py\n@@ -0,0 +1,473 @@\n+from __future__ import print_function\n+\n+import re\n+import shlex\n+import struct\n+import string\n+import logging\n+import threading\n+\n+from voltron.api import *\n+from voltron.plugin import *\n+from voltron.debugger import *\n+\n+try:\n+    import vdb\n+    import envi\n+    HAVE_VDB = True\n+except ImportError:\n+    HAVE_VDB = False\n+\n+log = logging.getLogger('debugger')\n+\n+if HAVE_VDB:\n+\n+    class NotAStringError(Exception):\n+        pass\n+\n+    class FailedToReadMemoryError(Exception):\n+        pass\n+\n+    class VDBAdaptor(DebuggerAdaptor):\n+        \"\"\"\n+        The interface with an instance of VDB\n+        \"\"\"\n+\n+        archs = {\n+            \"i386\": \"x86\",\n+            \"amd64\": \"x86_64\",\n+            \"arm\": \"arm\",\n+        }\n+\n+        sizes = {\n+            'x86': 4,\n+            'x86_64': 8,\n+            'arm': 4\n+        }\n+\n+        reg_names = {\n+            \"x86_64\": {\n+                \"pc\": \"rip\",\n+                \"sp\": \"rsp\",\n+            },\n+            \"x86\": {\n+                \"pc\": \"eip\",\n+                \"sp\": \"esp\",\n+            }\n+        }\n+\n+        def __init__(self, vdb, vtrace, *args, **kwargs):\n+            self.listeners = []\n+            self.host_lock = threading.RLock()\n+            self._vdb = vdb\n+            self._vtrace = vtrace\n+\n+        def version(self):\n+            \"\"\"\n+            Get the debugger's version.\n+\n+            Returns a string containing the debugger's version\n+            (e.g. 'GNU gdb (GDB) 7.8')\n+            \"\"\"\n+            return \"VDB/version-unknown\"\n+\n+        def _target(self, target_id=0):\n+            \"\"\"\n+            Return information about the specified target.\n+\n+            Returns data in the following structure:\n+            {\n+                \"id\":       0,         # ID that can be used in other funcs\n+                \"file\":     \"/bin/ls\", # target's binary file\n+                \"arch\":     \"x86_64\",  # target's architecture\n+                \"state:     \"stopped\"  # state\n+            }\n+            \"\"\"\n+            d = {}\n+            d[\"id\"] = 0\n+            d[\"state\"] = self._state()\n+            d[\"file\"] = shlex.split(self._vdb.getTrace().getMeta(\"ExecCommand\"))[0]\n+            d[\"arch\"] = self.get_arch()\n+            d['byte_order'] = self.get_byte_order()\n+            d['addr_size'] = self.get_addr_size()\n+            return d\n+\n+        @lock_host\n+        def target(self, target_id=0):\n+            \"\"\"\n+            Return information about the current inferior.\n+\n+            `target_id` is ignored.\n+            \"\"\"\n+            return self._target()\n+\n+        @lock_host\n+        def targets(self, target_ids=None):\n+            \"\"\"\n+            Return information about the debugger's current targets.\n+\n+            `target_ids` is ignored. Only the current target is returned. This\n+            method is only implemented to maintain API compatibility with the\n+            LLDBAdaptor.\n+            \"\"\"\n+            return [self._target()]\n+\n+        @validate_target\n+        @lock_host\n+        def state(self, target_id=0):\n+            \"\"\"\n+            Get the state of a given target.\n+            `target_id` is ignored.\n+            \"\"\"\n+            return self._state()\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def registers(self, target_id=0, thread_id=None, registers=[]):\n+            \"\"\"\n+            Get the register values for a given target/thread.\n+            `target_id` is ignored.\n+            \"\"\"\n+            arch = self.get_arch()\n+\n+            if arch in self.reg_names:\n+                if 'pc' in registers:\n+                    registers.remove('pc')\n+                    registers.append(self.reg_names[arch]['pc'])\n+                if 'sp' in registers:\n+                    registers.remove('sp')\n+                    registers.append(self.reg_names[arch]['sp'])\n+            else:\n+                raise Exception(\"Unsupported architecture: {}\".format(target['arch']))\n+\n+            if registers != []:\n+                regs = {}\n+                for reg in registers:\n+                    regs[reg] = self.get_register(reg)\n+            else:\n+                log.debug('Getting registers for arch {}'.format(arch))\n+                if arch == \"x86_64\":\n+                    regs = self.get_registers_x86_64()\n+                elif arch == \"x86\":\n+                    regs = self.get_registers_x86()\n+                elif arch == \"arm\":\n+                    regs = self.get_registers_arm()\n+                else:\n+                    raise UnknownArchitectureException()\n+\n+            return regs\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def stack_pointer(self, target_id=0, thread_id=None):\n+            \"\"\"\n+            Get the value of the stack pointer register.\n+            `target_id` is ignored.\n+            \"\"\"\n+            arch = self.get_arch()\n+            if arch in self.reg_names:\n+                sp_name = self.reg_names[arch]['sp']\n+                sp = self.get_register(sp_name)\n+            else:\n+                raise UnknownArchitectureException()\n+\n+            return sp_name, sp\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def program_counter(self, target_id=0, thread_id=None):\n+            \"\"\"\n+            Get the value of the program counter register.\n+            `target_id` is ignored.\n+            \"\"\"\n+            arch = self.get_arch()\n+            if arch in self.reg_names:\n+                pc_name = self.reg_names[arch]['pc']\n+                pc = self.get_register(pc_name)\n+            else:\n+                raise UnknownArchitectureException()\n+\n+            return pc_name, pc\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def memory(self, address, length, target_id=0):\n+            \"\"\"\n+            Get the register values for .\n+            Raises `FailedToReadMemoryError` if... that happens.\n+\n+            `address` is the address at which to start reading\n+            `length` is the number of bytes to read\n+            `target_id` is ignored.\n+            \"\"\"\n+            log.debug('Reading 0x{:x} bytes of memory at 0x{:x}'.format(length, address))\n+            t = self._vdb.getTrace()\n+            try:\n+                return t.readMemory(address, length)\n+            except:\n+                raise FailedToReadMemoryError()\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def stack(self, length, target_id=0, thread_id=None):\n+            \"\"\"\n+            Get the register values for .\n+\n+            `length` is the number of bytes to read\n+            `target_id` is a target ID (or None for the first target)\n+            `thread_id` is a thread ID (or None for the selected thread)\n+            \"\"\"\n+            # get the stack pointer\n+            sp_name, sp = self.stack_pointer(target_id=target_id, thread_id=thread_id)\n+\n+            # read memory\n+            memory = self.memory(sp, length, target_id=target_id)\n+\n+            return memory\n+\n+        def _get_n_opcodes_length(self, address, count):\n+            \"\"\"\n+            Get the number of bytes used to represent the `n` instructions\n+              at `address`.\n+\n+            `address` is the starting address of the sequence of instructions.\n+            `count` is the number of instructions to decode.\n+            \"\"\"\n+            length = 0\n+            t = self._vdb.getTrace()\n+            arch = self._vdb.arch.getArchId()\n+            for i in xrange(count):\n+                op = t.parseOpcode(address + length, arch=arch)\n+                length += op.size\n+            return length\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def disassemble(self, target_id=0, address=None, count=16):\n+            \"\"\"\n+            Get a disassembly of the instructions at the given address.\n+\n+            `address` is the address at which to disassemble. If None, the\n+            current program counter is used.\n+            `count` is the number of instructions to disassemble.\n+            \"\"\"\n+            if address == None:\n+                pc_name, address = self.program_counter(target_id=target_id)\n+\n+            length = self._get_n_opcodes_length(address, count)\n+            can = envi.memcanvas.StringMemoryCanvas(self._vdb.memobj, self._vdb.symobj)\n+            can.renderMemory(address, length, self._vdb.opcoderend)\n+            return str(can)\n+\n+        def _get_ascii_string(self, address, min_length=4, max_length=32):\n+            \"\"\"\n+            Get the ASCII string of length at least `min_length`, but\n+             not more than `max_length` of it, or raise\n+             `NotAStringError` if it doesnt look like an ASCII string.\n+            \"\"\"\n+            cs = []\n+            for i in xrange(max_length):\n+                try:\n+                    c = self.memory(address + i, 1)[0]\n+                except FailedToReadMemoryError:\n+                    break\n+                if ord(c) == 0:\n+                    break\n+                elif c not in string.printable:\n+                    break\n+                else:\n+                    cs.append(c)\n+\n+            if len(cs) >= min_length:\n+                return \"\".join(cs)\n+            else:\n+                raise NotAStringError()\n+\n+        def _get_unicode_string(self, address, min_length=4, max_length=32):\n+            \"\"\"\n+            Get the *simple* Unicode string of length at least `min_length`\n+             characters, but not more than `max_length` characters of it,\n+             or raise `NotAStringError` if it doesnt look like a\n+             *simple* Unicode string.\n+\n+            *simple* Unicode is ASCII with interspersed NULLs\n+            \"\"\"\n+            cs = []\n+            for i in xrange(max_length):\n+                try:\n+                    b = self.memory(address + (i * 2), 2)\n+                except FailedToReadMemoryError:\n+                    break\n+\n+                # need every other byte to be a NULL\n+                if ord(b[1]) != 0:\n+                    break\n+\n+                c = b[0]\n+                if ord(c) == 0:\n+                    break\n+                elif c not in string.printable:\n+                    break\n+                else:\n+                    cs.append(c)\n+\n+            if len(cs) >= min_length:\n+                return \"\".join(cs)\n+            else:\n+                raise NotAStringError()\n+\n+\n+        @validate_busy\n+        @validate_target\n+        @lock_host\n+        def dereference(self, pointer, target_id=0):\n+            \"\"\"\n+            Recursively dereference a pointer for display\n+            `target_id` is ignored.\n+            \"\"\"\n+            fmt = ('<' if self.get_byte_order() == 'little' else '>') + {2: 'H', 4: 'L', 8: 'Q'}[self.get_addr_size()]\n+\n+            addr = pointer\n+            chain = []\n+\n+            # recursively dereference\n+            while True:\n+                try:\n+                    mem = self.memory(addr, self.get_addr_size())\n+                except FailedToReadMemoryError:\n+                    break\n+                except Exception as e:\n+                    print(e)\n+                    print(type(e))\n+                    print(e.__class__.__name__)\n+                    break\n+                log.debug(\"read mem: {}\".format(mem))\n+                (ptr,) = struct.unpack(fmt, mem)\n+                if ptr in chain:\n+                    break\n+                chain.append(('pointer', addr))\n+                addr = ptr\n+\n+            # get some info for the last pointer\n+            # first try to resolve a symbol context for the address\n+            p, addr = chain[-1]\n+            output = self._vdb.reprPointer(addr)\n+            if \"Who knows?!?!!?\" not in output:\n+                chain.append(('symbol', output))\n+                log.debug(\"symbol context: {}\".format(str(chain[-1])))\n+            else:\n+                log.debug(\"no symbol context\")\n+                try:\n+                    chain.append((\"string\", self._get_ascii_string(addr)))\n+                except NotAStringError:\n+                    try:\n+                        chain.append((\"string\", self._get_unicode_string(addr)))\n+                    except NotAStringError:\n+                        pass\n+\n+            log.debug(\"chain: {}\".format(chain))\n+            return chain\n+\n+        @lock_host\n+        def command(self, command=None):\n+            \"\"\"\n+            Execute a command in the debugger.\n+\n+            `command` is the command string to execute.\n+            \"\"\"\n+            if command:\n+                # well, this is hacky...\n+                # hook the canvas to capture a command's output\n+                oldcan = self._vdb.canvas\n+                newcan = envi.memcanvas.StringMemoryCanvas(self._vdb.memobj, self._vdb.symobj)\n+                try:\n+                    self._vdb.canvas = newcan\n+                    self._vdb.onecmd(command)\n+                finally:\n+                    self._vdb.canvas = oldcan\n+                return str(newcan).rstrip(\"\\n\")\n+            else:\n+                raise Exception(\"No command specified\")\n+\n+            return res\n+\n+        @lock_host\n+        def disassembly_flavor(self):\n+            \"\"\"\n+            Return the disassembly flavor setting for the debugger.\n+\n+            Returns 'intel' or 'att'\n+            \"\"\"\n+            return \"intel\"\n+\n+        #\n+        # Private functions\n+        #\n+\n+        def _state(self):\n+            \"\"\"\n+            Get the state of a given target. Internal use.\n+            \"\"\"\n+            if not self._vdb.getTrace().isAttached():\n+                state = \"invalid\"\n+            else:\n+                if self._vdb.getTrace().isRunning():\n+                    state = \"running\"\n+                else:\n+                    state = \"stopped\"\n+            return state\n+\n+        def get_registers(self):\n+            return self._vdb.getTrace().getRegisters()\n+\n+        def get_register(self, reg_name):\n+            return self.get_registers()[reg_name]\n+\n+        def get_registers_x86_64(self):\n+            return self.get_registers()\n+\n+        def get_registers_x86(self):\n+            return self.get_registers()\n+\n+        def get_registers_arm(self):\n+            return self.get_registers()\n+\n+        def get_registers_sse(self, num=8):\n+            sse = {}\n+            for k, v in self.get_registers().items():\n+                if k.startswith(\"xmm\"):\n+                    sse[k] = v\n+            return sse\n+\n+        def get_registers_fpu(self):\n+            fpu = {}\n+            for k, v in self.get_registers().items():\n+                if k.startswith(\"st\"):\n+                    fpu[k] = v\n+            return fpu\n+\n+        def get_next_instruction(self):\n+            dis = self.disassemble(address=self.program_counter()[1], count=1)\n+            return dis.partition(\"\\n\")[0].strip()\n+\n+        def get_arch(self):\n+            arch = self._vdb.getTrace().getMeta(\"Architecture\")\n+            return self.archs[arch]\n+\n+        def get_addr_size(self):\n+            arch = self.get_arch()\n+            return self.sizes[arch]\n+\n+        def get_byte_order(self):\n+            return \"little\"\n+\n+\n+    class VDBAdaptorPlugin(DebuggerAdaptorPlugin):\n+        host = 'vdb'\n+        adaptor_class = VDBAdaptor\n"}
{"repo": "voltron", "commit": "22a80b12894a7ffb5aca27ceef96a826d6fd72a8", "diff": "diff --git a/voltron/plugins/view/backtrace.py b/voltron/plugins/view/backtrace.py\nindex a65f4cf..07db3f2 100644\n--- a/voltron/plugins/view/backtrace.py\n+++ b/voltron/plugins/view/backtrace.py\n@@ -8,35 +8,20 @@ log = logging.getLogger('view')\n \n \n class BacktraceView (TerminalView):\n-    view_type = 'bt'\n-\n-    @classmethod\n-    def configure_subparser(cls, subparsers):\n-        sp = subparsers.add_parser('bt', help='backtrace view')\n-        VoltronView.add_generic_arguments(sp)\n-        sp.set_defaults(func=BacktraceView)\n-\n-    def render(self, error=None):\n+    def render(self):\n         height, width = self.window_size()\n \n         # Set up header and error message if applicable\n         self.title = '[backtrace]'\n-        if error != None:\n-            self.body = self.colour(error, 'red')\n+        req = api_request('command')\n+        req.command = \"bt\"\n+        res = self.client.send_request(req)\n+        if res.is_success:\n+            # Get the command output\n+            self.body = res.output\n         else:\n-            req = api_request('command')\n-            req.command = \"bt\"\n-            res = self.client.send_request(req)\n-            if res.is_success:\n-                # Get the command output\n-                self.body = res.output\n-            else:\n-                log.error(\"Error getting backtrace: {}\".format(res.message))\n-                self.body = self.colour(res.message, 'red')\n-\n-        # Pad body\n-        self.truncate_body()\n-        self.pad_body()\n+            log.error(\"Error getting backtrace: {}\".format(res.message))\n+            self.body = self.colour(res.message, 'red')\n \n         # Call parent's render method\n         super(BacktraceView, self).render()\ndiff --git a/voltron/plugins/view/command.py b/voltron/plugins/view/command.py\nindex 98e5a95..f498eac 100644\n--- a/voltron/plugins/view/command.py\n+++ b/voltron/plugins/view/command.py\n@@ -7,11 +7,10 @@ from voltron.api import *\n log = logging.getLogger('view')\n \n class CommandView (TerminalView):\n-    view_type = 'cmd'\n-\n     @classmethod\n     def configure_subparser(cls, subparsers):\n-        sp = subparsers.add_parser('cmd', help='command view - specify a command to be run each time the debugger stops')\n+        sp = subparsers.add_parser('command',\n+                                   help='command view - specify a command to be run each time the debugger stops')\n         VoltronView.add_generic_arguments(sp)\n         sp.add_argument('command', action='store', help='command to run')\n         sp.set_defaults(func=CommandView)\n@@ -19,25 +18,20 @@ class CommandView (TerminalView):\n     def setup(self):\n         self.config['cmd'] = self.args.command\n \n-    def render(self, error=None):\n+    def render(self):\n         # Set up header and error message if applicable\n         self.title = '[cmd:' + self.config['cmd'] + ']'\n-        if error != None:\n-            self.body = self.colour(error, 'red')\n-        else:\n+\n+        # Get the command output\n+        req = api_request('command')\n+        req.command = self.config['cmd']\n+        res = self.client.send_request(req)\n+        if res.is_success:\n             # Get the command output\n-            req = api_request('command')\n-            req.command = self.config['cmd']\n-            res = self.client.send_request(req)\n-            if res.is_success:\n-                # Get the command output\n-                self.body = res.output\n-            else:\n-                log.error(\"Error executing command: {}\".format(res.message))\n-                self.body = self.colour(res.message, 'red')\n-\n-        self.truncate_body()\n-        self.pad_body()\n+            self.body = res.output\n+        else:\n+            log.error(\"Error executing command: {}\".format(res.message))\n+            self.body = self.colour(res.message, 'red')\n \n         # Call parent's render method\n         super(CommandView, self).render()\ndiff --git a/voltron/plugins/view/disasm.py b/voltron/plugins/view/disasm.py\nindex b454889..d65561d 100644\n--- a/voltron/plugins/view/disasm.py\n+++ b/voltron/plugins/view/disasm.py\n@@ -4,47 +4,34 @@ from voltron.api import *\n from voltron.lexers import *\n \n class DisasmView (TerminalView):\n-    view_type = 'disasm'\n-\n-    @classmethod\n-    def configure_subparser(cls, subparsers):\n-        sp = subparsers.add_parser('disasm', help='disassembly view')\n-        VoltronView.add_generic_arguments(sp)\n-        sp.set_defaults(func=DisasmView)\n-\n-    def render(self, error=None):\n+    def render(self):\n         height, width = self.window_size()\n \n         # Set up header & error message if applicable\n         self.title = '[code]'\n-        if error != None:\n-            self.body = self.colour(error, 'red')\n+\n+        # Request data\n+        req = api_request('disassemble')\n+        req.count = self.body_height()\n+        res = self.client.send_request(req)\n+        if res.is_success:\n+            # Get the disasm\n+            disasm = res.disassembly\n+            disasm = '\\n'.join(disasm.split('\\n')[:self.body_height()])\n+\n+            # Pygmentize output\n+            if have_pygments:\n+                try:\n+                    lexer = all_lexers['{}_{}'.format(res.host, res.flavor)]()\n+                    disasm = pygments.highlight(disasm, lexer, pygments.formatters.TerminalFormatter())\n+                except Exception as e:\n+                    log.warning('Failed to highlight disasm: ' + str(e))\n+\n+            # Build output\n+            self.body = disasm.rstrip()\n         else:\n-            # Request data\n-            req = api_request('disassemble')\n-            req.count = self.body_height()\n-            res = self.client.send_request(req)\n-            if res.is_success:\n-                # Get the disasm\n-                disasm = res.disassembly\n-                disasm = '\\n'.join(disasm.split('\\n')[:self.body_height()])\n-\n-                # Pygmentize output\n-                if have_pygments:\n-                    try:\n-                        lexer = all_lexers['{}_{}'.format(res.host, res.flavor)]()\n-                        disasm = pygments.highlight(disasm, lexer, pygments.formatters.TerminalFormatter())\n-                    except Exception as e:\n-                        log.warning('Failed to highlight disasm: ' + str(e))\n-\n-                # Build output\n-                self.body = disasm.rstrip()\n-            else:\n-                log.error(\"Error disassembling: {}\".format(res.message))\n-                self.body = self.colour(res.message, 'red')\n-\n-        self.truncate_body()\n-        self.pad_body()\n+            log.error(\"Error disassembling: {}\".format(res.message))\n+            self.body = self.colour(res.message, 'red')\n \n         # Call parent's render method\n         super(DisasmView, self).render()\n@@ -52,5 +39,5 @@ class DisasmView (TerminalView):\n \n class DisasmViewPlugin(ViewPlugin):\n     plugin_type = 'view'\n-    name = 'disassemble'\n+    name = 'disassembly'\n     view_class = DisasmView\ndiff --git a/voltron/plugins/view/memory.py b/voltron/plugins/view/memory.py\nindex 613a5c4..3a598fa 100644\n--- a/voltron/plugins/view/memory.py\n+++ b/voltron/plugins/view/memory.py\n@@ -8,7 +8,6 @@ from voltron.api import *\n log = logging.getLogger(\"view\")\n \n class MemoryView (TerminalView):\n-    view_type = 'memory'\n     printable_filter = ''.join([(len(repr(chr(x))) == 3) and chr(x) or '.' for x in range(256)])\n \n     @classmethod\n@@ -29,7 +28,7 @@ class MemoryView (TerminalView):\n         group.add_argument('--register', '-r', action='store', help='register containing the address from which to start reading memory', default=None)\n         sp.set_defaults(func=MemoryView)\n \n-    def render(self, error=None):\n+    def render(self):\n         height, width = self.window_size()\n \n         # get info about target\n@@ -44,70 +43,64 @@ class MemoryView (TerminalView):\n         if not self.title:\n             self.title = \"[memory]\"\n \n-        if error != None:\n-            self.body = self.colour(error, 'red')\n-        else:\n-            # find the address we're reading memory from\n-            addr = None\n-            if self.args.command:\n-                res = self.client.perform_request('command', command=self.args.command)\n-                if res.is_success:\n-                    for item in reversed(res.output.split()):\n-                        log.debug(\"checking item: {}\".format(item))\n+        # find the address we're reading memory from\n+        addr = None\n+        if self.args.command:\n+            res = self.client.perform_request('command', command=self.args.command)\n+            if res.is_success:\n+                for item in reversed(res.output.split()):\n+                    log.debug(\"checking item: {}\".format(item))\n+                    try:\n+                        addr = int(item)\n+                        break\n+                    except:\n                         try:\n-                            addr = int(item)\n+                            addr = int(item, 16)\n                             break\n                         except:\n-                            try:\n-                                addr = int(item, 16)\n-                                break\n-                            except:\n-                                pass\n-            elif self.args.address:\n-                addr = int(self.args.address, 16)\n-            elif self.args.register:\n-                res = self.client.perform_request('registers', registers=[self.args.register])\n-                if res.is_success:\n-                    addr = res.registers.values()[0]\n-\n-            # read memory\n-            if addr != None:\n-                res = self.client.perform_request('memory', address=addr, length=self.body_height()*self.args.bytes)\n-                if res.is_success:\n-\n-                    lines = []\n-                    for c in range(0, res.bytes, self.args.bytes):\n-                        chunk = res.memory[c:c+self.args.bytes]\n-                        addr_str = self.colour(self.format_address(addr + c, size=target['addr_size'], pad=False), self.config['format']['addr_colour'])\n-                        if self.args.deref:\n-                            fmt = ('<' if target['byte_order'] == 'little' else '>') + \\\n-                                    {2: 'H', 4: 'L', 8: 'Q'}[target['addr_size']]\n-                            pointer = list(struct.unpack(fmt, chunk))[0]\n-                            memory_str = ' '.join([\"%02X\" % ord(x) for x in chunk])\n-                            deref_res = self.client.perform_request('dereference', pointer=pointer)\n-                            if deref_res.is_success:\n-                                info_str = self.format_deref(deref_res.output)\n-                            else:\n-                                info_str = ''\n+                            pass\n+        elif self.args.address:\n+            addr = int(self.args.address, 16)\n+        elif self.args.register:\n+            res = self.client.perform_request('registers', registers=[self.args.register])\n+            if res.is_success:\n+                addr = res.registers.values()[0]\n+\n+        # read memory\n+        if addr != None:\n+            res = self.client.perform_request('memory', address=addr, length=self.body_height()*self.args.bytes)\n+            if res.is_success:\n+\n+                lines = []\n+                for c in range(0, res.bytes, self.args.bytes):\n+                    chunk = res.memory[c:c+self.args.bytes]\n+                    addr_str = self.colour(self.format_address(addr + c, size=target['addr_size'], pad=False), self.config['format']['addr_colour'])\n+                    if self.args.deref:\n+                        fmt = ('<' if target['byte_order'] == 'little' else '>') + \\\n+                                {2: 'H', 4: 'L', 8: 'Q'}[target['addr_size']]\n+                        pointer = list(struct.unpack(fmt, chunk))[0]\n+                        memory_str = ' '.join([\"%02X\" % ord(x) for x in chunk])\n+                        deref_res = self.client.perform_request('dereference', pointer=pointer)\n+                        if deref_res.is_success:\n+                            info_str = self.format_deref(deref_res.output)\n                         else:\n-                            memory_str = ' '.join([\"%02X\" % ord(x) for x in chunk])\n                             info_str = ''\n-                        ascii_str = ''.join([\"%s\" % ((ord(x) <= 127 and self.printable_filter[ord(x)]) or '.') for x in chunk])\n-                        divider = self.colour('|', self.config['format']['divider_colour'])\n-                        lines.append('{}: {} {} {} {} {}'.format(addr_str, memory_str, divider, ascii_str, divider, info_str))\n-\n-                    self.body = '\\n'.join(reversed(lines)).strip() if self.args.reverse else '\\n'.join(lines)\n-                    self.info = '[0x{0:0=4x}:'.format(len(res.memory)) + self.config['format']['addr_format'].format(addr) + ']'\n-                else:\n-                    log.error(\"Error reading memory: {}\".format(res.message))\n-                    self.body = self.colour(res.message, 'red')\n-                    self.info = '[0x{0:0=4x}:'.format(0) + self.config['format']['addr_format'].format(addr) + ']'\n+                    else:\n+                        memory_str = ' '.join([\"%02X\" % ord(x) for x in chunk])\n+                        info_str = ''\n+                    ascii_str = ''.join([\"%s\" % ((ord(x) <= 127 and self.printable_filter[ord(x)]) or '.') for x in chunk])\n+                    divider = self.colour('|', self.config['format']['divider_colour'])\n+                    lines.append('{}: {} {} {} {} {}'.format(addr_str, memory_str, divider, ascii_str, divider, info_str))\n+\n+                self.body = '\\n'.join(reversed(lines)).strip() if self.args.reverse else '\\n'.join(lines)\n+                self.info = '[0x{0:0=4x}:'.format(len(res.memory)) + self.config['format']['addr_format'].format(addr) + ']'\n             else:\n-                self.body = \"\"\n-                self.info = \"[no address]\"\n-\n-        self.truncate_body()\n-        self.pad_body()\n+                log.error(\"Error reading memory: {}\".format(res.message))\n+                self.body = self.colour(res.message, 'red')\n+                self.info = '[0x{0:0=4x}:'.format(0) + self.config['format']['addr_format'].format(addr) + ']'\n+        else:\n+            self.body = \"\"\n+            self.info = \"[no address]\"\n \n         super(MemoryView, self).render()\n \n@@ -140,15 +133,13 @@ class MemoryViewPlugin(ViewPlugin):\n \n \n class StackView(MemoryView):\n-    view_type = 'stack'\n-\n     @classmethod\n     def configure_subparser(cls, subparsers):\n         sp = subparsers.add_parser('stack', help='stack view')\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=StackView)\n \n-    def render(self, error=None):\n+    def render(self):\n         self.args.reverse = True\n         self.args.deref = True\n         self.args.register = 'sp'\n@@ -158,7 +149,7 @@ class StackView(MemoryView):\n \n         self.title = '[stack]'\n \n-        super(StackView, self).render(error=error)\n+        super(StackView, self).render()\n \n \n class StackViewPlugin(ViewPlugin):\ndiff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex e28c90c..78c7c64 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -3,9 +3,7 @@ from voltron.plugin import *\n from voltron.api import *\n \n \n-# Class to actually render the view\n class RegisterView (TerminalView):\n-    view_type = 'register'\n     FORMAT_INFO = {\n         'x86_64': [\n             {\n@@ -235,7 +233,7 @@ class RegisterView (TerminalView):\n \n     @classmethod\n     def configure_subparser(cls, subparsers):\n-        sp = subparsers.add_parser('reg', help='register view')\n+        sp = subparsers.add_parser('register', help='register view')\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=RegisterView)\n         g = sp.add_mutually_exclusive_group()\n@@ -259,7 +257,9 @@ class RegisterView (TerminalView):\n                 if sec not in self.config['sections']:\n                     self.config['sections'].append(sec)\n \n-    def render(self, error=None):\n+    def render(self):\n+        error = None\n+\n         # get target info (ie. arch)\n         res = self.client.perform_request('targets')\n         if res.is_error:\n@@ -355,9 +355,6 @@ class RegisterView (TerminalView):\n         if len(self.title) > width:\n             self.title = '[regs]'\n \n-        # Pad the body\n-        self.pad_body()\n-\n         # Call parent's render method\n         super(RegisterView, self).render()\n \ndiff --git a/voltron/view.py b/voltron/view.py\nindex 970c1d7..2fde0ab 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -162,23 +162,21 @@ class VoltronView (object):\n         os.system('clear')\n         try:\n             while True:\n-                # Connect to server\n                 try:\n+                    # Connect to server\n                     self.client.connect()\n-                    self.connected = True\n-                except socket.error, e:\n-                    self.connected = False\n \n-                if self.connected:\n-                    # if this is the first iteration, or we got a valid response on the last iteration, render\n+                    # If this is the first iteration (ie. we were just launched and the debugger is already stopped),\n+                    # or we got a valid response on the last iteration, render\n                     if res == None or hasattr(res, 'state') and res.state == 'stopped':\n                         self.render()\n \n                     # wait for the debugger to stop again\n                     wait_req = api_request('wait')\n                     res = self.client.send_request(wait_req)\n-                else:\n-                    # if we're not connected, try again in a second\n+                except socket.error, e:\n+                    # if we're not connected, render an error and try again in a second\n+                    self.do_render(error='Error connecting to server: {}'.format(e.strerror))\n                     time.sleep(1)\n         except SocketDisconnected as e:\n             if self.should_reconnect():\n@@ -187,9 +185,12 @@ class VoltronView (object):\n             else:\n                 raise\n \n-    def render(self, error=None):\n+    def render(self):\n         log.warning('Might wanna implement render() in this view eh')\n \n+    def do_render(error=None):\n+        pass\n+\n     def should_reconnect(self):\n         try:\n             return self.loaded_config['view']['reconnect']\n@@ -213,8 +214,22 @@ class TerminalView (VoltronView):\n     def clear(self):\n         os.system('clear')\n \n-    def render(self, msg=None):\n+    def render(self):\n+        self.do_render()\n+\n+    def do_render(self, error=None):\n+        # Clear the screen\n         self.clear()\n+\n+        # If we got an error, we'll use that as the body\n+        if error:\n+            self.body = self.colour(error, 'red')\n+\n+        # Pad and truncate the body\n+        self.pad_body()\n+        self.truncate_body()\n+\n+        # Print the header, body and footer\n         if self.config['header']['show']:\n             print(self.format_header())\n         print(self.body, end='')\n"}
{"repo": "voltron", "commit": "4fec12314ff76a289bf98213f729afbf7d2e0918", "diff": "diff --git a/voltron/main.py b/voltron/main.py\nindex 40d411d..a1113bc 100644\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -37,7 +37,8 @@ def main(debugger=None):\n     # Parse args\n     args = parser.parse_args()\n     if args.debug:\n-        log.setLevel(logging.DEBUG)\n+        voltron.config['general']['debug_logging'] = True\n+        voltron.setup_logging('main')\n \n     # Instantiate and run the appropriate module\n     inst = args.func(args, loaded_config=voltron.config)\n"}
{"repo": "voltron", "commit": "2b6f2704c2de4b93a5de91f32bc43ee0d15de6f5", "diff": "diff --git a/voltron/plugins/debugger/dbg_gdb.py b/voltron/plugins/debugger/dbg_gdb.py\nindex 67c5fd9..61e29e8 100644\n--- a/voltron/plugins/debugger/dbg_gdb.py\n+++ b/voltron/plugins/debugger/dbg_gdb.py\n@@ -221,7 +221,7 @@ if HAVE_GDB:\n             `thread_id` is a thread ID (or None for the selected thread)\n             \"\"\"\n             # get the stack pointer\n-            sp = self.stack_pointer(target_id=target_id, thread_id=thread_id)\n+            sp_name, sp = self.stack_pointer(target_id=target_id, thread_id=thread_id)\n \n             # read memory\n             memory = self.memory(sp, length, target_id=target_id)\n"}
{"repo": "voltron", "commit": "1032142f337fa3ad7264b4fb42aea85029094257", "diff": "diff --git a/voltron/api.py b/voltron/api.py\nindex 208553a..7b88f32 100644\n--- a/voltron/api.py\n+++ b/voltron/api.py\n@@ -250,6 +250,13 @@ class APIResponse(APIMessage):\n     def is_error(self):\n         return self.status == 'error'\n \n+    def __repr__(self):\n+        return \"<%s: success = %s, error = %s, body: %s>\" % (\n+                str(self.__class__),\n+                self.is_success,\n+                self.is_error,\n+                {f: getattr(self, f) for f in self._top_fields + self._fields.keys()}\n+        )\n \n class APISuccessResponse(APIResponse):\n     \"\"\"\n@@ -314,4 +321,4 @@ class APITargetBusyErrorResponse(APIErrorResponse):\n \n class APIMissingFieldErrorResponse(APIGenericErrorResponse):\n     code = 0x1007\n-    message = \"Missing field\"\n\\ No newline at end of file\n+    message = \"Missing field\"\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 4b48c4b..6fdd8e3 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -48,6 +48,18 @@ if HAVE_LLDB:\n         def host(self, value):\n             self._host = value\n \n+        def normalize_triple(self, triple):\n+            \"\"\"\n+            Returns a (cpu, platform, abi) triple\n+\n+            Returns None for any fields that can't be elided\n+            \"\"\"\n+\n+            arch, platform, abi = triple.split(\"-\")\n+            if arch == \"x86_64h\":\n+                arch = \"x86_64\"\n+            return (arch, platform, abi)\n+\n         def version(self):\n             \"\"\"\n             Get the debugger's version.\n@@ -78,7 +90,7 @@ if HAVE_LLDB:\n             d[\"state\"] = self.host.StateAsCString(t.process.GetState())\n             d[\"file\"] = t.GetExecutable().fullpath\n             try:\n-                d[\"arch\"] = t.triple.split('-')[0]\n+                d[\"arch\"], _, _ = self.normalize_triple(t.triple)\n             except:\n                 d[\"arch\"] = None\n             d[\"byte_order\"] = 'little' if t.byte_order == lldb.eByteOrderLittle else 'big'\ndiff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 82455f6..b73bd05 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -2,6 +2,7 @@ from voltron.view import *\n from voltron.plugin import *\n from voltron.api import *\n \n+\n # Class to actually render the view\n class RegisterView (TerminalView):\n     view_type = 'register'\n@@ -488,7 +489,7 @@ class RegisterView (TerminalView):\n                 j = (False, '!s')\n \n         # Construct message\n-        if j != None:\n+        if j is not None:\n             taken, reason = j\n             if taken:\n                 jump = 'Jump ({})'.format(reason)\n@@ -503,7 +504,7 @@ class RegisterView (TerminalView):\n         jump = t.format(jump)\n \n         # Colour\n-        if j != None:\n+        if j is not None:\n             jump = self.colour(jump, self.config['format']['value_colour_mod'])\n         else:\n             jump = self.colour(jump, self.config['format']['value_colour'])\n@@ -516,7 +517,7 @@ class RegisterView (TerminalView):\n             if width < len(SHORT_ADDR_FORMAT_128.format(0)) + self.XMM_INDENT:\n                 return val[:16] + '\\n' + ' '*self.XMM_INDENT + val[16:]\n             else:\n-                return val[:16] +  ':' + val[16:]\n+                return val[:16] + ':' + val[16:]\n         else:\n             return val\n \n"}
{"repo": "voltron", "commit": "dc7d52c85549b6e5a56abb7c15a29088cb4341d0", "diff": "diff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 82455f6..b73bd05 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -2,6 +2,7 @@ from voltron.view import *\n from voltron.plugin import *\n from voltron.api import *\n \n+\n # Class to actually render the view\n class RegisterView (TerminalView):\n     view_type = 'register'\n@@ -488,7 +489,7 @@ class RegisterView (TerminalView):\n                 j = (False, '!s')\n \n         # Construct message\n-        if j != None:\n+        if j is not None:\n             taken, reason = j\n             if taken:\n                 jump = 'Jump ({})'.format(reason)\n@@ -503,7 +504,7 @@ class RegisterView (TerminalView):\n         jump = t.format(jump)\n \n         # Colour\n-        if j != None:\n+        if j is not None:\n             jump = self.colour(jump, self.config['format']['value_colour_mod'])\n         else:\n             jump = self.colour(jump, self.config['format']['value_colour'])\n@@ -516,7 +517,7 @@ class RegisterView (TerminalView):\n             if width < len(SHORT_ADDR_FORMAT_128.format(0)) + self.XMM_INDENT:\n                 return val[:16] + '\\n' + ' '*self.XMM_INDENT + val[16:]\n             else:\n-                return val[:16] +  ':' + val[16:]\n+                return val[:16] + ':' + val[16:]\n         else:\n             return val\n \n"}
{"repo": "voltron", "commit": "4ed3ef398c59bc2b39b04696c94d9c969548ab22", "diff": "diff --git a/voltron/api.py b/voltron/api.py\nindex 208553a..7b88f32 100644\n--- a/voltron/api.py\n+++ b/voltron/api.py\n@@ -250,6 +250,13 @@ class APIResponse(APIMessage):\n     def is_error(self):\n         return self.status == 'error'\n \n+    def __repr__(self):\n+        return \"<%s: success = %s, error = %s, body: %s>\" % (\n+                str(self.__class__),\n+                self.is_success,\n+                self.is_error,\n+                {f: getattr(self, f) for f in self._top_fields + self._fields.keys()}\n+        )\n \n class APISuccessResponse(APIResponse):\n     \"\"\"\n@@ -314,4 +321,4 @@ class APITargetBusyErrorResponse(APIErrorResponse):\n \n class APIMissingFieldErrorResponse(APIGenericErrorResponse):\n     code = 0x1007\n-    message = \"Missing field\"\n\\ No newline at end of file\n+    message = \"Missing field\"\n"}
{"repo": "voltron", "commit": "3ad113c3a9116347b19c5d92f947e45030c4fe6f", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 037bbdd..9becad1 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -1,5 +1,6 @@\n try:\n     import logging\n+    blessed = None\n     import blessed\n \n     import voltron\n@@ -181,4 +182,7 @@ try:\n \n \n except Exception, e:\n-    print(blessed.Terminal().bold_red(\"Exception {} raised while loading Voltron: {}\".format(type(e), str(e))))\n+    msg = \"Exception {} raised while loading Voltron: {}\".format(type(e), str(e))\n+    if blessed:\n+        msg = blessed.Terminal().bold_red(msg)\n+    print(msg)\n"}
{"repo": "voltron", "commit": "405207d8ebd7810025ce27cfe54a1374332b4d52", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex ef35833..037bbdd 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -19,8 +19,6 @@ try:\n     voltron.setup_env()\n     log = voltron.setup_logging('debugger')\n \n-    cmd = None\n-\n     class VoltronCommand (object):\n         \"\"\"\n         Parent class for common methods across all debugger hosts.\n@@ -113,23 +111,21 @@ try:\n                 cmd = 'target stop-hook delete {}'.format(self.hook_idx if self.hook_idx else '')\n                 self.debugger.HandleCommand(cmd)\n \n-        def __lldb_init_module(debugger, dict):\n+        def __lldb_init_module(debugger, env_dict):\n             \"\"\"\n             Called by LLDB when the module is loaded\n             \"\"\"\n-            global cmd\n-            if not voltron.loaded:\n+            if not 'cmd' in env_dict:\n                 log.debug(\"Initialising LLDB command\")\n-                cmd = VoltronLLDBCommand(debugger, dict)\n+                env_dict['cmd'] = VoltronLLDBCommand(debugger, env_dict)\n                 print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n                 print(\"Run `voltron init` after you load a target.\")\n-                voltron.loaded = True\n \n-        def lldb_invoke(debugger, command, result, dict):\n+        def lldb_invoke(debugger, command, result, env_dict):\n             \"\"\"\n             Called when the voltron command is invoked within LLDB\n             \"\"\"\n-            cmd.invoke(debugger, command, result, dict)\n+            env_dict['cmd'].invoke(debugger, command, result, env_dict)\n \n \n     if in_gdb:\n"}
{"repo": "voltron", "commit": "c6a66406ea436c5c359de0c70ca0d255d516f780", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex 3741a8b..4b48c4b 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -348,7 +348,7 @@ if HAVE_LLDB:\n                 log.debug(\"no symbol context\")\n                 s = t.process.ReadCStringFromMemory(addr, 256, error)\n                 for i in range(0, len(s)):\n-                    if ord(s[i] >= 128):\n+                    if ord(s[i]) >= 128:\n                         s = s[:i]\n                         break\n                 if len(s):\n"}
{"repo": "voltron", "commit": "f4a7cdf3dfa3b66f1dd4491732f9828d9d10a0c4", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 36bed8f..d49536d 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -307,7 +307,6 @@ class TerminalView (VoltronView):\n         for line in self.body.split('\\n'):\n             s = AnsiString(line)\n             if len(s) > width:\n-                print(\"trimming line to {}\".format(width-1))\n                 line = s[:width-1] + self.colour('>', 'red')\n             lines.append(line)\n \n"}
{"repo": "voltron", "commit": "0cad3e57cbb84baba510ce85489fd66a5721b58a", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 55c3892..ef35833 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -118,10 +118,12 @@ try:\n             Called by LLDB when the module is loaded\n             \"\"\"\n             global cmd\n-            log.debug(\"Initialising LLDB command\")\n-            cmd = VoltronLLDBCommand(debugger, dict)\n-            print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n-            print(\"Run `voltron init` after you load a target.\")\n+            if not voltron.loaded:\n+                log.debug(\"Initialising LLDB command\")\n+                cmd = VoltronLLDBCommand(debugger, dict)\n+                print(blessed.Terminal().bold_red(\"Voltron loaded.\"))\n+                print(\"Run `voltron init` after you load a target.\")\n+                voltron.loaded = True\n \n         def lldb_invoke(debugger, command, result, dict):\n             \"\"\"\ndiff --git a/voltron/__init__.py b/voltron/__init__.py\nindex d7dc467..0615f1d 100644\n--- a/voltron/__init__.py\n+++ b/voltron/__init__.py\n@@ -16,6 +16,8 @@ config = None\n # reference to debugger adaptor\n debugger = None\n \n+loaded = False\n+\n def setup_env():\n     global env, config\n     env = Environment({\n"}
{"repo": "voltron", "commit": "f0c1a2f5fd17fc4acbdb7bc5f0fddbf9ca7563e0", "diff": "diff --git a/voltron/main.py b/voltron/main.py\nindex a0820df..14aad45 100644\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -49,9 +49,10 @@ def main(debugger=None):\n     except Exception as e:\n         log.error(\"Exception running module {}: {}\".format(inst.__class__.__name__, traceback.format_exc()))\n     except KeyboardInterrupt:\n-        pass\n+        suppress_exit_log = True\n     inst.cleanup()\n-    log.info('Exiting')\n+    if not suppress_exit_log:\n+        log.info('Exiting')\n \n \n if __name__ == \"__main__\":\n"}
{"repo": "voltron", "commit": "d0b32cbf2a74a9b07f2c3cb737e603ea03894c61", "diff": "diff --git a/voltron/cmd.py b/voltron/cmd.py\nindex 7f5e60a..826ea42 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -40,8 +40,7 @@ class VoltronCommand (object):\n     def start(self):\n         if not self.running:\n             print(\"Starting voltron\")\n-            self.running = True\n-            self.register_hooks()\n+            self.running = self.register_hooks() is not False\n         else:\n             print(\"Already running\")\n \ndiff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex 87bf8ca..c832821 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -30,7 +30,13 @@ class VoltronLLDBCommand (VoltronCommand):\n         super(VoltronLLDBCommand, self).start()\n \n     def register_hooks(self):\n-        lldb.debugger.HandleCommand('target stop-hook add -o \\'voltron update\\'')\n+        cro = lldb.SBCommandReturnObject()\n+        ci = lldb.debugger.GetCommandInterpreter()\n+        ci.HandleCommand('target stop-hook add -o \\'voltron update\\'', cro)\n+        ret = cro.Succeeded()\n+        if not ret:\n+            print(cro.GetError())\n+        return ret\n \n     def unregister_hooks(self):\n         # XXX: Fix this so it only removes our stop-hook\n"}
{"repo": "voltron", "commit": "a2971eb3d2e69f09bd2f46c059c41c1aa4ec4ff5", "diff": "diff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex b280535..7c55135 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -356,6 +356,26 @@ if HAVE_LLDB:\n             else:\n                 raise Exception(\"No command specified\")\n \n+        @lock_host\n+        def disassembly_flavor(self):\n+            \"\"\"\n+            Return the disassembly flavor setting for the debugger.\n+\n+            Returns 'intel' or 'att'\n+            \"\"\"\n+            res = lldb.SBCommandReturnObject()\n+            ci = self.host.GetCommandInterpreter()\n+            ci.HandleCommand('settings show target.x86-disassembly-flavor', res)\n+            if res.Succeeded():\n+                output = res.GetOutput().strip()\n+                flavor = output.split()[-1]\n+                if flavor == 'default':\n+                    flavor = 'att'\n+            else:\n+                raise Exception(res.GetError().strip())\n+\n+            return flavor\n+\n         #\n         # Other methods\n         #\n@@ -385,7 +405,6 @@ if HAVE_LLDB:\n                 listener['callback']()\n \n \n-\n     class LLDBAdaptorPlugin(DebuggerAdaptorPlugin):\n         host = 'lldb'\n         adaptor_class = LLDBAdaptor\n\\ No newline at end of file\n"}
{"repo": "voltron", "commit": "a1ddae69c52b8a43bbaa52f0a31cf42db7133318", "diff": "diff --git a/voltron/plugins/api/disassemble.py b/voltron/plugins/api/disassemble.py\nindex f3c3c6d..8ad7acb 100644\n--- a/voltron/plugins/api/disassemble.py\n+++ b/voltron/plugins/api/disassemble.py\n@@ -42,6 +42,8 @@ class APIDisassembleRequest(APIRequest):\n             disasm = voltron.debugger.disassemble(target_id=self.target_id, address=self.address, count=self.count)\n             res = APIDisassembleResponse()\n             res.disassembly = disasm\n+            res.flavor = voltron.debugger.disassembly_flavor()\n+            res.host = voltron.debugger._plugin.host\n         except NoSuchTargetException:\n             res = APINoSuchTargetErrorResponse()\n         except TargetBusyException:\n@@ -66,9 +68,10 @@ class APIDisassembleResponse(APISuccessResponse):\n         }\n     }\n     \"\"\"\n-    _fields = {'disassembly': True}\n+    _fields = {'disassembly': True, 'formatted': False, 'flavor': False, 'host': False}\n \n     disassembly = None\n+    formatted = None\n \n \n class APIDisassemblePlugin(APIPlugin):\n"}
{"repo": "voltron", "commit": "00c29145f0e9244e035563d2ccd1f985245dfaef", "diff": "diff --git a/voltron/plugin.py b/voltron/plugin.py\nindex 0c3053b..4f39f2f 100644\n--- a/voltron/plugin.py\n+++ b/voltron/plugin.py\n@@ -65,7 +65,9 @@ class PluginManager(object):\n             self._api_plugins[plugin.request] = p\n         elif self.valid_debugger_plugin(plugin):\n             log.debug(\"Registering debugger plugin: {}\".format(plugin))\n-            self._debugger_plugins[plugin.host] = plugin()\n+            p = plugin()\n+            p.adaptor_class._plugin = plugin\n+            self._debugger_plugins[plugin.host] = p\n         elif self.valid_view_plugin(plugin):\n             log.debug(\"Registering view plugin: {}\".format(plugin))\n             self._view_plugins[plugin.name] = plugin()\n"}
{"repo": "voltron", "commit": "17948858124cd26d411be3b3605d92170213993d", "diff": "diff --git a/tests/frontend_tests.py b/tests/frontend_tests.py\nindex 1d1235a..df4c0e5 100644\n--- a/tests/frontend_tests.py\n+++ b/tests/frontend_tests.py\n@@ -46,7 +46,7 @@ def setup():\n     voltron.debugger = adaptor\n \n     # start up a voltron server\n-    server = Server(plugin_mgr=pm, debugger=adaptor)\n+    server = Server()\n     server.start()\n \n     time.sleep(0.1)\ndiff --git a/tests/http_api_tests.py b/tests/http_api_tests.py\nindex 0ca58c2..324867b 100644\n--- a/tests/http_api_tests.py\n+++ b/tests/http_api_tests.py\n@@ -43,6 +43,8 @@ class APIHostNotSupportedPlugin(APIPlugin):\n def setup():\n     global server, client, target, pm, adaptor, methods\n \n+    time.sleep(1)\n+\n     log.info(\"setting up API tests\")\n \n     # set up voltron\n@@ -56,7 +58,7 @@ def setup():\n     inject_mock(adaptor)\n \n     # start up a voltron server\n-    server = Server(plugin_mgr=pm, debugger=adaptor)\n+    server = Server()\n     server.start()\n \n def teardown():\ndiff --git a/tests/socket_api_tests.py b/tests/socket_api_tests.py\nindex 16684a4..ccdfe16 100644\n--- a/tests/socket_api_tests.py\n+++ b/tests/socket_api_tests.py\n@@ -58,7 +58,7 @@ def setup():\n     inject_mock(adaptor)\n \n     # start up a voltron server\n-    server = Server(plugin_mgr=pm, debugger=adaptor)\n+    server = Server()\n     server.start()\n \n     time.sleep(0.1)\n"}
{"repo": "voltron", "commit": "9a7cf3ec8ee7a6fdb319782eebc1a4c9668da3fe", "diff": "diff --git a/voltron/debugger.py b/voltron/debugger.py\nnew file mode 100644\nindex 0000000..3adfc7d\n--- /dev/null\n+++ b/voltron/debugger.py\n@@ -0,0 +1,116 @@\n+from voltron.api import *\n+from voltron.plugin import *\n+\n+def validate_target(func, *args, **kwargs):\n+    \"\"\"\n+    A decorator that ensures that the specified target_id exists and\n+    is valid.\n+\n+    Expects the target ID to be either the 'target_id' param in kwargs,\n+    or the first positional parameter.\n+\n+    Raises a NoSuchTargetException if the target does not exist.\n+    \"\"\"\n+    def inner(self, *args, **kwargs):\n+        # find the target param\n+        target_id = None\n+        if 'target_id' in kwargs and kwargs['target_id'] != None:\n+            target_id = kwargs['target_id']\n+        elif len(args):\n+            target_id = args[0]\n+        else:\n+            target_id = 0\n+\n+        # if there was a target specified, check that it's valid\n+        if not self.target_is_valid(target_id):\n+            raise NoSuchTargetException()\n+\n+        # call the function\n+        return func(self, *args, **kwargs)\n+    return inner\n+\n+def validate_busy(func, *args, **kwargs):\n+    \"\"\"\n+    A decorator that raises an exception if the specified target is busy.\n+\n+    Expects the target ID to be either the 'target_id' param in kwargs,\n+    or the first positional parameter.\n+\n+    Raises a TargetBusyException if the target does not exist.\n+    \"\"\"\n+    def inner(self, *args, **kwargs):\n+        # find the target param\n+        target_id = None\n+        if 'target_id' in kwargs and kwargs['target_id'] != None:\n+            target_id = kwargs['target_id']\n+        elif len(args):\n+            target_id = args[0]\n+        else:\n+            target_id = 0\n+\n+        # if there was a target specified, ensure it's not busy\n+        if self.target_is_busy(target_id):\n+            raise TargetBusyException()\n+\n+        # call the function\n+        return func(self, *args, **kwargs)\n+    return inner\n+\n+def lock_host(func, *args, **kwargs):\n+    \"\"\"\n+    A decorator that acquires a lock before accessing the debugger to\n+    avoid API locking related errors with LLDB\n+    \"\"\"\n+    def inner(self, *args, **kwargs):\n+        self.host_lock.acquire()\n+        try:\n+            res = func(self, *args, **kwargs)\n+            self.host_lock.release()\n+        except Exception, e:\n+            self.host_lock.release()\n+            raise e\n+        return res\n+    return inner\n+\n+\n+\n+class DebuggerAdaptor(object):\n+    def target_exists(self, target_id=0):\n+        \"\"\"\n+        Returns True or False indicating whether or not the specified\n+        target is present and valid.\n+\n+        `target_id` is a target ID (or None for the first target)\n+        \"\"\"\n+        try:\n+            target = self._target(target_id=target_id)\n+        except Exception, e:\n+            log.error(\"Exception checking if target exists: {} {}\".format(type(e), e))\n+            return False\n+        return target != None\n+\n+    def target_is_valid(self, target_id=0):\n+        \"\"\"\n+        Returns True or False indicating whether or not the specified\n+        target is present and valid.\n+\n+        `target_id` is a target ID (or None for the first target)\n+        \"\"\"\n+        try:\n+            target = self._target(target_id=target_id)\n+        except:\n+            return False\n+        return target['state'] != \"invalid\"\n+\n+    def target_is_busy(self, target_id=0):\n+        \"\"\"\n+        Returns True or False indicating whether or not the specified\n+        target is busy.\n+\n+        `target_id` is a target ID (or None for the first target)\n+        \"\"\"\n+        try:\n+            target = self._target(target_id=target_id)\n+        except:\n+            raise NoSuchTargetException()\n+        return target['state'] == \"running\"\n\\ No newline at end of file\ndiff --git a/voltron/plugins/debugger/dbg_lldb.py b/voltron/plugins/debugger/dbg_lldb.py\nindex cf68ef3..b280535 100644\n--- a/voltron/plugins/debugger/dbg_lldb.py\n+++ b/voltron/plugins/debugger/dbg_lldb.py\n@@ -1,11 +1,11 @@\n from __future__ import print_function\n \n import logging\n-import logging.config\n import threading\n \n from voltron.api import *\n from voltron.plugin import *\n+from voltron.debugger import *\n \n try:\n     import lldb\n@@ -16,15 +16,8 @@ except ImportError:\n log = logging.getLogger('debugger')\n \n if HAVE_LLDB:\n-    class LLDBException(Exception):\n-        \"\"\"\n-        Raised when an LLDB operation fails\n-        \"\"\"\n-        def __init__(self, error=None):\n-            pass\n \n-\n-    class LLDBAdaptor (object):\n+    class LLDBAdaptor(DebuggerAdaptor):\n         \"\"\"\n         The interface with an instance of LLDB\n         \"\"\"\n@@ -37,7 +30,6 @@ if HAVE_LLDB:\n             \"arm64\":    {\"pc\": \"pc\", \"sp\": \"sp\"},\n         }\n         def __init__(self, host=None):\n-            self.wait_event = threading.Event()\n             self.host_lock = threading.RLock()\n             self.listeners = []\n             if host:\n@@ -51,98 +43,6 @@ if HAVE_LLDB:\n                 self.host = lldb.SBDebugger.Create()\n                 self.host.SetAsync(False)\n \n-        @property\n-        def host(self):\n-            \"\"\"\n-            Get the debugger host object that this adaptor talks to. Used by\n-            custom API plugins to talk directly to the debugger.\n-            \"\"\"\n-            return self._host\n-\n-        @host.setter\n-        def host(self, value):\n-            self._host = value\n-\n-        def version(self):\n-            \"\"\"\n-            Get the debugger's version.\n-\n-            Returns a string containing the debugger's version\n-            (e.g. 'lldb-310.2.37')\n-            \"\"\"\n-            return self.host.GetVersionString()\n-\n-        def validate_target(func, *args, **kwargs):\n-            \"\"\"\n-            A decorator that ensures that the specified target_id exists and\n-            is valid.\n-\n-            Expects the target ID to be either the 'target_id' param in kwargs,\n-            or the first positional parameter.\n-\n-            Raises a NoSuchTargetException if the target does not exist.\n-            \"\"\"\n-            def inner(self, *args, **kwargs):\n-                # find the target param\n-                target_id = None\n-                if 'target_id' in kwargs and kwargs['target_id'] != None:\n-                    target_id = kwargs['target_id']\n-                elif len(args):\n-                    target_id = args[0]\n-                else:\n-                    target_id = 0\n-\n-                # if there was a target specified, check that it's valid\n-                if not self.target_is_valid(target_id):\n-                    raise NoSuchTargetException()\n-\n-                # call the function\n-                return func(self, *args, **kwargs)\n-            return inner\n-\n-        def validate_busy(func, *args, **kwargs):\n-            \"\"\"\n-            A decorator that raises an exception if the specified target is busy.\n-\n-            Expects the target ID to be either the 'target_id' param in kwargs,\n-            or the first positional parameter.\n-\n-            Raises a TargetBusyException if the target does not exist.\n-            \"\"\"\n-            def inner(self, *args, **kwargs):\n-                # find the target param\n-                target_id = None\n-                if 'target_id' in kwargs and kwargs['target_id'] != None:\n-                    target_id = kwargs['target_id']\n-                elif len(args):\n-                    target_id = args[0]\n-                else:\n-                    target_id = 0\n-\n-                # if there was a target specified, ensure it's not busy\n-                if self.target_is_busy(target_id):\n-                    raise TargetBusyException()\n-\n-                # call the function\n-                return func(self, *args, **kwargs)\n-            return inner\n-\n-        def lock_host(func, *args, **kwargs):\n-            \"\"\"\n-            A decorator that acquires a lock before accessing the debugger to\n-            avoid API locking related errors with LLDB\n-            \"\"\"\n-            def inner(self, *args, **kwargs):\n-                self.host_lock.acquire()\n-                try:\n-                    res = func(self, *args, **kwargs)\n-                    self.host_lock.release()\n-                except Exception, e:\n-                    self.host_lock.release()\n-                    raise e\n-                return res\n-            return inner\n-\n         def target_exists(self, target_id=0):\n             \"\"\"\n             Returns True or False indicating whether or not the specified\n@@ -183,6 +83,27 @@ if HAVE_LLDB:\n                 raise NoSuchTargetException()\n             return target['state'] == \"running\"\n \n+        @property\n+        def host(self):\n+            \"\"\"\n+            Get the debugger host object that this adaptor talks to. Used by\n+            custom API plugins to talk directly to the debugger.\n+            \"\"\"\n+            return self._host\n+\n+        @host.setter\n+        def host(self, value):\n+            self._host = value\n+\n+        def version(self):\n+            \"\"\"\n+            Get the debugger's version.\n+\n+            Returns a string containing the debugger's version\n+            (e.g. 'lldb-310.2.37')\n+            \"\"\"\n+            return self.host.GetVersionString()\n+\n         def _target(self, target_id=0):\n             \"\"\"\n             Return information about the specified target.\n"}
{"repo": "voltron", "commit": "91280f6357029dd30ad4c3b38b8617b5a380a998", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 85e3c16..3845793 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -73,7 +73,15 @@ if in_lldb:\n         def status(self):\n             if self.server != None:\n                 summs = self.server.client_summary()\n-                print(\"There are {} clients attached\".format(len(summs)))\n+                print(\"The following listeners are active:\")\n+                listen = voltron.config['server']['listen']\n+                if listen['domain']:\n+                    print(\"  domain socket ({})\".format(voltron.env['sock']))\n+                if listen['tcp']:\n+                    print(\"  TCP socket ({})\".format(listen['tcp']))\n+                if listen['http']:\n+                    print(\"  web server ({})\".format(listen['http']))\n+                print(\"There are {} clients attached:\".format(len(summs)))\n                 for summary in summs:\n                     print(\"  \" + summary)\n             else:\n@@ -102,7 +110,7 @@ if in_lldb:\n             voltron.debugger = self.adaptor\n \n             # start the server\n-            self.server = Server(debugger=self.adaptor)\n+            self.server = Server()\n             self.server.start()\n \n             self.hook_idx = None\ndiff --git a/tests/http_api_tests.py b/tests/http_api_tests.py\nindex c303608..0ca58c2 100644\n--- a/tests/http_api_tests.py\n+++ b/tests/http_api_tests.py\n@@ -63,83 +63,83 @@ def teardown():\n     server.stop()\n \n def test_disassemble():\n-    data = requests.get('http://localhost:5555/disassemble?count=16').text\n+    data = requests.get('http://localhost:5555/api/disassemble?count=16').text\n     res = APIResponse(data=data)\n     assert res.is_success\n     assert res.disassembly == disassemble_response\n \n def test_execute_command():\n-    data = requests.get('http://localhost:5555/execute_command?command=reg%20read').text\n+    data = requests.get('http://localhost:5555/api/execute_command?command=reg%20read').text\n     res = APIResponse(data=data)\n     assert res.is_success\n     assert res.output == execute_command_response\n \n def test_list_targets():\n-    data = requests.get('http://localhost:5555/list_targets').text\n+    data = requests.get('http://localhost:5555/api/list_targets').text\n     res = api_response('list_targets', data=data)\n     assert res.is_success\n     assert res.targets == targets_response\n \n def test_read_memory():\n-    data = requests.get('http://localhost:5555/read_registers').text\n+    data = requests.get('http://localhost:5555/api/read_registers').text\n     res = api_response('read_registers', data=data)\n-    url = 'http://localhost:5555/read_memory?address={}&length=64'.format(res.registers['rip'])\n+    url = 'http://localhost:5555/api/read_memory?address={}&length=64'.format(res.registers['rip'])\n     data = requests.get(url).text\n     res = api_response('read_memory', data=data)\n     assert res.is_success\n     assert res.memory == read_memory_response\n \n def test_read_registers():\n-    data = requests.get('http://localhost:5555/read_registers').text\n+    data = requests.get('http://localhost:5555/api/read_registers').text\n     res = api_response('read_registers', data=data)\n     assert res.is_success\n     assert res.registers == read_registers_response\n \n def test_read_stack_length_missing():\n-    data = requests.get('http://localhost:5555/read_stack').text\n+    data = requests.get('http://localhost:5555/api/read_stack').text\n     res = APIErrorResponse(data=data)\n     assert res.is_error\n     assert res.message == 'length'\n \n def test_read_stack():\n-    data = requests.get('http://localhost:5555/read_stack?length=64').text\n+    data = requests.get('http://localhost:5555/api/read_stack?length=64').text\n     res = api_response('read_stack', data=data)\n     assert res.is_success\n     assert res.memory == read_stack_response\n \n def test_state():\n-    data = requests.get('http://localhost:5555/state').text\n+    data = requests.get('http://localhost:5555/api/state').text\n     res = api_response('state', data=data)\n     assert res.is_success\n     assert res.state == state_response\n \n def test_version():\n-    data = requests.get('http://localhost:5555/version').text\n+    data = requests.get('http://localhost:5555/api/version').text\n     res = api_response('version', data=data)\n     assert res.is_success\n     assert res.api_version == 1.0\n     assert res.host_version == 'lldb-something'\n \n def test_wait():\n-    data = requests.get('http://localhost:5555/wait?timeout=2').text\n+    data = requests.get('http://localhost:5555/api/wait?timeout=2').text\n     res = APIResponse(data=data)\n     assert res.is_error\n     assert res.code == 0x1004\n \n-# def test_bad_json():\n-#     data = requests.post('http://localhost:5555/api', data='xxx').text\n-#     res = APIResponse(data=data)\n-#     assert res.is_error\n-#     assert res.code == 0x1001\n-\n-# def test_bad_request():\n-#     data = requests.post('http://localhost:5555/api', data='{\"type\":\"request\",\"request\":\"no_such_request\"}').text\n-#     res = APIResponse(data=data)\n-#     assert res.is_error\n-#     assert res.code == 0x1002\n-\n-# def test_host_not_supported():\n-#     data = requests.post('http://localhost:5555/api', data='{\"type\":\"request\",\"request\":\"host_not_supported\"}').text\n-#     res = APIResponse(data=data)\n-#     assert res.is_error\n-#     assert res.code == 0x1003\n+def test_bad_json():\n+    data = requests.post('http://localhost:5555/api/request', data='xxx').text\n+    res = APIResponse(data=data)\n+    assert res.is_error\n+    assert res.code == 0x1001\n+\n+def test_bad_request():\n+    data = requests.post('http://localhost:5555/api/request', data='{\"type\":\"request\",\"request\":\"no_such_request\"}').text\n+    res = APIResponse(data=data)\n+    assert res.is_error\n+    assert res.code == 0x1002\n+\n+def test_host_not_supported():\n+    data = requests.post('http://localhost:5555/api/request', data='{\"type\":\"request\",\"request\":\"host_not_supported\"}').text\n+    res = APIResponse(data=data)\n+    assert res.is_error\n+    assert res.code == 0x1003\ndiff --git a/voltron/core.py b/voltron/core.py\nindex 81bce51..3b83752 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -12,6 +12,7 @@ import voltron\n import voltron.http\n from .api import *\n from .plugin import *\n+from .api import *\n \n log = logging.getLogger(\"core\")\n \n@@ -23,7 +24,7 @@ class Server(object):\n     controlling the background thread that communicates with clients, and\n     handling requests forwarded from that thread.\n     \"\"\"\n-    def __init__(self, debugger=None, plugin_mgr=None):\n+    def __init__(self):\n         self.clients = []\n \n         self.d_thread = None\n@@ -34,29 +35,21 @@ class Server(object):\n         self.d_exit_out, self.d_exit_in = os.pipe()\n         self.t_exit_out, self.t_exit_in = os.pipe()\n \n-        self.debugger = debugger\n-        if plugin_mgr:\n-            self.plugin_mgr = plugin_mgr\n-        else:\n-            self.plugin_mgr = PluginManager()\n-\n     def start(self):\n         listen = voltron.config['server']['listen']\n         if listen['domain']:\n             log.debug(\"Starting server thread for domain socket\")\n-            self.d_thread = ServerThread(self, self.clients, self.d_exit_out, self.debugger, self.plugin_mgr,\n-                voltron.env['sock'])\n+            self.d_thread = ServerThread(self, self.clients, self.d_exit_out, voltron.env['sock'])\n             self.d_thread.start()\n         if listen['tcp']:\n             log.debug(\"Starting server thread for TCP socket\")\n-            self.t_thread = ServerThread(self, self.clients, self.t_exit_out, self.debugger, self.plugin_mgr,\n-                tuple(listen['tcp']))\n+            self.t_thread = ServerThread(self, self.clients, self.t_exit_out, tuple(listen['tcp']))\n             self.t_thread.start()\n         if voltron.config['server']['listen']['http']:\n             log.debug(\"Starting server thread for HTTP server\")\n             (host, port) = tuple(listen['http'])\n             voltron.http.app.server = self\n-            self.h_thread = HTTPServerThread(self, self.clients, self.debugger, self.plugin_mgr, host, port)\n+            self.h_thread = HTTPServerThread(self, self.clients, host, port)\n             self.h_thread.start()\n \n     def stop(self):\n@@ -86,17 +79,17 @@ class Server(object):\n         #\n \n         # make sure we have a debugger, or we're gonna have a bad time\n-        if self.debugger:\n+        if voltron.debugger:\n             # parse incoming request with the top level APIRequest class so we can determine the request type\n             try:\n-                req = APIRequest(data=data, debugger=self.debugger)\n+                req = APIRequest(data=data)\n             except Exception, e:\n                 req = None\n                 log.error(log.error(\"Exception raised while parsing API request: {} {}\".format(type(e), e)))\n \n             if req:\n                 # instantiate the request class\n-                req = api_request(req.request, data=data, debugger=self.debugger)\n+                req = api_request(req.request, data=data)\n                 if not req:\n                     res = APIPluginNotFoundErrorResponse()\n             else:\n@@ -161,13 +154,11 @@ class ServerThread(threading.Thread):\n     passes them off to the APIDispatcher to be fulfilled. Then the responses\n     returned (synchronously) are sent back to the requesting client.\n     \"\"\"\n-    def __init__(self, server, clients, exit_pipe, debugger, plugin_mgr, sock):\n+    def __init__(self, server, clients, exit_pipe, sock):\n         threading.Thread.__init__(self)\n         self.server = server\n         self.clients = clients\n         self.exit_pipe = exit_pipe\n-        self.debugger = debugger\n-        self.plugin_mgr = plugin_mgr\n         self.sock = sock\n \n     def run(self):\n@@ -232,27 +223,31 @@ class HTTPServerThread(threading.Thread):\n     \"\"\"\n     Background thread to run the HTTP server.\n     \"\"\"\n-    def __init__(self, server, clients, debugger, plugin_mgr, host=\"127.0.0.1\", port=6969):\n+    def __init__(self, server, clients, host=\"127.0.0.1\", port=6969):\n         threading.Thread.__init__(self)\n         self.server = server\n         self.clients = clients\n-        self.debugger = debugger\n-        self.plugin_mgr = plugin_mgr\n         self.host = host\n         self.port = port\n \n     def run(self):\n         # graft the flask app (see http.py) onto the cherry tree\n-        cherrypy.tree.graft(voltron.http.app, '/')\n+        cherrypy.tree.graft(voltron.http.app, '/api')\n \n         # configure the cherrypy server\n         cherrypy.config.update({\n-            'engine.autoreload.on': True,\n             'log.screen': False,\n             'server.socket_port': self.port,\n             'server.socket_host': str(self.host)\n         })\n \n+        # mount the static dir\n+        cherrypy.tree.mount(None, '/', {'/' : {\n+            'tools.staticdir.dir': os.path.join(os.path.dirname(__file__), 'web'),\n+            'tools.staticdir.on': True,\n+            'tools.staticdir.index': 'index.html'\n+        }})\n+\n         # make with the serving\n         cherrypy.engine.start()\n         cherrypy.engine.block()\n@@ -270,7 +265,6 @@ class Client(object):\n         Initialise a new client\n         \"\"\"\n         self.sock = None\n-        self.plugin_mgr = PluginManager()\n \n     def connect(self):\n         \"\"\"\n@@ -335,7 +329,7 @@ class Client(object):\n         plugin, whose request class is instantiated and passed the remaining\n         arguments passed to this function.\n         \"\"\"\n-        return self.plugin_mgr.api_request(request_type, *args, **kwargs)\n+        return api_request(request_type, *args, **kwargs)\n \n     def perform_request(self, request_type, *args, **kwargs):\n         \"\"\"\n@@ -346,7 +340,7 @@ class Client(object):\n         arguments passed to this function.\n         \"\"\"\n         # create a request\n-        req = self.plugin_mgr.api_request(request_type, *args, **kwargs)\n+        req = api_request(request_type, *args, **kwargs)\n \n         # send it\n         res = self.send_request(req)\ndiff --git a/voltron/plugins/api/disassemble.py b/voltron/plugins/api/disassemble.py\nindex 9e1706e..f3c3c6d 100644\n--- a/voltron/plugins/api/disassemble.py\n+++ b/voltron/plugins/api/disassemble.py\n@@ -3,6 +3,7 @@ import logging\n import base64\n \n from voltron.api import *\n+from voltron.plugin import *\n \n log = logging.getLogger('api')\n \ndiff --git a/voltron/plugins/view/backtrace.py b/voltron/plugins/view/backtrace.py\nindex aa968dd..26352dc 100644\n--- a/voltron/plugins/view/backtrace.py\n+++ b/voltron/plugins/view/backtrace.py\n@@ -2,6 +2,7 @@ import logging\n \n from voltron.view import *\n from voltron.plugin import *\n+from voltron.api import *\n \n log = logging.getLogger('view')\n \ndiff --git a/voltron/plugins/view/command.py b/voltron/plugins/view/command.py\nindex 569d6dd..ee1359e 100644\n--- a/voltron/plugins/view/command.py\n+++ b/voltron/plugins/view/command.py\n@@ -2,6 +2,7 @@ import logging\n \n from voltron.view import *\n from voltron.plugin import *\n+from voltron.api import *\n \n log = logging.getLogger('view')\n \ndiff --git a/voltron/plugins/view/disasm.py b/voltron/plugins/view/disasm.py\nindex c6e779e..6bf6dff 100644\n--- a/voltron/plugins/view/disasm.py\n+++ b/voltron/plugins/view/disasm.py\n@@ -1,5 +1,6 @@\n from voltron.view import *\n from voltron.plugin import *\n+from voltron.api import *\n \n \n class DisasmView (TerminalView):\ndiff --git a/voltron/plugins/view/register.py b/voltron/plugins/view/register.py\nindex 94b29f0..0f197bd 100644\n--- a/voltron/plugins/view/register.py\n+++ b/voltron/plugins/view/register.py\n@@ -1,5 +1,6 @@\n from voltron.view import *\n from voltron.plugin import *\n+from voltron.api import *\n \n # Class to actually render the view\n class RegisterView (TerminalView):\ndiff --git a/voltron/plugins/view/stack.py b/voltron/plugins/view/stack.py\nindex 0f9c228..dec915d 100644\n--- a/voltron/plugins/view/stack.py\n+++ b/voltron/plugins/view/stack.py\n@@ -2,6 +2,7 @@ import logging\n \n from voltron.view import *\n from voltron.plugin import *\n+from voltron.api import *\n \n log = logging.getLogger(\"view\")\n \n"}
{"repo": "voltron", "commit": "7afc01bff9a5bcb04277375d8d9d08bd51494c58", "diff": "diff --git a/voltron/core.py b/voltron/core.py\nindex 0ed40b3..81bce51 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -11,7 +11,7 @@ import cherrypy\n import voltron\n import voltron.http\n from .api import *\n-from .plugin import PluginManager\n+from .plugin import *\n \n log = logging.getLogger(\"core\")\n \n@@ -95,18 +95,9 @@ class Server(object):\n                 log.error(log.error(\"Exception raised while parsing API request: {} {}\".format(type(e), e)))\n \n             if req:\n-                # find the api plugin for the incoming request type\n-                plugin = api_request(req.request)\n-                if plugin:\n-                    # make sure request class supports the debugger platform we're using\n-                    # XXX do this\n-\n-                    if True:\n-                        # instantiate the request class\n-                        req = plugin.request_class(data=data, debugger=self.debugger)\n-                    else:\n-                        res = APIDebuggerHostNotSupportedErrorResponse()\n-                else:\n+                # instantiate the request class\n+                req = api_request(req.request, data=data, debugger=self.debugger)\n+                if not req:\n                     res = APIPluginNotFoundErrorResponse()\n             else:\n                 res = APIInvalidRequestErrorResponse()\ndiff --git a/voltron/plugins/view/command.py b/voltron/plugins/view/command.py\nindex 551c7e9..569d6dd 100644\n--- a/voltron/plugins/view/command.py\n+++ b/voltron/plugins/view/command.py\n@@ -32,7 +32,7 @@ class CommandView (TerminalView):\n                 # Get the command output\n                 self.body = res.output\n             else:\n-                log.error(\"Error disassembling: {}\".format(res.message))\n+                log.error(\"Error executing command: {}\".format(res.message))\n                 self.body = self.colour(res.message, 'red')\n \n         self.pad_body()\n"}
{"repo": "voltron", "commit": "7c93891612f6e0ea8c55496b4cb607bf435ee0e5", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex d2ce720..85e3c16 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -97,8 +97,11 @@ if in_lldb:\n             # load plugins\n             self.pm = PluginManager()\n \n-            # set up an lldb adaptor and start the voltron server\n+            # set up an lldb adaptor and set it as the package-wide adaptor\n             self.adaptor = self.pm.debugger_plugin_for_host('lldb').adaptor_class()\n+            voltron.debugger = self.adaptor\n+\n+            # start the server\n             self.server = Server(debugger=self.adaptor)\n             self.server.start()\n \ndiff --git a/setup.py b/setup.py\nindex ff725aa..4095c90 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -10,7 +10,7 @@ setup(\n     keywords = \"voltron gdb lldb\",\n     url = \"https://github.com/snarez/voltron\",\n     packages=['voltron'],\n-    install_requires = ['rl', 'scruffy'],\n+    install_requires = ['rl', 'scruffy', 'flask', 'cherrypy'],\n     data_files=['voltron.gdb', 'dbgentry.py'],\n     package_data = {'voltron': ['config/*']},\n     install_package_data = True,\ndiff --git a/tests/common.py b/tests/common.py\nindex 21fe74b..26abeff 100644\n--- a/tests/common.py\n+++ b/tests/common.py\n@@ -1,9 +1,10 @@\n import logging\n+from mock import Mock\n \n LOGGER_DEFAULT = {\n     'handlers': ['file'],\n     'level': 'DEBUG',\n-    'propagate': True\n+    'propagate': False\n }\n \n LOG_CONFIG = {\n@@ -37,3 +38,47 @@ LOG_CONFIG = {\n }\n \n logging.config.dictConfig(LOG_CONFIG)\n+\n+state_response = \"stopped\"\n+targets_response = [{\n+    \"id\":       0,\n+    \"file\":     \"/bin/ls\",\n+    \"arch\":     \"x86_64\",\n+    \"state\":     \"stopped\"\n+}]\n+read_registers_response = ({\"gs\": 0, \"fooff\": 0, \"edi\": 1, \"edx\": 1349115624, \"r13w\": 0, \"r8l\": 0, \"fiseg\": 0, \"r8d\": 0,\n+    \"r13d\": 0, \"r13l\": 0, \"fstat\": 0, \"r8w\": 0, \"ymm9\": \"n/a\", \"ymm8\": \"n/a\", \"r14\": 0, \"r15\": 0, \"r12\": 0, \"r13\": 0,\n+    \"dh\": 222, \"di\": 1, \"ymm1\": \"n/a\", \"ymm0\": \"n/a\", \"ymm3\": \"n/a\", \"ymm2\": \"n/a\", \"ymm5\": \"n/a\", \"ymm4\": \"n/a\",\n+    \"ymm7\": \"n/a\", \"ymm6\": \"n/a\", \"dx\": 57064, \"dil\": 1, \"xmm6\": \"n/a\", \"r10l\": 0, \"bpl\": 200, \"r10d\": 1349110784,\n+    \"xmm10\": \"n/a\", \"xmm11\": \"n/a\", \"xmm12\": \"n/a\", \"xmm13\": \"n/a\", \"xmm14\": \"n/a\", \"xmm15\": \"n/a\", \"fioff\": 0,\n+    \"sil\": 216, \"r10w\": 52224, \"mxcsr\": 8064, \"ebp\": 1349115592, \"ebx\": 0, \"r15d\": 0, \"fop\": 0, \"esp\": 1349115576,\n+    \"r15l\": 0, \"r15w\": 0, \"ftag\": 0, \"esi\": 1349115608, \"bl\": 0, \"bh\": 0, \"xmm2\": \"n/a\", \"xmm3\": \"n/a\", \"xmm0\": \"n/a\",\n+    \"xmm1\": \"n/a\", \"bp\": 57032, \"xmm7\": \"n/a\", \"xmm4\": \"n/a\", \"xmm5\": \"n/a\", \"xmm8\": \"n/a\", \"xmm9\": \"n/a\", \"bx\": 0,\n+    \"ecx\": 1349115632, \"r9l\": 0, \"dl\": 232, \"r12w\": 0, \"r9d\": 1349111808, \"r8\": 0, \"rdx\": 140734542503656, \"r12d\": 0,\n+    \"r9w\": 53248, \"rdi\": 1, \"r12l\": 0, \"ch\": 222, \"cl\": 240, \"stmm4\": \"n/a\", \"stmm5\": \"n/a\", \"stmm6\": \"n/a\", \"stmm7\":\n+    \"n/a\", \"stmm0\": \"n/a\", \"stmm1\": \"n/a\", \"stmm2\": \"n/a\", \"stmm3\": \"n/a\", \"cx\": 57072, \"cs\": 43,\n+    \"rcx\": 140734542503664, \"rflags\": 582, \"rsi\": 140734542503640, \"mxcsrmask\": 65535, \"eax\": 257305888,\n+    \"rsp\": 140734542503608, \"trapno\": 3, \"r14d\": 0, \"faultvaddr\": 4552486912, \"err\": 0, \"rbx\": 0, \"r14l\": 0,\n+    \"rbp\": 140734542503624, \"r14w\": 0, \"ah\": 45, \"al\": 32, \"rip\": 4552273184, \"r9\": 140734542499840, \"spl\": 184,\n+    \"ax\": 11552, \"fctrl\": 895, \"rax\": 4552273184, \"r11l\": 70, \"r10\": 140734542498816, \"r11\": 582, \"r11d\": 582,\n+    \"foseg\": 0, \"r11w\": 582, \"fs\": 0, \"ymm11\": \"n/a\", \"ymm10\": \"n/a\", \"ymm13\": \"n/a\", \"ymm12\": \"n/a\", \"ymm15\": \"n/a\",\n+    \"ymm14\": \"n/a\", \"sp\": 57016, \"si\": 57048})\n+read_memory_response = \"\\xff\"*0x40\n+read_stack_response = \"\\xff\"*0x40\n+wait_response = \"stopped\"\n+execute_command_response = \"inferior`main:\\n-> 0x100000d20:  pushq  %rbp\\n   0x100000d21:  movq   %rsp, %rbp\\n   0x100000d24:  subq   $0x40, %rsp\\n   0x100000d28:  movl   $0x0, -0x4(%rbp)\\n   0x100000d2f:  movl   %edi, -0x8(%rbp)\\n   0x100000d32:  movq   %rsi, -0x10(%rbp)\\n   0x100000d36:  movl   $0x0, -0x14(%rbp)\\n   0x100000d3d:  movq   $0x0, -0x20(%rbp)\\n   0x100000d45:  cmpl   $0x1, -0x8(%rbp)\\n   0x100000d4c:  jle    0x100000d94               ; main + 116\\n   0x100000d52:  movq   -0x10(%rbp), %rax\\n   0x100000d56:  movq   0x8(%rax), %rdi\\n   0x100000d5a:  leaq   0x18a(%rip), %rsi         ; \\\"sleep\\\"\\n   0x100000d61:  callq  0x100000ea0               ; symbol stub for: strcmp\\n   0x100000d66:  cmpl   $0x0, %eax\\n   0x100000d6b:  jne    0x100000d94               ; main + 116\\n   0x100000d71:  leaq   0x179(%rip), %rdi         ; \\\"*** Sleeping for 5 seconds\\\\n\\\"\\n   0x100000d78:  movb   $0x0, %al\\n   0x100000d7a:  callq  0x100000e94               ; symbol stub for: printf\\n   0x100000d7f:  movl   $0x5, %edi\\n   0x100000d84:  movl   %eax, -0x24(%rbp)\\n   0x100000d87:  callq  0x100000e9a               ; symbol stub for: sleep\\n   0x100000d8c:  movl   %eax, -0x28(%rbp)\\n   0x100000d8f:  jmpq   0x100000e88               ; main + 360\\n   0x100000d94:  cmpl   $0x1, -0x8(%rbp)\\n   0x100000d9b:  jle    0x100000dd6               ; main + 182\\n   0x100000da1:  movq   -0x10(%rbp), %rax\\n   0x100000da5:  movq   0x8(%rax), %rdi\\n   0x100000da9:  leaq   0x15d(%rip), %rsi         ; \\\"loop\\\"\\n   0x100000db0:  callq  0x100000ea0               ; symbol stub for: strcmp\\n   0x100000db5:  cmpl   $0x0, %eax\\n   0x100000dba:  jne    0x100000dd6               ; main + 182\"\n+disassemble_response = execute_command_response\n+\n+\n+def inject_mock(adaptor):\n+    adaptor.version = Mock(return_value='lldb-something')\n+    adaptor.state = Mock(return_value=state_response)\n+    adaptor.target = Mock(return_value=targets_response[0])\n+    adaptor._target = Mock(return_value=targets_response[0])\n+    adaptor.targets = Mock(return_value=targets_response)\n+    adaptor.read_registers = Mock(return_value=read_registers_response)\n+    adaptor.read_memory = Mock(return_value=read_memory_response)\n+    adaptor.read_stack = Mock(return_value=read_stack_response)\n+    adaptor.wait = Mock(return_value=wait_response)\n+    adaptor.execute_command = Mock(return_value=execute_command_response)\n+    adaptor.disassemble = Mock(return_value=disassemble_response)\ndiff --git a/tests/frontend_tests.py b/tests/frontend_tests.py\nindex 45b40df..c46c978 100644\n--- a/tests/frontend_tests.py\n+++ b/tests/frontend_tests.py\n@@ -3,7 +3,7 @@ These tests load an inferior into an LLDB instance and then issue API requests\n using the client.\n \n Tests:\n-Client -> Server -> APIDispatcher-> LLDBAdaptor\n+Client -> Server -> LLDBAdaptor\n \n Using an instantiated SBDebugger instance\n \"\"\"\ndiff --git a/tests/lldb_api_tests.py b/tests/lldb_api_tests.py\nindex 601a875..f88539a 100644\n--- a/tests/lldb_api_tests.py\n+++ b/tests/lldb_api_tests.py\n@@ -37,6 +37,8 @@ log.setLevel(logging.DEBUG)\n def setup():\n     global adaptor, dbg, target\n \n+    time.sleep(2)\n+\n     log.info(\"setting up LLDB API tests\")\n \n     # create an LLDBAdaptor\ndiff --git a/tests/lldb_cli_tests.py b/tests/lldb_cli_tests.py\nindex ed026a4..7582f13 100644\n--- a/tests/lldb_cli_tests.py\n+++ b/tests/lldb_cli_tests.py\n@@ -2,7 +2,7 @@\n Tests that test voltron in the lldb cli driver\n \n Tests:\n-Client -> Server -> APIDispatcher-> LLDBAdaptor\n+Client -> Server -> LLDBAdaptor\n \n Inside an LLDB CLI driver instance\n \"\"\"\n@@ -46,9 +46,9 @@ def setup():\n     start_debugger()\n     time.sleep(1)\n \n-\n def teardown():\n-    p.terminate()\n+    read_data()\n+    p.terminate(True)\n \n def start_debugger(do_break=True):\n     global p, client\n@@ -66,10 +66,7 @@ def start_debugger(do_break=True):\n     client.connect()\n \n def stop_debugger():\n-    try:\n-        p.terminate()\n-    except:\n-        pass\n+    p.terminate(True)\n \n def read_data():\n     try:\ndiff --git a/tests/voltron_api_tests.py b/tests/voltron_api_tests.py\ndeleted file mode 100644\nindex db2193a..0000000\n--- a/tests/voltron_api_tests.py\n+++ /dev/null\n@@ -1,338 +0,0 @@\n-\"\"\"\n-Tests that emulate the debugger adaptor and just test the interaction between\n-the front end and back end API classes.\n-\n-Tests:\n-Client -> Server -> APIDispatcher\n-\"\"\"\n-\n-import tempfile\n-import sys\n-import json\n-import time\n-import logging\n-import subprocess\n-import base64\n-\n-from mock import Mock\n-from nose.tools import *\n-\n-import voltron\n-from voltron.core import *\n-from voltron.api import *\n-from voltron.plugin import PluginManager, DebuggerAdaptorPlugin\n-\n-import platform\n-if platform.system() == 'Darwin':\n-    sys.path.append(\"/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Resources/Python\")\n-\n-from common import *\n-\n-log = logging.getLogger(__name__)\n-\n-state_response = \"stopped\"\n-targets_response = [{\n-    \"id\":       0,\n-    \"file\":     \"/bin/ls\",\n-    \"arch\":     \"x86_64\",\n-    \"state\":     \"stopped\"\n-}]\n-read_registers_response = ({\"gs\": 0, \"fooff\": 0, \"edi\": 1, \"edx\": 1349115624, \"r13w\": 0, \"r8l\": 0, \"fiseg\": 0, \"r8d\": 0,\n-    \"r13d\": 0, \"r13l\": 0, \"fstat\": 0, \"r8w\": 0, \"ymm9\": \"n/a\", \"ymm8\": \"n/a\", \"r14\": 0, \"r15\": 0, \"r12\": 0, \"r13\": 0,\n-    \"dh\": 222, \"di\": 1, \"ymm1\": \"n/a\", \"ymm0\": \"n/a\", \"ymm3\": \"n/a\", \"ymm2\": \"n/a\", \"ymm5\": \"n/a\", \"ymm4\": \"n/a\",\n-    \"ymm7\": \"n/a\", \"ymm6\": \"n/a\", \"dx\": 57064, \"dil\": 1, \"xmm6\": \"n/a\", \"r10l\": 0, \"bpl\": 200, \"r10d\": 1349110784,\n-    \"xmm10\": \"n/a\", \"xmm11\": \"n/a\", \"xmm12\": \"n/a\", \"xmm13\": \"n/a\", \"xmm14\": \"n/a\", \"xmm15\": \"n/a\", \"fioff\": 0,\n-    \"sil\": 216, \"r10w\": 52224, \"mxcsr\": 8064, \"ebp\": 1349115592, \"ebx\": 0, \"r15d\": 0, \"fop\": 0, \"esp\": 1349115576,\n-    \"r15l\": 0, \"r15w\": 0, \"ftag\": 0, \"esi\": 1349115608, \"bl\": 0, \"bh\": 0, \"xmm2\": \"n/a\", \"xmm3\": \"n/a\", \"xmm0\": \"n/a\",\n-    \"xmm1\": \"n/a\", \"bp\": 57032, \"xmm7\": \"n/a\", \"xmm4\": \"n/a\", \"xmm5\": \"n/a\", \"xmm8\": \"n/a\", \"xmm9\": \"n/a\", \"bx\": 0,\n-    \"ecx\": 1349115632, \"r9l\": 0, \"dl\": 232, \"r12w\": 0, \"r9d\": 1349111808, \"r8\": 0, \"rdx\": 140734542503656, \"r12d\": 0,\n-    \"r9w\": 53248, \"rdi\": 1, \"r12l\": 0, \"ch\": 222, \"cl\": 240, \"stmm4\": \"n/a\", \"stmm5\": \"n/a\", \"stmm6\": \"n/a\", \"stmm7\":\n-    \"n/a\", \"stmm0\": \"n/a\", \"stmm1\": \"n/a\", \"stmm2\": \"n/a\", \"stmm3\": \"n/a\", \"cx\": 57072, \"cs\": 43,\n-    \"rcx\": 140734542503664, \"rflags\": 582, \"rsi\": 140734542503640, \"mxcsrmask\": 65535, \"eax\": 257305888,\n-    \"rsp\": 140734542503608, \"trapno\": 3, \"r14d\": 0, \"faultvaddr\": 4552486912, \"err\": 0, \"rbx\": 0, \"r14l\": 0,\n-    \"rbp\": 140734542503624, \"r14w\": 0, \"ah\": 45, \"al\": 32, \"rip\": 4552273184, \"r9\": 140734542499840, \"spl\": 184,\n-    \"ax\": 11552, \"fctrl\": 895, \"rax\": 4552273184, \"r11l\": 70, \"r10\": 140734542498816, \"r11\": 582, \"r11d\": 582,\n-    \"foseg\": 0, \"r11w\": 582, \"fs\": 0, \"ymm11\": \"n/a\", \"ymm10\": \"n/a\", \"ymm13\": \"n/a\", \"ymm12\": \"n/a\", \"ymm15\": \"n/a\",\n-    \"ymm14\": \"n/a\", \"sp\": 57016, \"si\": 57048})\n-read_memory_response = \"\\xff\"*0x40\n-read_stack_response = \"\\xff\"*0x40\n-wait_response = \"stopped\"\n-execute_command_response = \"inferior`main:\\n-> 0x100000d20:  pushq  %rbp\\n   0x100000d21:  movq   %rsp, %rbp\\n   0x100000d24:  subq   $0x40, %rsp\\n   0x100000d28:  movl   $0x0, -0x4(%rbp)\\n   0x100000d2f:  movl   %edi, -0x8(%rbp)\\n   0x100000d32:  movq   %rsi, -0x10(%rbp)\\n   0x100000d36:  movl   $0x0, -0x14(%rbp)\\n   0x100000d3d:  movq   $0x0, -0x20(%rbp)\\n   0x100000d45:  cmpl   $0x1, -0x8(%rbp)\\n   0x100000d4c:  jle    0x100000d94               ; main + 116\\n   0x100000d52:  movq   -0x10(%rbp), %rax\\n   0x100000d56:  movq   0x8(%rax), %rdi\\n   0x100000d5a:  leaq   0x18a(%rip), %rsi         ; \\\"sleep\\\"\\n   0x100000d61:  callq  0x100000ea0               ; symbol stub for: strcmp\\n   0x100000d66:  cmpl   $0x0, %eax\\n   0x100000d6b:  jne    0x100000d94               ; main + 116\\n   0x100000d71:  leaq   0x179(%rip), %rdi         ; \\\"*** Sleeping for 5 seconds\\\\n\\\"\\n   0x100000d78:  movb   $0x0, %al\\n   0x100000d7a:  callq  0x100000e94               ; symbol stub for: printf\\n   0x100000d7f:  movl   $0x5, %edi\\n   0x100000d84:  movl   %eax, -0x24(%rbp)\\n   0x100000d87:  callq  0x100000e9a               ; symbol stub for: sleep\\n   0x100000d8c:  movl   %eax, -0x28(%rbp)\\n   0x100000d8f:  jmpq   0x100000e88               ; main + 360\\n   0x100000d94:  cmpl   $0x1, -0x8(%rbp)\\n   0x100000d9b:  jle    0x100000dd6               ; main + 182\\n   0x100000da1:  movq   -0x10(%rbp), %rax\\n   0x100000da5:  movq   0x8(%rax), %rdi\\n   0x100000da9:  leaq   0x15d(%rip), %rsi         ; \\\"loop\\\"\\n   0x100000db0:  callq  0x100000ea0               ; symbol stub for: strcmp\\n   0x100000db5:  cmpl   $0x0, %eax\\n   0x100000dba:  jne    0x100000dd6               ; main + 182\"\n-disassemble_response = execute_command_response\n-\n-class APIHostNotSupportedRequest(APIRequest):\n-    @server_side\n-    def dispatch(self):\n-        return APIDebuggerHostNotSupportedErrorResponse()\n-\n-\n-class APIHostNotSupportedPlugin(APIPlugin):\n-    request = \"host_not_supported\"\n-    request_class = APIHostNotSupportedRequest\n-    response_class = APIResponse\n-\n-\n-def setup():\n-    global server, client, target, pm, adaptor, methods\n-\n-    log.info(\"setting up API tests\")\n-\n-    # set up voltron\n-    voltron.setup_env()\n-    pm = PluginManager()\n-    plugin = pm.debugger_plugin_for_host('lldb')\n-    adaptor = plugin.adaptor_class()\n-    voltron.debugger = adaptor\n-\n-    # update the thingy\n-    adaptor.version = Mock(return_value='lldb-something')\n-    adaptor.state = Mock(return_value=state_response)\n-    adaptor.target = Mock(return_value=targets_response[0])\n-    adaptor._target = Mock(return_value=targets_response[0])\n-    adaptor.targets = Mock(return_value=targets_response)\n-    adaptor.read_registers = Mock(return_value=read_registers_response)\n-    adaptor.read_memory = Mock(return_value=read_memory_response)\n-    adaptor.read_stack = Mock(return_value=read_stack_response)\n-    adaptor.wait = Mock(return_value=wait_response)\n-    adaptor.execute_command = Mock(return_value=execute_command_response)\n-    adaptor.disassemble = Mock(return_value=disassemble_response)\n-\n-    # start up a voltron server\n-    server = Server(plugin_mgr=pm, debugger=adaptor)\n-    server.start()\n-\n-    time.sleep(0.1)\n-\n-    # set up client\n-    client = Client()\n-    client.connect()\n-\n-def teardown():\n-    server.stop()\n-\n-def make_direct_request(request):\n-    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n-    sock.connect(voltron.env['sock'])\n-    sock.send(request)\n-    data = sock.recv(0xFFFF)\n-    return data\n-\n-def test_direct_invalid_json():\n-    data = make_direct_request('xxx')\n-    res = APIResponse(data=data)\n-    assert res.is_error\n-    assert res.error_code == 0x1001\n-\n-def test_front_end_bad_request():\n-    req = pm.api_plugins['version'].request_class()\n-    req.request = 'xxx'\n-    res = client.send_request(req)\n-    assert res.is_error\n-    assert res.error_code == 0x1002\n-\n-def test_front_end_host_not_supported():\n-    req = pm.api_plugins['host_not_supported'].request_class()\n-    res = client.send_request(req)\n-    assert res.is_error\n-    assert res.error_code == 0x1003\n-\n-def test_backend_version():\n-    res = pm.api_plugins['version'].request_class().dispatch()\n-    assert res.data['api_version'] == 1.0\n-    assert res.data['host_version'] == 'lldb-something'\n-\n-def test_direct_version():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"version\"\n-        }\n-    ))\n-    res = pm.api_plugins['version'].response_class(data)\n-    assert res.data['api_version'] == 1.0\n-    assert res.data['host_version'] == 'lldb-something'\n-\n-def test_frontend_version():\n-    req = pm.api_plugins['version'].request_class()\n-    res = client.send_request(req)\n-    assert res.data['api_version'] == 1.0\n-    assert res.data['host_version'] == 'lldb-something'\n-\n-def test_backend_state():\n-    res = pm.api_plugins['state'].request_class().dispatch()\n-    assert res.is_success\n-    assert res.data[\"state\"] == \"stopped\"\n-\n-def test_direct_state():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"state\"\n-        }\n-    ))\n-    res = pm.api_plugins['state'].response_class(data)\n-    assert res.is_success\n-    assert res.state == \"stopped\"\n-\n-def test_frontend_state():\n-    req = pm.api_plugins['state'].request_class()\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.state == \"stopped\"\n-\n-def test_frontend_state_with_id():\n-    req = pm.api_plugins['state'].request_class()\n-    req.data['target_id'] = 0\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.state == \"stopped\"\n-\n-def test_frontend_wait_timeout():\n-    req = pm.api_plugins['wait'].request_class(timeout=2)\n-    res = client.send_request(req)\n-    assert res.is_error\n-\n-def test_backend_list_targets():\n-    res = pm.api_plugins['list_targets'].request_class().dispatch()\n-    assert res.is_success\n-    assert res.data[\"targets\"] == targets_response\n-\n-def test_direct_list_targets():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"list_targets\"\n-        }\n-    ))\n-    res = pm.api_plugins['list_targets'].response_class(data=data)\n-    assert res.is_success\n-    assert res.data[\"targets\"] == targets_response\n-\n-def test_frontend_list_targets():\n-    req = pm.api_plugins['list_targets'].request_class()\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.data[\"targets\"] == targets_response\n-\n-def test_backend_read_registers():\n-    res = pm.api_plugins['read_registers'].request_class().dispatch()\n-    assert res.is_success\n-    assert res.data[\"registers\"] == read_registers_response\n-\n-def test_direct_read_registers():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"read_registers\"\n-        }\n-    ))\n-    res = pm.api_plugins['read_registers'].response_class(data)\n-    assert res.is_success\n-    assert res.data[\"registers\"] == read_registers_response\n-\n-def test_frontend_read_registers():\n-    req = pm.api_plugins['read_registers'].request_class()\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.data[\"registers\"] == read_registers_response\n-\n-def test_backend_read_memory():\n-    res = pm.api_plugins['read_memory'].request_class(address=0x1000, length=0x40).dispatch()\n-    assert res.is_success\n-    assert res.memory == read_memory_response\n-\n-def test_direct_read_memory():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"read_memory\",\n-            \"data\": {\n-                \"target_id\": 0,\n-                \"address\": 0x1000,\n-                \"length\": 0x40\n-            }\n-        }\n-    ))\n-    res = pm.api_plugins['read_memory'].response_class(data)\n-    assert res.is_success\n-    assert res.memory == read_memory_response\n-\n-def test_frontend_read_memory():\n-    req = pm.api_plugins['read_memory'].request_class(0x1000, 0x40)\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.memory == read_memory_response\n-\n-def test_backend_read_stack():\n-    res = pm.api_plugins['read_stack'].request_class(length=0x40).dispatch()\n-    assert res.is_success\n-    assert res.memory == read_stack_response\n-\n-def test_direct_read_stack():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"read_stack\",\n-            \"data\": {\n-                \"target_id\": 0,\n-                \"length\": 0x40\n-            }\n-        }\n-    ))\n-    res = pm.api_plugins['read_stack'].response_class(data)\n-    assert res.is_success\n-    assert res.memory == read_stack_response\n-\n-def test_frontend_read_stack():\n-    req = pm.api_plugins['read_stack'].request_class(0x40)\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.memory == read_stack_response\n-\n-def test_backend_execute_command():\n-    res = pm.api_plugins['execute_command'].request_class(\"reg read\").dispatch()\n-    assert res.is_success\n-    assert res.output == execute_command_response\n-\n-def test_direct_execute_command():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"execute_command\",\n-            \"data\": {\n-                \"command\": \"reg read\"\n-            }\n-        }\n-    ))\n-    res = pm.api_plugins['execute_command'].response_class(data)\n-    assert res.is_success\n-    assert res.output == execute_command_response\n-\n-def test_frontend_execute_command():\n-    req = pm.api_plugins['execute_command'].request_class(\"reg read\")\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.output == execute_command_response\n-\n-def test_backend_disassemble():\n-    res = pm.api_plugins['disassemble'].request_class(count=16).dispatch()\n-    assert res.is_success\n-    assert res.disassembly == disassemble_response\n-\n-def test_direct_disassemble():\n-    data = make_direct_request(json.dumps(\n-        {\n-            \"type\":         \"request\",\n-            \"request\":      \"disassemble\",\n-            \"data\": {\"count\": 16}\n-        }\n-    ))\n-    res = pm.api_plugins['disassemble'].response_class(data)\n-    assert res.is_success\n-    assert res.disassembly == disassemble_response\n-\n-def test_frontend_disassemble():\n-    req = pm.api_plugins['disassemble'].request_class(count=16)\n-    res = client.send_request(req)\n-    assert res.is_success\n-    assert res.disassembly == disassemble_response\ndiff --git a/voltron/__init__.py b/voltron/__init__.py\nindex 6439fcc..f434d22 100644\n--- a/voltron/__init__.py\n+++ b/voltron/__init__.py\n@@ -4,6 +4,8 @@ import logging.config\n \n from .main import main\n \n+import plugin\n+\n from scruffy import Environment\n \n # scruffy environment containing config, plugins, etc\n@@ -56,6 +58,9 @@ def setup_env():\n     })\n     config = env['config']\n \n+    # create shared instance of plugin manager\n+    plugin.pm = plugin.PluginManager()\n+\n LOGGER_DEFAULT = {\n     'handlers': ['null'],\n     'level': 'DEBUG',\ndiff --git a/voltron/api.py b/voltron/api.py\nindex 5ce4156..4874342 100644\n--- a/voltron/api.py\n+++ b/voltron/api.py\n@@ -247,7 +247,7 @@ class APIRequest(APIMessage):\n \n     @request.setter\n     def request(self, value):\n-        self.props['request'] = value\n+        self.props['request'] = str(value)\n \n     @property\n     def debugger(self):\n@@ -280,7 +280,7 @@ class APIResponse(APIMessage):\n \n     @status.setter\n     def status(self, value):\n-        self.props['status'] = value\n+        self.props['status'] = str(value)\n \n     @property\n     def is_success(self):\n@@ -298,7 +298,7 @@ class APIResponse(APIMessage):\n \n     @error_code.setter\n     def error_code(self, value):\n-        self.data['code'] = value\n+        self.data['code'] = int(value)\n \n     @property\n     def error_message(self):\n@@ -308,7 +308,7 @@ class APIResponse(APIMessage):\n \n     @error_message.setter\n     def error_message(self, value):\n-        self.data['message'] = value\n+        self.data['message'] = str(value)\n \n     def validate(self):\n         if not self.status:\n@@ -330,8 +330,8 @@ class APIErrorResponse(APIResponse):\n     \"\"\"\n     A generic API error response.\n     \"\"\"\n-    def __init__(self, code=None, message=None):\n-        super(APIErrorResponse, self).__init__()\n+    def __init__(self, code=None, message=None, *args, **kwargs):\n+        super(APIErrorResponse, self).__init__(*args, **kwargs)\n         self.status = \"error\"\n         if hasattr(self.__class__, 'code'):\n             self.error_code = self.__class__.code\ndiff --git a/voltron/core.py b/voltron/core.py\nindex d1cf489..dfaa978 100644\n--- a/voltron/core.py\n+++ b/voltron/core.py\n@@ -6,8 +6,10 @@ import threading\n import logging\n import logging.config\n import json\n+import cherrypy\n \n import voltron\n+import voltron.http\n from .api import *\n from .plugin import PluginManager\n \n@@ -24,8 +26,13 @@ class Server(object):\n     def __init__(self, debugger=None, plugin_mgr=None):\n         self.clients = []\n \n-        # pipes for controlling ServerThread\n-        self.exit_out, self.exit_in = os.pipe()\n+        self.d_thread = None\n+        self.t_thread = None\n+        self.h_thread = None\n+\n+        # pipes for controlling ServerThreads\n+        self.d_exit_out, self.d_exit_in = os.pipe()\n+        self.t_exit_out, self.t_exit_in = os.pipe()\n \n         self.debugger = debugger\n         if plugin_mgr:\n@@ -34,16 +41,35 @@ class Server(object):\n             self.plugin_mgr = PluginManager()\n \n     def start(self):\n-        # spin off a server thread\n-        log.debug(\"Starting server thread\")\n-        self.thread = ServerThread(self, self.clients, self.exit_out, self.debugger, self.plugin_mgr)\n-        self.thread.start()\n+        listen = voltron.config['server']['listen']\n+        if listen['domain']:\n+            log.debug(\"Starting server thread for domain socket\")\n+            self.d_thread = ServerThread(self, self.clients, self.d_exit_out, self.debugger, self.plugin_mgr,\n+                voltron.env['sock'])\n+            self.d_thread.start()\n+        if listen['tcp']:\n+            log.debug(\"Starting server thread for TCP socket\")\n+            self.t_thread = ServerThread(self, self.clients, self.t_exit_out, self.debugger, self.plugin_mgr,\n+                tuple(listen['tcp']))\n+            self.t_thread.start()\n+        if voltron.config['server']['listen']['http']:\n+            log.debug(\"Starting server thread for HTTP server\")\n+            (host, port) = tuple(listen['http'])\n+            voltron.http.app.server = self\n+            self.h_thread = HTTPServerThread(self, self.clients, self.debugger, self.plugin_mgr, host, port)\n+            self.h_thread.start()\n \n     def stop(self):\n         # terminate the server thread by writing some data to the exit pipe\n-        log.debug(\"Stopping server thread\")\n-        os.write(self.exit_in, chr(0))\n-        self.thread.join(10)\n+        log.debug(\"Stopping server threads\")\n+        if self.d_thread:\n+            os.write(self.d_exit_in, chr(0))\n+            self.d_thread.join(10)\n+        if self.t_thread:\n+            os.write(self.t_exit_in, chr(0))\n+            self.t_thread.join(10)\n+        if self.h_thread:\n+            self.h_thread.stop()\n \n     def client_summary(self):\n         sums = []\n@@ -51,6 +77,92 @@ class Server(object):\n             sums.append(str(client))\n         return sums\n \n+    def handle_request(self, data, client=None):\n+        req = None\n+        res = None\n+\n+        log.debug(\"Received API request: {}\".format(data))\n+\n+        #\n+        # preprocess the request to make sure the data and environment are OK\n+        #\n+\n+        # make sure we have a debugger, or we're gonna have a bad time\n+        if self.debugger:\n+            # parse incoming request with the top level APIRequest class so we can determine the request type\n+            try:\n+                req = APIRequest(data=data, debugger=self.debugger)\n+            except Exception, e:\n+                req = None\n+                log.error(log.error(\"Exception raised while parsing API request: {}\".format(e)))\n+\n+            if req:\n+                # find the api plugin for the incoming request type\n+                plugin = self.plugin_mgr.api_plugin_for_request(req.request)\n+                if plugin:\n+                    # make sure request class supports the debugger platform we're using\n+                    # XXX do this\n+\n+                    if True:\n+                        # instantiate the request class\n+                        req = plugin.request_class(data=data, debugger=self.debugger)\n+                    else:\n+                        res = APIDebuggerHostNotSupportedErrorResponse()\n+                else:\n+                    res = APIPluginNotFoundErrorResponse()\n+            else:\n+                res = APIInvalidRequestErrorResponse()\n+        else:\n+            res = APIDebuggerNotPresentErrorResponse()\n+\n+        #\n+        # validate and dispatch the request\n+        #\n+\n+        if not res:\n+            # dispatch the request and send the response\n+            if req and req.request == 'wait':\n+                # wait requests get handled in a background thread\n+                t = threading.Thread(target=self.dispatch_request, args=[req, client])\n+                t.start()\n+            else:\n+                # everything else is handled on the main thread\n+                return self.dispatch_request(req, client)\n+        else:\n+            if client:\n+                # already got an error response and we have a client, send it\n+                client.send_response(str(res))\n+            else:\n+                return res\n+\n+    def dispatch_request(self, req, client=None):\n+        \"\"\"\n+        Dispatch a request object.\n+        \"\"\"\n+        # make sure it's valid\n+        res = None\n+        try:\n+            req.validate()\n+        except InvalidMessageException, e:\n+            res = APIInvalidRequestErrorResponse(str(e))\n+\n+        # dispatch the request\n+        if not res:\n+            try:\n+                res = req.dispatch()\n+            except Exception, e:\n+                msg = \"Exception raised while dispatching request: {}\".format(e)\n+                log.error(msg)\n+                res = APIGenericErrorResponse(message=msg)\n+\n+        # send the response\n+        if client:\n+            log.debug(\"Client was passed to dispatch_request() - sending response\")\n+            client.send_response(str(res))\n+        else:\n+            log.debug(\"Client was NOT passed to dispatch_request() - returning response\")\n+            return res\n+\n \n class ServerThread(threading.Thread):\n     \"\"\"\n@@ -60,24 +172,21 @@ class ServerThread(threading.Thread):\n     passes them off to the APIDispatcher to be fulfilled. Then the responses\n     returned (synchronously) are sent back to the requesting client.\n     \"\"\"\n-    def __init__(self, server, clients, exit_pipe, debugger, plugin_mgr):\n+    def __init__(self, server, clients, exit_pipe, debugger, plugin_mgr, sock):\n         threading.Thread.__init__(self)\n         self.server = server\n         self.clients = clients\n         self.exit_pipe = exit_pipe\n         self.debugger = debugger\n         self.plugin_mgr = plugin_mgr\n+        self.sock = sock\n \n     def run(self):\n-        # make sure there's no left over socket\n-        try:\n-            os.remove(voltron.env['sock'])\n-        except:\n-            pass\n+        # make sure there's no left over socket file\n+        self.cleanup_socket()\n \n         # set up the server socket\n-        serv = ServerSocket(voltron.env['sock'])\n-        self.lock = threading.Lock()\n+        serv = ServerSocket(self.sock)\n \n         # main event loop\n         running = True\n@@ -102,12 +211,9 @@ class ServerThread(threading.Thread):\n                     data = None\n                     try:\n                         data = fd.recv_request()\n-                        self.handle_request(data, fd)\n-                    except socket.error:\n-                        log.error(\"Socket error\")\n-                        self.purge_client(fd)\n-                    except SocketDisconnected:\n-                        log.error(\"Socket disconnected\")\n+                        self.server.handle_request(data, fd)\n+                    except Exception, e:\n+                        log.error(\"Exception raised while handling request: {} {}\".format(type(e), str(e)))\n                         self.purge_client(fd)\n \n         # clean up\n@@ -115,10 +221,14 @@ class ServerThread(threading.Thread):\n             self.purge_client(client)\n         os.close(self.exit_pipe)\n         serv.close()\n-        try:\n-            os.remove(voltron.env['sock'])\n-        except:\n-            pass\n+        self.cleanup_socket()\n+\n+    def cleanup_socket(self):\n+        if type(self.sock) == str:\n+            try:\n+                os.remove(self.sock)\n+            except:\n+                pass\n \n     def purge_client(self, client):\n         try:\n@@ -128,88 +238,38 @@ class ServerThread(threading.Thread):\n         if client in self.clients:\n             self.clients.remove(client)\n \n-    def handle_request(self, data, client):\n-        res = None\n-\n-        log.debug(\"Received API request: {}\".format(data))\n \n-        # preprocess the request to determine whether or not it needs to be dispatched in a background thread\n-        try:\n-            req = APIRequest(data=data, debugger=self.debugger)\n-        except Exception, e:\n-            req = None\n-            log.error(log.error(\"Exception raised while parsing API request: {}\".format(e)))\n-\n-        # dispatch the request and send the response\n-        if req and req.request == 'wait':\n-            # wait requests get handled in a background thread\n-            t = threading.Thread(target=self.dispatch_request, args=[data, client])\n-            t.start()\n-        else:\n-            # everything else is handled on the main thread\n-            self.dispatch_request(data, client)\n-\n-    def dispatch_request(self, data, client):\n-        \"\"\"\n-        Dispatch an API request. This method parses the data, determines the\n-        request type, looks up the appropriate plugin, uses it to carry out\n-        the request and sends the response to the client.\n-\n-        This function may be run in a background thread in order to process a\n-        request that blocks without interfering with the main thread.\n-        \"\"\"\n-        # make sure we have a debugger, or we're gonna have a bad time\n-        if self.debugger:\n-            # parse incoming request with the top level APIRequest class so we can determine the request type\n-            try:\n-                req = APIRequest(data=data, debugger=self.debugger)\n-            except Exception, e:\n-                req = None\n-                log.error(log.error(\"Exception raised while parsing API request: {}\".format(e)))\n-\n-            if req:\n-                # find the api plugin for the incoming request type\n-                plugin = self.plugin_mgr.api_plugin_for_request(req.request)\n-                if plugin:\n-                    # make sure request class supports the debugger platform we're using\n-                    # XXX do this\n+class HTTPServerThread(threading.Thread):\n+    \"\"\"\n+    Background thread to run the HTTP server.\n+    \"\"\"\n+    def __init__(self, server, clients, debugger, plugin_mgr, host=\"127.0.0.1\", port=6969):\n+        threading.Thread.__init__(self)\n+        self.server = server\n+        self.clients = clients\n+        self.debugger = debugger\n+        self.plugin_mgr = plugin_mgr\n+        self.host = host\n+        self.port = port\n \n-                    if True:\n-                        # instantiate the request class\n-                        req = plugin.request_class(data=data, debugger=self.debugger)\n+    def run(self):\n+        # graft the flask app (see http.py) onto the cherry tree\n+        cherrypy.tree.graft(voltron.http.app, '/')\n \n-                        # make sure it's valid\n-                        res = None\n-                        try:\n-                            req.validate()\n-                        except InvalidMessageException, e:\n-                            res = APIInvalidRequestErrorResponse(str(e))\n-\n-                        if not res:\n-                            # dispatch the request\n-                            try:\n-                                res = req.dispatch()\n-                            except Exception, e:\n-                                msg = \"Exception raised while dispatching request: {}\".format(e)\n-                                log.error(msg)\n-                                res = APIGenericErrorResponse(message=msg)\n-                    else:\n-                        res = APIDebuggerHostNotSupportedErrorResponse()\n-                else:\n-                    res = APIPluginNotFoundErrorResponse()\n-            else:\n-                res = APIInvalidRequestErrorResponse()\n-        else:\n-            res = APIDebuggerNotPresentErrorResponse()\n+        # configure the cherrypy server\n+        cherrypy.config.update({\n+            'engine.autoreload.on': True,\n+            'log.screen': False,\n+            'server.socket_port': self.port,\n+            'server.socket_host': str(self.host)\n+        })\n \n-        log.debug(\"Returning API response: {} {}\".format(type(res), str(res)))\n+        # make with the serving\n+        cherrypy.engine.start()\n+        cherrypy.engine.block()\n \n-        # send the response\n-        try:\n-            client.send_response(str(res))\n-        except Exception, e:\n-            log.error(\"Exception {} sending response: {}\".format(type(e), e))\n-            self.purge_client(client)\n+    def stop(self):\n+        cherrypy.engine.exit()\n \n \n class Client(object):\n@@ -287,15 +347,7 @@ class Client(object):\n         plugin, whose request class is instantiated and passed the remaining\n         arguments passed to this function.\n         \"\"\"\n-        # look up the plugin\n-        plugin = self.plugin_mgr.api_plugin_for_request(request_type)\n-        if plugin and plugin.request_class:\n-            #create a request\n-            req = plugin.request_class(*args, **kwargs)\n-        else:\n-            raise InvalidRequestTypeException()\n-\n-        return req\n+        return self.plugin_mgr.api_request(request_type, *args, **kwargs)\n \n     def perform_request(self, request_type, *args, **kwargs):\n         \"\"\"\n@@ -306,7 +358,7 @@ class Client(object):\n         arguments passed to this function.\n         \"\"\"\n         # create a request\n-        req = self.create_request(request_type, *args, **kwargs)\n+        req = self.plugin_mgr.api_request(request_type, *args, **kwargs)\n \n         # send it\n         res = self.send_request(req)\n@@ -339,9 +391,12 @@ class ServerSocket(BaseSocket):\n     \"\"\"\n     Server socket for accepting new client connections.\n     \"\"\"\n-    def __init__(self, sockfile):\n-        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n-        self.sock.bind(sockfile)\n+    def __init__(self, sock):\n+        if type(sock) == str:\n+            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n+        elif type(sock) == tuple:\n+            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self.sock.bind(sock)\n         self.sock.listen(1)\n \n     def accept(self):\n@@ -371,4 +426,3 @@ class ClientSocket(BaseSocket):\n \n     def send_response(self, response):\n         self.send(response)\n-\ndiff --git a/voltron/plugin.py b/voltron/plugin.py\nindex ec6f22c..b7d898d 100644\n--- a/voltron/plugin.py\n+++ b/voltron/plugin.py\n@@ -128,6 +128,24 @@ class PluginManager(object):\n         \"\"\"\n         return self.view_plugins[host]\n \n+    def api_request(self, request_type, *args, **kwargs):\n+        \"\"\"\n+        Create an API request.\n+\n+        `request_type` is the request type (string). This is used to look up a\n+        plugin, whose request class is instantiated and passed the remaining\n+        arguments passed to this function.\n+        \"\"\"\n+        # look up the plugin\n+        plugin = self.api_plugin_for_request(request_type)\n+        if plugin and plugin.request_class:\n+            #create a request\n+            req = plugin.request_class(*args, **kwargs)\n+        else:\n+            raise InvalidRequestTypeException()\n+\n+        return req\n+\n \n class APIPlugin(Plugin):\n     \"\"\"\n@@ -182,3 +200,38 @@ class ViewPlugin(Plugin):\n     plugin_type = 'view'\n     name = None\n     view_class = None\n+\n+\n+#\n+# Shared plugin manager and convenience methods\n+#\n+\n+pm = None\n+\n+def api_request(request, *args, **kwargs):\n+    plugin = pm.api_plugin_for_request(request)\n+    if plugin:\n+        return plugin.request_class(*args, **kwargs)\n+    else:\n+        return None\n+\n+def api_response(request, *args, **kwargs):\n+    plugin = pm.api_plugin_for_request(request)\n+    if plugin:\n+        return plugin.response_class(*args, **kwargs)\n+    else:\n+        return None\n+\n+def debugger_adaptor(host, *args, **kwargs):\n+    plugin = pm.debugger_plugin_for_host(host)\n+    if plugin:\n+        return plugin.adaptor_class(*args, **kwargs)\n+    else:\n+        return None\n+\n+def view(name, *args, **kwargs):\n+    plugin = pm.view_plugin_with_name(name)\n+    if plugin:\n+        return plugin.view_class(*args, **kwargs)\n+    else:\n+        return None\ndiff --git a/voltron/plugins/api/disassemble.py b/voltron/plugins/api/disassemble.py\nindex 51aa8aa..c71a87f 100644\n--- a/voltron/plugins/api/disassemble.py\n+++ b/voltron/plugins/api/disassemble.py\n@@ -65,7 +65,7 @@ class APIDisassembleRequest(APIRequest):\n \n     @target_id.setter\n     def target_id(self, value):\n-        self.data['target_id'] = value\n+        self.data['target_id'] = int(value)\n \n     @property\n     def count(self):\n@@ -73,7 +73,7 @@ class APIDisassembleRequest(APIRequest):\n \n     @count.setter\n     def count(self, value):\n-        self.data['count'] = value\n+        self.data['count'] = int(value)\n \n     @property\n     def address(self):\n@@ -81,7 +81,7 @@ class APIDisassembleRequest(APIRequest):\n \n     @address.setter\n     def address(self, value):\n-        self.data['address'] = value\n+        self.data['address'] = int(value)\n \n \n class APIDisassembleResponse(APISuccessResponse):\n@@ -102,7 +102,7 @@ class APIDisassembleResponse(APISuccessResponse):\n \n     @disassembly.setter\n     def disassembly(self, value):\n-        self.data['disassembly'] = value\n+        self.data['disassembly'] = str(value)\n \n \n class APIDisassemblePlugin(APIPlugin):\ndiff --git a/voltron/plugins/api/execute_command.py b/voltron/plugins/api/execute_command.py\nindex 11a5169..aaded3d 100644\n--- a/voltron/plugins/api/execute_command.py\n+++ b/voltron/plugins/api/execute_command.py\n@@ -46,7 +46,7 @@ class APIExecuteCommandRequest(APIRequest):\n \n     @command.setter\n     def command(self, value):\n-        self.data['command'] = value\n+        self.data['command'] = str(value)\n \n \n class APIExecuteCommandResponse(APISuccessResponse):\n@@ -67,7 +67,7 @@ class APIExecuteCommandResponse(APISuccessResponse):\n \n     @output.setter\n     def output(self, value):\n-        self.data['output'] = value\n+        self.data['output'] = str(value)\n \n \n class APIExecuteCommandPlugin(APIPlugin):\ndiff --git a/voltron/plugins/api/read_memory.py b/voltron/plugins/api/read_memory.py\nindex 120aa88..c1996e0 100644\n--- a/voltron/plugins/api/read_memory.py\n+++ b/voltron/plugins/api/read_memory.py\n@@ -79,7 +79,7 @@ class APIReadMemoryRequest(APIRequest):\n \n     @target_id.setter\n     def target_id(self, value):\n-        self.data['target_id'] = value\n+        self.data['target_id'] = int(value)\n \n \n \ndiff --git a/voltron/plugins/api/read_stack.py b/voltron/plugins/api/read_stack.py\nindex 1fc6821..2857acf 100644\n--- a/voltron/plugins/api/read_stack.py\n+++ b/voltron/plugins/api/read_stack.py\n@@ -65,7 +65,7 @@ class APIReadStackRequest(APIRequest):\n \n     @target_id.setter\n     def target_id(self, value):\n-        self.data['target_id'] = value\n+        self.data['target_id'] = int(value)\n \n     @property\n     def thread_id(self):\n@@ -73,7 +73,7 @@ class APIReadStackRequest(APIRequest):\n \n     @thread_id.setter\n     def thread_id(self, value):\n-        self.data['thread_id'] = value\n+        self.data['thread_id'] = int(value)\n \n     @property\n     def length(self):\n@@ -115,7 +115,7 @@ class APIReadStackResponse(APISuccessResponse):\n \n     @stack_pointer.setter\n     def stack_pointer(self, value):\n-        self.data['stack_pointer'] = value\n+        self.data['stack_pointer'] = int(value)\n \n \n \ndiff --git a/voltron/plugins/api/state.py b/voltron/plugins/api/state.py\nindex 234f6c7..44e46e0 100644\n--- a/voltron/plugins/api/state.py\n+++ b/voltron/plugins/api/state.py\n@@ -44,7 +44,7 @@ class APIStateRequest(APIRequest):\n \n     @target_id.setter\n     def target_id(self, value):\n-        self.data['target_id'] = value\n+        self.data['target_id'] = int(value)\n \n \n class APIStateResponse(APISuccessResponse):\n@@ -64,7 +64,7 @@ class APIStateResponse(APISuccessResponse):\n \n     @state.setter\n     def state(self, value):\n-        self.data['state'] = value\n+        self.data['state'] = str(value)\n \n \n class APIStatePlugin(APIPlugin):\ndiff --git a/voltron/plugins/api/version.py b/voltron/plugins/api/version.py\nindex 2e58afe..e9c0a7f 100644\n--- a/voltron/plugins/api/version.py\n+++ b/voltron/plugins/api/version.py\n@@ -41,7 +41,7 @@ class APIVersionResponse(APISuccessResponse):\n \n     @api_version.setter\n     def api_version(self, value):\n-        self.data['api_version'] = value\n+        self.data['api_version'] = float(value)\n \n     @property\n     def host_version(self):\n@@ -49,7 +49,7 @@ class APIVersionResponse(APISuccessResponse):\n \n     @host_version.setter\n     def host_version(self, value):\n-        self.data['host_version'] = value\n+        self.data['host_version'] = str(value)\n \n \n \ndiff --git a/voltron/plugins/api/wait.py b/voltron/plugins/api/wait.py\nindex f94e37e..2d64a5c 100644\n--- a/voltron/plugins/api/wait.py\n+++ b/voltron/plugins/api/wait.py\n@@ -72,7 +72,7 @@ class APIWaitRequest(APIRequest):\n \n     @target_id.setter\n     def target_id(self, value):\n-        self.data['target_id'] = value\n+        self.data['target_id'] = int(value)\n \n     @property\n     def state_changes(self):\n@@ -88,7 +88,7 @@ class APIWaitRequest(APIRequest):\n \n     @timeout.setter\n     def timeout(self, value):\n-        self.data['timeout'] = value\n+        self.data['timeout'] = float(value)\n \n \n class APIWaitResponse(APISuccessResponse):\n@@ -108,7 +108,7 @@ class APIWaitResponse(APISuccessResponse):\n \n     @state.setter\n     def state(self, value):\n-        self.data['state'] = value\n+        self.data['state'] = str(value)\n \n \n \ndiff --git a/voltron/view.py b/voltron/view.py\nindex 485eea5..57ddc6a 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -265,3 +265,12 @@ class TerminalView (VoltronView):\n             pad = 0\n \n         self.body += int(pad)*'\\n'\n+\n+\n+def merge(d1, d2):\n+    for k1,v1 in d1.items():\n+        if isinstance(v1, dict) and k1 in d2.keys() and isinstance(d2[k1], dict):\n+            merge(v1, d2[k1])\n+        else:\n+            d2[k1] = v1\n+    return d2\n\\ No newline at end of file\n"}
{"repo": "voltron", "commit": "90c33b43250eb0a8465f5a313b73af0bc0ece3de", "diff": "diff --git a/voltron/comms.py b/voltron/comms.py\nindex f2362a2..5396b5c 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -201,6 +201,9 @@ class Server (object):\n                 pass\n         client.send_event(resp)\n \n+    def cleanup(self):\n+        pass\n+\n \n # Wrapper for a ServerThread to run in standalone mode for debuggers without python support\n class StandaloneServer(Server):\n@@ -210,6 +213,7 @@ class StandaloneServer(Server):\n         sp.set_defaults(func=StandaloneServer)\n \n     def __init__(self, args={}, loaded_config={}):\n+        super(StandaloneServer, self).__init__()\n         self.args = args\n \n     def run(self):\n"}
{"repo": "voltron", "commit": "137da51720c684711fde8c67c9994da99d0d7cc4", "diff": "diff --git a/voltron/comms.py b/voltron/comms.py\nindex 60d00ed..33e7965 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -114,7 +114,7 @@ class InteractiveClient(Client):\n         if self.callback_thread:\n             return self.pending.get()\n         else:\n-            return _recv()\n+            return self._recv()\n \n     def _recv(self):\n         return super(InteractiveClient, self).recv()\n"}
{"repo": "voltron", "commit": "4e993f8122dffa5c47b78525541782c9b48a25ed", "diff": "diff --git a/voltron/comms.py b/voltron/comms.py\nindex 60d00ed..33e7965 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -114,7 +114,7 @@ class InteractiveClient(Client):\n         if self.callback_thread:\n             return self.pending.get()\n         else:\n-            return _recv()\n+            return self._recv()\n \n     def _recv(self):\n         return super(InteractiveClient, self).recv()\n"}
{"repo": "voltron", "commit": "d8006a43a8cc1142f75a5e6ec1593df04f7b8378", "diff": "diff --git a/voltron/gdbcmd.py b/voltron/gdbcmd.py\nindex 7037491..d3fe108 100644\n--- a/voltron/gdbcmd.py\n+++ b/voltron/gdbcmd.py\n@@ -58,7 +58,7 @@ class GDBHelper (DebuggerHelper):\n         try:\n             return gdb.selected_frame().architecture().name()\n         except:\n-            return re.search('\\(currently (.*)\\)', gdb.execute('show architecture', to_string=True)).groups(0)\n+            return re.search('\\(currently (.*)\\)', gdb.execute('show architecture', to_string=True)).group(1)\n \n     @staticmethod\n     def helper():\n"}
{"repo": "voltron", "commit": "96d4c513856af33a0cb547dbd1f47337d9b51a1b", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 6c4b3e2..9bb0eff 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -691,7 +691,7 @@ class RegisterView (TerminalView):\n             if values['c'] or values['z']:\n                 j = (True, 'c || z')\n             else:\n-                j = (True, '!c && !z')\n+                j = (False, '!c && !z')\n         elif inst in ['jcxz', 'jecxz', 'jrcxz']:\n             if self.get_arch() == 'x64':\n                 cx = regs['rcx']\n"}
{"repo": "voltron", "commit": "52313b035e9ac1781be4d28f0f3104f03f9ec1d0", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 22cf858..3ea1bf5 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -691,7 +691,7 @@ class RegisterView (TerminalView):\n             if values['c'] or values['z']:\n                 j = (True, 'c || z')\n             else:\n-                j = (True, '!c && !z')\n+                j = (False, '!c && !z')\n         elif inst in ['jcxz', 'jecxz', 'jrcxz']:\n             if self.get_arch() == 'x64':\n                 cx = regs['rcx']\n"}
{"repo": "voltron", "commit": "44063e1f792e6619676c8e323337d364a238240c", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 22cf858..6c4b3e2 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -718,9 +718,9 @@ class RegisterView (TerminalView):\n                 j = (False, 's!=o')\n         elif inst in ['jl', 'jnge']:\n             if values['s'] == values['o']:\n-                j = (True, 's!=o')\n-            else:\n                 j = (False, 's==o')\n+            else:\n+                j = (True, 's!=o')\n         elif inst in ['jle', 'jng']:\n             if values['z'] or values['s'] == values['o']:\n                 j = (True, 'z || s==o')\n"}
{"repo": "voltron", "commit": "4c1e1dbe062e9716d8d71ac386466acf67786688", "diff": "diff --git a/setup.py b/setup.py\nindex c2d532d..8d7e76d 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -10,7 +10,7 @@ setup(\n     keywords = \"voltron gdb lldb\",\n     url = \"https://github.com/snarez/voltron\",\n     packages=['voltron'],\n-    install_requires = [],\n+    install_requires = ['rl'],\n     data_files=['voltron.gdb', 'dbgentry.py'],\n     package_data = {'voltron': ['config/*']},\n     install_package_data = True,\n"}
{"repo": "voltron", "commit": "e2550db0357a043853e143ae17e96064ded00c87", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 22cf858..6c4b3e2 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -718,9 +718,9 @@ class RegisterView (TerminalView):\n                 j = (False, 's!=o')\n         elif inst in ['jl', 'jnge']:\n             if values['s'] == values['o']:\n-                j = (True, 's!=o')\n-            else:\n                 j = (False, 's==o')\n+            else:\n+                j = (True, 's!=o')\n         elif inst in ['jle', 'jng']:\n             if values['z'] or values['s'] == values['o']:\n                 j = (True, 'z || s==o')\n"}
{"repo": "voltron", "commit": "404c83a98c6cbad895e369308cf9979b9ced55cc", "diff": "diff --git a/dbgentry.py b/dbgentry.py\nindex 53ba0ca..637cb0d 100644\n--- a/dbgentry.py\n+++ b/dbgentry.py\n@@ -29,9 +29,9 @@ if in_gdb:\n     # Called when the module is loaded by gdb\n     if __name__ == \"__main__\":\n         log.debug('Initialising GDB command')\n-        print(\"Voltron loaded.\")\n         inst = voltron.gdbcmd.VoltronGDBCommand()\n         voltron.cmd.inst = inst\n+        print(\"Voltron loaded.\")\n \n if not in_lldb and not in_gdb:\n     print(\"Something wicked this way comes\")\ndiff --git a/voltron/cmd.py b/voltron/cmd.py\nindex e2df3f2..7f5e60a 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -57,6 +57,7 @@ class VoltronCommand (object):\n     def start_server(self):\n         if self.server == None:\n             self.server = Server()\n+            self.server.base_helper = self.base_helper\n             self.server.start()\n         else:\n             log.debug(\"Server thread is already running\")\n@@ -69,48 +70,17 @@ class VoltronCommand (object):\n             log.debug(\"Server thread is not running\")\n \n     def status(self):\n-        if self.running:\n-            if self.server != None:\n-                print(\"There are {} clients attached\".format(len(self.server.clients)))\n-                for client in self.server.clients:\n-                    print(\"{} registered with type: {}\".format(client, str(client.registration['config']['type'])))\n-            else:\n-                print(\"Server is not running (no inferior)\")\n+        if self.server != None:\n+            summs = self.server.client_summary()\n+            print(\"There are {} clients attached:\".format(len(summs)))\n+            for summary in summs:\n+                print(summary)\n         else:\n-            print(\"Not running\")\n+            print(\"Server is not running (no inferior)\")\n \n     def update(self):\n         log.debug(\"Updating clients\")\n-\n-        # Make sure we have a target\n-        if not self.base_helper.has_target():\n-            return\n-\n-        # Make sure we have a server and helper running\n-        if self.server == None:\n-            self.start_server()\n-        if self.helper == None:\n-            self.helper = self.base_helper.helper()\n-\n-        # Process updates for registered clients\n-        log.debug(\"Processing updates\")\n-        for client in filter(lambda c: c.registration['config']['update_on'] == 'stop', self.server.clients):\n-            event = {'msg_type': 'update', 'arch': self.helper.arch_group}\n-            if client.registration['config']['type'] == 'cmd':\n-                event['data'] = self.helper.get_cmd_output(client.registration['config']['cmd'])\n-            elif client.registration['config']['type'] == 'register':\n-                event['data'] = {'regs': self.helper.get_registers(), 'inst': self.helper.get_next_instruction()}\n-            elif client.registration['config']['type'] == 'disasm':\n-                event['data'] = self.helper.get_disasm()\n-            elif client.registration['config']['type'] == 'stack':\n-                event['data'] = {'data': self.helper.get_stack(), 'sp': self.helper.get_sp()}\n-            elif client.registration['config']['type'] == 'bt':\n-                event['data'] = self.helper.get_backtrace()\n-\n-            try:\n-                client.send_event(event)\n-            except socket.error:\n-                self.server.purge_client(client)\n+        self.server.update_clients()\n \n     # These methods are overridden by the debugger-specific classes\n     def register_hooks(self):\ndiff --git a/voltron/comms.py b/voltron/comms.py\nindex 69f5051..0167485 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -22,6 +22,11 @@ queue = Queue.Queue()\n \n log = configure_logging()\n \n+#\n+# Classes shared between client and server\n+#\n+\n+# Base socket class\n class BaseSocket(object):\n     def fileno(self):\n         return self.sock.fileno()\n@@ -32,8 +37,14 @@ class BaseSocket(object):\n     def send(self, buf):\n         self.sock.send(buf)\n \n+\n class SocketDisconnected(Exception): pass\n \n+\n+#\n+# Client-side classes\n+#\n+\n # Socket to register with the server and receive messages, calls view's render() method when a message comes in\n class Client(BaseSocket):\n     def __init__(self, view=None, config={}):\n@@ -84,6 +95,8 @@ class Client(BaseSocket):\n             log.debug('Empty read')\n             raise SocketDisconnected(\"socket closed\")\n \n+\n+# Used by calculon\n class InteractiveClient(Client):\n     def query(self, msg):\n         self.send(pickle.dumps(msg))\n@@ -92,15 +105,26 @@ class InteractiveClient(Client):\n             return pickle.loads(resp)\n \n \n-# Wrapper for a ServerThread to run in the context of a debugger host\n+#\n+# Server-side classes\n+#\n+\n+# Wrapper for a ServerThread to run in the context of a debugger host. Responsible for:\n+# - Collecting clients (populated by ServerThread)\n+# - Providing summaries of connected clients to the host DebuggerCommand or Console\n+# - Collecting data from a DebuggerHelper and sending out updates\n+# - Responding to requests from interactive clients\n+# - Handling push updates from proxy clients\n class Server (object):\n     def __init__(self):\n         self._clients = []\n         self.exit_out, self.exit_in = os.pipe()\n+        self.base_helper = None\n+        self.helper = None\n \n     def start(self):\n         log.debug(\"Starting server thread\")\n-        self.thread = ServerThread(self._clients, self.exit_out)\n+        self.thread = ServerThread(self, self._clients, self.exit_out)\n         self.thread.start()\n \n     def stop(self):\n@@ -112,6 +136,71 @@ class Server (object):\n     def clients(self):\n         return self._clients\n \n+    def client_summary(self):\n+        return [str(c) + ': ' + c.registration['config']['type'] for c in self._clients]\n+\n+    def refresh_helper(self):\n+        # if we don't have a helper, or the one we have is for the wrong architecture, get a new one\n+        if self.helper == None or self.helper != None and self.helper.get_arch() not in self.helper.archs:\n+            self.helper = self.base_helper.helper()\n+\n+    def update_clients(self):\n+        log.debug(\"Updating clients\")\n+\n+        # Make sure we have a target\n+        if not self.base_helper.has_target():\n+            return\n+\n+        # Make sure we have a helper\n+        self.refresh_helper()\n+\n+        # Process updates for registered clients\n+        log.debug(\"Processing updates\")\n+        for client in filter(lambda c: c.registration['config']['update_on'] == 'stop', self._clients):\n+            event = {'msg_type': 'update', 'arch': self.helper.arch_group}\n+            if client.registration['config']['type'] == 'cmd':\n+                event['data'] = self.helper.get_cmd_output(client.registration['config']['cmd'])\n+            elif client.registration['config']['type'] == 'register':\n+                event['data'] = {'regs': self.helper.get_registers(), 'inst': self.helper.get_next_instruction()}\n+            elif client.registration['config']['type'] == 'disasm':\n+                event['data'] = self.helper.get_disasm()\n+            elif client.registration['config']['type'] == 'stack':\n+                event['data'] = {'data': self.helper.get_stack(), 'sp': self.helper.get_sp()}\n+            elif client.registration['config']['type'] == 'bt':\n+                event['data'] = self.helper.get_backtrace()\n+\n+            try:\n+                client.send_event(event)\n+            except socket.error:\n+                self.server.purge_client(client)\n+\n+    def handle_push_update(self, client, msg):\n+        log.debug('Got a push update from client {} of type {} with data: {}'.format(self, msg['update_type'], str(msg['data'])))\n+        event = {'msg_type': 'update', 'data': msg['data']}\n+        for c in self._clients:\n+            if c.registration != None and c.registration['config']['type'] == msg['update_type']:\n+                c.send_event(event)\n+        client.send_event(pickle.dumps({'msg_type': 'ack'}))\n+\n+    def handle_interactive_query(self, client, msg):\n+        log.debug('Got an interactive query from client {} of type {}'.format(self, msg['query']))\n+        resp = {'value': None}\n+        if msg['query'] == 'get_register':\n+            reg = msg['register']\n+            registers = self.helper.get_registers()\n+            if reg in registers:\n+                resp['value'] = registers[reg]\n+        elif msg['query'] == 'get_memory':\n+            try:\n+                start = int(msg['start'])\n+                end = int(msg['end'])\n+                length = end - start\n+                assert(length > 0)\n+                resp['value'] = self.helper.get_memory(start, length)\n+            except:\n+                pass\n+        client.send_event(resp)\n+\n \n # Wrapper for a ServerThread to run in standalone mode for debuggers without python support\n class StandaloneServer(Server):\n@@ -130,10 +219,10 @@ class StandaloneServer(Server):\n             time.sleep(1)\n \n \n-# Thread spun off when the server is started to listen for incoming client connections, and send out any\n-# events that have been queued by the hooks in the debugger command class\n+# Thread spun off when the server is started to listen for incoming client connections\n class ServerThread(threading.Thread):\n-    def __init__(self, clients, exit_pipe):\n+    def __init__(self, server, clients, exit_pipe):\n+        self.server = server\n         self.clients = clients\n         self.exit_pipe = exit_pipe\n         threading.Thread.__init__(self)\n@@ -156,7 +245,9 @@ class ServerThread(threading.Thread):\n             rfds, _, _ = select.select(_rfds, [], [])\n             for i in rfds:\n                 if i == serv:\n-                    self.clients.append(i.accept())\n+                    client = i.accept()\n+                    client.server = self.server\n+                    self.clients.append(client)\n                 elif i == self.exit_pipe:\n                     # Flush the pipe\n                     os.read(self.exit_pipe, 1)\n@@ -184,7 +275,7 @@ class ServerThread(threading.Thread):\n         self.clients.remove(client)\n \n \n-# Socket for talking to an individual client\n+# Socket for talking to an individual client, collected by Server/ServerThread\n class ClientHandler(BaseSocket):\n     def __init__(self, sock):\n         self.sock = sock\n@@ -193,6 +284,7 @@ class ClientHandler(BaseSocket):\n     def read(self):\n         data = self.sock.recv(READ_MAX)\n         if len(data.strip()):\n+            # receive message\n             try:\n                 msg = pickle.loads(data)\n                 log.debug('Received msg: ' + str(msg))\n@@ -201,54 +293,24 @@ class ClientHandler(BaseSocket):\n                 log.error('Invalid message data: ' + str(data))\n                 return\n \n+            # store registration or dispatch message to server\n             if msg['msg_type'] == 'register':\n-                self.handle_register(msg)\n+                log.debug('Registering client {} with config: {}'.format(self, str(msg['config'])))\n+                self.registration = msg\n             elif msg['msg_type'] == 'push_update':\n-                self.handle_push_update(msg)\n+                self.server.handle_push_update(self, msg)\n             elif msg['msg_type'] == 'interactive':\n-                self.handle_interactive_query(msg)\n+                self.server.handle_interactive_query(self, msg)\n             else:\n                 log.error('Invalid message type: ' + msg['msg_type'])\n         else:\n             raise SocketDisconnected(\"socket closed\")\n \n-    def handle_register(self, msg):\n-        log.debug('Registering client {} with config: {}'.format(self, str(msg['config'])))\n-        self.registration = msg\n-\n-    def handle_push_update(self, msg):\n-        log.debug('Got a push update from client {} of type {} with data: {}'.format(self, msg['update_type'], str(msg['data'])))\n-        event = {'msg_type': 'update', 'data': msg['data']}\n-        for client in clients:\n-            if client.registration != None and client.registration['config']['type'] == msg['update_type']:\n-                queue.put((client, event))\n-        self.send(pickle.dumps({'msg_type': 'ack'}))\n-\n-    def handle_interactive_query(self, msg):\n-        log.debug('Got an interactive query from client {} of type {}'.format(self, msg['query']))\n-        helper = voltron.cmd.inst.helper\n-        resp = {'value': None}\n-        if msg['query'] == 'get_register':\n-            reg = msg['register']\n-            registers = helper.get_registers()\n-            if reg in registers:\n-                resp['value'] = registers[reg]\n-        elif msg['query'] == 'get_memory':\n-            try:\n-                start = int(msg['start'])\n-                end = int(msg['end'])\n-                length = end - start\n-                assert(length > 0)\n-                resp['value'] = helper.get_memory(start, length)\n-            except:\n-                pass\n-\n-        self.send_event(resp)\n-\n     def send_event(self, event):\n         log.debug('Sending event to client {}: {}'.format(self, event))\n         self.send(pickle.dumps(event))\n \n+\n # Main server socket for accept()s\n class ServerSocket(BaseSocket):\n     def __init__(self, sockfile):\ndiff --git a/voltron/console.py b/voltron/console.py\nindex 623ae7a..be381db 100644\n--- a/voltron/console.py\n+++ b/voltron/console.py\n@@ -45,11 +45,15 @@ class Console(object):\n         # set up lldb command interpreter\n         self.ci = self.dbg.GetCommandInterpreter()\n \n+        # set up voltron server\n+        self.server = Server()\n+        self.server.base_helper = LLDBHelper\n+        self.server.start()\n+\n         # set up voltron console command\n         self.cmd = VoltronLLDBConsoleCommand()\n-        voltron.cmd.inst = self.cmd\n-        self.cmd.start()\n-        self.cmd.start_server()\n+        self.cmd.server = self.server\n+        voltron.lldbcmd.inst = self.cmd\n \n     def run(self):\n         # print banner\ndiff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex 629f184..896c1bc 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -11,14 +11,15 @@ from .common import *\n log = configure_logging()\n inst = None\n \n+\n class VoltronLLDBCommand (VoltronCommand):\n     def __init__(self, debugger, dict):\n+        super(VoltronCommand, self).__init__()\n         self.debugger = debugger\n-        debugger.HandleCommand('command script add -f dbgentry.lldb_invoke voltron')\n-        self.base_helper = LLDBHelper\n+        lldb.debugger.HandleCommand('command script add -f dbgentry.lldb_invoke voltron')\n         self.running = False\n         self.server = None\n-        self.helper = None\n+        self.base_helper = LLDBHelper\n \n     def invoke(self, debugger, command, result, dict):\n         self.handle_command(command)\n@@ -38,15 +39,11 @@ class VoltronLLDBCommand (VoltronCommand):\n \n class VoltronLLDBConsoleCommand (VoltronCommand):\n     def __init__(self):\n-        self.base_helper = LLDBHelper\n+        # we just add a reference to a dummy script, and intercept calls to `voltron` in the console\n+        # this kinda sucks, but it'll do for now\n+        lldb.debugger.HandleCommand('command script add -f xxx voltron')\n         self.running = False\n         self.server = None\n-        self.helper = None\n-\n-    def start(self):\n-        if self.server == None:\n-            self.start_server()\n-        super(VoltronLLDBConsoleCommand, self).start()\n \n \n class LLDBHelper (DebuggerHelper):\n@@ -60,13 +57,13 @@ class LLDBHelper (DebuggerHelper):\n         return lldb.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n \n     @staticmethod\n-    def get_arch(self):\n+    def get_arch():\n         return lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n \n     @staticmethod\n     def helper():\n         if LLDBHelper.has_target():\n-            arch = lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n+            arch = LLDBHelper.get_arch()\n             for cls in LLDBHelper.__subclasses__():\n                 if hasattr(cls, 'archs') and arch in cls.archs:\n                     inst = cls()\ndiff --git a/voltron/main.py b/voltron/main.py\nindex d1ae388..9583a42 100755\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -5,6 +5,7 @@ import argparse\n import logging\n import logging.config\n import struct\n+import traceback\n \n from .view import *\n from .comms import *\n@@ -50,7 +51,7 @@ def main(debugger=None, dict=None):\n     try:\n         inst.run()\n     except Exception as e:\n-        log.error(\"Exception running module {}: {}\".format(inst.__class__.__name__, sys.exc_info()))\n+        log.error(\"Exception running module {}: {}\".format(inst.__class__.__name__, traceback.format_exc()))\n     except KeyboardInterrupt:\n         pass\n     inst.cleanup()\n"}
{"repo": "voltron", "commit": "6d26440d10eda907fddd5dc303dea89d9c92447a", "diff": "diff --git a/voltron/common.py b/voltron/common.py\nindex ad612d9..63d120b 100644\n--- a/voltron/common.py\n+++ b/voltron/common.py\n@@ -25,12 +25,12 @@ LOG_CONFIG = {\n             'class': 'logging.FileHandler',\n             'formatter': 'standard',\n             'filename': 'voltron.debug.' + str(os.getpid()),\n-            'filters': ['debug_only']\n+            'delay': True\n         }\n     },\n     'loggers': {\n         'voltron': {\n-            'handlers': ['default'],\n+            'handlers': ['default', 'debug_file'],\n             'level': 'INFO',\n             'propogate': True,\n         }\n@@ -47,8 +47,6 @@ class DebugMaxFilter(logging.Filter):\n \n def configure_logging():\n     logging.config.dictConfig(LOG_CONFIG)\n-    logging_inited = True\n-\n     log = logging.getLogger('voltron')\n     return log\n \n"}
{"repo": "voltron", "commit": "1ea0dd1ea6777bf2fc1262b174eadea7320cc727", "diff": "diff --git a/voltron/remote_debugger.py b/voltron/rdb.py\nsimilarity index 94%\nrename from voltron/remote_debugger.py\nrename to voltron/rdb.py\nindex 49b88fe..62b8bdb 100644\n--- a/voltron/remote_debugger.py\n+++ b/voltron/rdb.py\n@@ -2,9 +2,9 @@ import pdb\n import socket\n import sys\n \n-# Trying to debug a quirk in some code that gets called async by {ll,d}db?\n+# Trying to debug a quirk in some code that gets called async by {ll,g}db?\n #\n-# from .remote_debugger import Rdb\n+# from .rdb import Rdb\n # Rdb().set_trace()\n #\n # Then: telnet localhost 4444\n"}
{"repo": "voltron", "commit": "b52553eb6131e64128f8c67c84080acc8571a185", "diff": "diff --git a/voltron/cmd.py b/voltron/cmd.py\nindex ab38f36..e2df3f2 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -70,9 +70,12 @@ class VoltronCommand (object):\n \n     def status(self):\n         if self.running:\n-            print(\"There are {} clients attached\".format(len(self.server.clients)))\n-            for client in self.server.clients:\n-                print(\"{} registered with type: {}\".format(client, str(client.registration['config']['type'])))\n+            if self.server != None:\n+                print(\"There are {} clients attached\".format(len(self.server.clients)))\n+                for client in self.server.clients:\n+                    print(\"{} registered with type: {}\".format(client, str(client.registration['config']['type'])))\n+            else:\n+                print(\"Server is not running (no inferior)\")\n         else:\n             print(\"Not running\")\n \n"}
{"repo": "voltron", "commit": "1b00674276acd465ca69b78d6ea91aa9467ed92f", "diff": "diff --git a/voltron/gdbcmd.py b/voltron/gdbcmd.py\nindex e2aca67..794bd76 100644\n--- a/voltron/gdbcmd.py\n+++ b/voltron/gdbcmd.py\n@@ -135,14 +135,12 @@ class GDBHelperX86 (GDBHelper):\n         return vals\n \n     def get_registers_sse(self, num=8):\n+        # the old way of doing this randomly crashed gdb or threw a python exception\n         regs = {}\n-        for i in range(num):\n-            reg = 'xmm'+str(i)\n-            try:\n-                regs[reg] = int(str(gdb.parse_and_eval('$'+reg+'.uint128')), 16) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n-            except:\n-                log.debug('Failed getting reg: ' + reg)\n-                regs[reg] = 'N/A'\n+        for line in gdb.execute('info all-registers', to_string=True).split('\\n'):\n+            m = re.match('^(xmm\\d+)\\s.*uint128 = (0x[0-9a-f]+)\\}', line)\n+            if m:\n+                regs[m.group(1)] = int(m.group(2), 16)\n         return regs\n \n     def get_registers_fpu(self):\n"}
{"repo": "voltron", "commit": "94d379551ca59d8adb68d30cda599777578c7675", "diff": "diff --git a/voltron/cmd.py b/voltron/cmd.py\nindex 2db1403..ab38f36 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -107,7 +107,7 @@ class VoltronCommand (object):\n             try:\n                 client.send_event(event)\n             except socket.error:\n-                self.server.drop_client(client)\n+                self.server.purge_client(client)\n \n     # These methods are overridden by the debugger-specific classes\n     def register_hooks(self):\n"}
{"repo": "voltron", "commit": "e802e42c9030a6f100a722cece85331d603f7b51", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 6b3078c..40d754c 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -167,8 +167,15 @@ class VoltronView (object):\n         self.client.do_connect()\n         os.system('clear')\n         self.render(error='Waiting for an update from the debugger')\n-        while True:\n-            self.client.read()\n+        try:\n+            while True:\n+                self.client.read()\n+        except Exception:\n+            if self.should_restart_on_error():\n+                log.debug(\"Restarting process\")\n+                self.reexec()\n+            else:\n+                raise\n \n \n     def render(self, msg=None):\n@@ -186,6 +193,17 @@ class VoltronView (object):\n             lines.append(\"%s:  %-*s  |%s|\\n\" % (ADDR_FORMAT_64.format(offset+c), length*3, hex, printable))\n         return ''.join(lines).strip()\n \n+    def should_restart_on_error(self):\n+        # Fallback to original behaviour\n+        try:\n+            return self.loaded_config['view']['restart_on_error']\n+        except:\n+            return True\n+\n+    def reexec(self):\n+        # Instead of trying to reset internal state, just exec ourselves again\n+        os.execv(sys.argv[0], sys.argv)\n+\n \n class TerminalView (VoltronView):\n     COLOURS = {\n"}
{"repo": "voltron", "commit": "53269a31280dec42ba8be24ba449b9ee9c7ef513", "diff": "diff --git a/voltron/cmd.py b/voltron/cmd.py\nindex bceb7c0..8a0803e 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -18,8 +18,6 @@ class VoltronCommand (object):\n     def handle_command(self, command):\n         global log\n         if \"start\" in command:\n-            if 'debug' in command:\n-                log.setLevel(logging.DEBUG)\n             self.start()\n         elif \"stop\" in command:\n             self.stop()\n@@ -27,8 +25,17 @@ class VoltronCommand (object):\n             self.status()\n         elif \"update\" in command:\n             self.update()\n+        elif 'debug' in command:\n+            if 'enable' in command:\n+                log.setLevel(logging.DEBUG)\n+                print(\"Debug logging enabled\")\n+            elif 'disable' in command:\n+                log.setLevel(logging.INFO)\n+                print(\"Debug logging disabled\")\n+            else:\n+                print(\"Debug logging is currently \" + (\"enabled\" if log.getEffectiveLevel() == logging.DEBUG else \"disabled\"))\n         else:\n-            print(\"Usage: voltron <start|stop|update|status>\")\n+            print(\"Usage: voltron <start|stop|update|status|debug>\")\n \n     def start(self):\n         if not self.running:\n@@ -72,13 +79,15 @@ class VoltronCommand (object):\n     def update(self):\n         log.debug(\"Updating clients\")\n \n+        # Make sure we have a target\n+        if not self.base_helper.has_target():\n+            return\n+\n         # Make sure we have a server and helper running\n         if self.server == None:\n             self.start_server()\n         if self.helper == None:\n-            self.helper = self.find_helper()\n-        if not self.has_target():\n-            return\n+            self.helper = self.base_helper.helper()\n \n         # Process updates for registered clients\n         log.debug(\"Processing updates\")\n@@ -105,11 +114,6 @@ class VoltronCommand (object):\n     def unregister_hooks(self):\n         pass\n \n-    def find_helper(self):\n-        pass\n-\n-    def has_target(self):\n-        return True\n \n \n class DebuggerHelper (object):\ndiff --git a/voltron/gdbcmd.py b/voltron/gdbcmd.py\nindex fe8bf89..981adec 100644\n--- a/voltron/gdbcmd.py\n+++ b/voltron/gdbcmd.py\n@@ -18,6 +18,7 @@ class VoltronGDBCommand (VoltronCommand, gdb.Command):\n         self.running = False\n         self.server = None\n         self.helper = None\n+        self.base_helper = GDBHelper\n \n     def invoke(self, arg, from_tty):\n         self.handle_command(arg)\n@@ -46,15 +47,12 @@ class VoltronGDBCommand (VoltronCommand, gdb.Command):\n         if self.server == None:\n             self.start_server()\n \n-    def find_helper(self):\n-        arch = GDBHelper.get_arch()\n-        for cls in GDBHelper.__subclasses__():\n-            if hasattr(cls, 'archs') and arch in cls.archs:\n-                return cls()\n-        raise LookupError('No helper found for arch {}'.format(arch))\n-\n \n class GDBHelper (DebuggerHelper):\n+    @staticmethod\n+    def has_target():\n+        return len(gdb.inferiors()) > 0\n+\n     @staticmethod\n     def get_arch():\n         try:\n@@ -62,6 +60,14 @@ class GDBHelper (DebuggerHelper):\n         except:\n             return re.search('\\(currently (.*)\\)', gdb.execute('show architecture', to_string=True)).groups(0)\n \n+    @staticmethod\n+    def helper():\n+        arch = GDBHelper.get_arch()\n+        for cls in GDBHelper.__subclasses__():\n+            if hasattr(cls, 'archs') and arch in cls.archs:\n+                return cls()\n+        raise LookupError('No helper found for arch {}'.format(arch))\n+\n     def get_next_instruction(self):\n         return self.get_disasm().split('\\n')[0].split(':')[1].strip()\n \ndiff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex b312c76..e914b40 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -11,14 +11,12 @@ from .common import *\n log = configure_logging()\n inst = None\n \n-def get_frame():\n-    return lldb.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n-\n \n class VoltronLLDBCommand (VoltronCommand):\n     def __init__(self, debugger, dict):\n         self.debugger = debugger\n         debugger.HandleCommand('command script add -f dbgentry.lldb_invoke voltron')\n+        self.base_helper = LLDBHelper\n         self.running = False\n         self.server = None\n         self.helper = None\n@@ -38,25 +36,32 @@ class VoltronLLDBCommand (VoltronCommand):\n         # XXX: Fix this so it only removes our stop-hook\n         lldb.debugger.HandleCommand('target stop-hook delete')\n \n-    def find_helper(self):\n-        arch = lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n-        for cls in LLDBHelper.__subclasses__():\n-            if hasattr(cls, 'archs') and arch in cls.archs:\n-                inst = cls()\n-                return inst\n-        raise LookupError('No helper found for arch {}'.format(arch))\n-\n-    def has_target(self):\n-        # LLDB from Xcode 5+ Does this awesome thing where it doesn't mention\n-        # that the registers it's returning are in no way useful.\n-        # Test to see if there actually are any.\n-        registers = get_frame().GetRegisters()\n-        return len(registers) != 0\n \n class LLDBHelper (DebuggerHelper):\n+    @staticmethod\n+    def has_target():\n+        registers = LLDBHelper.get_frame().GetRegisters()\n+        return len(registers) != 0\n+\n+    @staticmethod\n+    def get_frame():\n+        return lldb.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n+\n+    @staticmethod\n     def get_arch(self):\n         return lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n \n+    @staticmethod\n+    def helper():\n+        if LLDBHelper.has_target():        \n+            arch = lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n+            for cls in LLDBHelper.__subclasses__():\n+                if hasattr(cls, 'archs') and arch in cls.archs:\n+                    inst = cls()\n+                    return inst\n+            raise LookupError('No helper found for arch {}'.format(arch))\n+        raise LookupError('No target')\n+\n     def get_next_instruction(self):\n         target = lldb.debugger.GetTargetAtIndex(0)\n         pc = lldb.SBAddress(self.get_pc(), target)\n@@ -66,7 +71,7 @@ class LLDBHelper (DebuggerHelper):\n     def get_registers(self):\n         log.debug('Getting registers')\n \n-        regs = get_frame().GetRegisters()\n+        regs = LLDBHelper.get_frame().GetRegisters()\n         objs = []\n         for i in xrange(len(regs)):\n             objs += regs[i]\n@@ -145,7 +150,7 @@ class LLDBHelperARM (LLDBHelper):\n     sp = 'sp'\n \n \n-class LLDBHelperARM (LLDBHelper):\n+class LLDBHelperARM64 (LLDBHelper):\n     archs = ['arm64']\n     arch_group = 'arm64'\n     pc = 'pc'\n"}
{"repo": "voltron", "commit": "30515ba13ebc770fcf7f239a090ac7e39019f823", "diff": "diff --git a/voltron/common.py b/voltron/common.py\nindex 27ab459..431284d 100644\n--- a/voltron/common.py\n+++ b/voltron/common.py\n@@ -1,3 +1,4 @@\n+import os\n import logging\n import logging.config\n \ndiff --git a/voltron/comms.py b/voltron/comms.py\nindex 14ad146..1a6de6d 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -17,7 +17,7 @@ def _sock():\n     if \"VOLTRON_SOCKET\" in os.environ:\n         return os.getenv(\"VOLTRON_SOCKET\")\n     else:\n-        d = os.path.expanduser(\"~/.voltron\")\n+        d = VOLTRON_DIR\n         if not os.path.exists(d):\n             os.mkdir(d, 0700)\n         return os.path.join(d, \"voltron.sock\")\ndiff --git a/voltron/main.py b/voltron/main.py\nindex 4e5792f..ef0fbfc 100755\n--- a/voltron/main.py\n+++ b/voltron/main.py\n@@ -20,7 +20,7 @@ def main(debugger=None, dict=None):\n     # Load config\n     config = {}\n     try:\n-        config_data = file(os.path.expanduser(VOLTRON_CONFIG)).read()\n+        config_data = file(VOLTRON_CONFIG).read()\n         lines = filter(lambda x: len(x) != 0 and x[0] != '#', config_data.split('\\n'))\n         config = json.loads('\\n'.join(lines))\n     except:\n"}
{"repo": "voltron", "commit": "d864b2c0e0529bbb21df2f7dc9bf70d47627b27d", "diff": "diff --git a/voltron/view.py b/voltron/view.py\nindex 04a5929..190eb6d 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -116,7 +116,7 @@ class VoltronView (object):\n         self.init_window()\n \n         # Setup a SIGWINCH handler so we do reasonable things on resize\n-        signal.signal(signal.SIGWINCH, lambda sig, stack: self.render())\n+        # signal.signal(signal.SIGWINCH, lambda sig, stack: self.render())\n \n         # Connect to server\n         self.connect()\n"}
{"repo": "voltron", "commit": "56e9a28ec050afa7dbb635df52f988c436645ace", "diff": "diff --git a/voltron/remote_debugger.py b/voltron/remote_debugger.py\nnew file mode 100644\nindex 0000000..49b88fe\n--- /dev/null\n+++ b/voltron/remote_debugger.py\n@@ -0,0 +1,33 @@\n+import pdb\n+import socket\n+import sys\n+\n+# Trying to debug a quirk in some code that gets called async by {ll,d}db?\n+#\n+# from .remote_debugger import Rdb\n+# Rdb().set_trace()\n+#\n+# Then: telnet localhost 4444\n+\n+\n+socks = {}\n+# Only bind the socket once\n+def _sock(port):\n+    if port in socks:\n+        return socks[port]\n+\n+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+    s.bind((\"127.0.0.1\", port))\n+    socks[port] = s\n+    return s\n+\n+class Rdb(pdb.Pdb):\n+    def __init__(self, port=4444):\n+        self.old_stdout = sys.stdout\n+        self.old_stdin = sys.stdin\n+        self.skt = _sock(port)\n+        self.skt.listen(1)\n+        (clientsocket, address) = self.skt.accept()\n+        handle = clientsocket.makefile('rw')\n+        pdb.Pdb.__init__(self, completekey='tab', stdin=handle, stdout=handle)\n+        sys.stdout = sys.stdin = handle\n"}
{"repo": "voltron", "commit": "c0c6334c2843a520e44d6552f8d5fab85f15f738", "diff": "diff --git a/voltron/remote_debugger.py b/voltron/remote_debugger.py\nnew file mode 100644\nindex 0000000..49b88fe\n--- /dev/null\n+++ b/voltron/remote_debugger.py\n@@ -0,0 +1,33 @@\n+import pdb\n+import socket\n+import sys\n+\n+# Trying to debug a quirk in some code that gets called async by {ll,d}db?\n+#\n+# from .remote_debugger import Rdb\n+# Rdb().set_trace()\n+#\n+# Then: telnet localhost 4444\n+\n+\n+socks = {}\n+# Only bind the socket once\n+def _sock(port):\n+    if port in socks:\n+        return socks[port]\n+\n+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+    s.bind((\"127.0.0.1\", port))\n+    socks[port] = s\n+    return s\n+\n+class Rdb(pdb.Pdb):\n+    def __init__(self, port=4444):\n+        self.old_stdout = sys.stdout\n+        self.old_stdin = sys.stdin\n+        self.skt = _sock(port)\n+        self.skt.listen(1)\n+        (clientsocket, address) = self.skt.accept()\n+        handle = clientsocket.makefile('rw')\n+        pdb.Pdb.__init__(self, completekey='tab', stdin=handle, stdout=handle)\n+        sys.stdout = sys.stdin = handle\n"}
{"repo": "voltron", "commit": "557aadf44b4245c6dd8a2a270144763d0a2c6205", "diff": "diff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex 45e9ec8..f8134ed 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -39,7 +39,6 @@ class VoltronLLDBCommand (VoltronCommand):\n         for cls in LLDBHelper.__inheritors__:\n             if hasattr(cls, 'archs') and arch in cls.archs:\n                 inst = cls()\n-                inst.debugger = lldb.debugger\n                 return inst\n         raise LookupError('No helper found for arch {}'.format(arch))\n \n"}
{"repo": "voltron", "commit": "70c26d3c55aec79b7fc721b4eec2169b3a67723c", "diff": "diff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex 7331254..45e9ec8 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -20,7 +20,6 @@ class VoltronLLDBCommand (VoltronCommand):\n         self.helper = None\n \n     def invoke(self, debugger, command, result, dict):\n-        self.debugger = debugger\n         self.handle_command(command)\n \n     def start(self):\n@@ -29,31 +28,31 @@ class VoltronLLDBCommand (VoltronCommand):\n         super(VoltronLLDBCommand, self).start()\n \n     def register_hooks(self):\n-        self.debugger.HandleCommand('target stop-hook add -o \\'voltron update\\'')\n+        lldb.debugger.HandleCommand('target stop-hook add -o \\'voltron update\\'')\n \n     def unregister_hooks(self):\n         # XXX: Fix this so it only removes our stop-hook\n-        self.debugger.HandleCommand('target stop-hook delete')\n+        lldb.debugger.HandleCommand('target stop-hook delete')\n \n     def find_helper(self):\n-        arch = self.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n+        arch = lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n         for cls in LLDBHelper.__inheritors__:\n             if hasattr(cls, 'archs') and arch in cls.archs:\n                 inst = cls()\n-                inst.debugger = self.debugger\n+                inst.debugger = lldb.debugger\n                 return inst\n         raise LookupError('No helper found for arch {}'.format(arch))\n \n \n class LLDBHelper (DebuggerHelper):\n     def get_arch(self):\n-        return self.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n+        return lldb.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n \n     def get_frame(self):\n-        return self.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n+        return lldb.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n \n     def get_next_instruction(self):\n-        target = self.debugger.GetTargetAtIndex(0)\n+        target = lldb.debugger.GetTargetAtIndex(0)\n         pc = lldb.SBAddress(self.get_pc(), target)\n         inst = target.ReadInstructions(pc, 1)\n         return str(inst).split(':')[1].strip()\n@@ -61,7 +60,6 @@ class LLDBHelper (DebuggerHelper):\n     def get_registers(self):\n         log.debug('Getting registers')\n \n-        # Get registers\n         objs = self.get_frame().GetRegisters()\n         objs = list(objs[0]) + list(objs[1]) + list(objs[2])\n         regs = {}\n@@ -99,7 +97,7 @@ class LLDBHelper (DebuggerHelper):\n         if cmd:\n             log.debug('Getting command output: ' + cmd)\n             res = lldb.SBCommandReturnObject()\n-            self.debugger.GetCommandInterpreter().HandleCommand(cmd, res)\n+            lldb.debugger.GetCommandInterpreter().HandleCommand(cmd, res)\n             res = res.GetOutput()\n         else:\n             res = \"<No command>\"\n"}
{"repo": "voltron", "commit": "7d56862074fcb9ed0548222c4f03e9bc23a4cd0d", "diff": "diff --git a/voltron/comms.py b/voltron/comms.py\nindex 212f094..df11e50 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -36,6 +36,7 @@ class Client (asyncore.dispatcher):\n             try:\n                 self.connect(SOCK)\n                 success = True\n+                self.register()\n             except Exception as e:\n                 self.view.render(error=\"Failed connecting to server:\" + str(e))\n                 time.sleep(1)\ndiff --git a/voltron/view.py b/voltron/view.py\nindex 4435528..b0c2dac 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -152,7 +152,6 @@ class VoltronView (object):\n     def connect(self):\n         try:\n             self.client = Client(view=self, config=self.config)\n-            self.client.register()\n         except Exception as e:\n             log.error('Exception connecting: ' + str(e))\n             raise e\n"}
{"repo": "voltron", "commit": "b87a6f814404317a18e3a773b758f365d66d902b", "diff": "diff --git a/voltron/__init__.py b/voltron/__init__.py\nindex 5ab8080..08ff75d 100644\n--- a/voltron/__init__.py\n+++ b/voltron/__init__.py\n@@ -1,9 +1,8 @@\n import logging\n import logging.config\n \n-from cmd import *\n-from comms import *\n-from view import *\n-from voltron import *\n-\n-logging.config.dictConfig(LOG_CONFIG)\n+from .cmd import *\n+from .comms import *\n+from .view import *\n+from .common import *\n+from .main import *\ndiff --git a/voltron/cmd.py b/voltron/cmd.py\nindex 06cd101..a4bd344 100644\n--- a/voltron/cmd.py\n+++ b/voltron/cmd.py\n@@ -1,14 +1,15 @@\n from __future__ import print_function\n \n import logging\n+import logging.config\n from collections import defaultdict\n \n-from comms import *\n+from .comms import *\n \n DISASM_MAX = 32\n STACK_MAX = 64\n \n-log = logging.getLogger('voltron')\n+log = configure_logging()\n \n class VoltronCommand (object):\n     running = False\n@@ -71,9 +72,16 @@ class VoltronCommand (object):\n     def update(self):\n         log.debug(\"Updating clients\")\n \n+        # Make sure we have a server and helper running\n+        if self.server == None:\n+            self.start_server()\n+        if self.helper == None:\n+            self.helper = self.find_helper()\n+\n+        # Process updates for registered clients\n+        log.debug(\"Processing updates\")\n         for client in filter(lambda c: c.registration['config']['update_on'] == 'stop', clients):\n             event = {'msg_type': 'update', 'arch': self.helper.arch_group}\n-\n             if client.registration['config']['type'] == 'cmd':\n                 event['data'] = self.helper.get_cmd_output(client.registration['config']['cmd'])\n             elif client.registration['config']['type'] == 'register':\n@@ -84,7 +92,8 @@ class VoltronCommand (object):\n                 event['data'] = {'data': self.helper.get_stack(), 'sp': self.helper.get_sp()}\n             elif client.registration['config']['type'] == 'bt':\n                 event['data'] = self.helper.get_backtrace()\n-                \n+            \n+            # Add the new event to the queue\n             self.server.enqueue_event(client, event)\n \n     # These methods are overridden by the debugger-specific classes\ndiff --git a/voltron/comms.py b/voltron/comms.py\nindex 5fdb8a3..212f094 100644\n--- a/voltron/comms.py\n+++ b/voltron/comms.py\n@@ -6,6 +6,10 @@ import Queue\n import time\n import pickle\n import threading\n+import logging\n+import logging.config\n+\n+from .common import *\n \n READ_MAX = 0xFFFF\n \n@@ -14,7 +18,7 @@ SOCK = \"/tmp/voltron.sock\"\n queue = Queue.Queue()\n clients = []\n \n-log = logging.getLogger('voltron')\n+log = configure_logging()\n \n # Socket to register with the server and receive messages, calls view's render() method when a message comes in\n class Client (asyncore.dispatcher):\n@@ -23,6 +27,9 @@ class Client (asyncore.dispatcher):\n         self.view = view\n         self.config = config\n         self.reg_info = None\n+        self.do_connect()\n+\n+    def do_connect(self):\n         self.create_socket(socket.AF_UNIX, socket.SOCK_STREAM)\n         success = False\n         while not success:\n@@ -30,7 +37,7 @@ class Client (asyncore.dispatcher):\n                 self.connect(SOCK)\n                 success = True\n             except Exception as e:\n-                log.error(\"Failed connecting to server:\" + str(e))\n+                self.view.render(error=\"Failed connecting to server:\" + str(e))\n                 time.sleep(1)\n \n     def register(self):\n@@ -55,6 +62,10 @@ class Client (asyncore.dispatcher):\n         else:\n             log.debug('Empty read')\n \n+    def handle_close(self):\n+        self.close()\n+        self.do_connect()\n+\n     def writable(self):\n         return False\n \ndiff --git a/voltron/gdbcmd.py b/voltron/gdbcmd.py\nindex 2bd1962..2a87da9 100644\n--- a/voltron/gdbcmd.py\n+++ b/voltron/gdbcmd.py\n@@ -5,9 +5,10 @@ import sys\n import gdb\n import logging\n \n-from voltron.cmd import *\n+from .cmd import *\n+from .common import *\n \n-log = logging.getLogger('voltron')\n+log = configure_logging()\n \n class VoltronGDBCommand (VoltronCommand, gdb.Command):\n     def __init__(self):\n@@ -31,8 +32,6 @@ class VoltronGDBCommand (VoltronCommand, gdb.Command):\n \n     def stop_handler(self, event):\n         log.debug('Inferior stopped')\n-        if self.helper == None:\n-            self.helper = self.find_helper()\n         self.update()\n \n     def exit_handler(self, event):\n@@ -202,10 +201,3 @@ class GDBHelperARM (GDBHelper):\n     def get_register(self, reg):\n         log.debug('Getting register: ' + reg)\n         return int(gdb.parse_and_eval('(long)$'+reg)) & 0xFFFFFFFF\n-\n-\n-if __name__ == \"__main__\":\n-    log.debug('Loading GDB command')\n-    print(\"Voltron loaded.\")\n-    inst = VoltronGDBCommand()\n-\ndiff --git a/voltron/gdbproxy.py b/voltron/gdbproxy.py\nindex 5e7c9c4..0c755db 100644\n--- a/voltron/gdbproxy.py\n+++ b/voltron/gdbproxy.py\n@@ -4,9 +4,10 @@ import socket\n import struct\n import cPickle as pickle\n \n-from comms import SOCK, READ_MAX\n+from .comms import SOCK, READ_MAX\n+from .common import *\n \n-log = logging.getLogger('voltron')\n+log = configure_logging()\n \n # This class is called from the command line by GDBv6's stop-hook. The dumped registers and stack are collected,\n # parsed and sent to the voltron standalone server, which then sends the updates out to any registered clients.\ndiff --git a/voltron/lldbcmd.py b/voltron/lldbcmd.py\nindex d18fcee..7331254 100644\n--- a/voltron/lldbcmd.py\n+++ b/voltron/lldbcmd.py\n@@ -2,34 +2,32 @@ from __future__ import print_function\n \n import lldb\n import logging\n+import logging.config\n \n-from cmd import *\n-from comms import *\n-\n-log = logging.getLogger('voltron')\n+from .cmd import *\n+from .comms import *\n+from .common import *\n \n+log = configure_logging()\n inst = None\n \n-# Called when the module is loaded into lldb and initialised\n-def __lldb_init_module(debugger, dict):\n-    global inst\n-    log.debug('Loading LLDB command')\n-    inst = VoltronLLDBCommand(debugger, dict)\n-\n-# Called when the command is invoked\n-def lldb_invoke(debugger, command, result, dict):\n-    inst.invoke(debugger, command, result, dict)\n-\n class VoltronLLDBCommand (VoltronCommand):\n     def __init__(self, debugger, dict):\n         self.debugger = debugger\n-        debugger.HandleCommand('command script add -f lldbcmd.lldb_invoke voltron')\n+        debugger.HandleCommand('command script add -f dbgentry.lldb_invoke voltron')\n         self.running = False\n+        self.server = None\n+        self.helper = None\n \n     def invoke(self, debugger, command, result, dict):\n         self.debugger = debugger\n         self.handle_command(command)\n \n+    def start(self):\n+        if self.server == None:\n+            self.start_server()\n+        super(VoltronLLDBCommand, self).start()\n+\n     def register_hooks(self):\n         self.debugger.HandleCommand('target stop-hook add -o \\'voltron update\\'')\n \n@@ -37,14 +35,19 @@ class VoltronLLDBCommand (VoltronCommand):\n         # XXX: Fix this so it only removes our stop-hook\n         self.debugger.HandleCommand('target stop-hook delete')\n \n-    def get_arch(self):\n+    def find_helper(self):\n         arch = self.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n-        if arch == 'x86_64':\n-            return 'x64'\n-        elif arch == 'i386':\n-            return 'x86'\n-        elif arch == 'arm':\n-            return 'arm'\n+        for cls in LLDBHelper.__inheritors__:\n+            if hasattr(cls, 'archs') and arch in cls.archs:\n+                inst = cls()\n+                inst.debugger = self.debugger\n+                return inst\n+        raise LookupError('No helper found for arch {}'.format(arch))\n+\n+\n+class LLDBHelper (DebuggerHelper):\n+    def get_arch(self):\n+        return self.debugger.GetTargetAtIndex(0).triple.split('-')[0]\n \n     def get_frame(self):\n         return self.debugger.GetTargetAtIndex(0).process.selected_thread.GetFrameAtIndex(0)\n@@ -83,15 +86,8 @@ class VoltronLLDBCommand (VoltronCommand):\n \n     def get_stack(self):\n         log.debug('Getting stack')\n-        arch = self.get_arch()\n-        if arch == 'x64':\n-            sp = self.get_register('rsp')\n-        elif arch == 'x86':\n-            sp = self.get_register('esp')\n-        elif arch == 'arm':\n-            sp = self.get_register('sp')\n         error = lldb.SBError()\n-        res = lldb.debugger.GetTargetAtIndex(0).process.ReadMemory(sp, STACK_MAX*16, error)\n+        res = lldb.debugger.GetTargetAtIndex(0).process.ReadMemory(self.get_sp(), STACK_MAX*16, error)\n         return res\n \n     def get_backtrace(self):\n@@ -107,4 +103,26 @@ class VoltronLLDBCommand (VoltronCommand):\n             res = res.GetOutput()\n         else:\n             res = \"<No command>\"\n-        return res\n\\ No newline at end of file\n+        return res\n+\n+\n+class LLDBHelperX86 (LLDBHelper):\n+    archs = ['i386']\n+    arch_group = 'x86'\n+    pc = 'eip'\n+    sp = 'esp'\n+\n+\n+class LLDBHelperX64 (LLDBHelper):\n+    archs = ['x86_64']\n+    arch_group = 'x64'\n+    pc = 'rip'\n+    sp = 'rsp'\n+\n+\n+class LLDBHelperARM (LLDBHelper):\n+    archs = ['arm']\n+    arch_group = 'arm'\n+    pc = 'pc'\n+    sp = 'sp'\n+\ndiff --git a/voltron/view.py b/voltron/view.py\nindex 1f7d8fe..4435528 100644\n--- a/voltron/view.py\n+++ b/voltron/view.py\n@@ -6,6 +6,7 @@ import logging\n import cPickle as pickle\n import curses\n import pprint\n+import re\n \n try:\n     import pygments\n@@ -17,9 +18,10 @@ except:\n \n from collections import defaultdict\n \n-from comms import *\n+from .comms import *\n+from .common import *\n \n-log = logging.getLogger('voltron')\n+log = configure_logging()\n \n ADDR_FORMAT_128 = '0x{0:0=32X}'\n ADDR_FORMAT_64 = '0x{0:0=16X}'\n@@ -157,7 +159,7 @@ class VoltronView (object):\n \n     def run(self):\n         os.system('clear')\n-        log.info('Waiting for an update from the debugger')\n+        self.render(error='Waiting for an update from the debugger')\n         asyncore.loop()\n \n     def render(self, msg=None):\n@@ -295,6 +297,27 @@ class TerminalView (VoltronView):\n         \n         return footer\n \n+    def pad_body(self):\n+        height, width = self.window_size()\n+\n+        # Split body into lines\n+        lines = self.body.split('\\n')\n+\n+        # Subtract lines (including wrapped lines)\n+        # import pdb;pdb.set_trace()\n+        pad = self.body_height()\n+        for line in lines:\n+            line = ''.join(re.split('\\033\\[\\d+m', line))\n+            (n, rem) = divmod(len(line), width)\n+            if rem > 0: n += 1\n+            pad -= n\n+\n+        # If we have too much data for the view, too bad\n+        if pad < 0:\n+            pad = 0\n+\n+        self.body += int(pad)*'\\n'\n+\n \n class CursesView (VoltronView):\n     def init_window(self):\n@@ -317,7 +340,6 @@ class CursesView (VoltronView):\n         self.screen.clear()\n \n     def window_size(self):\n-        # Get terminal size - this also sucks, but curses sucks more\n         height, width = os.popen('stty size').read().split()\n         height = int(height)\n         width = int(width)\n@@ -557,75 +579,78 @@ class RegisterView (TerminalView):\n                 if sec not in self.config['sections']:\n                     self.config['sections'].append(sec)\n \n-    def render(self, msg=None):\n-        # Store current message\n-        self.curr_msg = msg\n-\n-        # Build template\n-        template = '\\n'.join(map(lambda x: self.TEMPLATES[msg['arch']][self.config['orientation']][x], self.config['sections']))\n-\n-        # Process formatting settings\n-        data = defaultdict(lambda: 'n/a')\n-        data.update(msg['data']['regs'])\n-        inst = msg['data']['inst']\n-        formats = self.FORMAT_INFO[msg['arch']]\n-        formatted = {}\n-        for fmt in formats:\n-            # Apply defaults where they're missing\n-            fmt = dict(self.config['format_defaults'].items() + fmt.items())\n-\n-            # Format the data for each register\n-            for reg in fmt['regs']:\n-                # Format the label\n-                label = fmt['label_format'].format(reg)\n-                if fmt['label_func'] != None:\n-                    formatted[reg+'l'] = eval(fmt['label_func'])(label)\n-                if fmt['label_colour_en']:\n-                    formatted[reg+'l'] =  self.colour(formatted[reg+'l'], fmt['label_colour'])\n-\n-                # Format the value\n-                val = data[reg]\n-                if type(val) == str:\n-                    temp = fmt['value_format'].format(0)\n-                    if len(val) < len(temp):\n-                        val += (len(temp) - len(val))*' '\n-                    formatted_reg = self.colour(val, fmt['value_colour'])\n-                else:\n-                    colour = fmt['value_colour']\n-                    if self.last_regs == None or self.last_regs != None and val != self.last_regs[reg]:\n-                        colour = fmt['value_colour_mod']\n-                    formatted_reg = val\n-                    if fmt['value_format'] != None:\n-                        formatted_reg = fmt['value_format'].format(formatted_reg)\n-                    if fmt['value_func'] != None:\n-                        if type(fmt['value_func']) == str:\n-                            formatted_reg = eval(fmt['value_func'])(formatted_reg)\n-                        else:\n-                            formatted_reg = fmt['value_func'](formatted_reg)\n-                    if fmt['value_colour_en']:\n-                        formatted_reg = self.colour(formatted_reg, colour)\n-                if fmt['format_name'] == None:\n-                    formatted[reg] = formatted_reg\n-                else:\n-                    formatted[fmt['format_name']] = formatted_reg\n-\n-        # Prepare output\n-        log.debug('Formatted: ' + str(formatted))\n+    def render(self, msg=None, error=None):\n+        if msg != None:\n+            # Store current message\n+            self.curr_msg = msg\n+\n+            # Build template\n+            template = '\\n'.join(map(lambda x: self.TEMPLATES[msg['arch']][self.config['orientation']][x], self.config['sections']))\n+\n+            # Process formatting settings\n+            data = defaultdict(lambda: 'n/a')\n+            data.update(msg['data']['regs'])\n+            inst = msg['data']['inst']\n+            formats = self.FORMAT_INFO[msg['arch']]\n+            formatted = {}\n+            for fmt in formats:\n+                # Apply defaults where they're missing\n+                fmt = dict(self.config['format_defaults'].items() + fmt.items())\n+\n+                # Format the data for each register\n+                for reg in fmt['regs']:\n+                    # Format the label\n+                    label = fmt['label_format'].format(reg)\n+                    if fmt['label_func'] != None:\n+                        formatted[reg+'l'] = eval(fmt['label_func'])(label)\n+                    if fmt['label_colour_en']:\n+                        formatted[reg+'l'] =  self.colour(formatted[reg+'l'], fmt['label_colour'])\n+\n+                    # Format the value\n+                    val = data[reg]\n+                    if type(val) == str:\n+                        temp = fmt['value_format'].format(0)\n+                        if len(val) < len(temp):\n+                            val += (len(temp) - len(val))*' '\n+                        formatted_reg = self.colour(val, fmt['value_colour'])\n+                    else:\n+                        colour = fmt['value_colour']\n+                        if self.last_regs == None or self.last_regs != None and val != self.last_regs[reg]:\n+                            colour = fmt['value_colour_mod']\n+                        formatted_reg = val\n+                        if fmt['value_format'] != None:\n+                            formatted_reg = fmt['value_format'].format(formatted_reg)\n+                        if fmt['value_func'] != None:\n+                            if type(fmt['value_func']) == str:\n+                                formatted_reg = eval(fmt['value_func'])(formatted_reg)\n+                            else:\n+                                formatted_reg = fmt['value_func'](formatted_reg)\n+                        if fmt['value_colour_en']:\n+                            formatted_reg = self.colour(formatted_reg, colour)\n+                    if fmt['format_name'] == None:\n+                        formatted[reg] = formatted_reg\n+                    else:\n+                        formatted[fmt['format_name']] = formatted_reg\n+\n+            # Prepare output\n+            log.debug('Formatted: ' + str(formatted))\n+            self.body = template.format(**formatted)\n+\n+            # Store the regs\n+            self.last_regs = data\n+\n+        # Prepare headers and footers\n         height, width = self.window_size()\n         self.title = '[regs:{}]'.format('|'.join(self.config['sections']))\n         if len(self.title) > width:\n             self.title = '[regs]'\n-        self.body = template.format(**formatted)\n \n-        # Pad\n-        lines = self.body.split('\\n')\n-        pad = self.body_height() - len(lines)\n-        if pad < 0:\n-            pad = 0\n-        self.body += pad*'\\n'\n+        # Set body to error message if appropriate\n+        if msg == None and error != None:\n+            self.body = self.colour(error, 'red')\n \n-        # Store the regs\n-        self.last_regs = data\n+        # Pad the body\n+        self.pad_body()\n \n         # Call parent's render method\n         super(RegisterView, self).render()\n@@ -811,24 +836,29 @@ class DisasmView (TerminalView):\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=DisasmView)\n \n-    def render(self, msg=None):\n+    def render(self, msg=None, error=None):\n         height, width = self.window_size()\n \n-        # Get the disasm\n-        disasm = msg['data']\n-        disasm = '\\n'.join(disasm.split('\\n')[:self.body_height()])\n+        # Set up header & error message if applicable\n+        self.title = '[code]'\n+        if error != None:\n+            self.body = self.colour(error, 'red')\n \n-        # Pygmentize output\n-        if have_pygments:\n-            try:\n-                lexer = pygments.lexers.get_lexer_by_name('gdb')\n-                disasm = pygments.highlight(disasm, lexer, pygments.formatters.Terminal256Formatter())\n-            except Exception as e:\n-                log.warning('Failed to highlight disasm: ' + str(e))\n+        if msg != None:\n+            # Get the disasm\n+            disasm = msg['data']\n+            disasm = '\\n'.join(disasm.split('\\n')[:self.body_height()])\n \n-        # Build output\n-        self.title = '[code]'\n-        self.body = disasm.rstrip()\n+            # Pygmentize output\n+            if have_pygments:\n+                try:\n+                    lexer = pygments.lexers.get_lexer_by_name('gdb')\n+                    disasm = pygments.highlight(disasm, lexer, pygments.formatters.Terminal256Formatter())\n+                except Exception as e:\n+                    log.warning('Failed to highlight disasm: ' + str(e))\n+\n+            # Build output\n+            self.body = disasm.rstrip()\n \n         # Call parent's render method\n         super(DisasmView, self).render()\n@@ -846,24 +876,30 @@ class StackView (TerminalView):\n         sp.add_argument('--bytes', '-b', action='store', type=int, help='bytes per line (default 16)', default=16)\n         sp.set_defaults(func=StackView)\n \n-    def render(self, msg=None):\n+    def render(self, msg=None, error=None):\n         height, width = self.window_size()\n \n-        # Get the stack data\n-        data = msg['data']\n-        stack_raw = data['data']\n-        sp = data['sp']\n-        stack_raw = stack_raw[:(self.body_height())*self.args.bytes]\n-\n-        # Hexdump it\n-        lines = self.hexdump(stack_raw, offset=sp, length=self.args.bytes).split('\\n')\n-        lines.reverse()\n-        stack = '\\n'.join(lines)\n-\n-        # Build output\n+        # Set up header and error message if applicable\n         self.title = \"[stack]\"\n-        self.info = '[0x{0:0=4x}:'.format(len(stack_raw)) + ADDR_FORMAT_64.format(sp) + ']'\n-        self.body = stack.strip()\n+        if error != None:\n+            self.body = self.colour(error, 'red')\n+            self.pad_body()\n+\n+        if msg != None:\n+            # Get the stack data\n+            data = msg['data']\n+            stack_raw = data['data']\n+            sp = data['sp']\n+            stack_raw = stack_raw[:(self.body_height())*self.args.bytes]\n+\n+            # Hexdump it\n+            lines = self.hexdump(stack_raw, offset=sp, length=self.args.bytes).split('\\n')\n+            lines.reverse()\n+            stack = '\\n'.join(lines)\n+\n+            # Build output\n+            self.info = '[0x{0:0=4x}:'.format(len(stack_raw)) + ADDR_FORMAT_64.format(sp) + ']'\n+            self.body = stack.strip()\n \n         # Call parent's render method\n         super(StackView, self).render()\n@@ -880,19 +916,23 @@ class BacktraceView (TerminalView):\n         VoltronView.add_generic_arguments(sp)\n         sp.set_defaults(func=BacktraceView)\n \n-    def render(self, msg=None):\n+    def render(self, msg=None, error=None):\n         height, width = self.window_size()\n \n-        # Get the back trace data\n-        data = msg['data']\n-        lines = data.split('\\n')\n-        pad = self.body_height() - len(lines) + 1\n-        if pad < 0:\n-            pad = 0\n-\n-        # Build output\n+        # Set up header and error message if applicable\n         self.title = '[backtrace]'\n-        self.body = data.strip() + pad*'\\n'\n+        if error != None:\n+            self.body = self.colour(error, 'red')\n+\n+        if msg != None:\n+            # Get the back trace data\n+            data = msg['data']\n+\n+            # Build output\n+            self.body = data.strip()\n+\n+        # Pad body\n+        self.pad_body()\n \n         # Call parent's render method\n         super(BacktraceView, self).render()\n@@ -913,17 +953,22 @@ class CommandView (TerminalView):\n     def setup(self):\n         self.config['cmd'] = self.args.command\n \n-    def render(self, msg=None):\n-        # Get the command output\n-        data = msg['data']\n-        lines = data.split('\\n')\n-        pad = self.body_height() - len(lines) + 1\n-        if pad < 0:\n-            pad = 0\n-\n-        # Build output\n+    def render(self, msg=None, error=None):\n+        # Set up header and error message if applicable\n         self.title = '[cmd:' + self.config['cmd'] + ']'\n-        self.body = data.rstrip() + pad*'\\n'\n+        if error != None:\n+            self.body = self.colour(error, 'red')\n+\n+        if msg != None:\n+            # Get the command output\n+            data = msg['data']\n+            lines = data.split('\\n')\n+            pad = self.body_height() - len(lines) + 1\n+            if pad < 0:\n+                pad = 0\n+\n+            # Build output\n+            self.body = data.rstrip() + pad*'\\n'\n \n         # Call parent's render method\n         super(CommandView, self).render()\ndiff --git a/voltron/voltron.py b/voltron/voltron.py\ndeleted file mode 100755\nindex db60a67..0000000\n--- a/voltron/voltron.py\n+++ /dev/null\n@@ -1,88 +0,0 @@\n-#!/usr/bin/env python\n-\n-import os\n-import argparse\n-import logging\n-import logging.config\n-import struct\n-import json\n-\n-from view import *\n-from comms import *\n-from gdbproxy import *\n-\n-LOG_CONFIG = {\n-        'version': 1,\n-        'formatters': {\n-            'standard': {'format': 'voltron: [%(levelname)s] %(message)s'}\n-        },\n-        'handlers': {\n-            'default': {\n-                'class': 'logging.StreamHandler',\n-                'formatter': 'standard'\n-            }\n-        },\n-        'loggers': {\n-            'voltron': {\n-                'handlers': ['default'],\n-                'level': 'INFO',\n-                'propogate': True,\n-            }\n-        }\n-}\n-logging.config.dictConfig(LOG_CONFIG)\n-log = logging.getLogger('voltron')\n-\n-def main(debugger=None, dict=None):\n-    global log, queue, inst\n-\n-    # Load config\n-    config = {}\n-    try:\n-        config_data = file(os.path.expanduser('~/.voltron')).read()\n-        lines = filter(lambda x: len(x) != 0 and x[0] != '#', config_data.split('\\n'))\n-        config = json.loads('\\n'.join(lines))\n-    except:\n-        log.debug(\"No config file\")\n-\n-    # Set up command line arg parser\n-    parser = argparse.ArgumentParser()\n-    parser.add_argument('--debug', '-d', action='store_true', help='print debug logging')\n-    top_level_sp = parser.add_subparsers(title='subcommands', description='valid subcommands')\n-    view_parser = top_level_sp.add_parser('view', help='display a view')\n-    view_sp = view_parser.add_subparsers(title='views', description='valid view types', help='additional help')\n-\n-    # Update the view base class\n-    base = CursesView if 'curses' in config.keys() and config['curses'] else TerminalView\n-    for cls in TerminalView.__subclasses__():\n-        cls.__bases__ = (base,)\n-\n-    # Set up a subcommand for each view class \n-    for cls in base.__subclasses__():\n-        cls.configure_subparser(view_sp)\n-\n-    # And subcommands for the loathsome red-headed stepchildren\n-    StandaloneServer.configure_subparser(top_level_sp)\n-    GDB6Proxy.configure_subparser(top_level_sp)\n-\n-    # Parse args\n-    args = parser.parse_args()\n-    if args.debug:\n-        log.setLevel(logging.DEBUG)\n-\n-    # Instantiate and run the appropriate module\n-    inst = args.func(args, loaded_config=config)\n-    try:\n-        inst.run()\n-    except Exception as e:\n-        log.error(\"Exception running module {}: {}\".format(inst.__class__.__name__, str(e)))\n-    except KeyboardInterrupt:\n-        pass\n-    inst.cleanup()\n-    log.info('Exiting')\n-\n-\n-if __name__ == \"__main__\":\n-    main()\n-\n-\n"}
{"repo": "voltron", "commit": "b09436757f5975de900de2c6337bf17fe6a9282e", "diff": "diff --git a/voltron.py b/voltron.py\nindex c9fa7e2..4f854a3 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -424,7 +424,8 @@ class ClientHandler (asyncore.dispatcher):\n \n     def handle_close(self):\n         self.close()\n-        clients.remove(self)\n+        if self in clients:\n+            clients.remove(self)\n \n     def send_event(self, event):\n         log.debug('Sending event to client {}: {}'.format(self, event))\n@@ -438,10 +439,6 @@ class ClientHandler (asyncore.dispatcher):\n class Server (asyncore.dispatcher):\n     def __init__(self, sockfile):\n         asyncore.dispatcher.__init__(self)\n-        try:\n-            os.remove(SOCK)\n-        except:\n-            pass\n         self.create_socket(socket.AF_UNIX, socket.SOCK_STREAM)\n         self.bind(sockfile)\n         self.listen(1)\n@@ -467,6 +464,12 @@ class ServerThread (threading.Thread):\n     def run(self):\n         global clients, queue\n \n+        # Make sure there's no left over socket\n+        try:\n+            os.remove(SOCK)\n+        except:\n+            pass\n+\n         # Create a server instance\n         serv = Server(SOCK)\n         self.lock = threading.Lock()\n@@ -483,7 +486,13 @@ class ServerThread (threading.Thread):\n                 client.send_event(event)\n \n         # Clean up\n+        for client in clients:\n+            client.close()\n         serv.close()\n+        try:\n+            os.remove(SOCK)\n+        except:\n+            pass\n \n     def should_exit(self):\n         self.lock.acquire()\n@@ -519,18 +528,22 @@ class Client (asyncore.dispatcher):\n \n     def handle_read(self):\n         data = self.recv(READ_MAX)\n-        try:\n-            msg = pickle.loads(data)\n-            log.debug('Received message: ' + str(msg))\n-        except Exception as e:\n-            log.error('Exception parsing message: ' + str(e))\n-            log.error('Invalid message: ' + data)\n+        if len(data) > 0:\n+            msg = None\n+            try:\n+                msg = pickle.loads(data)\n+                log.debug('Received message: ' + str(msg))\n+            except Exception as e:\n+                log.error('Exception parsing message: ' + str(e))\n+                log.error('Invalid message: ' + data)\n \n-        try:\n-            if self.view:\n-                self.view.render(msg)\n-        except Exception as e:\n-            log.error('Error rendering view: ' + str(e))\n+            try:\n+                if msg and self.view:\n+                    self.view.render(msg)\n+            except Exception as e:\n+                log.error('Error rendering view: ' + str(e))\n+        else:\n+            log.debug('Empty read')\n \n     def writable(self):\n         return False\n"}
{"repo": "voltron", "commit": "8adaf6779c7720d32b84c4fe2d5d3fa3d6ec8b8e", "diff": "diff --git a/voltron.py b/voltron.py\nindex a7ec671..c9fa7e2 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -14,6 +14,7 @@ import Queue\n import struct\n import json\n import curses\n+import time\n \n from collections import defaultdict\n from termcolor import colored\n@@ -378,7 +379,8 @@ class StandaloneServer (object):\n         log.debug(\"Starting standalone server\")\n         self.thread = ServerThread()\n         self.thread.start()\n-        while True: pass\n+        while True:\n+            time.sleep(1)\n \n     def cleanup(self):\n         log.info(\"Exiting\")\n@@ -428,6 +430,9 @@ class ClientHandler (asyncore.dispatcher):\n         log.debug('Sending event to client {}: {}'.format(self, event))\n         self.send(pickle.dumps(event))\n \n+    def writable(self):\n+        return False\n+\n \n # Main server socket for accept()s\n class Server (asyncore.dispatcher):\n@@ -452,6 +457,9 @@ class Server (asyncore.dispatcher):\n             except Exception as e:\n                 log.error(\"Exception handling accept: \" + str(e))\n \n+    def writable(self):\n+        return False\n+\n \n # Thread spun off when the plugin is started to listen for incoming client connections, and send out any\n # events that have been queued by the hooks in the debugger command class\n@@ -525,7 +533,8 @@ class Client (asyncore.dispatcher):\n             log.error('Error rendering view: ' + str(e))\n \n     def writable(self):\n-        return False; \n+        return False\n+\n \n # Parent class for all views\n class VoltronView (object):\n"}
{"repo": "voltron", "commit": "32244e12de76ac0b5f3099d786f053f0c0275a25", "diff": "diff --git a/voltron.py b/voltron.py\nindex 73aa35a..851d7db 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -1064,9 +1064,8 @@ class CommandView (TerminalView):\n             pad = 0\n \n         # Build output\n-        self.header = self.format_header('[cmd:' + self.config['cmd'] + ']')\n+        self.title = '[cmd:' + self.config['cmd'] + ']'\n         self.body = data.rstrip() + pad*'\\n'\n-        self.footer = self.format_footer()\n \n         # Call parent's render method\n         super(CommandView, self).render()\n"}
{"repo": "voltron", "commit": "4fc74a76d7e51dc7cff56a061f60cc67dfc73d11", "diff": "diff --git a/voltron.py b/voltron.py\nindex 82f5ac7..0f34be3 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -940,7 +940,7 @@ class BacktraceView (TerminalView):\n         self.footer = self.format_footer()\n \n         # Call parent's render method\n-        super(StackView, self).render()\n+        super(BacktraceView, self).render()\n \n \n class CommandView (TerminalView):\n"}
{"repo": "voltron", "commit": "485e90176c6cbeae1b22332e4ef7a6cbb80c7e3d", "diff": "diff --git a/voltron.py b/voltron.py\nindex fcfdfe0..82f5ac7 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -86,7 +86,9 @@ def main(debugger=None, dict=None):\n     log = logging.getLogger('')\n \n     # Load config\n-    config = json.loads(file(os.path.expanduser('~/.voltron')).read())\n+    config_data = file(os.path.expanduser('~/.voltron')).read()\n+    lines = filter(lambda x: len(x) != 0 and x[0] != '#', config_data.split('\\n'))\n+    config = json.loads('\\n'.join(lines))\n \n     # Set up queue\n     queue = Queue.Queue()\n"}
{"repo": "voltron", "commit": "a2150ee5cadfc929de69c6e808d699d6161dc91a", "diff": "diff --git a/voltron.py b/voltron.py\nindex d8442e5..840f231 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -723,10 +723,11 @@ class RegisterView (VoltronView):\n         fmt = dict(self.FORMAT_DEFAULTS.items() + filter(lambda x: 'rflags' in x['regs'], self.FORMAT_INFO['x64'])[0].items())\n \n         # Handle each flag bit\n-        val = int(val, 16)\n+        val = int(val, 10)\n         formatted = {}\n         for flag in self.FLAG_BITS.keys():\n-            values[flag] = val & (1 << self.FLAG_BITS[flag])\n+            values[flag] = (val & (1 << self.FLAG_BITS[flag]) > 0)\n+            log.debug(\"Flag {} value {} (for rflags 0x{})\".format(flag, values[flag], val))\n             formatted[flag] = str.upper(flag) if values[flag] else flag\n             if self.last_flags != None and self.last_flags[flag] != values[flag]:\n                 colour = fmt['value_colour_mod']\n"}
{"repo": "voltron", "commit": "4a17d4450b7092dd4a980d474ffc38e21c387a1a", "diff": "diff --git a/voltron.py b/voltron.py\nindex e7a0853..041bffd 100755\n--- a/voltron.py\n+++ b/voltron.py\n@@ -173,7 +173,7 @@ if in_gdb:\n             if self.running:\n                 print(\"There are {} clients attached\".format(len(clients)))\n                 for client in clients:\n-                    print(\"{} registered for: {}\".format(client, client.registration['for_types']))\n+                    print(\"{} registered with config: {}\".format(client, str(client.registration['config'])))\n             else:\n                 print(\"Not running\")\n \n"}
{"repo": "AndBug", "commit": "08edb5bec5deaaf5e90f20091ebcd4cb0a5b3055", "diff": "diff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 4f48717..4698d85 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -204,7 +204,7 @@ class Frame(SessionElement):\n             return False\n         slot = slots[loc]\n         buf.packInt(slot.index)\n-        pack_value(sess, buf, value, slot.tag) #TODO: GENERICS\n+        pack_value(sess, buf, value, slot.jni) #TODO: GENERICS\n \n         code, buf = conn.request(0x1002, buf.data())\n         if code != 0:\n@@ -990,7 +990,8 @@ class Object(Value):\n             return None\n         field = fields[loc]\n         buf.packFieldId(field.fid)\n-        pack_value(sess, buf, value, ord(field.jni))\n+        #TODO: WTF: ord(field.jni) !?\n+        pack_value(sess, buf, value, field.jni[0])\n         code, buf = conn.request(0x0903, buf.data())\n         if code != 0:\n             raise RequestError(code)\n@@ -1135,12 +1136,15 @@ register_pack_value('I', lambda p, b, v: b.packInt(int(v)))\n register_pack_value('J', lambda p, b, v: b.packLong(long(v)))\n register_pack_value('S', lambda p, b, v: b.packShort(int(v))) #TODO: TEST\n register_pack_value('V', lambda p, b, v: b.packVoid())\n-register_pack_value('Z', lambda p, b, v: (b.packU8(1 if v != 'False' else 0)))\n+register_pack_value('Z', lambda p, b, v: b.packU8(bool(v) and 1 or 0))\n #register_pack_value('s', lambda p, b, v: b.packStr(v)) # TODO: pack String\n \n def pack_value(sess, buf, value, tag = None):\n-    if tag is None:\n+    if not tag:\n         raise RequestError(tag)\n+    if isinstance(tag, basestring):\n+        tag = ord(tag[0])\n+    print \"PACK\", repr(tag), repr(value)\n     fn = pack_value_impl[tag]\n     if fn is None:\n         raise RequestError(tag)\n"}
{"repo": "AndBug", "commit": "85f6e9e3965d649e49bf831d28112d398e88f0c2", "diff": "diff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex edffaa3..72ee556 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -786,6 +786,7 @@ class Session(object):\n             if rx_dalvik_tname.match(name):\n                 seq = (t for t in seq if t.name == name)\n             else:\n+                name = str(name)\n                 name = name if not re.match('^\\d+$', name) else '<' + name + '>'\n                 seq = (t for t in seq if name in t.name.split(' ',1))\n         return andbug.data.view(seq)\n"}
{"repo": "AndBug", "commit": "436f7236ae9ea39bb6222e0ad62fe304dc475e24", "diff": "diff --git a/lib/andbug/errors.py b/lib/andbug/errors.py\nindex 5339a4d..f3786af 100644\n--- a/lib/andbug/errors.py\n+++ b/lib/andbug/errors.py\n@@ -30,6 +30,9 @@ class DependencyError(UserError):\n     'indicates that an optional dependency was not found'\n     pass\n \n+class VoidError(UserError):\n+    'indicates a process returned a nil object'\n+\n def perr(*args):\n     print >>sys.stderr, ' '.join(map(str, args))\n \ndiff --git a/lib/andbug/log.py b/lib/andbug/log.py\nindex 248afae..aff53d9 100644\n--- a/lib/andbug/log.py\n+++ b/lib/andbug/log.py\n@@ -144,6 +144,7 @@ def info(tag, meta, data = None):\n def read_log(path=None, file=None):\n     if path is None:\n         if file is None:\n-            reader = stdin\n-        else:\n             reader = LogReader(sys.stdin)\n+        else:\n+            reader = LogReader(file)\n+    return reader\ndiff --git a/lib/andbug/options.py b/lib/andbug/options.py\nindex 55d3cdc..0e9358f 100644\n--- a/lib/andbug/options.py\n+++ b/lib/andbug/options.py\n@@ -12,8 +12,6 @@\n ## You should have received a copy of the GNU Lesser General Public License\n ## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n-import sys\n-\n class ParseError(Exception):\n     def __init__(self, reason, option):\n         self.reason = reason\ndiff --git a/lib/andbug/util.py b/lib/andbug/util.py\nindex e6193d5..984b227 100644\n--- a/lib/andbug/util.py\n+++ b/lib/andbug/util.py\n@@ -23,13 +23,11 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n \n-import subprocess, threading, os, os.path\n+import subprocess, os, os.path\n import re\n from andbug.errors import *\n RE_INT = re.compile('^[0-9]+$')\n \n-from cStringIO import StringIO\n-\n class ShellException( Exception ):\n     def __init__( self, command, output, status ):\n         self.command = command\n@@ -96,7 +94,7 @@ def adb(*args):\n     #print adb, ' '.join(map(str, args))\n     try:\n         return sh(seq(\"adb\", *args))\n-    except OSError as err:\n+    except OSError:\n         raise ConfigError('could not find \"adb\" from the Android SDK in your PATH')\n \n def find_dev(dev=None):\ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 0a828e9..ea72ab2 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -12,7 +12,7 @@\n ## You should have received a copy of the GNU Lesser General Public License\n ## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n-import andbug, andbug.data, andbug.proto\n+import andbug, andbug.data, andbug.proto, andbug.errors\n import threading, re\n from andbug.data import defer\n from threading import Lock\n@@ -25,8 +25,9 @@ from Queue import Queue\n ## References:\n ## -- All codes that are sent to Dalvik VM where extracted from\n ##    dalvik/vm/jdwp/JdwpHandler.cpp and converted to HEX values\n-##    (e.g. Resume Thread: {11, 3, ....} => 0B03)\n+##    (e.g. Resume Thread: {11, 3, ....} => 0b03)\n ## -- JDWP Protocol:\n+##    the set of functions defined, here, overlap those provided by dalvik\n ##    http://docs.oracle.com/javase/1.4.2/docs/guide/jpda/jdwp/jdwp-protocol.html\n \n class RequestError(Exception):\n@@ -159,15 +160,15 @@ class Thread(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.packObjectId(self.tid)\n-        code, buf = conn.request(0x0B01, buf.data())\n+        code, buf = conn.request(0x0b02, buf.data())\n         if code != 0:\n             raise RequestError(code)\n \n     def resume(self):\n         conn = self.conn\n         buf = conn.buffer()\n-        buf.pack('o', self.tid)\n-        code, buf = conn.request(0x0B03, buf.data())\n+        buf.packObjectId(self.tid)\n+        code, buf = conn.request(0x0b03, buf.data())\n         if code != 0:\n             raise RequestError(code)\n \n@@ -179,7 +180,7 @@ class Thread(SessionElement):\n         buf = conn.buffer()\n         # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (3), ThreadId\n         buf.pack('11i1t', 40, 1, 1, 3, self.tid) \n-        code, buf = conn.request(0x0F01, buf.data())\n+        code, buf = conn.request(0x0f01, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n@@ -197,7 +198,7 @@ class Thread(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.pack('oii', self.tid, 0, -1)\n-        code, buf = conn.request(0x0B06, buf.data())\n+        code, buf = conn.request(0x0b06, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         ct = buf.unpackInt()\n@@ -215,7 +216,7 @@ class Thread(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.packObjectId(self.tid)\n-        code, buf = conn.request(0x0B07, buf.data())\n+        code, buf = conn.request(0x0b07, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         return buf.unpackInt()\n@@ -225,7 +226,7 @@ class Thread(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.packObjectId(self.tid)\n-        code, buf = conn.request(0x0B01, buf.data())\n+        code, buf = conn.request(0x0b01, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         return buf.unpackStr()\n@@ -234,8 +235,8 @@ class Thread(SessionElement):\n     def status(self):\n         conn = self.conn\n         buf = conn.buffer()\n-        buf.pack('o', self.tid)\n-        code, buf = conn.request(0x0B04, buf.data())\n+        buf.packObjectId(self.tid)\n+        code, buf = conn.request(0x0b04, buf.data())\n         if code != 0:\n             raise RequestError(code)\n \n@@ -290,7 +291,7 @@ class Location(SessionElement):\n         buf.pack('11i1', 40, 1, 1, 7) \n \n         self.packTo(buf)\n-        code, buf = conn.request(0x0F01, buf.data())\n+        code, buf = conn.request(0x0f01, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n@@ -334,7 +335,7 @@ class Slot(SessionElement):\n             return 'slot at index %i' % (self.index)\n \n     def load_slot(self):\n-        self.sess.pool(Class, self.sess, tid).load_slots()\n+        self.sess.pool(Class, self.sess, self.tid).load_slots()\n \n     firstLoc = defer(load_slot, 'firstLoc')\n     locLength = defer(load_slot, 'locLength')\n@@ -414,6 +415,7 @@ class Method(SessionElement):\n         tid = self.tid\n         mid = self.mid\n         data = conn.buffer().pack('om', tid, mid)\n+        # NOTE: this is defined in jdwpHandler.cpp, but not jdwp 1.4.2\n         code, buf = conn.request(0x0605, data)\n         if code != 0: raise RequestError(code)\n     \n@@ -458,6 +460,7 @@ class RefType(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         self.packTo(buf)\n+        # NOTE: this is defined in jdwpHandler.cpp, but not jdwp 1.4.2\n         code, buf = conn.request(0x020d, buf.data())\n         if code != 0:\n             raise RequestError(code)\n@@ -472,7 +475,8 @@ class RefType(SessionElement):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.pack(\"t\", self.tid)\n-        code, buf = conn.request(0x020E, buf.data())\n+        # NOTE: this is defined in jdwpHandler.cpp, but not jdwp 1.4.2\n+        code, buf = conn.request(0x020e, buf.data())\n         if code != 0:\n             raise RequestError(code)\n \n@@ -503,6 +507,7 @@ class RefType(SessionElement):\n         buf.packInt(len(fields))\n         for field in fields:\n             buf.packFieldId(field.fid)\n+        # NOTE: this is defined in jdwpHandler.cpp, but not jdwp 1.4.2\n         code, buf = conn.request(0x0206, buf.data())\n         if code != 0:\n             raise RequestError(code)\n@@ -521,7 +526,8 @@ class RefType(SessionElement):\n         pool = sess.pool\n         buf = conn.buffer()\n         buf.pack(\"t\", tid)\n-        code, buf = conn.request(0x020F, buf.data())\n+        # NOTE: this is defined in jdwpHandler.cpp, but not jdwp 1.4.2\n+        code, buf = conn.request(0x020f, buf.data())\n         if code != 0:\n             raise RequestError(code)\n \n@@ -591,7 +597,7 @@ class Class(RefType):\n         buf = conn.buffer()\n         # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (4)\n         buf.pack('11i1t', 40, 1, 1, 4, self.tid) \n-        code, buf = conn.request(0x0F01, buf.data())\n+        code, buf = conn.request(0x0f01, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n@@ -641,8 +647,8 @@ class Hook(SessionElement):\n         buf = conn.buffer()\n         # 40:EK_METHOD_ENTRY\n         buf.pack('1i', 40, int(self.ident))\n-        # 0x0F02 = {15, 2} EventRequest.Clear\n-        code, unknown = conn.request(0x0F02, buf.data())\n+        # 0x0f02 = {15, 2} EventRequest.Clear\n+        code, unknown = conn.request(0x0f02, buf.data())\n         # fixme: check what a hell is the value stored in unknown\n         if code != 0:\n             raise RequestError(code)\n@@ -787,7 +793,7 @@ rx_dalvik_tname = re.compile('^<[0-9]+> .*$')\n \n class Object(Value):\n     def __init__(self, sess, oid):\n-        if oid == 0: raise VoidError()\n+        if oid == 0: raise andbug.errors.VoidError()\n         SessionElement.__init__(self, sess)\n         self.oid = oid\n \n"}
{"repo": "AndBug", "commit": "6cfc0fd86e42777a01a9ac0833ea16ab58dac1e2", "diff": "diff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 1c2b36d..5818743 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -229,6 +229,36 @@ class Thread(SessionElement):\n             raise RequestError(code)\n         return buf.unpackStr()\n \n+    @property\n+    def status(self):\n+        conn = self.conn\n+        buf = conn.buffer()\n+        buf.pack('o', self.tid)\n+        code, buf = conn.request(0x0B04, buf.data())\n+        if code != 0:\n+            raise RequestError(code)\n+\n+        threadStatus = buf.unpackInt()\n+        suspendStatus = buf.unpackInt()\n+\n+        return threadStatus, suspendStatus\n+\n+    @staticmethod\n+    def threadStatusStr(tStatus):\n+        szTS = ('zombie', 'running', 'sleeping', 'monitor', 'waiting', 'initializing', 'starting', 'native', 'vmwait')\n+        tStatus = int(tStatus)\n+        if tStatus < 0 or tStatus >= len(szTS):\n+            return \"UNKNOWN\"\n+        return szTS[tStatus]\n+\n+    @staticmethod\n+    def suspendStatusStr(sStatus):\n+        szSS = ('running', 'suspended')\n+        sStatus = int(sStatus)\n+        if sStatus < 0 or sStatus >= len(szSS):\n+            return \"UNKNOWN\"\n+        return szSS[sStatus]\n+\n class Location(SessionElement):\n     def __init__(self, sess, tid, mid, loc):\n         SessionElement.__init__(self, sess)\n"}
{"repo": "AndBug", "commit": "0fb882f18bf224a3206979b4ee2ac5ddf2b0802d", "diff": "diff --git a/lib/andbug/cmd/break.py b/lib/andbug/cmd/break.py\nindex 7480445..78baa25 100644\n--- a/lib/andbug/cmd/break.py\n+++ b/lib/andbug/cmd/break.py\n@@ -34,13 +34,13 @@ def cmd_break_methods(ctxt, cpath, mpath):\n             if l.native:\n                 andbug.screed.item('Could not hook native %s' % l)\n                 continue\n-            l.hook(func = report_hit)\n-            andbug.screed.item('Hooked %s' % l)\n+            h = l.hook(func = report_hit)\n+            andbug.screed.item('Hooked %s' % h)\n \n def cmd_break_classes(ctxt, cpath):\n     for c in ctxt.sess.classes(cpath):\n-        c.hookEntries(func = report_hit)\n-        andbug.screed.item('Hooked %s' % c)\n+        h = c.hookEntries(func = report_hit)\n+        andbug.screed.item('Hooked %s' % h)\n \n @andbug.command.action(\n     '<class> [<method>]', name='break', aliases=('b',), shell=True\ndiff --git a/lib/andbug/cmd/break_remove.py b/lib/andbug/cmd/break_remove.py\nnew file mode 100644\nindex 0000000..2afbab4\n--- /dev/null\n+++ b/lib/andbug/cmd/break_remove.py\n@@ -0,0 +1,32 @@\n+## Copyright 2011, Felipe Barriga Richards <spam@felipebarriga.cl>.\n+##                 All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under\n+## the terms of version 3 of the GNU Lesser General Public License as\n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n+'implementation of the \"break-remove\" command'\n+\n+import andbug.command, andbug.screed\n+\n+@andbug.command.action('<eid>', name='break-remove', shell=True)\n+def break_remove(ctxt, eid):\n+    'remove a hook/breakpoint'\n+    ctxt.sess.suspend()\n+    try:\n+        eid = int(eid)\n+        if eid in ctxt.sess.emap:\n+            ctxt.sess.emap[eid].clear()\n+            andbug.screed.section('Hook <%s> removed' % eid)\n+        else:\n+            print '!! error, hook not found. eid=%s' % eid\n+    finally:\n+        ctxt.sess.resume()\ndiff --git a/lib/andbug/cmd/class_trace.py b/lib/andbug/cmd/class_trace.py\nindex 87e2ab4..6bae26e 100644\n--- a/lib/andbug/cmd/class_trace.py\n+++ b/lib/andbug/cmd/class_trace.py\n@@ -16,6 +16,7 @@\n \n import andbug.command, andbug.screed, andbug.options\n from Queue import Queue\n+import re\n \n def report_hit(t):\n     t = t[0]\ndiff --git a/lib/andbug/cmd/shell.py b/lib/andbug/cmd/shell.py\nindex 1610ce2..1b97277 100644\n--- a/lib/andbug/cmd/shell.py\n+++ b/lib/andbug/cmd/shell.py\n@@ -22,12 +22,24 @@ BANNER = 'AndBug (C) 2011 Scott W. Dunlop <swdunlop@gmail.com>'\n def input():\n     return raw_input('>> ')\n \n+def completer(text, state):\n+    available_commands = andbug.command.ACTION_MAP.keys()\n+    options = [x for x in available_commands if x.startswith(text)]\n+    try:\n+        return options[state]\n+    except IndexError:\n+        return None\n+\n+\n @andbug.command.action('')\n def shell(ctxt):\n     'starts the andbug shell with the specified process'\n     if not ctxt.shell:\n         try:\n             import readline\n+            readline.set_completer(completer)\n+            readline.parse_and_bind(\"tab: complete\")\n+\n         except:\n             readline = None\n         ctxt.shell = True\ndiff --git a/lib/andbug/cmd/thread_trace.py b/lib/andbug/cmd/thread_trace.py\nnew file mode 100644\nindex 0000000..2b0270a\n--- /dev/null\n+++ b/lib/andbug/cmd/thread_trace.py\n@@ -0,0 +1,45 @@\n+## Copyright 2011, IOActive, Inc. All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n+'implementation of the \"thread trace\" command'\n+\n+import andbug.command, andbug.screed, andbug.options\n+from Queue import Queue\n+\n+def report_hit(t):\n+    t = t[0]\n+    try:\n+        with andbug.screed.section(\"trace %s\" % t):\n+            for f in t.frames:\n+                name = str(f.loc)\n+                if f.native:\n+                    name += ' <native>'\n+                with andbug.screed.item(name):\n+                    for k, v in f.values.items():\n+                        andbug.screed.item( \"%s=%s\" %(k, v))\n+    finally:\n+        t.resume()\n+\n+@andbug.command.action('<thread-name>', aliases=('tt','ttrace'))\n+\n+def thread_trace(ctxt, tname=None):\n+\t'reports calls to specific thread in the process'\n+\tctxt.sess.suspend()\n+\twith andbug.screed.section('Setting Hooks'):\n+\t\ttry:\n+\t\t\tfor t in ctxt.sess.threads(tname):\n+\t\t\t\tt.hook(func = report_hit)\n+\t\t\t\tandbug.screed.item('Hooked %s' % t)\n+\t\tfinally:\n+\t\t\tctxt.sess.resume()\ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 503f476..1c2b36d 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -173,6 +173,17 @@ class Thread(SessionElement):\n     def packTo(self, buf):\n         buf.packObjectId(self.tid)\n \n+    def hook(self, func = None, queue = None):\n+        conn = self.conn\n+        buf = conn.buffer()\n+        # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (3), ThreadId\n+        buf.pack('11i1t', 40, 1, 1, 3, self.tid) \n+        code, buf = conn.request(0x0F01, buf.data())\n+        if code != 0:\n+            raise RequestError(code)\n+        eid = buf.unpackInt()\n+        return self.sess.hook(eid, func, queue, self)\n+\n     @classmethod\n     def unpackFrom(impl, sess, buf):\n         tid = buf.unpackObjectId()\n@@ -595,9 +606,18 @@ class Hook(SessionElement):\n \n     def clear(self):\n         #TODO: unclean\n-        #TODO: EventRequest.Clear\n+        conn = self.conn\n+        buf = conn.buffer()\n+        # 40:EK_METHOD_ENTRY\n+        buf.pack('1i', 40, int(self.ident))\n+        # 0x0F02 = {15, 2} EventRequest.Clear\n+        code, unknown = conn.request(0x0F02, buf.data())\n+        # fixme: check what a hell is the value stored in unknown\n+        if code != 0:\n+            raise RequestError(code)\n+\n         with self.sess.ectl:\n-            del self.sess.emap[ident]\n+            del self.sess.emap[self.ident]\n \n unpack_impl = [None,] * 256\n \n"}
{"repo": "AndBug", "commit": "8887960bf59b45894f4eb08f9c6b60a7564db6c1", "diff": "diff --git a/lib/andbug/cmd/break.py b/lib/andbug/cmd/break.py\nindex 7480445..78baa25 100644\n--- a/lib/andbug/cmd/break.py\n+++ b/lib/andbug/cmd/break.py\n@@ -34,13 +34,13 @@ def cmd_break_methods(ctxt, cpath, mpath):\n             if l.native:\n                 andbug.screed.item('Could not hook native %s' % l)\n                 continue\n-            l.hook(func = report_hit)\n-            andbug.screed.item('Hooked %s' % l)\n+            h = l.hook(func = report_hit)\n+            andbug.screed.item('Hooked %s' % h)\n \n def cmd_break_classes(ctxt, cpath):\n     for c in ctxt.sess.classes(cpath):\n-        c.hookEntries(func = report_hit)\n-        andbug.screed.item('Hooked %s' % c)\n+        h = c.hookEntries(func = report_hit)\n+        andbug.screed.item('Hooked %s' % h)\n \n @andbug.command.action(\n     '<class> [<method>]', name='break', aliases=('b',), shell=True\ndiff --git a/lib/andbug/cmd/break_list.py b/lib/andbug/cmd/break_list.py\nnew file mode 100644\nindex 0000000..aaa70b6\n--- /dev/null\n+++ b/lib/andbug/cmd/break_list.py\n@@ -0,0 +1,27 @@\n+## Copyright 2011, Felipe Barriga Richards <spam@felipebarriga.cl>.\n+##                 All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n+'implementation of the \"break-list\" command'\n+\n+import andbug.command, andbug.screed\n+\n+@andbug.command.action('', name='break-list', shell=True)\n+def break_list(ctxt):\n+    'list active breakpoints/hooks'\n+    with andbug.screed.section('Active Hooks'):\n+        for eid in ctxt.sess.emap:\n+            andbug.screed.item('Hook %s' % ctxt.sess.emap[eid])\n+\n+    ctxt.block_exit()\ndiff --git a/lib/andbug/cmd/break_remove.py b/lib/andbug/cmd/break_remove.py\nnew file mode 100644\nindex 0000000..2afbab4\n--- /dev/null\n+++ b/lib/andbug/cmd/break_remove.py\n@@ -0,0 +1,32 @@\n+## Copyright 2011, Felipe Barriga Richards <spam@felipebarriga.cl>.\n+##                 All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under\n+## the terms of version 3 of the GNU Lesser General Public License as\n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n+'implementation of the \"break-remove\" command'\n+\n+import andbug.command, andbug.screed\n+\n+@andbug.command.action('<eid>', name='break-remove', shell=True)\n+def break_remove(ctxt, eid):\n+    'remove a hook/breakpoint'\n+    ctxt.sess.suspend()\n+    try:\n+        eid = int(eid)\n+        if eid in ctxt.sess.emap:\n+            ctxt.sess.emap[eid].clear()\n+            andbug.screed.section('Hook <%s> removed' % eid)\n+        else:\n+            print '!! error, hook not found. eid=%s' % eid\n+    finally:\n+        ctxt.sess.resume()\ndiff --git a/lib/andbug/cmd/class_trace.py b/lib/andbug/cmd/class_trace.py\nindex 87e2ab4..6bae26e 100644\n--- a/lib/andbug/cmd/class_trace.py\n+++ b/lib/andbug/cmd/class_trace.py\n@@ -16,6 +16,7 @@\n \n import andbug.command, andbug.screed, andbug.options\n from Queue import Queue\n+import re\n \n def report_hit(t):\n     t = t[0]\ndiff --git a/lib/andbug/cmd/classes.py b/lib/andbug/cmd/classes.py\nindex 2c58b7d..3179d15 100644\n--- a/lib/andbug/cmd/classes.py\n+++ b/lib/andbug/cmd/classes.py\n@@ -16,9 +16,9 @@\n \n import andbug.command, andbug.screed\n \n-@andbug.command.action('')\n+@andbug.command.action('[<partial class name>]')\n def classes(ctxt, expr=None):\n-    'lists loaded classes'\n+    'lists loaded classes. if no partial class name supplied, list all classes.'\n     with andbug.screed.section('Loaded Classes'):\n \t    for c in ctxt.sess.classes():\n \t        n = c.jni\n@@ -30,4 +30,6 @@ def classes(ctxt, expr=None):\n                 if expr is not None:\n                     if n.find(expr) >= 0:\n                         andbug.screed.item(n)\n+                else:\n+                    andbug.screed.item(n)\n \ndiff --git a/lib/andbug/cmd/help.py b/lib/andbug/cmd/help.py\nindex 5bc69d9..b13b712 100644\n--- a/lib/andbug/cmd/help.py\n+++ b/lib/andbug/cmd/help.py\n@@ -54,8 +54,13 @@ CAUTION = '''\n     made or implied.'''\n \n SHELL_EXAMPLES = (\n+    'threads',\n+    'threads verbose=2',\n+    'threads \"Signal Catcher\" verbose=3',\n     'classes',\n-    'methods com.ioactive.decoy.DecoyActivity onInit'\n+    'classes ioactive',\n+    'methods com.ioactive.decoy.DecoyActivity onInit',\n+    'method-trace com.ioactive.decoy.DecoyActivity'\n )\n \n CLI_EXAMPLES = (\ndiff --git a/lib/andbug/cmd/inspect.py b/lib/andbug/cmd/inspect.py\nnew file mode 100644\nindex 0000000..e661c20\n--- /dev/null\n+++ b/lib/andbug/cmd/inspect.py\n@@ -0,0 +1,50 @@\n+## Copyright 2011, Felipe Barriga Richards <spam@felipebarriga.cl>.\n+##                 All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n+'implementation of the \"inspect\" command'\n+\n+import andbug.command, andbug.screed\n+\n+def find_object(ctxt, oid):\n+    for t in ctxt.sess.threads():\n+        for f in t.frames:\n+            for k, v in f.values.items():\n+                if type(v) is andbug.vm.Object and v.oid == oid:\n+                    return (v, t)\n+    return None\n+\n+@andbug.command.action('<object-id>')\n+def inspect(ctxt, oid):\n+    'inspect an object'\n+    ctxt.sess.suspend()\n+    \n+    try:\n+        oid = long(oid)\n+        rtval = find_object(ctxt, oid)\n+        if rtval is None:\n+            andbug.screed.section('object <%s> not found' % oid)\n+        else:\n+            obj, thread = rtval\n+            with andbug.screed.section('object <%s> %s in %s'\n+                % (str(obj.oid), str(obj.jni), str(thread))):\n+                for k, v in obj.fields.items():\n+                    andbug.screed.item('%s=%s <%s>' % (k, v, type(v).__name__))\n+    except ValueError:\n+        print('!! error, invalid oid param. expecting <long> and got <%s>.'\n+            % type(oid).__name__)\n+\n+    finally:\n+        ctxt.sess.resume()\n+  \n\\ No newline at end of file\ndiff --git a/lib/andbug/cmd/navi.py b/lib/andbug/cmd/navi.py\nindex b12c382..00418fa 100644\n--- a/lib/andbug/cmd/navi.py\n+++ b/lib/andbug/cmd/navi.py\n@@ -9,6 +9,7 @@\n \n import andbug, os.path, cgi, json, subprocess, threading\n from urllib2 import quote as urlquote\n+import re\n \n try:\n     import bottle\n@@ -28,7 +29,7 @@ def get_threads():\n     threads = proc.threads()[:] # TODO This workaround for view is vulgar.\n     def tin(name):\n         try:\n-            return int(name.split('<')[1].split('>')[0])\n+            return int(re.split('<|>', name)[1])\n         except:\n             return name\n \ndiff --git a/lib/andbug/cmd/shell.py b/lib/andbug/cmd/shell.py\nindex 1610ce2..1b97277 100644\n--- a/lib/andbug/cmd/shell.py\n+++ b/lib/andbug/cmd/shell.py\n@@ -22,12 +22,24 @@ BANNER = 'AndBug (C) 2011 Scott W. Dunlop <swdunlop@gmail.com>'\n def input():\n     return raw_input('>> ')\n \n+def completer(text, state):\n+    available_commands = andbug.command.ACTION_MAP.keys()\n+    options = [x for x in available_commands if x.startswith(text)]\n+    try:\n+        return options[state]\n+    except IndexError:\n+        return None\n+\n+\n @andbug.command.action('')\n def shell(ctxt):\n     'starts the andbug shell with the specified process'\n     if not ctxt.shell:\n         try:\n             import readline\n+            readline.set_completer(completer)\n+            readline.parse_and_bind(\"tab: complete\")\n+\n         except:\n             readline = None\n         ctxt.shell = True\ndiff --git a/lib/andbug/cmd/threads.py b/lib/andbug/cmd/threads.py\nindex 9c42f7d..ab6289f 100644\n--- a/lib/andbug/cmd/threads.py\n+++ b/lib/andbug/cmd/threads.py\n@@ -15,21 +15,64 @@\n 'implementation of the \"threads\" command'\n \n import andbug.command, andbug.screed\n+import re\n \n-@andbug.command.action('[<name>]')\n-def threads(ctxt, name=None):\n-    'lists threads in the process'\n+def thread_methods(t, verbose):\n+    for f in t.frames:\n+        name = str(f.loc)\n+        if f.native:\n+            name += ' <native>'\n+        with andbug.screed.item(name):\n+            if verbose > 1:\n+                for k, v in f.values.items():\n+                    if verbose == 2:\n+                        andbug.screed.item(\"%s=<%s>\" % (k, type(v).__name__))\n+                    else:\n+                        andbug.screed.item(\"%s=%s <%s>\" % (k, v, type(v).__name__))\n+ \n+@andbug.command.action('[<name>] [verbose=<verbose level>]')\n+def threads(ctxt, arg1 = None, arg2 = None):\n+    'lists threads in the process. verbosity: 0 (thread), (1 methods), (2 vars), (3 vars data)'\n+\n+    def threadId(name):\n+        \"\"\"Extract threadId from name (e.g. \"thread <2> HeapWorker\" => 2).\"\"\"\n+        return int(re.split('<|>', str(name))[1])\n+\n+    def parse_verbosity(param):\n+        \"\"\"Return False if it's not a verbosity argument.\n+        If it's an invalid number return 0\"\"\"\n+        if param is None or param[:8] != 'verbose=':\n+            return False\n+\n+        verbosity = int(param[8:])\n+        return verbosity\n+\n+    def parse_args(arg1, arg2):\n+        if arg1 is None:\n+            return (None, 0)\n+\n+        if arg2 is None:\n+            verbose = parse_verbosity(arg1)\n+            if verbose is False:\n+                return (arg1, 0)\n+            else:\n+                return (None, verbose)\n+\n+        verbose = parse_verbosity(arg2)\n+        if verbose is False: verbose = 0\n+        \n+        return (arg1, verbose)\n+\n+    name, verbose = parse_args(arg1, arg2)\n     ctxt.sess.suspend()\n \n     try:\n-        for t in ctxt.sess.threads(name):\n+        threads = sorted(ctxt.sess.threads(name).items, key=threadId)\n+\n+        for t in threads:\n             with andbug.screed.section(str(t)):\n-                for f in t.frames:\n-                    name = str(f.loc)\n-                    if f.native:\n-                        name += ' <native>'\n-                    with andbug.screed.item(name):\n-                        for k, v in f.values.items():\n-                            andbug.screed.item( \"%s=%s\" %(k, v))\n+                if verbose > 0:\n+                    thread_methods(t, verbose)\n     finally:\n         ctxt.sess.resume()\n+        \ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 30e4e35..1c2b36d 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -22,6 +22,12 @@ from Queue import Queue\n ## -- unpackFrom methods are used to unpack references to an element from\n ##    a JDWP buffer.  This does not mean unpacking the actual definition of\n ##    the element, which tends to be one-shot.\n+## References:\n+## -- All codes that are sent to Dalvik VM where extracted from\n+##    dalvik/vm/jdwp/JdwpHandler.cpp and converted to HEX values\n+##    (e.g. Resume Thread: {11, 3, ....} => 0B03)\n+## -- JDWP Protocol:\n+##    http://docs.oracle.com/javase/1.4.2/docs/guide/jpda/jdwp/jdwp-protocol.html\n \n class RequestError(Exception):\n     'raised when a request for more information from the process fails'\n@@ -176,7 +182,7 @@ class Thread(SessionElement):\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n-        return self.sess.hook(eid, func, queue)\n+        return self.sess.hook(eid, func, queue, self)\n \n     @classmethod\n     def unpackFrom(impl, sess, buf):\n@@ -257,8 +263,8 @@ class Location(SessionElement):\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n-        return self.sess.hook(eid, func, queue)\n-    \n+        return self.sess.hook(eid, func, queue, self)\n+\n     @property\n     def native(self):\n         return self.loc == -1\n@@ -558,7 +564,7 @@ class Class(RefType):\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n-        return self.sess.hook(eid, func, queue)\n+        return self.sess.hook(eid, func, queue, self)\n         \n     #def load_class(self):\n     #   self.sess.load_classes()\n@@ -571,19 +577,24 @@ class Class(RefType):\n     #flags = defer(load_class, 'flags')\n \n class Hook(SessionElement):\n-    def __init__(self, sess, ident, func = None, queue = None):\n+    def __init__(self, sess, ident, func = None, queue = None, origin = None):\n         SessionElement.__init__(self, sess)\n         if queue is not None:\n             self.queue = queue\n         elif func is None:\n             self.queue = queue or Queue()\n         self.func = func        \n-                                    \n+\n         self.ident = ident\n+        self.origin = origin\n         #TODO: unclean\n         with self.sess.ectl:\n             self.sess.emap[ident] = self\n \n+    def __str__(self):\n+        return ('<%s> %s %s' %\n+            (str(self.ident), str(self.origin), str(type(self.origin))))\n+\n     def put(self, data):\n         if self.func is not None:\n             return self.func(data)\n@@ -595,9 +606,18 @@ class Hook(SessionElement):\n \n     def clear(self):\n         #TODO: unclean\n-        #TODO: EventRequest.Clear\n+        conn = self.conn\n+        buf = conn.buffer()\n+        # 40:EK_METHOD_ENTRY\n+        buf.pack('1i', 40, int(self.ident))\n+        # 0x0F02 = {15, 2} EventRequest.Clear\n+        code, unknown = conn.request(0x0F02, buf.data())\n+        # fixme: check what a hell is the value stored in unknown\n+        if code != 0:\n+            raise RequestError(code)\n+\n         with self.sess.ectl:\n-            del self.sess.emap[ident]\n+            del self.sess.emap[self.ident]\n \n unpack_impl = [None,] * 256\n \n@@ -640,8 +660,8 @@ class Session(object):\n         while True:\n             self.processEvent(*self.evtq.get())\n \n-    def hook(self, ident, func = None, queue = None):\n-        return Hook(self, ident, func, queue)\n+    def hook(self, ident, func = None, queue = None, origin = None):\n+        return Hook(self, ident, func, queue, origin)\n \n     def processEvent(self, ident, buf):\n         pol, ct = buf.unpack('1i')\n@@ -743,6 +763,11 @@ class Object(Value):\n     def __repr__(self):\n         return '<obj %s #%x>' % (self.jni, self.oid)\n     \n+#    def __str__(self):\n+#        return str(self.fields.values())\n+    def __str__(self):\n+        return str(\"%s <%s>\" % (str(self.jni), str(self.oid)))\n+        \n     @classmethod\n     def unpackFrom(impl, sess, buf):\n         oid = buf.unpackObjectId()\n@@ -833,6 +858,9 @@ class Array(Object):\n     \n     def __iter__(self): return iter(self.getSlice())\n \n+    def __str__(self):\n+        return str(self.getSlice())\n+        \n     @property\n     def length(self):\n         conn = self.conn\n"}
{"repo": "AndBug", "commit": "602b933ce929cb2ee89e34f2cf76f21de40c39df", "diff": "diff --git a/lib/andbug/cmd/break.py b/lib/andbug/cmd/break.py\nindex 15dae64..e70ce01 100644\n--- a/lib/andbug/cmd/break.py\n+++ b/lib/andbug/cmd/break.py\n@@ -29,13 +29,13 @@ def report_hit(t):\n \n def cmd_break_methods(ctxt, cpath, mpath):\n     for c in ctxt.sess.classes(cpath):\n-        for m in ctxt.sess.methods(mpath):\n+        for m in c.methods(mpath):\n             l = m.firstLoc\n             if l.native:\n-                andbug.screed.item('Could not hook native %s' % loc)\n+                andbug.screed.item('Could not hook native %s' % l)\n                 continue\n             l.hook(func = report_hit)\n-            andbug.screed.item('Hooked %s' % loc)\n+            andbug.screed.item('Hooked %s' % l)\n \n def cmd_break_classes(ctxt, cpath):\n     for c in ctxt.sess.classes(cpath):\n@@ -53,6 +53,6 @@ def cmd_break(ctxt, cpath, mquery=None):\n         if mname is None:\n             cmd_break_classes(ctxt, cpath)\n         else:\n-            cmd_break_methods(ctxt, cpath, mname, mjni)\n+            cmd_break_methods(ctxt, cpath, mname)\n \n     ctxt.block_exit()\ndiff --git a/lib/andbug/cmd/classes.py b/lib/andbug/cmd/classes.py\nindex ad8d61d..bb7f040 100644\n--- a/lib/andbug/cmd/classes.py\n+++ b/lib/andbug/cmd/classes.py\n@@ -17,10 +17,17 @@\n import andbug.command, andbug.screed\n \n @andbug.command.action('')\n-def classes(ctxt):\n+def classes(ctxt, expr=None):\n     'lists loaded classes'\n     with andbug.screed.section('Loaded Classes'):\n \t    for c in ctxt.sess.classes():\n \t        n = c.jni\n \t        if n.startswith('L') and n.endswith(';'):\n-\t            andbug.screed.item(n[1:-1].replace('/', '.'))\n+                    n = n[1:-1].replace('/', '.')\n+                else:\n+                    continue\n+\n+                if expr is not None:\n+                    if n.find(expr) >= 0:\n+                        andbug.screed.item(n)\n+\ndiff --git a/lib/andbug/cmd/navi.py b/lib/andbug/cmd/navi.py\nindex 2001632..b12c382 100644\n--- a/lib/andbug/cmd/navi.py\n+++ b/lib/andbug/cmd/navi.py\n@@ -26,7 +26,13 @@ def index_seq(seq):\n \n def get_threads():\n     threads = proc.threads()[:] # TODO This workaround for view is vulgar.\n-    threads.sort(lambda a, b: cmp(a.name, b.name))\n+    def tin(name):\n+        try:\n+            return int(name.split('<')[1].split('>')[0])\n+        except:\n+            return name\n+\n+    threads.sort(lambda a, b: cmp(tin(a.name), tin(b.name)))\n     return threads\n \n def get_classes():\n@@ -71,6 +77,9 @@ def info(value):\n         return thread_info(value)\n     if isinstance(value, andbug.Frame):\n         return frame_info(value)\n+    if isinstance(value, andbug.Array):\n+        if value.jni in ('[C', '[B'):\n+            return repr(value).replace('\\\\x00', '') # HACK\n     if isinstance(value, andbug.Object):\n         return object_info(value)\n     return str(value)\n"}
{"repo": "AndBug", "commit": "31ed33c2df0c0d2471e3eb1b9eef77fb9eab4c7f", "diff": "diff --git a/lib/andbug/__init__.py b/lib/andbug/__init__.py\nindex c749d2d..ee50483 100644\n--- a/lib/andbug/__init__.py\n+++ b/lib/andbug/__init__.py\n@@ -38,6 +38,6 @@ from andbug.command import action\n \n ## andbug.vm -- abstraction of the virtual machine model\n from andbug.vm import (\n-    Element, Session, Frame, Object, String, Method, RefType, Slot, \n+    Element, Session, Frame, Array, Object, String, Method, RefType, Slot, \n     Thread, Hook, Location, Class, connect\n )\n"}
{"repo": "AndBug", "commit": "6cb430327c847dfa503d5abede23dd3f2968775c", "diff": "diff --git a/lib/andbug/cmd/resume.py b/lib/andbug/cmd/resume.py\nindex f975481..373ab77 100644\n--- a/lib/andbug/cmd/resume.py\n+++ b/lib/andbug/cmd/resume.py\n@@ -19,12 +19,13 @@ import andbug.command, andbug.screed\n @andbug.command.action('[<name>]', shell=True)\n def resume(ctxt, name=None):\n     'resumes threads in the process'\n-    ctxt.sess.resume()\n+    if name is None:\n+        ctxt.sess.resume()\n+        return andbug.screed.section('Process Resumed')\n+    elif name == '*':\n+        name = None\n \n     with andbug.screed.section('Resuming Threads'):\n-        try:\n-            for t in ctxt.sess.threads(name):\n-                t.resume()\n-                andbug.screed.item('resumed %s' % t)\n-        finally:\n-            ctxt.sess.resume()\n+        for t in ctxt.sess.threads(name):\n+            t.resume()\n+            andbug.screed.item('resumed %s' % t)\ndiff --git a/lib/andbug/cmd/suspend.py b/lib/andbug/cmd/suspend.py\nindex 1a829fd..7f3f234 100644\n--- a/lib/andbug/cmd/suspend.py\n+++ b/lib/andbug/cmd/suspend.py\n@@ -19,12 +19,13 @@ import andbug.command, andbug.screed\n @andbug.command.action('[<name>]', shell=True)\n def suspend(ctxt, name=None):\n     'suspends threads in the process'\n-    ctxt.sess.suspend()\n+    if name is None:\n+        ctxt.sess.suspend()\n+        return andbug.screed.section('Process Suspended')\n+    elif name == '*':\n+        name = None\n \n     with andbug.screed.section('Suspending Threads'):\n-        try:\n-            for t in ctxt.sess.threads(name):\n-                t.suspend()\n-                andbug.screed.item('suspended %s' % t)\n-        finally:\n-            ctxt.sess.resume()\n+        for t in ctxt.sess.threads(name):\n+            t.suspend()\n+            andbug.screed.item('suspended %s' % t)\ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 368638d..2a94a91 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -683,6 +683,12 @@ class Session(object):\n         if code != 0:\n             raise RequestError(code)\n \n+    @property\n+    def count(self):\n+        code, buf = self.conn.request(0x0108, '')\n+        if code != 0:\n+            raise RequestError(code)\n+\n     def resume(self):\n         code, buf = self.conn.request(0x0109, '')\n         if code != 0:\n@@ -833,9 +839,13 @@ class Array(Object):\n         if last > length:\n             raise IndexError('last offset (%s) past length of array' % last)\n         if first < 0:\n-            first = length + first\n+            first = length + first + 1\n+            if first < 0:\n+                raise IndexError('first absolute (%s) past length of array' % first)\n         if last < 0:\n-            last = length + last\n+            last = length + last + 1\n+            if last < 0:\n+                raise IndexError('last absolute (%s) past length of array' % last)\n         if first > last:\n             first, last = last, first\n         \n"}
{"repo": "AndBug", "commit": "46216a8e7a38bd6b85968c85568aa83a730ed183", "diff": "diff --git a/lib/andbug/cmd/navi.py b/lib/andbug/cmd/navi.py\nindex 85ec19b..03b86dc 100644\n--- a/lib/andbug/cmd/navi.py\n+++ b/lib/andbug/cmd/navi.py\n@@ -38,6 +38,9 @@ def frame_info(frame):\n     return info[0 if (len(info) == 1) else 1]\n \n def truncate_ojni(jni):\n+    if jni.startswith('['):\n+        return truncate_ojni(jni[1:]) + '[]'\n+\n     if jni.startswith('L'): \n         jni = jni[1:]\n         if jni.endswith(';'): jni = jni[:-1]\n@@ -138,6 +141,8 @@ NAVI_VERSION = 'AndBug Navi ' + NAVI_VERNO\n def view_slot(tid, fid, key, path=None):\n     'lists the values in the frame'\n     tid, fid, key = int(tid), int(fid), str(key)\n+    print repr(tid), repr(fid), repr(key), repr(path)\n+\n     value = tuple(threads[tid].frames)[fid].values.get(key)\n     data = json.dumps(view(value))\n     bottle.response.content_type = 'application/json'\n"}
{"repo": "AndBug", "commit": "bb355bc0960bad94e0a6b2cef1eca62d0e4dce65", "diff": "diff --git a/lib/andbug/cmd/navi.py b/lib/andbug/cmd/navi.py\nnew file mode 100644\nindex 0000000..070aadb\n--- /dev/null\n+++ b/lib/andbug/cmd/navi.py\n@@ -0,0 +1,249 @@\n+#!/usr/bin/env python\n+\n+## TODO: expand the forest to use <slot>, <info>, <more>\n+## TODO: add <value> browser\n+## TODO: add <value>/<slot> browser.\n+## TODO: add <array>/<index> browser.\n+## TODO: add close button to popouts\n+## TODO: add static class list\n+## TODO: remove useless \"masonry\" class\n+\n+import andbug\n+\n+try:\n+    import bottle\n+except ImportError:\n+    raise andbug.DependencyError('navi requires the \"bottle\" package')\n+    \n+import andbug, os.path, cgi, json, subprocess\n+from urllib2 import quote as urlquote\n+\n+################################################################### UTILITIES\n+# These functions make life a little easier, doing things like restructuring\n+# data structures to be easier to use from templates.\n+#############################################################################\n+\n+def index_seq(seq):\n+    for i in range(len(seq)):\n+        yield i, seq[i]\n+\n+############################################################## INFO UTILITIES\n+# These functions summarize various Java objects into human-readable \n+# representations.\n+#############################################################################\n+\n+def thread_info(thread):\n+    info = str(thread)\n+    return info[7:] if info.startswith('thread ') else info\n+\n+def frame_info(frame):\n+    info = str(frame).split( ', at ', 1)\n+    return info[0 if (len(info) == 1) else 1]\n+\n+def truncate_ojni(jni):\n+    if jni.startswith('L'): \n+        jni = jni[1:]\n+        if jni.endswith(';'): jni = jni[:-1]\n+\n+    jni = jni.split('/')\n+    if len(jni) == 1:\n+        return jni[0]\n+    else:\n+        return '%s.%s' % (\n+            '.'.join((a[0] if a else '') for a in jni[:-1]),\n+            jni[-1]\n+        )\n+\n+def object_info(object):\n+    return '<%s>' % truncate_ojni(object.jni)\n+\n+def info(value):\n+    if isinstance(value, andbug.Thread):\n+        return thread_info(value)\n+    if isinstance(value, andbug.Frame):\n+        return frame_info(value)\n+    if isinstance(value, andbug.Object):\n+        return object_info(value)\n+    return str(value)\n+    \n+############################################################## VIEW UTILITIES\n+# These functions summarize various Java objects into JSON views suitable for\n+# navigation panels.  Each view comes as a list, consisting of the name of a\n+# suitable constructor, and a series of arguments for the constructor.\n+#############################################################################\n+\n+def object_view(value):\n+    seq = ['obj', value.jni]\n+    for key, val in value.fields.iteritems():\n+        seq.append((key, info(val), key))\n+    return seq\n+    #TODO: slots\n+\n+def view(value):\n+    if isinstance(value, andbug.Object):\n+        return object_view(value)\n+    return ['val', info(value)]\n+\n+################################################################## DATA ROOTS\n+# We use static roots derived from the location of the Navi script.\n+#############################################################################\n+\n+NAVI_ROOT = os.path.abspath( \n+    os.path.join( os.path.dirname( __file__ ), '..' )\n+)\n+STATIC_ROOT = os.path.join( NAVI_ROOT, 'data', '' )\n+COFFEE_ROOT = os.path.join( NAVI_ROOT, 'coffee', '' )\n+bottle.TEMPLATE_PATH.append( os.path.join( NAVI_ROOT, 'view' ) )\n+\n+def resolve_resource(root, rsrc):\n+    assert root.endswith(os.path.sep)\n+    rsrc = os.path.abspath(root + rsrc)\n+    if rsrc.startswith(root):\n+        return rsrc\n+    else:\n+        raise Exception('Less dots next time.')\n+\n+def resolve_coffee_resource(root, rsrc):\n+    # We do not cache this at all; since this is a single-user, one-page\n+    # interface.. I give a damn.\n+    \n+    return data\n+\n+@bottle.route( '/s/:req#.*#' )\n+def static_data(req):\n+    rsrc = resolve_resource(COFFEE_ROOT, req)  \n+\n+    if rsrc.endswith('.coffee') and os.path.exists(rsrc):\n+        req = rsrc.replace(COFFEE_ROOT, '')[:-7] + '.js'\n+        try:\n+            ret = subprocess.call(('coffee', '-o', STATIC_ROOT, '-c', rsrc))\n+        except OSError:\n+            pass # use the cached version, looks like coffee isn't working.\n+    return bottle.static_file(req, root=STATIC_ROOT)\n+\n+################################################################# GLOBAL DATA\n+# Our Bottle server uses WSGIRef, which is a single-process asynchronous HTTP\n+# server.  Any given request handler can be sure that it has complete control\n+# of these globals, because WSGIRef is far too stupid to handle multiple\n+# concurrent requests.\n+#############################################################################\n+\n+NAVI_VERNO = '0.1'\n+NAVI_VERSION = 'AndBug Navi ' + NAVI_VERNO\n+\n+################################################################# THREAD AXIS\n+# The thread axis works from the process's thread list, digging into \n+# individual thread frames and their associated slots.\n+#\n+# >>> DEPRECATED <<<\n+#############################################################################\n+'''\n+@bottle.route('/t')\n+def list_threads():\n+    'lists the threads in the virtual machine'\n+    return bottle.template('threads', thread_index=thread_index)\n+\n+@bottle.route('/t/:tid')\n+def list_threads(tid):\n+    'lists the frames in the thread'\n+    tid = int(tid)\n+    frames = tuple(threads[tid].frames)\n+    frame_index = tuple(index_seq(frames))\n+    return bottle.template('frames', tid=tid, frame_index=frame_index)\n+\n+@bottle.route('/t/:tid/:fid')\n+def list_values(tid, fid):\n+    'lists the values in the frame'\n+    tid, fid = int(tid), int(fid)\n+    values = tuple(threads[tid].frames)[fid].values\n+    return bottle.template('values', tid=tid, fid=fid, values=values)\n+'''\n+\n+@bottle.route('/t/:tid/:fid/:key')\n+@bottle.route('/t/:tid/:fid/:key/:path#.*#')\n+def view_slot(tid, fid, key, path=None):\n+    'lists the values in the frame'\n+    tid, fid, key = int(tid), int(fid), str(key)\n+    value = tuple(threads[tid].frames)[fid].values.get(key)\n+    data = json.dumps(view(value))\n+    bottle.response.content_type = 'application/json'\n+    return data\n+\n+###################################################### THE THREAD FOREST (TT)\n+# The thread-forest API produces a JSON summary of the threads and their\n+# frame stacks.  This is consolidated into one data structure to reduce\n+# round trip latency.\n+#############################################################################\n+\n+#TODO: INSULATE\n+def seq_frame(frame, url):\n+    if not url.endswith('/'):\n+        url += '/'\n+    seq = [info(frame), frame.native]\n+    for key, val in frame.values.iteritems():\n+        seq.append((key, info(val), url + key))\n+    return seq\n+\n+def seq_thread(thread, url):\n+    if not url.endswith('/'): \n+        url += '/'\n+    seq = [info(thread)]\n+    frames = thread.frames\n+    for i in range(len(frames)):\n+        seq.append(seq_frame(frames[i], url + str(i)))\n+    return seq\n+\n+def seq_process():            \n+    return list(\n+        seq_thread(threads[i], '/t/%s/' % i) for i in range(len(threads))\n+    )\n+\n+@bottle.route('/tt')\n+def json_process():\n+    data = json.dumps(seq_process())\n+    bottle.response.content_type = 'application/json'\n+    return data\n+\n+############################################################## FRONT SIDE (/)\n+# The front-side interface uses the JSON API with jQuery and jQuery UI to\n+# present a coherent 'one-page' interface to the user; embeds the process\n+# forest for efficiency.\n+#############################################################################\n+\n+@bottle.route('/')\n+def frontend():\n+    return bottle.template('frontend', forest=json.dumps(seq_process()))\n+\n+################################################################### BOOTSTRAP\n+# Bottle assumes that the server session will dominate the process, and does\n+# not handle being spun up and down on demand.  Navi does not depend heavily\n+# on Bottle, so this could be decoupled and put under WSGIREF.\n+#############################################################################\n+\n+def navi_loop(p):\n+    # Look, bottle makes me do sad things..\n+    global proc, threads, classes\n+    proc = p\n+    \n+    # We do not resume, because JDWP will do this automatically when we\n+    # terminate.  (Thanks, Google.)\n+    proc.suspend()\n+\n+    # We cache a sorted list of threads and classes for usability\n+    threads = proc.threads()[:] # TODO This workaround for view is vulgar.\n+    threads.sort(lambda a, b: cmp(a.name, b.name))\n+    classes = proc.classes()[:] # TODO This workaround for view is vulgar.\n+    classes.sort(lambda a, b: cmp(a.jni, b.jni))\n+\n+    bottle.run(\n+        host='localhost',\n+        port=8080,\n+        reloader=False\n+    )\n+\n+@andbug.command.action('')\n+def navi(ctxt):\n+    'starts an http server for browsing process state'\n+    andbug.screed.item('navigating process state at http://localhost:8080')\n+    navi_loop(ctxt.sess)\n+\n"}
{"repo": "AndBug", "commit": "1454b2c62a1cf22347acb9618788bdf8bcfd87b6", "diff": "diff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex ec4dc7b..368638d 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -33,9 +33,13 @@ class Element(object):\n     def __repr__(self):\n         return '<%s>' % self\n \n+    def __str__(self):\n+        return '%s:%s' % (type(self).__name__, id(self))\n+\n class SessionElement(Element):\n     def __init__(self, sess):\n         self.sess = sess\n+\n     @property\n     def conn(self):\n         return self.sess.conn\n@@ -141,9 +145,6 @@ class Thread(SessionElement):\n         SessionElement.__init__(self, sess)\n         self.tid = tid\n     \n-    def __repr__(self):\n-        return '<%s>' % self\n-\n     def __str__(self):\n         return 'thread %s' % (self.name or hex(self.tid))\n \n@@ -393,7 +394,10 @@ class RefType(SessionElement):\n         self.tid = tid\n     \n     def __repr__(self):\n-        return '<ref %s %s#%x>' % (self.jni, chr(self.tag), self.tid)\n+        return '<type %s %s#%x>' % (self.jni, chr(self.tag), self.tid)\n+\n+    def __str__(self):\n+        return repr(self)\n \n     @classmethod \n     def unpackFrom(impl, sess, buf):\n@@ -415,28 +419,6 @@ class RefType(SessionElement):\n     gen = defer(load_signature, 'gen')\n     jni = defer(load_signature, 'jni')\n \n-                \n-class Class(RefType): \n-    def __init__(self, sess, tid):\n-        RefType.__init__(self, sess, tid)\n-    \n-    def __str__(self):\n-        return self.name\n-    \n-    def __repr__(self):\n-        return '<class %s>' % self\n-\n-    def hookEntries(self, func = None, queue = None):\n-        conn = self.conn\n-        buf = conn.buffer()\n-        # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (4)\n-        buf.pack('11i1t', 40, 1, 1, 4, self.tid) \n-        code, buf = conn.request(0x0F01, buf.data())\n-        if code != 0:\n-            raise RequestError(code)\n-        eid = buf.unpackInt()\n-        return self.sess.hook(eid, func, queue)\n-        \n     def load_fields(self):\n         sess = self.sess\n         conn = self.conn\n@@ -460,6 +442,7 @@ class Class(RefType):\n         self.fieldList = andbug.data.view(\n             load_field() for i in range(ct)\n         )        \n+\n     fieldList = defer(load_fields, 'fieldList')\n \n     @property\n@@ -525,16 +508,6 @@ class Class(RefType):\n     methodByJni = defer(load_methods, 'methodByJni')\n     methodByName = defer(load_methods, 'methodByName')\n \n-    def load_class(self):\n-        self.sess.load_classes()\n-        assert self.tag != None\n-        assert self.flags != None\n-\n-    tag = defer(load_class, 'tag')\n-    jni = defer(load_class, 'jni')\n-    gen = defer(load_class, 'gen')\n-    flags = defer(load_class, 'flags')\n-\n     def methods(self, name=None, jni=None):\n         if name and jni:\n             seq = self.methodByName[name]\n@@ -555,6 +528,37 @@ class Class(RefType):\n         name = name.replace('/', '.')\n         return name\n \n+class Class(RefType): \n+    def __init__(self, sess, tid):\n+        RefType.__init__(self, sess, 'L', tid)\n+        \n+    def __str__(self):\n+        return self.name\n+    \n+    def __repr__(self):\n+        return '<class %s>' % self\n+\n+    def hookEntries(self, func = None, queue = None):\n+        conn = self.conn\n+        buf = conn.buffer()\n+        # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (4)\n+        buf.pack('11i1t', 40, 1, 1, 4, self.tid) \n+        code, buf = conn.request(0x0F01, buf.data())\n+        if code != 0:\n+            raise RequestError(code)\n+        eid = buf.unpackInt()\n+        return self.sess.hook(eid, func, queue)\n+        \n+    #def load_class(self):\n+    #   self.sess.load_classes()\n+    #   assert self.tag != None\n+    #   assert self.flags != None\n+\n+    #tag = defer(load_class, 'tag')\n+    #jni = defer(load_class, 'jni')\n+    #gen = defer(load_class, 'gen')\n+    #flags = defer(load_class, 'flags')\n+\n class Hook(SessionElement):\n     def __init__(self, sess, ident, func = None, queue = None):\n         SessionElement.__init__(self, sess)\n@@ -752,6 +756,11 @@ class Object(Value):\n     \n     refType = defer(load_refType, 'refType')\n \n+    @property\n+    def fieldList(self):\n+        r = list(f for f in self.refType.fieldList if not f.static)\n+        return r\n+\n     @property\n     def typeTag(self):\n         return self.refType.tag\n@@ -762,11 +771,11 @@ class Object(Value):\n         conn = self.conn\n         buf = conn.buffer()\n         buf.packTypeId(self.oid)\n-        fields = list(f for f in self.fieldList if not f.static)\n+        fields = self.fieldList\n         buf.packInt(len(fields))\n         for field in fields:\n             buf.packFieldId(field.fid)\n-        code, buf = conn.request(0x1001, buf.data())\n+        code, buf = conn.request(0x0902, buf.data())\n         if code != 0:\n             raise RequestError(code)\n         ct = buf.unpackInt()\n"}
{"repo": "AndBug", "commit": "b5c156898e4b831d4bc9814440d81b172574510c", "diff": "diff --git a/lib/andbug/cmd/threads.py b/lib/andbug/cmd/threads.py\nindex 41f0492..d27ef94 100644\n--- a/lib/andbug/cmd/threads.py\n+++ b/lib/andbug/cmd/threads.py\n@@ -16,13 +16,13 @@\n \n import andbug.command, andbug.screed\n \n-@andbug.command.action('')\n-def threads(ctxt):\n+@andbug.command.action('[<name>]')\n+def threads(ctxt, name=None):\n     'lists threads in the process'\n     ctxt.sess.suspend()\n \n     try:\n-        for t in ctxt.sess.threads:\n+        for t in ctxt.sess.threads(name):\n             with andbug.screed.section(str(t)):\n                 for f in t.frames:\n                     name = str(f.loc)\ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex ac435b6..a6dd75e 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -13,7 +13,7 @@\n ## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug, andbug.data\n-import threading\n+import threading, re\n from andbug.data import defer\n from threading import Lock\n from Queue import Queue\n@@ -591,8 +591,7 @@ class Session(object):\n         if code != 0:\n             raise RequestError(code)\n \n-    @property\n-    def threads(self):\n+    def threads(self, name=None):\n         pool = self.pool\n         code, buf = self.conn.request(0x0104, '')\n         if code != 0:\n@@ -602,7 +601,16 @@ class Session(object):\n         def load_thread():\n             tid = buf.unpackObjectId()\n             return pool(Thread, self, tid)\n-        return andbug.data.view(load_thread() for x in range(0,ct))\n+\n+        seq = (load_thread() for x in range(0,ct))\n+        if name is not None:\n+            if rx_dalvik_tname.match(name):\n+                seq = (t for t in seq if t.name == name)\n+            else:\n+                seq = (t for t in seq if t.name.split(' ',1)[-1] == name)\n+        return andbug.data.view(seq)\n+\n+rx_dalvik_tname = re.compile('^<[0-9]+> .*$')\n \n class RefType(SessionElement):\n     def __init__(self, sess, tag, tid):\n"}
{"repo": "AndBug", "commit": "12425d563c119f8de1ec54df19778d0ac60799c8", "diff": "diff --git a/lib/andbug/command.py b/lib/andbug/command.py\nindex eec0b9d..6997403 100644\n--- a/lib/andbug/command.py\n+++ b/lib/andbug/command.py\n@@ -171,6 +171,7 @@ class Context(object):\n             raise ConfigError('could not parse \"adb shell ps\" output')\n         \n         if pid:\n+            pid = int(pid)\n             ps = list(p for p in ps if p[0] == pid)\n             if not ps:\n                 raise OptionError('could not find process ' + pid)\n"}
{"repo": "AndBug", "commit": "cd4d49dba85375df0365bde0e80f74e14872ab5c", "diff": "diff --git a/lib/andbug/command.py b/lib/andbug/command.py\nindex 8346dcd..eec0b9d 100644\n--- a/lib/andbug/command.py\n+++ b/lib/andbug/command.py\n@@ -53,13 +53,15 @@ class ConfigError(UserError):\n     'indicates an error in the configuration of AndBug'\n     pass\n \n+def perr(*args):\n+    print >>sys.stderr, ' '.join(map(str, args))\n+\n RE_INT = re.compile('^[0-9]+$')\n \n def seq(*args):\n     return args\n \n def adb(*args):\n-    print 'adb:', repr(args)\n     try:\n         return sh(seq(\"adb\", *args))\n     except OSError as err:\n@@ -207,24 +209,24 @@ class Context(object):\n         act = ACTION_MAP.get(cmd)\n \n         if not act:\n-            print '!! command not supported: \"%s.\"' % cmd\n+            perr('!! command not supported: \"%s.\"' % cmd)\n             return False\n \n         if not self.can_perform(act):\n             if ctxt.shell:\n-                print '!! %s is not available in the shell.' % cmd\n+                perr('!! %s is not available in the shell.' % cmd)\n             else:\n-                print '!! %s is only available in the shell.' % cmd\n+                perr('!! %s is only available in the shell.' % cmd)\n             return False\n \n         args, opts = self.parseOpts(args, act.opts, act.proc)\n         argct = len(args) + 1 \n \n         if argct < act.min_arity:\n-            print 'andbug: command \"%s\" requires more arguments.' % cmd\n+            perr('!! command \"%s\" requires more arguments.' % cmd)\n             return False\n         elif argct > act.max_arity:\n-            print 'andbug: too many arguments for command \"%s.\"' % cmd\n+            perr('!! too many arguments for command \"%s.\"' % cmd)\n             return False\n \n         opts = filter(lambda opt: opt[0] in act.keys, opts)\n@@ -254,7 +256,6 @@ ACTION_LIST = []\n ACTION_MAP = {}\n \n def bind_action(name, fn, aliases):\n-    print \"BIND\", name, fn, aliases\n     ACTION_LIST.append(fn)\n     ACTION_MAP[name] = fn\n     for alias in aliases:\n@@ -298,7 +299,6 @@ def run_command(args, ctxt = None):\n     for item in args:\n         if item in ('-h', '--help', '-?', '-help'):\n             args = ('help', args[0])\n-            print args\n             break\n     \n     return ctxt.perform(args[0], args[1:])\n"}
{"repo": "AndBug", "commit": "c294d8751ff58f75e64ee2373452572ded5889bf", "diff": "diff --git a/lib/andbug/cmd/trace.py b/lib/andbug/cmd/trace.py\nindex d344147..e75037c 100644\n--- a/lib/andbug/cmd/trace.py\n+++ b/lib/andbug/cmd/trace.py\n@@ -17,27 +17,28 @@\n import andbug.command, andbug.screed, andbug.options\n from Queue import Queue\n \n+def report_hit(t):\n+    t = t[0]\n+    try:\n+        with andbug.screed.section(\"trace %s\" % t):\n+            for f in t.frames:\n+                name = str(f.loc)\n+                if f.native:\n+                    name += ' <native>'\n+                with andbug.screed.item(name):\n+                    for k, v in f.values.items():\n+                        andbug.screed.item( \"%s=%s\" %(k, v))\n+    finally:\n+        t.resume()\n+\n @andbug.command.action('<class-path>')\n def trace(ctxt, cpath):\n     'reports calls to dalvik methods associated with a class'\n-    q = Queue()    \n-\n     cpath = andbug.options.parse_cpath(cpath)\n+\n     with andbug.screed.section('Setting Hooks'):\n         for c in ctxt.sess.classes(cpath):\n-            c.hookEntries(q)\n+            c.hookEntries(func = report_hit)\n             andbug.screed.item('Hooked %s' % c)\n-\n-    while True:\n-        try:\n-            t = q.get()[0]\n-            with andbug.screed.section(str(t)):\n-                for f in t.frames:\n-                    name = str(f.loc)\n-                    if f.native:\n-                        name += ' <native>'\n-                    with andbug.screed.item(name):\n-                        for k, v in f.values.items():\n-                            andbug.screed.item( \"%s=%s\" %(k, v))\n-        finally:\n-            t.resume()\n+    \n+    ctxt.block_exit()\n\\ No newline at end of file\ndiff --git a/lib/andbug/command.py b/lib/andbug/command.py\nindex 1bec3db..aece229 100644\n--- a/lib/andbug/command.py\n+++ b/lib/andbug/command.py\n@@ -31,6 +31,7 @@ import os, os.path, sys, getopt, tempfile, inspect, re\n import andbug.proto, andbug.vm, andbug.cmd, andbug.source\n import traceback\n from andbug.util import sh\n+from time import sleep\n \n #TODO: make short_opts, long_opts, opt_table a dynamic parsing derivative.\n \n@@ -187,6 +188,20 @@ class Context(object):\n             return act.shell != False\n         return act.shell != True\n \n+    def block_exit(self):\n+        'prevents termination outside of shells'\n+\n+        if self.shell:\n+            # we do not need to block_exit, readline is doing a great\n+            # job of that for us.\n+            return\n+\n+        while True:\n+            # the purpose of the main thread becomes sleeping forever\n+            # this is because Python's brilliant threading model only\n+            # allows the main thread to perceive CTRL-C.\n+            sleep(3600)\n+        \n     def perform(self, cmd, args):\n         'performs the named command with the supplied arguments'\n         act = ACTION_MAP.get(cmd)\ndiff --git a/lib/andbug/proto.py b/lib/andbug/proto.py\nindex d324473..c82007a 100644\n--- a/lib/andbug/proto.py\n+++ b/lib/andbug/proto.py\n@@ -191,12 +191,12 @@ class Connection(Thread):\n \n     def processRequest(self, ident, code, data):\n         'internal to the i/o thread w/ recv ctrl; processes incoming request'\n-        fn = self.rmap.get(code)\n-        if not fn: return #TODO\n+        chan = self.rmap.get(code)\n+        if not chan: return #TODO\n         buf = JdwpBuffer()\n         buf.config(*self.sizes)\n         buf.prepareUnpack(data)\n-        fn(ident, buf)\n+        return chan.put((ident, buf))\n         \n     def processResponse(self, ident, code, data):\n         'internal to the i/o thread w/ recv ctrl; processes incoming response'\n@@ -205,17 +205,16 @@ class Connection(Thread):\n         buf = JdwpBuffer()\n         buf.config(*self.sizes)\n         buf.prepareUnpack(data)\n-        chan.put((code, buf))\n+        return chan.put((code, buf))\n \n-    def hook(self, code, func):\n+    def hook(self, code, chan):\n         '''\n-        func will be invoked when code requests are received in the i/o thread;\n-        you cannot safely issue requests here -- therefore, you should generally\n-        pass the call to a queue.\n+        when code requests are received, they will be put in chan for\n+        processing\n         '''\n \n         with self.xmitlock:\n-            self.bindqueue.put(('r', code, func))\n+            self.bindqueue.put(('r', code, chan))\n         \n     ####################################################### TRANSMITTING PACKETS\n     \ndiff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex 52aefa6..ac435b6 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -13,6 +13,7 @@\n ## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug, andbug.data\n+import threading\n from andbug.data import defer\n from threading import Lock\n from Queue import Queue\n@@ -196,7 +197,7 @@ class Location(SessionElement):\n         tag, cid, mid, loc = buf.unpack('1tm8')\n         return sess.pool(impl, sess, cid, mid, loc)\n \n-    def hook(self, queue = None):\n+    def hook(self, func = None, queue = None):\n         conn = self.conn\n         buf = conn.buffer()\n         # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type Location (7)\n@@ -207,7 +208,7 @@ class Location(SessionElement):\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n-        return self.sess.hook(eid, queue)\n+        return self.sess.hook(eid, func, queue)\n     \n     @property\n     def native(self):\n@@ -359,7 +360,7 @@ class Class(SessionElement):\n     def __repr__(self):\n         return '<class %s>' % self\n \n-    def hookEntries(self, queue):\n+    def hookEntries(self, func = None, queue = None):\n         conn = self.conn\n         buf = conn.buffer()\n         # 40:EK_METHOD_ENTRY, 1: SP_THREAD, 1 condition of type ClassRef (4)\n@@ -368,7 +369,7 @@ class Class(SessionElement):\n         if code != 0:\n             raise RequestError(code)\n         eid = buf.unpackInt()\n-        return self.sess.hook(eid, queue)\n+        return self.sess.hook(eid, func, queue)\n         \n     def load_methods(self):\n         cid = self.cid\n@@ -443,16 +444,24 @@ class Class(SessionElement):\n         return name\n \n class Hook(SessionElement):\n-    def __init__(self, sess, ident, queue = None):\n+    def __init__(self, sess, ident, func = None, queue = None):\n         SessionElement.__init__(self, sess)\n-        self.queue = queue or Queue()\n+        if queue is not None:\n+            self.queue = queue\n+        elif func is None:\n+            self.queue = queue or Queue()\n+        self.func = func        \n+                                    \n         self.ident = ident\n         #TODO: unclean\n         with self.sess.ectl:\n             self.sess.emap[ident] = self\n \n     def put(self, data):\n-        return self.queue.put(data)\n+        if self.func is not None:\n+            return self.func(data)\n+        else:\n+            return self.queue.put(data)\n             \n     def get(self, block = False, timeout = None):\n         return self.queue.get(block, timeout)\n@@ -492,12 +501,22 @@ class Session(object):\n         self.conn = conn\n         self.emap = {}\n         self.ectl = Lock()\n+        self.evtq = Queue()\n         if conn is not None:\n-            conn.hook(0x4064, self.processEvent)\n+            conn.hook(0x4064, self.evtq)\n             #TODO: REDUNDANT\n+        self.ethd = threading.Thread(\n+            name='Session', target=self.run\n+        )\n+        self.ethd.daemon=1\n+        self.ethd.start()\n+\n+    def run(self):\n+        while True:\n+            self.processEvent(*self.evtq.get())\n \n-    def hook(self, ident, queue = None):\n-        return Hook(self, ident, queue)\n+    def hook(self, ident, func = None, queue = None):\n+        return Hook(self, ident, func, queue)\n \n     def processEvent(self, ident, buf):\n         pol, ct = buf.unpack('1i')\n@@ -519,7 +538,7 @@ class Session(object):\n             if self.conn is None: \n                 self.conn = andbug.proto.connect('127.0.0.1', self.portno)\n         \n-            self.conn.hook(0x4064, self.processEvent)\n+            self.conn.hook(0x4064, func=self.processEvent)\n         return self.conn\n     \n     def load_classes(self):\n@@ -662,14 +681,19 @@ class Object(Value):\n ##        obj.dump()\n \n class Array(Object):\n-    #def __repr__(self):\n-    #    return '<array #%x %i>' % (self.oid, len(self))\n-    \n     def __repr__(self):\n-       return repr(self.getSlice())\n+        data = self.getSlice()\n+\n+        # Java very commonly uses character and byte arrays to express\n+        # text instead of strings, because they are mutable and have \n+        # different encoding implications.\n \n-    #def __str__(self):\n-    #   return repr(self.getSlice())\n+        if self.jni == '[C':\n+            return repr(''.join(data))\n+        elif self.jni == '[B':\n+            return repr(''.join(chr(c) for c in data))\n+        else:\n+            return repr(data)\n \n     def __getitem__(self, index):\n         if index < 0:\n"}
{"repo": "AndBug", "commit": "12e751fc932866ccafc135a6836218bece1056ea", "diff": "diff --git a/lib/andbug/vm.py b/lib/andbug/vm.py\nindex fa7d96d..18dca40 100644\n--- a/lib/andbug/vm.py\n+++ b/lib/andbug/vm.py\n@@ -27,8 +27,9 @@ class Context(object):\n     'an andbug vm context'\n     \n     def __init__(self, sess):\n+        assert isinstance(sess, Session)\n         self.sess = sess\n-        self.pool = andbug.data.Pool()\n+        self.pool = andbug.data.pool()\n     @property\n     def conn(self):\n         return self.sess.conn\n@@ -39,13 +40,18 @@ class Context(object):\n     def cpool(self):\n         return self.pool\n \n-class Session(object):\n-    def __init__(self, conn):\n-        self.conn = conn\n-        self.pool = andbug.data.Pool()\n     @property\n-    def spool(self):\n-        return self.sess.spool\n+    def threads(self):\n+        pool = self.pool\n+        code, buf = self.conn.request(0x0104, '')\n+        if code != 0:\n+            raise RequestError(code)\n+        ct = buf.unpackInt()\n+\n+        def load_thread():\n+            tid = buf.unpackObjectId()\n+            return pool(Thread, self, tid)\n+        return andbug.data.view(load_thread() for x in range(0,ct))\n \n class Element(object):\n     def __repr__(self):\n@@ -53,6 +59,7 @@ class Element(object):\n \n class ContextElement(Element):\n     def __init__(self, ctxt):\n+        assert isinstance(ctxt, Context)\n         self.ctxt = ctxt\n     @property\n     def sess(self):\n@@ -63,6 +70,7 @@ class ContextElement(Element):\n \n class SessionElement(Element):\n     def __init__(self, sess):\n+        assert isinstance(sess, Session)\n         self.sess = sess\n     @property\n     def conn(self):\n@@ -70,7 +78,7 @@ class SessionElement(Element):\n \n class Frame(ContextElement):\n     def __init__(self, ctxt, fid):\n-        ContextElement.__init__(ctxt)\n+        ContextElement.__init__(self, ctxt)\n         self.fid = fid\n         self.loc = None\n         self.tid = None\n@@ -116,9 +124,9 @@ class Frame(ContextElement):\n \n         return vals\n                                 \n-class Thread(SessionElement):\n-    def __init__(self, sess, tid):\n-        SessionElement.__init__(self, sess)\n+class Thread(ContextElement):\n+    def __init__(self, ctxt, tid):\n+        ContextElement.__init__(self, ctxt)\n         self.tid = tid\n     \n     def __repr__(self):\n@@ -147,13 +155,14 @@ class Thread(SessionElement):\n         buf.packObjectId(self.tid)\n \n     @classmethod\n-    def unpackFrom(impl, sess, buf):\n+    def unpackFrom(impl, ctxt, buf):\n         tid = buf.unpackObjectId()\n-        return sess.pool(impl, sess, tid)\n+        return ctxt.pool(impl, ctxt, tid)\n \n     @property\n     def frames(self):\n         tid = self.tid\n+        ctxt = self.ctxt\n         sess = self.sess\n         conn = self.conn\n         buf = conn.buffer()\n@@ -164,7 +173,7 @@ class Thread(SessionElement):\n         ct = buf.unpackInt()\n \n         def load_frame():\n-            f = Frame.unpackFrom(sess, buf)\n+            f = Frame.unpackFrom(ctxt, buf)\n             f.loc = Location.unpackFrom(sess, buf)\n             f.tid = tid\n             return f\n@@ -336,7 +345,6 @@ class Method(SessionElement):\n \n     def load_method(self):\n         self.klass.load_methods()\n-        assert self.name != None\n \n     name = defer(load_method, 'name')\n     jni = defer(load_method, 'jni')\n@@ -581,19 +589,6 @@ class Session(object):\n             seq = self.classList\n         return andbug.data.view(seq)\n     \n-    @property\n-    def threads(self):\n-        pool = self.pool\n-        code, buf = self.conn.request(0x0104, '')\n-        if code != 0:\n-            raise RequestError(code)\n-        ct = buf.unpackInt()\n-\n-        def load_thread():\n-            tid = buf.unpackObjectId()\n-            return pool(Thread, self, tid)\n-        return andbug.data.view(load_thread() for x in range(0,ct))\n-\n     def suspend(self):\n         code, buf = self.conn.request(0x0108, '')\n         if code != 0:\n@@ -612,6 +607,14 @@ class Session(object):\n         if code != 0:\n             raise RequestError(code)\n \n+    @property\n+    def threads(self):\n+        return Context(self).threads\n+\n+    @property\n+    def spool(self):\n+        return self.pool\n+\n class RefType(SessionElement):\n     def __init__(self, sess, tag, tid):\n         SessionElement.__init__(self, sess)\n"}
{"repo": "AndBug", "commit": "2b478f0d0750c89d3ab17ca505510391061fc4ae", "diff": "diff --git a/lib/andbug/proto.py b/lib/andbug/proto.py\nindex 8d2b294..d324473 100644\n--- a/lib/andbug/proto.py\n+++ b/lib/andbug/proto.py\n@@ -12,19 +12,26 @@\n ## You should have received a copy of the GNU Lesser General Public License\n ## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n+'''\n+The andbug.proto module abstracts the JDWP wire protocol into a more \n+manageable request/response API using an input worker thread in the\n+background and a number of mutexes to control contests for output.\n+'''\n+\n import socket\n from threading import Thread, Lock\n from andbug.jdwp import JdwpBuffer\n-import andbug.log\n from Queue import Queue, Empty as EmptyQueue\n \n class EOF(Exception):\n+    'signals that an EOF has been encountered'\n     def __init__(self, inner = None):\n         Exception.__init__(\n             self, str(inner) if inner else \"EOF\"\n         )\n \n class HandshakeError(Exception):\n+    'signals that the JDWP handshake failed'\n     def __init__(self):\n         Exception.__init__(\n             self, 'handshake error, received message did not match'\n@@ -43,6 +50,7 @@ IDSZ_REQ = (\n )\n \n def connect(addr, portno = None, trace=False):\n+    'connects to an AF_UNIX or AF_INET JDWP transport'\n     if addr and portno:\n         conn = socket.create_connection((addr, portno))\n     elif isinstance(addr, int):\n@@ -52,6 +60,7 @@ def connect(addr, portno = None, trace=False):\n         conn.connect(addr)\n \n     def read(amt):\n+        'read wrapper internal to andbug.proto.connect'\n         req = amt\n         buf = ''\n         while req:\n@@ -64,6 +73,7 @@ def connect(addr, portno = None, trace=False):\n         return buf \n     \n     def write(data):\n+        'write wrapper internal to andbug.proto.connect'\n         try:\n             if trace:\n                 print \":: XMIT:\", repr(data)\n@@ -77,7 +87,7 @@ def connect(addr, portno = None, trace=False):\n \n class Connection(Thread):\n     '''\n-    The JDWP Connectionor is a thread which abstracts the asynchronous JDWP protocol\n+    The JDWP Connection is a thread which abstracts the asynchronous JDWP protocol\n     into a more synchronous one.  The thread will listen for packets using the\n     supplied read function, and transmit them using the write function.  \n \n@@ -98,13 +108,14 @@ class Connection(Thread):\n         self._read = read\n         self.write = write\n         self.initialized = False\n-        self.nextId = 3\n+        self.next_id = 3\n         self.bindqueue = Queue()\n         self.qmap = {}\n         self.rmap = {}\n         self.xmitlock = Lock()\n \n     def read(self, sz):\n+        'read size bytes'\n         if sz == 0: return ''\n         pkt = self._read(sz)\n         if not len(pkt): raise EOF()\n@@ -113,14 +124,18 @@ class Connection(Thread):\n     ###################################################### INITIALIZATION STEPS\n     \n     def writeIdSzReq(self):\n+        'write an id size request'\n         return self.write(IDSZ_REQ)\n \n     def readIdSzRes(self):\n-        head = self.readHeader();\n+        'read an id size response'\n+        head = self.readHeader()\n         if head[0] != 20:\n             raise ProtocolError('expected size of an idsize response')\n         if head[2] != 0x80:\n-            raise ProtocolError('expected first server message to be a response')\n+            raise ProtocolError(\n+                'expected first server message to be a response'\n+            )\n         if head[1] != 1:\n             raise ProtocolError('expected first server message to be 1')\n \n@@ -131,11 +146,13 @@ class Connection(Thread):\n         return None\n \n     def readHandshake(self):\n+        'read the jdwp handshake'\n         data = self.read(len(HANDSHAKE_MSG))\n         if data != HANDSHAKE_MSG:\n             raise HandshakeError()\n         \n     def writeHandshake(self):\n+        'write the jdwp handshake'\n         return self.write(HANDSHAKE_MSG)\n \n     ############################################### READING / PROCESSING PACKETS\n@@ -166,13 +183,14 @@ class Connection(Thread):\n             self.processRequest(ident, code, data)\n \n     def processBind(self, qr, ident, chan):\n+        'internal to i/o thread; performs a query or request bind'\n         if qr == 'q':\n             self.qmap[ident] = chan\n         elif qr == 'r':\n             self.rmap[ident] = chan\n \n     def processRequest(self, ident, code, data):\n-        'used internally by the processor; must have recv control'\n+        'internal to the i/o thread w/ recv ctrl; processes incoming request'\n         fn = self.rmap.get(code)\n         if not fn: return #TODO\n         buf = JdwpBuffer()\n@@ -181,7 +199,7 @@ class Connection(Thread):\n         fn(ident, buf)\n         \n     def processResponse(self, ident, code, data):\n-        'used internally by the processor; must have recv control'        \n+        'internal to the i/o thread w/ recv ctrl; processes incoming response'\n         chan = self.qmap.pop(ident, None)\n         if not chan: return\n         buf = JdwpBuffer()\n@@ -191,7 +209,7 @@ class Connection(Thread):\n \n     def hook(self, code, func):\n         '''\n-        func will be invoked when code requests are received in the process loop;\n+        func will be invoked when code requests are received in the i/o thread;\n         you cannot safely issue requests here -- therefore, you should generally\n         pass the call to a queue.\n         '''\n@@ -203,8 +221,8 @@ class Connection(Thread):\n     \n     def acquireIdent(self):\n         'used internally by the processor; must have xmit control'\n-        ident = self.nextId\n-        self.nextId += 2\n+        ident = self.next_id\n+        self.next_id += 2\n         return ident\n \n     def writeContent(self, ident, flags, code, body):\n@@ -254,6 +272,7 @@ class Connection(Thread):\n         return None\n \n     def run(self):\n+        'runs forever; overrides the default Thread.run()'\n         try:\n             while True:\n                 self.process()\n"}
{"repo": "AndBug", "commit": "c5640b01db42e60f771aa79ace51c4748be9cfbe", "diff": "diff --git a/lib/andbug/log.py b/lib/andbug/log.py\nindex 7032a0d..c03f902 100644\n--- a/lib/andbug/log.py\n+++ b/lib/andbug/log.py\n@@ -16,134 +16,134 @@ import os, sys, time\n from cStringIO import StringIO\n \n def blocks(seq, sz):\n-\tofs = 0\n-\tlim = len(seq)\n-\twhile ofs < lim:\n-\t\tyield seq[ofs:ofs+sz]\n-\t\tofs += sz\n+    ofs = 0\n+    lim = len(seq)\n+    while ofs < lim:\n+        yield seq[ofs:ofs+sz]\n+        ofs += sz\n \n def censor(seq):\n-\tfor ch in seq:\n-\t\tif ch < '!': \n-\t\t\tyield '.'\n-\t\telif ch > '~':\n-\t\t\tyield '.'\n-\t\telse:\n-\t\t\tyield ch\n+    for ch in seq:\n+        if ch < '!': \n+            yield '.'\n+        elif ch > '~':\n+            yield '.'\n+        else:\n+            yield ch\n \n def format_hex(data, indent=\"\", width=16, out=None):\n-\tif out == None:\n-\t\tout = StringIO()\n-\t\tstrout = True\n-\telse:\n-\t\tstrout = False\n-\n-\tindent += \"%08x:  \"\n-\tofs = 0\n-\tfor block in blocks(data, width):\n-\t\tout.write(indent % ofs)\n-\t\tout.write(' '.join(map(lambda x: x.encode('hex'), block)))\n-\t\tif len(block) < width:\n-\t\t\tout.write( '   ' * (width - len(block)) )\n-\t\tout.write('  ')\n-\t\tout.write(''.join(censor(block)))\n-\t\tout.write(os.linesep)\n-\t\tofs += len(block)\n-\n-\tif strout:\n-\t\treturn out.getvalue()\n+    if out == None:\n+        out = StringIO()\n+        strout = True\n+    else:\n+        strout = False\n+\n+    indent += \"%08x:  \"\n+    ofs = 0\n+    for block in blocks(data, width):\n+        out.write(indent % ofs)\n+        out.write(' '.join(map(lambda x: x.encode('hex'), block)))\n+        if len(block) < width:\n+            out.write( '   ' * (width - len(block)) )\n+        out.write('  ')\n+        out.write(''.join(censor(block)))\n+        out.write(os.linesep)\n+        ofs += len(block)\n+\n+    if strout:\n+        return out.getvalue()\n \n def parse_hex(dump, out=None):\n-\tif out == None:\n-\t\tout = StringIO()\n-\t\tstrout = True\n-\telse:\n-\t\tstrout = False\n+    if out == None:\n+        out = StringIO()\n+        strout = True\n+    else:\n+        strout = False\n \n-\tfor row in dump.splitlines():\n-\t\trow = row.strip().split('  ')\n-\t\tblock = row[1].strip().split(' ')\n-\t\tblock = ''.join(map(lambda x: chr(int(x, 16)), block))\n-\t\tout.write(block)\n+    for row in dump.splitlines():\n+        row = row.strip().split('  ')\n+        block = row[1].strip().split(' ')\n+        block = ''.join(map(lambda x: chr(int(x, 16)), block))\n+        out.write(block)\n \n-\tif strout:\n-\t\treturn out.getvalue()\n+    if strout:\n+        return out.getvalue()\n \n class LogEvent(object):\n-\tdef __init__(self, time, tag, meta, data):\n-\t\tself.time = time\n-\t\tself.tag = tag\n-\t\tself.meta = meta\n-\t\tself.data = data or ''\n-\t\n-\tdef __str__(self):\n-\t\treturn \"%s %s %s\\n%s\" % (\n-\t\t\tself.tag, self.time, self.meta, \n-\t\t\tformat_hex(self.data, indent=\"    \")\n-\t\t)\n+    def __init__(self, time, tag, meta, data):\n+        self.time = time\n+        self.tag = tag\n+        self.meta = meta\n+        self.data = data or ''\n+    \n+    def __str__(self):\n+        return \"%s %s %s\\n%s\" % (\n+            self.tag, self.time, self.meta, \n+            format_hex(self.data, indent=\"    \")\n+        )\n \n class LogWriter(object):\n-\tdef __init__(self, file=sys.stdout):\n-\t\tself.file = file\n-\t\t\n-\tdef writeEvent(self, evt):\n-\t\tself.file.write(str(evt))\n+    def __init__(self, file=sys.stdout):\n+        self.file = file\n+        \n+    def writeEvent(self, evt):\n+        self.file.write(str(evt))\n \n class LogReader(object):\n-\tdef __init__(self, file=sys.stdin):\n-\t\tself.file = file\n-\t\tself.last = None\n-\t\n-\tdef readLine(self):\n-\t\tif self.last is None:\n-\t\t\tline = self.file.readline().rstrip()\n-\t\telse:\n-\t\t\tline = self.last\n-\t\t\tself.last = None\n-\t\treturn line\n-\n-\tdef pushLine(self, line):\n-\t\tself.last = line\n-\n-\tdef readEvent(self):\n-\t\tline = self.readLine()\n-\t\tif not line: return None\n-\t\tif line[0] == ' ':\n-\t\t\treturn self.readEvent() # Again..\n-\t\t \n-\t\ttag, time, meta = line.split(' ', 3)\n-\t\ttime = int(time)\n-\t\tdata = []\n-\n-\t\twhile True:\n-\t\t\tline = self.readLine()\n-\t\t\tif line.startswith( '    ' ):\n-\t\t\t\tdata.append(line)\n-\t\t\telse:\n-\t\t\t\tself.pushLine(line)\n-\t\t\t\tbreak\n-\t\t\t\t\n-\t\tif data:\n-\t\t\tdata = parse_hex('\\n'.join(data))\n-\t\telse:\n-\t\t\tdata = ''\n-\n-\t\treturn LogEvent(time, tag, meta, data)\n+    def __init__(self, file=sys.stdin):\n+        self.file = file\n+        self.last = None\n+    \n+    def readLine(self):\n+        if self.last is None:\n+            line = self.file.readline().rstrip()\n+        else:\n+            line = self.last\n+            self.last = None\n+        return line\n+\n+    def pushLine(self, line):\n+        self.last = line\n+\n+    def readEvent(self):\n+        line = self.readLine()\n+        if not line: return None\n+        if line[0] == ' ':\n+            return self.readEvent() # Again..\n+         \n+        tag, time, meta = line.split(' ', 3)\n+        time = int(time)\n+        data = []\n+\n+        while True:\n+            line = self.readLine()\n+            if line.startswith( '    ' ):\n+                data.append(line)\n+            else:\n+                self.pushLine(line)\n+                break\n+                \n+        if data:\n+            data = parse_hex('\\n'.join(data))\n+        else:\n+            data = ''\n+\n+        return LogEvent(time, tag, meta, data)\n \n stderr = LogWriter(sys.stderr)\n stdout = LogWriter(sys.stdout)\n \n def error(tag, meta, data = None):\n-\tnow = int(time.time())\n-\tstderr.writeEvent(LogEvent(now, tag, meta, data))\n+    now = int(time.time())\n+    stderr.writeEvent(LogEvent(now, tag, meta, data))\n \n def info(tag, meta, data = None):\n-\tnow = int(time.time())\n-\tstdout.writeEvent(LogEvent(now, tag, meta, data))\n+    now = int(time.time())\n+    stdout.writeEvent(LogEvent(now, tag, meta, data))\n \n def read_log(path=None, file=None):\n-\tif path is None:\n-\t\tif file is None:\n-\t\t\treader = stdin\n-\t\telse:\n-\t\t\treader = LogReader(sys.stdin)\n+    if path is None:\n+        if file is None:\n+            reader = stdin\n+        else:\n+            reader = LogReader(sys.stdin)\n"}
{"repo": "AndBug", "commit": "6d26c384cda2b7ff480af041ac372d16de6e6d0e", "diff": "diff --git a/lib/andbug/data.py b/lib/andbug/data.py\nindex c23ad46..44479a1 100644\n--- a/lib/andbug/data.py\n+++ b/lib/andbug/data.py\n@@ -15,160 +15,160 @@\n from threading import Lock\n \n class multidict(dict):\n-\t'''\n-\tboring old multidicts..\n-\t'''\n-\tdef get(self, key, alt=[]):\n-\t\treturn dict.get(self, key, alt)\n-\t\n-\tdef put(self, key, val):\n-\t\ttry:\n-\t\t\tdict.__getitem__(self, key).append(val)\n-\t\texcept KeyError:\n-\t\t\tv = view()\n-\t\t\tv.append(val)\n-\t\t\tdict.__setitem__(self, key, v)\n-\n-\tdef __setitem__(self, key, val):\n-\t\tself.put(key, val)\n-\t\n-\tdef __getitem__(self, key):\n-\t\treturn self.get(key)\n+    '''\n+    boring old multidicts..\n+    '''\n+    def get(self, key, alt=[]):\n+        return dict.get(self, key, alt)\n+    \n+    def put(self, key, val):\n+        try:\n+            dict.__getitem__(self, key).append(val)\n+        except KeyError:\n+            v = view()\n+            v.append(val)\n+            dict.__setitem__(self, key, v)\n+\n+    def __setitem__(self, key, val):\n+        self.put(key, val)\n+    \n+    def __getitem__(self, key):\n+        return self.get(key)\n \n class pool(object):\n-\t'''\n-\ta pool of singleton objects such that, for any combination of constructor \n-\tand 1 or more initializers, there may be zero or one objects; attempting\n-\tto reference a nonexisted object causes it to be created.\n-\n-\texample:\n-\t\tdef t(a): return [a,0]\n-\t\tp = pool()\n-\t\tt1 = p(t,1)\n-\t\tt2 = p(t,2)\n-\t\tp(t,1)[1] = -1\n-\t\t# t1[1] is now -1, not 1\n-\t'''\n-\tdef __init__(self):\n-\t\tself.pools = {}\n-\t\tself.lock = Lock()\n-\tdef __call__(self, *ident):\n-\t\twith self.lock:\n-\t\t\tpool = self.pools.get(ident)\n-\t\t\tif pool is None:\n-\t\t\t\tpool = ident[0](*ident[1:])\n-\t\t\t\tself.pools[ident] = pool\n-\t\t\treturn pool\n+    '''\n+    a pool of singleton objects such that, for any combination of constructor \n+    and 1 or more initializers, there may be zero or one objects; attempting\n+    to reference a nonexisted object causes it to be created.\n+\n+    example:\n+        def t(a): return [a,0]\n+        p = pool()\n+        t1 = p(t,1)\n+        t2 = p(t,2)\n+        p(t,1)[1] = -1\n+        # t1[1] is now -1, not 1\n+    '''\n+    def __init__(self):\n+        self.pools = {}\n+        self.lock = Lock()\n+    def __call__(self, *ident):\n+        with self.lock:\n+            pool = self.pools.get(ident)\n+            if pool is None:\n+                pool = ident[0](*ident[1:])\n+                self.pools[ident] = pool\n+            return pool\n \n class view(object):\n-\t'''\n-\ta homogenous collection of objects that may be acted upon in unison, such\n-\tthat calling a method on the collection with given arguments would result\n-\tin calling that method on each object and returning the results as a list\n-\t'''\n-\n-\tdef __init__(self, items = []):\n-\t\tself.items = list(items)\n-\tdef __repr__(self):\n-\t\treturn '(' + ', '.join(str(item) for item in self.items) + ')'\n-\tdef __len__(self):\n-\t\treturn len(self.items)\n-\tdef __getitem__(self, index):\n-\t\treturn self.items[index]\n-\tdef __iter__(self):\n-\t\treturn iter(self.items)\n-\tdef __getattr__(self, key):\n-\t\tdef poolcall(*args, **kwargs):\n-\t\t\tt = tuple( \n-\t\t\t\tgetattr(item, key)(*args, **kwargs) for item in self.items\n-\t\t\t)\n-\t\t\tfor n in t:\n-\t\t\t\tif not isinstance(n, view):\n-\t\t\t\t\treturn view(t)\n-\t\t\treturn view(flatten(t))\n-\t\tpoolcall.func_name = '*' + key\n-\t\treturn poolcall\n-\tdef get(self, key):\n-\t\treturn view(getattr(item, key) for item in self.items)\n-\tdef set(self, key, val):\n-\t\tfor item in self.items:\n-\t\t\tsetattr(item, key, val)\n-\tdef append(self, val):\n-\t\tself.items.append(val)\n+    '''\n+    a homogenous collection of objects that may be acted upon in unison, such\n+    that calling a method on the collection with given arguments would result\n+    in calling that method on each object and returning the results as a list\n+    '''\n+\n+    def __init__(self, items = []):\n+        self.items = list(items)\n+    def __repr__(self):\n+        return '(' + ', '.join(str(item) for item in self.items) + ')'\n+    def __len__(self):\n+        return len(self.items)\n+    def __getitem__(self, index):\n+        return self.items[index]\n+    def __iter__(self):\n+        return iter(self.items)\n+    def __getattr__(self, key):\n+        def poolcall(*args, **kwargs):\n+            t = tuple( \n+                getattr(item, key)(*args, **kwargs) for item in self.items\n+            )\n+            for n in t:\n+                if not isinstance(n, view):\n+                    return view(t)\n+            return view(flatten(t))\n+        poolcall.func_name = '*' + key\n+        return poolcall\n+    def get(self, key):\n+        return view(getattr(item, key) for item in self.items)\n+    def set(self, key, val):\n+        for item in self.items:\n+            setattr(item, key, val)\n+    def append(self, val):\n+        self.items.append(val)\n \n def flatten(seq):\n-\tfor ss in seq:\n-\t\tfor s in ss:\n-\t\t\tyield s\n+    for ss in seq:\n+        for s in ss:\n+            yield s\n \n def defer(func, name):\n-\t'''\n-\ta property decorator that, when applied, specifies a property that relies\n-\ton the execution of a costly function for its resolution; this permits the\n-\tdeferral of evaluation until the first time it is needed.\n-\n-\tunlike other deferral implementation, this one accepts the reality that the\n-\tproduct of a single calculation may be multiple properties\n-\t'''\n-\tdef fget(obj, type=None):\t\n-\t\ttry:\n-\t\t\treturn obj.props[name]\n-\t\texcept KeyError:\n-\t\t\tpass\n-\t\texcept AttributeError:\n-\t\t\tobj.props = {}\n-\n-\t\tobj.props[name] = None\n-\t\tfunc(obj)\n-\t\treturn obj.props[name]\n-\t\n-\tdef fset(obj, value):\n-\t\ttry:\n-\t\t\tobj.props[name] = value\n-\t\texcept AttributeError:\n-\t\t\tobj.props = {name : value}\n-\n-\tfget.func_name = 'get_' + name\n-\tfset.func_name = 'set_' + name\n-\treturn property(fget, fset)\n+    '''\n+    a property decorator that, when applied, specifies a property that relies\n+    on the execution of a costly function for its resolution; this permits the\n+    deferral of evaluation until the first time it is needed.\n+\n+    unlike other deferral implementation, this one accepts the reality that the\n+    product of a single calculation may be multiple properties\n+    '''\n+    def fget(obj, type=None):   \n+        try:\n+            return obj.props[name]\n+        except KeyError:\n+            pass\n+        except AttributeError:\n+            obj.props = {}\n+\n+        obj.props[name] = None\n+        func(obj)\n+        return obj.props[name]\n+    \n+    def fset(obj, value):\n+        try:\n+            obj.props[name] = value\n+        except AttributeError:\n+            obj.props = {name : value}\n+\n+    fget.func_name = 'get_' + name\n+    fset.func_name = 'set_' + name\n+    return property(fget, fset)\n \n if __name__ == '__main__':\n-\tpool = pool()\n-\n-\tclass classitem:\n-\t\tdef __init__(self, cid):\n-\t\t\tself.cid = cid\n-\t\tdef __repr__(self):\n-\t\t\treturn '<class %s>' % self.cid\n-\n-\tclass methoditem:\n-\t\tdef __init__(self, cid, mid):\n-\t\t\tself.cid = cid\n-\t\t\tself.mid = mid\n-\t\tdef __repr__(self):\n-\t\t\treturn '<method %s:%s>' % (self.cid, self.mid)\n-\t\tdef classitem(self):\n-\t\t\treturn pool(classitem, self.cid)\n-\t\tdef load_line_table(self):\n-\t\t\tprint \"LOAD-LINE-TABLE\", self.cid, self.mid\n-\t\t\tself.first = 1\n-\t\t\tself.last = 1\n-\t\t\tself.lines = []\n-\t\tdef trace(self):\n-\t\t\tprint \"TRACE\", self.cid, self.mid\n-\n-\t\tfirst = defer(load_line_table, 'first')\n-\t\tlast =  defer(load_line_table, 'last')\n-\t\tlines = defer(load_line_table, 'lines')\n-\n-\tm1 = pool(methoditem, 'c1', 'm1')\n-\tm2 = pool(methoditem, 'c1', 'm2')\n-\tm3 = pool(methoditem, 'c2', 'm3')\n-\tv = view((m1,m2,m3))\n-\tprint v\n-\tprint v.trace\n-\tprint v.trace()\n-\tprint (v.get('first'))\n-\tprint (v.get('last'))\n-\tprint v.classitem()\n-\tprint list(m for m in v)\n+    pool = pool()\n+\n+    class classitem:\n+        def __init__(self, cid):\n+            self.cid = cid\n+        def __repr__(self):\n+            return '<class %s>' % self.cid\n+\n+    class methoditem:\n+        def __init__(self, cid, mid):\n+            self.cid = cid\n+            self.mid = mid\n+        def __repr__(self):\n+            return '<method %s:%s>' % (self.cid, self.mid)\n+        def classitem(self):\n+            return pool(classitem, self.cid)\n+        def load_line_table(self):\n+            print \"LOAD-LINE-TABLE\", self.cid, self.mid\n+            self.first = 1\n+            self.last = 1\n+            self.lines = []\n+        def trace(self):\n+            print \"TRACE\", self.cid, self.mid\n+\n+        first = defer(load_line_table, 'first')\n+        last =  defer(load_line_table, 'last')\n+        lines = defer(load_line_table, 'lines')\n+\n+    m1 = pool(methoditem, 'c1', 'm1')\n+    m2 = pool(methoditem, 'c1', 'm2')\n+    m3 = pool(methoditem, 'c2', 'm3')\n+    v = view((m1,m2,m3))\n+    print v\n+    print v.trace\n+    print v.trace()\n+    print (v.get('first'))\n+    print (v.get('last'))\n+    print v.classitem()\n+    print list(m for m in v)\n"}
{"repo": "AndBug", "commit": "b77232333bbb83b47782116e466d90a215cdb5a7", "diff": "diff --git a/lib/andbug/process.py b/lib/andbug/process.py\nindex 8983979..79c948a 100644\n--- a/lib/andbug/process.py\n+++ b/lib/andbug/process.py\n@@ -17,7 +17,8 @@ from andbug.data import defer\n from threading import Lock\n from Queue import Queue\n \n-class Failure(Exception):\n+class RequestError(Exception):\n+    'raised when a request for more information from the process fails'\n     def __init__(self, code):\n         Exception.__init__(self, 'request failed, code %s' % code)\n         self.code = code\n@@ -67,7 +68,7 @@ class Frame(object):\n \n         code, buf = conn.request(0x1001, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         ct = buf.unpackInt()\n \n         for x in range(0, ct):\n@@ -93,7 +94,7 @@ class Thread(object):\n         buf.packObjectId(self.tid)\n         code, buf = conn.request(0x0B01, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n     def resume(self):\n         conn = self.proc.conn\n@@ -101,7 +102,7 @@ class Thread(object):\n         buf.pack('o', self.tid)\n         code, buf = conn.request(0x0B03, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n     def packTo(self, buf):\n         buf.packObjectId(self.tid)\n@@ -120,7 +121,7 @@ class Thread(object):\n         buf.pack('oii', self.tid, 0, -1)\n         code, buf = conn.request(0x0B06, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         ct = buf.unpackInt()\n \n         def load_frame():\n@@ -138,7 +139,7 @@ class Thread(object):\n         buf.packObjectId(self.tid)\n         code, buf = conn.request(0x0B07, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         return buf.unpackInt()\n \n     @property\n@@ -148,7 +149,7 @@ class Thread(object):\n         buf.packObjectId(self.tid)\n         code, buf = conn.request(0x0B01, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         return buf.unpackStr()\n \n class Location(object):\n@@ -183,7 +184,7 @@ class Location(object):\n         self.packTo(buf)\n         code, buf = conn.request(0x0F01, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         eid = buf.unpackInt()\n         return self.proc.hook(eid, queue)\n     \n@@ -265,7 +266,7 @@ class Method(object):\n         mid = self.mid\n         data = conn.buffer().pack('om', cid, mid)\n         code, buf = conn.request(0x0601, data)\n-        if code != 0: raise Failure(code)\n+        if code != 0: raise RequestError(code)\n         \n         f, l, ct = buf.unpack('88i')\n         if (f == -1) or (l == -1):             \n@@ -309,7 +310,7 @@ class Method(object):\n         mid = self.mid\n         data = conn.buffer().pack('om', cid, mid)\n         code, buf = conn.request(0x0605, data)\n-        if code != 0: raise Failure(code)\n+        if code != 0: raise RequestError(code)\n     \n         act, sct = buf.unpack('ii')\n         #TODO: Do we care about the argCnt ?\n@@ -347,7 +348,7 @@ class Class(object):\n         buf.pack('11i1t', 40, 1, 1, 4, self.cid) \n         code, buf = conn.request(0x0F01, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         eid = buf.unpackInt()\n         return self.proc.hook(eid, queue)\n         \n@@ -360,7 +361,7 @@ class Class(object):\n         buf.pack(\"t\", cid)\n         code, buf = conn.request(0x020F, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n         ct = buf.unpackU32()\n                 \n@@ -451,7 +452,7 @@ def unpack_events(proc, buf):\n         ek = buf.unpackU8()\n         im = unpack_impl[ek]\n         if im is None:\n-            raise Failure(ek)\n+            raise RequestError(ek)\n         else:\n             yield im(proc, buf)\n \n@@ -485,7 +486,7 @@ class Process(object):\n             ek = buf.unpackU8()\n             im = unpack_impl[ek]\n             if im is None:\n-                raise Failure(ek)\n+                raise RequestError(ek)\n             evt = im(self, buf)\n             with self.ectl:\n                 hook = self.emap.get(evt[0])\n@@ -504,7 +505,7 @@ class Process(object):\n     def load_classes(self):\n         code, buf = self.connect().request(0x0114)\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n         def load_class():\n             tag, cid, jni, gen, flags = buf.unpack('1t$$i')\n@@ -538,7 +539,7 @@ class Process(object):\n         pool = self.pool\n         code, buf = self.conn.request(0x0104, '')\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         ct = buf.unpackInt()\n \n         def load_thread():\n@@ -549,12 +550,12 @@ class Process(object):\n     def suspend(self):\n         code, buf = self.conn.request(0x0108, '')\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n     def resume(self):\n         code, buf = self.conn.request(0x0109, '')\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n     def exit(self, code = 0):\n         conn = self.proc.conn\n@@ -562,7 +563,7 @@ class Process(object):\n         buf.pack('i', code)\n         code, buf = conn.request(0x0108, '')\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n \n class RefType(object):\n     def __init__(self, proc, tag, tid):\n@@ -586,7 +587,7 @@ class RefType(object):\n         self.packTo(buf)\n         code, buf = conn.request(0x020d, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         self.jni = buf.unpackStr()\n         self.gen = buf.unpackStr()\n \n@@ -622,7 +623,7 @@ class Object(object):\n         self.packTo(buf)\n         code, buf = conn.request(0x0901, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         self.reftype = RefType.unpackFrom(self.proc, buf)\n     \n     reftype = defer(load_reftype, 'reftype')\n@@ -641,7 +642,7 @@ class String(Object):\n         self.packTo(buf)\n         code, buf = conn.request(0x0A01, buf.data())\n         if code != 0:\n-            raise Failure(code)\n+            raise RequestError(code)\n         return buf.unpackStr()\n \n unpack_value_impl = [None,] * 256\n@@ -667,7 +668,7 @@ def unpack_value(proc, buf, tag = None):\n     if tag is None: tag = buf.unpackU8()\n     fn = unpack_value_impl[tag]\n     if fn is None:\n-        raise Failure(tag)\n+        raise RequestError(tag)\n     else:\n         return fn(proc, buf)\n \n"}
{"repo": "AndBug", "commit": "4a577edd4cd50f3c80442cdcf995d2759c7d06b2", "diff": "diff --git a/lib/andbug/__init__.py b/lib/andbug/__init__.py\nindex 7bc0c49..792cfc0 100644\n--- a/lib/andbug/__init__.py\n+++ b/lib/andbug/__init__.py\n@@ -1,2 +1,16 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n import jdwp, proto, log, command\n connect = proto.connect\ndiff --git a/lib/andbug/cmd/classes.py b/lib/andbug/cmd/classes.py\nindex d717c5a..79d208d 100644\n--- a/lib/andbug/cmd/classes.py\n+++ b/lib/andbug/cmd/classes.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug.command\n \ndiff --git a/lib/andbug/cmd/help.py b/lib/andbug/cmd/help.py\nindex 1019859..3f57f8d 100644\n--- a/lib/andbug/cmd/help.py\n+++ b/lib/andbug/cmd/help.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug.command, andbug.options\n \ndiff --git a/lib/andbug/cmd/methods.py b/lib/andbug/cmd/methods.py\nindex b0e811f..4a1f738 100644\n--- a/lib/andbug/cmd/methods.py\n+++ b/lib/andbug/cmd/methods.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug.command, andbug.options\n \ndiff --git a/lib/andbug/cmd/threads.py b/lib/andbug/cmd/threads.py\nindex 8c8085f..b055e9b 100644\n--- a/lib/andbug/cmd/threads.py\n+++ b/lib/andbug/cmd/threads.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import sys\n from getopt import getopt\ndiff --git a/lib/andbug/cmd/trace.py b/lib/andbug/cmd/trace.py\nindex 15f112b..b75e0d0 100644\n--- a/lib/andbug/cmd/trace.py\n+++ b/lib/andbug/cmd/trace.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import sys\n import andbug.command\ndiff --git a/lib/andbug/command.py b/lib/andbug/command.py\nindex 3f6ada6..e1ff3f0 100644\n--- a/lib/andbug/command.py\n+++ b/lib/andbug/command.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n import os, os.path, sys, getopt, tempfile, inspect, re\n import andbug.proto, andbug.process, andbug.cmd\n from andbug.util import sh\ndiff --git a/lib/andbug/data.py b/lib/andbug/data.py\nindex 6a1477d..c23ad46 100644\n--- a/lib/andbug/data.py\n+++ b/lib/andbug/data.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n from threading import Lock\n \ndiff --git a/lib/andbug/log.py b/lib/andbug/log.py\nindex d34cba7..7032a0d 100644\n--- a/lib/andbug/log.py\n+++ b/lib/andbug/log.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP \"AS IS\" AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n    \n import os, sys, time\n from cStringIO import StringIO\ndiff --git a/lib/andbug/options.py b/lib/andbug/options.py\nindex bcc09ca..38da24f 100644\n--- a/lib/andbug/options.py\n+++ b/lib/andbug/options.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import sys\n \ndiff --git a/lib/andbug/process.py b/lib/andbug/process.py\nindex 0d4dc8e..8983979 100644\n--- a/lib/andbug/process.py\n+++ b/lib/andbug/process.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import andbug, andbug.data\n from andbug.data import defer\ndiff --git a/lib/andbug/proto.py b/lib/andbug/proto.py\nindex f1e0039..8d2b294 100644\n--- a/lib/andbug/proto.py\n+++ b/lib/andbug/proto.py\n@@ -1,27 +1,16 @@\n ## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n ##\n-## Redistribution and use in source and binary forms, with or without \n-## modification, are permitted provided that the following conditions are \n-## met:\n-## \n-##    1. Redistributions of source code must retain the above copyright \n-##       notice, this list of conditions and the following disclaimer.\n-## \n-##    2. Redistributions in binary form must reproduce the above copyright \n-##       notice, this list of conditions and the following disclaimer in the\n-##       documentation and/or other materials provided with the distribution.\n-## \n-## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n-## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n-## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n-## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n-## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n-## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n-## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n-## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n-## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n-## POSSIBILITY OF SUCH DAMAGE.\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n import socket\n from threading import Thread, Lock\ndiff --git a/setup.py b/setup.py\nindex 1f10b3c..68ef7b5 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n from distutils.core import setup, Extension, Command\n \n # Used by TestCommand and CleanCommand\ndiff --git a/tests/__init__.py b/tests/__init__.py\nindex a288bcb..4ccb0c4 100644\n--- a/tests/__init__.py\n+++ b/tests/__init__.py\n@@ -1,2 +1,15 @@\n-import jdwp\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n \n+import jdwp\ndiff --git a/tests/jdwp.py b/tests/jdwp.py\nindex df1ee8b..b2d4013 100644\n--- a/tests/jdwp.py\n+++ b/tests/jdwp.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n import andbug.jdwp\n from unittest import TestCase, main as test_main\n \ndiff --git a/tests/log.py b/tests/log.py\nindex 37a823a..5133837 100644\n--- a/tests/log.py\n+++ b/tests/log.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n from andbug.log import LogReader, LogWriter, LogEvent\n from unittest import TestCase, main as test_main\n from cStringIO import StringIO\ndiff --git a/tests/options.py b/tests/options.py\nindex 088dc97..6a25101 100644\n--- a/tests/options.py\n+++ b/tests/options.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n from andbug.options import parse_cpath, parse_mquery\n from unittest import TestCase, main as test_main\n \ndiff --git a/tests/proto.py b/tests/proto.py\nindex 700b147..5e00c1a 100644\n--- a/tests/proto.py\n+++ b/tests/proto.py\n@@ -1,3 +1,17 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## AndBug is free software: you can redistribute it and/or modify it under \n+## the terms of version 3 of the GNU Lesser General Public License as \n+## published by the Free Software Foundation.\n+##\n+## AndBug is distributed in the hope that it will be useful, but WITHOUT ANY\n+## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \n+## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for \n+## more details.\n+##\n+## You should have received a copy of the GNU Lesser General Public License\n+## along with AndBug.  If not, see <http://www.gnu.org/licenses/>.\n+\n from andbug.proto import Connection, HANDSHAKE_MSG, IDSZ_REQ\n from unittest import TestCase, main as test_main\n from cStringIO import StringIO\n"}
{"repo": "AndBug", "commit": "8b2a6565ee90dc4efd467d2739fc3f9f2d6355d3", "diff": "diff --git a/lib/andbug/cmd/help.py b/lib/andbug/cmd/help.py\nnew file mode 100644\nindex 0000000..1019859\n--- /dev/null\n+++ b/lib/andbug/cmd/help.py\n@@ -0,0 +1,37 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## Redistribution and use in source and binary forms, with or without \n+## modification, are permitted provided that the following conditions are \n+## met:\n+## \n+##    1. Redistributions of source code must retain the above copyright \n+##       notice, this list of conditions and the following disclaimer.\n+## \n+##    2. Redistributions in binary form must reproduce the above copyright \n+##       notice, this list of conditions and the following disclaimer in the\n+##       documentation and/or other materials provided with the distribution.\n+## \n+## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n+## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n+## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n+## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n+## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n+## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n+## POSSIBILITY OF SUCH DAMAGE.\n+\n+import andbug.command, andbug.options\n+\n+@andbug.command.action('<command>', proc=False)\n+def help(ctxt, cmd):\n+    'information about how to use andbug'\n+\n+    act = andbug.command.ACTION_MAP.get(cmd)\n+    if act is None:\n+        print 'andbug: there is no command named \"%s.\"' % cmd\n+        return\n+    print \"USAGE:\", cmd, \"[-d <dev>] -p <pid>\", act.usage \n+    print \"      \", act.__doc__\ndiff --git a/sample/trace.py b/lib/andbug/cmd/trace.py\nsimilarity index 100%\nrename from sample/trace.py\nrename to lib/andbug/cmd/trace.py\n"}
{"repo": "AndBug", "commit": "b66b21540bcd132f705c4c157447d7ce1d20ae17", "diff": "diff --git a/lib/andbug/cmd/methods.py b/lib/andbug/cmd/methods.py\nindex a91d4e2..e13e458 100644\n--- a/lib/andbug/cmd/methods.py\n+++ b/lib/andbug/cmd/methods.py\n@@ -23,44 +23,6 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n \n-'''\n-import sys\n-from getopt import getopt\n-from andbug.process import Process\n-from andbug.options import parse_cname\n-\n-def parse_options(opts):\n-    name, jni = None, None\n-    opts, args = getopt(sys.argv[1:], 'n:j:')\n-    for opt, val in opts:\n-        if opt == '-n':\n-            name = name\n-        elif opt == '-j':\n-            jni = val\n-    return name, jni, args\n-\n-def usage(name):\n-    print 'usage: %s [-n method-name] [-j method-jni-signature] port class' % name\n-    print '   ex: %s -n <init> 9012 java.net.URL' % name\n-    print ''\n-    sys.exit(2)\n-\n-def main(args):\n-    if len(args) < 3: usage(args[0])\n-    mn, jni, args = parse_options(args[1:])\n-    if len(args) != 2: usage(args[0])\n-\n-    port = int(args[0])\n-    cn = parse_cname(args[1])\n-    p = Process()\n-    p.connect(port)\n-    for m in p.classes(cn).methods(name=mn, jni=jni):\n-        print m#m.name, m.jni, m.firstLoc, m.lastLoc\n-\n-if __name__ == '__main__':\n-    main(sys.argv)\n-'''\n-\n import andbug.command, andbug.options\n \n @andbug.command.action('<class-name> [-n <name>] [-j <jni-signature>]', opts=(\ndiff --git a/sample/threads.py b/lib/andbug/cmd/threads.py\nsimilarity index 76%\nrename from sample/threads.py\nrename to lib/andbug/cmd/threads.py\nindex 4da5a64..2e2a31f 100644\n--- a/sample/threads.py\n+++ b/lib/andbug/cmd/threads.py\n@@ -27,27 +27,16 @@ import sys\n from getopt import getopt\n from andbug.process import Process, Failure\n \n-def usage(name):\n-\tprint 'usage: %s port' % name\n-\tprint '   ex: %s 9012' % name\n-\tprint ''\n-\tsys.exit(2)\n+import andbug.command\n \n-def main(args):\n-\tif len(args) != 2:\n-\t\tusage(args[0])\n-\n-\tport = int(args[1])\n-\tp = Process(port)\n-\tp.suspend()\n-\ttry:\n-\t\tfor t in p.threads:\n-\t\t\tf = t.frames[0]\n-\t\t\tprint str(t), f.loc, ('<native>' if f.native else '')\n-\t\t\tfor k, v in f.values.items():\n-\t\t\t\tprint \"    \", k, \"=\", v\n-\tfinally:\n-\t\tp.resume()\n-\n-if __name__ == '__main__':\n-\tmain(sys.argv)\n\\ No newline at end of file\n+@andbug.command.action('')\n+def threads(ctxt):\n+    ctxt.proc.suspend()\n+    try:\n+        for t in ctxt.proc.threads:\n+            f = t.frames[0]\n+            print str(t), f.loc, ('<native>' if f.native else '')\n+            for k, v in f.values.items():\n+                print \"    \", k, \"=\", v\n+    finally:\n+        ctxt.proc.resume()\n"}
{"repo": "AndBug", "commit": "15ea9f71d075b740f7b33be9a12ee33433c8abb8", "diff": "diff --git a/sample/methods.py b/lib/andbug/cmd/methods.py\nsimilarity index 58%\nrename from sample/methods.py\nrename to lib/andbug/cmd/methods.py\nindex 60016ba..a91d4e2 100644\n--- a/sample/methods.py\n+++ b/lib/andbug/cmd/methods.py\n@@ -23,39 +23,51 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n \n+'''\n import sys\n from getopt import getopt\n from andbug.process import Process\n from andbug.options import parse_cname\n \n def parse_options(opts):\n-\tname, jni = None, None\n-\topts, args = getopt(sys.argv[1:], 'n:j:')\n-\tfor opt, val in opts:\n-\t\tif opt == '-n':\n-\t\t\tname = name\n-\t\telif opt == '-j':\n-\t\t\tjni = val\n-\treturn name, jni, args\n+    name, jni = None, None\n+    opts, args = getopt(sys.argv[1:], 'n:j:')\n+    for opt, val in opts:\n+        if opt == '-n':\n+            name = name\n+        elif opt == '-j':\n+            jni = val\n+    return name, jni, args\n \n def usage(name):\n-\tprint 'usage: %s [-n method-name] [-j method-jni-signature] port class' % name\n-\tprint '   ex: %s -n <init> 9012 java.net.URL' % name\n-\tprint ''\n-\tsys.exit(2)\n+    print 'usage: %s [-n method-name] [-j method-jni-signature] port class' % name\n+    print '   ex: %s -n <init> 9012 java.net.URL' % name\n+    print ''\n+    sys.exit(2)\n \n def main(args):\n-\tif len(args) < 3: usage(args[0])\n-\tmn, jni, args = parse_options(args[1:])\n-\tif len(args) != 2: usage(args[0])\n+    if len(args) < 3: usage(args[0])\n+    mn, jni, args = parse_options(args[1:])\n+    if len(args) != 2: usage(args[0])\n \n-\tport = int(args[0])\n-\tcn = parse_cname(args[1])\n-\tp = Process()\n-\tp.connect(port)\n-\tfor m in p.classes(cn).methods(name=mn, jni=jni):\n-\t\tprint m#m.name, m.jni, m.firstLoc, m.lastLoc\n+    port = int(args[0])\n+    cn = parse_cname(args[1])\n+    p = Process()\n+    p.connect(port)\n+    for m in p.classes(cn).methods(name=mn, jni=jni):\n+        print m#m.name, m.jni, m.firstLoc, m.lastLoc\n \n if __name__ == '__main__':\n-\tmain(sys.argv)\n+    main(sys.argv)\n+'''\n \n+import andbug.command, andbug.options\n+\n+@andbug.command.action('<class-name> [-n <name>] [-j <jni-signature>]', opts=(\n+    (str, 'name', 'method name'),\n+    (str, 'jni', 'method jni signature')\n+))\n+def methods(ctxt, cname, name=None, jni=None):\n+    cn = andbug.options.parse_cname(cname)\n+    for m in ctxt.proc.classes(cn).methods(name=name, jni=jni):\n+        print m #m.name, m.jni, m.firstLoc, m.lastLoc\ndiff --git a/lib/andbug/command.py b/lib/andbug/command.py\nindex f00ac73..682180b 100644\n--- a/lib/andbug/command.py\n+++ b/lib/andbug/command.py\n@@ -1,21 +1,15 @@\n-import os, os.path, sys, getopt, tempfile, imp\n+import os, os.path, sys, getopt, tempfile, inspect\n import andbug.proto, andbug.process, andbug.cmd\n from andbug.util import sh\n \n+#TODO: make short_opts, long_opts, opt_table a dynamic parsing derivative.\n+\n OPTIONS = (\n     (int, 'pid', 'the process to be debugged, by pid'),\n     (str, 'name', 'the name of the process to be debugged, as found in ps'),\n     (str, 'dev', 'the device or emulator to be debugged (see adb)')\n )\n \n-SHORT_OPTS = ''.join(opt[1][0] + ':' for opt in OPTIONS)\n-LONG_OPTS = list(opt[1] + '=' for opt in OPTIONS)\n-OPT_TABLE = {}\n-\n-for opt in OPTIONS:\n-        OPT_TABLE['-' + opt[1][0]] = opt[0], opt[1]\n-        OPT_TABLE['--' + opt[1]] = opt[0], opt[1]\n-\n class OptionError(Exception):\n     pass\n \n@@ -35,12 +29,20 @@ class Context(object):\n         self.conn = andbug.proto.connect(self.forward())\n         self.proc = andbug.process.Process(self.conn)\n \n-    def parse_opts(self, args):\n+    def parse_opts(self, args, options=OPTIONS):\n+        short_opts = ''.join(opt[1][0] + ':' for opt in options)\n+        long_opts = list(opt[1] + '=' for opt in options)\n+        opt_table = {}\n+\n+        for opt in options:\n+                opt_table['-' + opt[1][0]] = opt[0], opt[1]\n+                opt_table['--' + opt[1]] = opt[0], opt[1]\n+\n         t = {}\n-        opts, args = getopt.gnu_getopt(args, SHORT_OPTS, LONG_OPTS)\n+        opts, args = getopt.gnu_getopt(args, short_opts, long_opts)\n \n         for o, v in opts:\n-            conv, key = OPT_TABLE[o]\n+            conv, key = opt_table[o]\n             try:\n                 v = conv(v)\n             except:\n@@ -99,13 +101,21 @@ class Context(object):\n         act = ACTION_MAP.get(cmd)\n \n         if not act:\n-            print \"andbug: command %s not supported.\" % cmd\n+            print 'andbug: command \"%s\" not supported.' % cmd\n             return False\n \n-        args = self.parse_opts(args)\n-        self.connect()\n-        act(self, *args)\n-        return True\n+        args = self.parse_opts(args, act.opts)\n+        argct = len(args) + 1 \n+        if argct < act.arity:\n+            print 'andbug: command \"%s\" requires more arguments.' % cmd\n+            return False\n+        elif argct > act.arity:\n+            print 'andbug: too many arguments for command \"%s.\"' % cmd\n+            return False\n+        else:\n+            self.connect()\n+            act(self, *args)\n+            return True\n         \n ACTION_LIST = []\n ACTION_MAP = {}\n@@ -113,11 +123,17 @@ ACTION_MAP = {}\n def bind_action(name, fn):\n     ACTION_LIST.append(fn)\n     ACTION_MAP[name] = fn\n-    print ACTION_MAP\n \n-def action(usage):\n+def action(usage, opts = ()):\n+    opts = OPTIONS[:] + opts\n+\n     def bind(fn):\n         fn.usage = usage\n+        fn.opts = opts\n+        spec = inspect.getargspec(fn)\n+        defct = len(spec.defaults) if spec.defaults else 0\n+        argct = len(spec.args) if spec.args else 0\n+        fn.arity = argct - defct\n         bind_action(fn.__name__, fn)\n     return bind\n \n"}
{"repo": "AndBug", "commit": "d0fe9ca55fd0d51a4509ec9a4a69d20a44291d8b", "diff": "diff --git a/lib/andbug/__init__.py b/lib/andbug/__init__.py\nindex fd1b17b..7bc0c49 100644\n--- a/lib/andbug/__init__.py\n+++ b/lib/andbug/__init__.py\n@@ -1,3 +1,2 @@\n-import jdwp, proto, log\n+import jdwp, proto, log, command\n connect = proto.connect\n-\ndiff --git a/lib/andbug/cmd/__init__.py b/lib/andbug/cmd/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/sample/classes.py b/lib/andbug/cmd/classes.py\nsimilarity index 76%\nrename from sample/classes.py\nrename to lib/andbug/cmd/classes.py\nindex 76192ae..d717c5a 100644\n--- a/sample/classes.py\n+++ b/lib/andbug/cmd/classes.py\n@@ -23,26 +23,12 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n \n-import sys\n-from getopt import getopt\n-from andbug.process import Process\n+import andbug.command\n \n-def usage(name):\n-\tprint 'usage: %s port' % name\n-\tprint '   ex: %s 9012' % name\n-\tprint ''\n-\tsys.exit(2)\n-\n-def main(args):\n-\tif len(args) != 2:\n-\t\tusage(args[0])\n-\n-\tport = int(args[1])\n-\tp = Process(port)\n-\tfor c in p.classes():\n-\t\tn = c.jni\n-\t\tif n.startswith('L') and n.endswith(';'):\n-\t\t\tprint n[1:-1].replace('/', '.')\n-\n-if __name__ == '__main__':\n-\tmain(sys.argv)\n\\ No newline at end of file\n+@andbug.command.action('')\n+def classes(ctxt):\n+    'lists loaded classes'\n+    for c in ctxt.proc.classes():\n+        n = c.jni\n+        if n.startswith('L') and n.endswith(';'):\n+            print n[1:-1].replace('/', '.')\ndiff --git a/lib/andbug/command.py b/lib/andbug/command.py\nnew file mode 100644\nindex 0000000..f00ac73\n--- /dev/null\n+++ b/lib/andbug/command.py\n@@ -0,0 +1,151 @@\n+import os, os.path, sys, getopt, tempfile, imp\n+import andbug.proto, andbug.process, andbug.cmd\n+from andbug.util import sh\n+\n+OPTIONS = (\n+    (int, 'pid', 'the process to be debugged, by pid'),\n+    (str, 'name', 'the name of the process to be debugged, as found in ps'),\n+    (str, 'dev', 'the device or emulator to be debugged (see adb)')\n+)\n+\n+SHORT_OPTS = ''.join(opt[1][0] + ':' for opt in OPTIONS)\n+LONG_OPTS = list(opt[1] + '=' for opt in OPTIONS)\n+OPT_TABLE = {}\n+\n+for opt in OPTIONS:\n+        OPT_TABLE['-' + opt[1][0]] = opt[0], opt[1]\n+        OPT_TABLE['--' + opt[1]] = opt[0], opt[1]\n+\n+class OptionError(Exception):\n+    pass\n+\n+class Context(object):\n+    def __init__(self):\n+        self.conn = None\n+        self.proc = None\n+\n+    def forward(self):\n+        temp = tempfile.mktemp()\n+        cmd = ['adb', '-s', self.dev] if self.dev else ['adb']\n+        cmd += ['forward', 'localfilesystem:' + temp,  'jdwp:' + self.pid]\n+        sh(cmd)\n+        return temp\n+\n+    def connect(self):\n+        self.conn = andbug.proto.connect(self.forward())\n+        self.proc = andbug.process.Process(self.conn)\n+\n+    def parse_opts(self, args):\n+        t = {}\n+        opts, args = getopt.gnu_getopt(args, SHORT_OPTS, LONG_OPTS)\n+\n+        for o, v in opts:\n+            conv, key = OPT_TABLE[o]\n+            try:\n+                v = conv(v)\n+            except:\n+                v = None\n+            t[key] = v\n+\n+        pid = t.get('pid')\n+        name = t.get('name')\n+        dev = t.get('dev')\n+\n+        if dev:\n+            if dev not in map( \n+                lambda x: x.split()[0], \n+                sh(('adb', 'devices')).splitlines()[1:-1]\n+            ):\n+                raise OptionError('device serial number not online')\n+            \n+            self.dev = dev            \n+        else:\n+            if len(sh(('adb', 'devices')).splitlines()) != 3:\n+                raise OptionError(\n+                    'you must specify a device serial unless there is only one online'\n+                )\n+            self.dev = None\n+\n+        ps = ('adb', 'shell', 'ps', '-s', dev) if dev else ('adb', 'shell', 'ps') \n+        \n+        if pid and name:\n+            raise OptionError('pid and process name options should not be combined')\n+        elif pid:\n+            if pid not in map( \n+                lambda x: x.split()[1], \n+                sh(('adb', 'shell', 'ps')).splitlines()[1:]\n+            ):\n+                raise OptionError('could not find process ' + pid)\n+        elif name:\n+            rows = filter( \n+                lambda x: x.split()[-1] == name, \n+                sh(('adb', 'shell', 'ps')).splitlines()[1:]\n+            )\n+\n+            if not rows:\n+                raise OptionError('could not find process ' + name)\n+            pid = rows[0].split()[1]\n+        else:\n+            raise OptionError('process pid or name must be specified')\n+\n+        self.pid = pid\n+        self.dev = dev\n+        return args\n+\n+    def perform(self, cmd, args):\n+        if cmd == 'help':\n+            list_commands()\n+            return False\n+        act = ACTION_MAP.get(cmd)\n+\n+        if not act:\n+            print \"andbug: command %s not supported.\" % cmd\n+            return False\n+\n+        args = self.parse_opts(args)\n+        self.connect()\n+        act(self, *args)\n+        return True\n+        \n+ACTION_LIST = []\n+ACTION_MAP = {}\n+\n+def bind_action(name, fn):\n+    ACTION_LIST.append(fn)\n+    ACTION_MAP[name] = fn\n+    print ACTION_MAP\n+\n+def action(usage):\n+    def bind(fn):\n+        fn.usage = usage\n+        bind_action(fn.__name__, fn)\n+    return bind\n+\n+CMD_DIR_PATH = os.path.abspath(os.path.join( os.path.dirname(__file__), \"cmd\" ))\n+\n+def load_commands():\n+    import pkgutil, andbug.cmd\n+    for name in os.listdir(CMD_DIR_PATH):\n+        if name.startswith( '__' ):\n+            continue\n+        if name.endswith( '.py' ):\n+            name = 'andbug.cmd.' + name[:-3]\n+            __import__( name )\n+\n+def run_command(args):\n+    ctxt = Context()\n+    return ctxt.perform(args[0], args[1:])\n+\n+def list_commands():\n+    print \":: Standard Options ::\"\n+    for t, k, d in OPTIONS:\n+        print \"\\t-%s, --%s <%s>  \\t%s\" % (k[0], k, t.__name__, d)\n+    print\n+    print \":: Commands ::\"\n+    for row in ACTION_LIST:\n+        print \"\\t%s\\t\\t\\t%s\" % (row.__name__, row.__doc__)\n+    print\n+    print \":: Examples ::\"\n+    print \"\\tandbug classes -n com.ioactive.decoy\"\n+\n+\ndiff --git a/lib/andbug/process.py b/lib/andbug/process.py\nindex ca8ca3f..dd3d3f0 100644\n--- a/lib/andbug/process.py\n+++ b/lib/andbug/process.py\n@@ -466,13 +466,11 @@ def unpack_method_entry(proc, buf):\n register_unpack_impl(40, unpack_method_entry)\n \n class Process(object):\n-    def __init__(self, portno = None, conn = None):\n+    def __init__(self, conn = None):\n         self.pool = andbug.data.pool()\n         self.conn = conn\n         self.emap = {}\n         self.ectl = Lock()\n-        if conn is None:\n-            self.connect(portno)\n \n     def hook(self, ident, queue = None):\n         return Hook(self, ident, queue)\ndiff --git a/lib/andbug/proto.py b/lib/andbug/proto.py\nindex afeb379..a742239 100644\n--- a/lib/andbug/proto.py\n+++ b/lib/andbug/proto.py\n@@ -29,238 +29,244 @@ from andbug.jdwp import JdwpBuffer\n from Queue import Queue, Empty as EmptyQueue\n \n class EOF(Exception):\n-\tdef __init__(self, inner = None):\n-\t\tException.__init__(\n-\t\t\tself, str(inner) if inner else \"EOF\"\n-\t\t)\n+    def __init__(self, inner = None):\n+        Exception.__init__(\n+            self, str(inner) if inner else \"EOF\"\n+        )\n \n class HandshakeError(Exception):\n-\tdef __init__(self):\n-\t\tException.__init__(\n-\t\t\tself, 'handshake error, received message did not match'\n-\t\t)\n+    def __init__(self):\n+        Exception.__init__(\n+            self, 'handshake error, received message did not match'\n+        )\n \n class ProtocolError(Exception):\n-\tpass\n+    pass\n \n HANDSHAKE_MSG = 'JDWP-Handshake'\n HEADER_FORMAT = '4412'\n IDSZ_REQ = (\n-\t'\\x00\\x00\\x00\\x0B' # Length\n-\t'\\x00\\x00\\x00\\x01' # Identifier\n-\t'\\x00'             # Flags\n-\t'\\x01\\x07'         # Command 1:7\n+    '\\x00\\x00\\x00\\x0B' # Length\n+    '\\x00\\x00\\x00\\x01' # Identifier\n+    '\\x00'             # Flags\n+    '\\x01\\x07'         # Command 1:7\n )\n \n-def connect(addr, portno, trace=False):\n-\tconn = socket.create_connection((addr, portno))\n+def connect(addr, portno = None, trace=False):\n+    if addr and portno:\n+        conn = socket.create_connection((addr, portno))\n+    elif isinstance(addr, int):\n+        conn = socket.create_connection(('127.0.0.1', addr))\n+    else:\n+        conn = socket.socket(socket.AF_UNIX)\n+        conn.connect(addr)\n \n-\tdef read(amt):\n-\t\treq = amt\n-\t\tbuf = ''\n-\t\twhile req:\n-\t\t\tpkt = conn.recv(req)\n-\t\t\tif not pkt: raise EOF()\n-\t\t\tbuf += pkt\n-\t\t\treq -= len(pkt)\n-\t\tif trace:\n-\t\t\tprint \":: RECV:\", repr(buf)\n-\t\treturn buf \n-\t\n-\tdef write(data):\n-\t\ttry:\n-\t\t\tif trace:\n-\t\t\t\tprint \":: XMIT:\", repr(data)\n-\t\t\tconn.sendall(data)\n-\t\texcept Exception as exc:\n-\t\t\traise EOF(exc)\n-\t\t\n-\tp = Connection(read, write)\n-\tp.start()\n-\treturn p\n+    def read(amt):\n+        req = amt\n+        buf = ''\n+        while req:\n+            pkt = conn.recv(req)\n+            if not pkt: raise EOF()\n+            buf += pkt\n+            req -= len(pkt)\n+        if trace:\n+            print \":: RECV:\", repr(buf)\n+        return buf \n+    \n+    def write(data):\n+        try:\n+            if trace:\n+                print \":: XMIT:\", repr(data)\n+            conn.sendall(data)\n+        except Exception as exc:\n+            raise EOF(exc)\n+        \n+    p = Connection(read, write)\n+    p.start()\n+    return p\n \n class Connection(Thread):\n-\t'''\n-\tThe JDWP Connectionor is a thread which abstracts the asynchronous JDWP protocol\n-\tinto a more synchronous one.  The thread will listen for packets using the\n-\tsupplied read function, and transmit them using the write function.  \n+    '''\n+    The JDWP Connectionor is a thread which abstracts the asynchronous JDWP protocol\n+    into a more synchronous one.  The thread will listen for packets using the\n+    supplied read function, and transmit them using the write function.  \n \n-\tRequests are sent by the processor using the calling thread, with a mutex \n-\tused to protect the write function from concurrent access.  The requesting\n-\tthread is then blocked waiting on a response from the processor thread.\n+    Requests are sent by the processor using the calling thread, with a mutex \n+    used to protect the write function from concurrent access.  The requesting\n+    thread is then blocked waiting on a response from the processor thread.\n \n-\tThe Connectionor will repeatedly use the read function to receive packets, which\n-\twill be dispatched based on whether they are responses to a previous request,\n-\tor events.  Responses to requests will cause the requesting thread to be\n-\tunblocked, thus simulating a synchronous request.\n-\t'''\n+    The Connectionor will repeatedly use the read function to receive packets, which\n+    will be dispatched based on whether they are responses to a previous request,\n+    or events.  Responses to requests will cause the requesting thread to be\n+    unblocked, thus simulating a synchronous request.\n+    '''\n \n-\tdef __init__(self, read, write):\n-\t\tThread.__init__(self)\n-\t\tself.xmitbuf = JdwpBuffer()\n-\t\tself.recvbuf = JdwpBuffer()\n-\t\tself._read = read\n-\t\tself.write = write\n-\t\tself.initialized = False\n-\t\tself.nextId = 3\n-\t\tself.bindqueue = Queue()\n-\t\tself.qmap = {}\n-\t\tself.rmap = {}\n-\t\tself.xmitlock = Lock()\n+    def __init__(self, read, write):\n+        Thread.__init__(self)\n+        self.xmitbuf = JdwpBuffer()\n+        self.recvbuf = JdwpBuffer()\n+        self._read = read\n+        self.write = write\n+        self.initialized = False\n+        self.nextId = 3\n+        self.bindqueue = Queue()\n+        self.qmap = {}\n+        self.rmap = {}\n+        self.xmitlock = Lock()\n \n-\tdef read(self, sz):\n-\t\tif sz == 0: return ''\n-\t\tpkt = self._read(sz)\n-\t\tif not len(pkt): raise EOF()\n-\t\treturn pkt\n+    def read(self, sz):\n+        if sz == 0: return ''\n+        pkt = self._read(sz)\n+        if not len(pkt): raise EOF()\n+        return pkt\n \n-\t###################################################### INITIALIZATION STEPS\n-\t\n-\tdef writeIdSzReq(self):\n-\t\treturn self.write(IDSZ_REQ)\n+    ###################################################### INITIALIZATION STEPS\n+    \n+    def writeIdSzReq(self):\n+        return self.write(IDSZ_REQ)\n \n-\tdef readIdSzRes(self):\n-\t\thead = self.readHeader();\n-\t\tif head[0] != 20:\n-\t\t\traise ProtocolError('expected size of an idsize response')\n-\t\tif head[2] != 0x80:\n-\t\t\traise ProtocolError('expected first server message to be a response')\n-\t\tif head[1] != 1:\n-\t\t\traise ProtocolError('expected first server message to be 1')\n+    def readIdSzRes(self):\n+        head = self.readHeader();\n+        if head[0] != 20:\n+            raise ProtocolError('expected size of an idsize response')\n+        if head[2] != 0x80:\n+            raise ProtocolError('expected first server message to be a response')\n+        if head[1] != 1:\n+            raise ProtocolError('expected first server message to be 1')\n \n-\t\tsizes = self.recvbuf.unpack( 'iiiii', self.read(20) )\n-\t\tself.sizes = sizes\n-\t\tself.recvbuf.config(*sizes)\n-\t\tself.xmitbuf.config(*sizes)\n-\t\treturn None\n+        sizes = self.recvbuf.unpack( 'iiiii', self.read(20) )\n+        self.sizes = sizes\n+        self.recvbuf.config(*sizes)\n+        self.xmitbuf.config(*sizes)\n+        return None\n \n-\tdef readHandshake(self):\n-\t\tdata = self.read(len(HANDSHAKE_MSG))\n-\t\tif data != HANDSHAKE_MSG:\n-\t\t\traise HandshakeError()\n-\t\t\n-\tdef writeHandshake(self):\n-\t\treturn self.write(HANDSHAKE_MSG)\n+    def readHandshake(self):\n+        data = self.read(len(HANDSHAKE_MSG))\n+        if data != HANDSHAKE_MSG:\n+            raise HandshakeError()\n+        \n+    def writeHandshake(self):\n+        return self.write(HANDSHAKE_MSG)\n \n-\t############################################### READING / PROCESSING PACKETS\n-\t\n-\tdef readHeader(self):\n-\t\t'reads a header and returns [size, id, flags, event]'\n-\t\thead = self.read(11)\n-\t\tdata = self.recvbuf.unpack(HEADER_FORMAT, head)\n-\t\tdata[0] -= 11\n-\t\treturn data\n-\t\n-\tdef process(self):\n-\t\t'invoked repeatedly by the processing thread'\n+    ############################################### READING / PROCESSING PACKETS\n+    \n+    def readHeader(self):\n+        'reads a header and returns [size, id, flags, event]'\n+        head = self.read(11)\n+        data = self.recvbuf.unpack(HEADER_FORMAT, head)\n+        data[0] -= 11\n+        return data\n+    \n+    def process(self):\n+        'invoked repeatedly by the processing thread'\n \n-\t\tsize, ident, flags, code = self.readHeader() #TODO: HANDLE CLOSE\n-\t\tdata = self.read(size) #TODO: HANDLE CLOSE\n-\t\ttry: # We process binds after receiving messages to prevent a race\n-\t\t\twhile True:\n-\t\t\t\tself.processBind(*self.bindqueue.get(False))\n-\t\texcept EmptyQueue:\n-\t\t\tpass\n+        size, ident, flags, code = self.readHeader() #TODO: HANDLE CLOSE\n+        data = self.read(size) #TODO: HANDLE CLOSE\n+        try: # We process binds after receiving messages to prevent a race\n+            while True:\n+                self.processBind(*self.bindqueue.get(False))\n+        except EmptyQueue:\n+            pass\n \n-\t\t#TODO: update binds with all from bindqueue\n-\t\t\n-\t\tif flags == 0x80:\n-\t\t\tself.processResponse(ident, code, data)\n-\t\telse:\n-\t\t\tself.processRequest(ident, code, data)\n+        #TODO: update binds with all from bindqueue\n+        \n+        if flags == 0x80:\n+            self.processResponse(ident, code, data)\n+        else:\n+            self.processRequest(ident, code, data)\n \n-\tdef processBind(self, qr, ident, chan):\n-\t\tif qr == 'q':\n-\t\t\tself.qmap[ident] = chan\n-\t\telif qr == 'r':\n-\t\t\tself.rmap[ident] = chan\n+    def processBind(self, qr, ident, chan):\n+        if qr == 'q':\n+            self.qmap[ident] = chan\n+        elif qr == 'r':\n+            self.rmap[ident] = chan\n \n-\tdef processRequest(self, ident, code, data):\n-\t\t'used internally by the processor; must have recv control'\n-\t\tfn = self.rmap.get(code)\n-\t\tif not fn: return #TODO\n-\t\tbuf = JdwpBuffer()\n-\t\tbuf.config(*self.sizes)\n-\t\tbuf.prepareUnpack(data)\n-\t\tfn(ident, buf)\n-\t\t\n-\tdef processResponse(self, ident, code, data):\n-\t\t'used internally by the processor; must have recv control'\t\t\n-\t\tchan = self.qmap.pop(ident, None)\n-\t\t\n-\t\tif not chan: return\n-\t\tbuf = JdwpBuffer()\n-\t\tbuf.config(*self.sizes)\n-\t\tbuf.prepareUnpack(data)\n-\t\tchan.put((code, buf))\n+    def processRequest(self, ident, code, data):\n+        'used internally by the processor; must have recv control'\n+        fn = self.rmap.get(code)\n+        if not fn: return #TODO\n+        buf = JdwpBuffer()\n+        buf.config(*self.sizes)\n+        buf.prepareUnpack(data)\n+        fn(ident, buf)\n+        \n+    def processResponse(self, ident, code, data):\n+        'used internally by the processor; must have recv control'        \n+        chan = self.qmap.pop(ident, None)\n+        \n+        if not chan: return\n+        buf = JdwpBuffer()\n+        buf.config(*self.sizes)\n+        buf.prepareUnpack(data)\n+        chan.put((code, buf))\n \n-\tdef hook(self, code, func):\n-\t\t'''\n-\t\tfunc will be invoked when code requests are received in the process loop;\n-\t\tyou cannot safely issue requests here -- therefore, you should generally\n-\t\tpass the call to a queue.\n-\t\t'''\n-\t\twith self.xmitlock:\n-\t\t\tself.bindqueue.put(('r', code, func))\n-\t\t\n-\t####################################################### TRANSMITTING PACKETS\n-\t\n-\tdef acquireIdent(self):\n-\t\t'used internally by the processor; must have xmit control'\n-\t\tident = self.nextId\n-\t\tself.nextId += 2\n-\t\treturn ident\n+    def hook(self, code, func):\n+        '''\n+        func will be invoked when code requests are received in the process loop;\n+        you cannot safely issue requests here -- therefore, you should generally\n+        pass the call to a queue.\n+        '''\n+        with self.xmitlock:\n+            self.bindqueue.put(('r', code, func))\n+        \n+    ####################################################### TRANSMITTING PACKETS\n+    \n+    def acquireIdent(self):\n+        'used internally by the processor; must have xmit control'\n+        ident = self.nextId\n+        self.nextId += 2\n+        return ident\n \n-\tdef writeContent(self, ident, flags, code, body):\n-\t\t'used internally by the processor; must have xmit control'\n+    def writeContent(self, ident, flags, code, body):\n+        'used internally by the processor; must have xmit control'\n \n-\t\tsize = len(body) + 11\n-\t\tself.xmitbuf.preparePack(11)\n-\t\tdata = self.xmitbuf.pack(\n-\t\t\tHEADER_FORMAT, size, ident, flags, code\n-\t\t)\n-\t\tself.write(data)\n-\t\treturn self.write(body)\n+        size = len(body) + 11\n+        self.xmitbuf.preparePack(11)\n+        data = self.xmitbuf.pack(\n+            HEADER_FORMAT, size, ident, flags, code\n+        )\n+        self.write(data)\n+        return self.write(body)\n \n-\tdef request(self, code, data='', timeout=None):\n-\t\t'send a request, then waits for a response; returns response'\n-\t\tqueue = Queue()\n+    def request(self, code, data='', timeout=None):\n+        'send a request, then waits for a response; returns response'\n+        queue = Queue()\n \n-\t\twith self.xmitlock:\n-\t\t\tident = self.acquireIdent()\n-\t\t\tself.bindqueue.put(('q', ident, queue))\n-\t\t\tself.writeContent(ident, 0x0, code, data)\n-\t\t\n-\t\ttry:\n-\t\t\treturn queue.get(1, timeout)\n-\t\texcept EmptyQueue:\n-\t\t\treturn None\n+        with self.xmitlock:\n+            ident = self.acquireIdent()\n+            self.bindqueue.put(('q', ident, queue))\n+            self.writeContent(ident, 0x0, code, data)\n+        \n+        try:\n+            return queue.get(1, timeout)\n+        except EmptyQueue:\n+            return None\n \n-\tdef buffer(self):\n-\t\t'returns a JdwpBuffer configured for this connection'\n-\t\tbuf = JdwpBuffer()\n-\t\tbuf.config(*self.sizes)\n-\t\treturn buf\n-\t\t\n-\t################################################################# THREAD API\n-\t\n-\tdef start(self):\n-\t\t'performs handshaking and solicits configuration information'\n-\t\tself.daemon = True\n+    def buffer(self):\n+        'returns a JdwpBuffer configured for this connection'\n+        buf = JdwpBuffer()\n+        buf.config(*self.sizes)\n+        return buf\n+        \n+    ################################################################# THREAD API\n+    \n+    def start(self):\n+        'performs handshaking and solicits configuration information'\n+        self.daemon = True\n \n-\t\tif not self.initialized:\n-\t\t\tself.writeHandshake()\n-\t\t\tself.readHandshake()\n-\t\t\tself.writeIdSzReq()\n-\t\t\tself.readIdSzRes()\n-\t\t\tself.initialized = True\n-\t\t\tThread.start(self)\n-\t\treturn None\n+        if not self.initialized:\n+            self.writeHandshake()\n+            self.readHandshake()\n+            self.writeIdSzReq()\n+            self.readIdSzRes()\n+            self.initialized = True\n+            Thread.start(self)\n+        return None\n \n-\tdef run(self):\n-\t\ttry:\n-\t\t\twhile True:\n-\t\t\t\tself.process()\n-\t\texcept EOF:\n-\t\t\treturn\n-\t\n+    def run(self):\n+        try:\n+            while True:\n+                self.process()\n+        except EOF:\n+            return\n+    \ndiff --git a/lib/andbug/util.py b/lib/andbug/util.py\nnew file mode 100644\nindex 0000000..6ee4214\n--- /dev/null\n+++ b/lib/andbug/util.py\n@@ -0,0 +1,87 @@\n+## Copyright 2011, Scott W. Dunlop <swdunlop@gmail.com> All rights reserved.\n+##\n+## Redistribution and use in source and binary forms, with or without \n+## modification, are permitted provided that the following conditions are \n+## met:\n+## \n+##    1. Redistributions of source code must retain the above copyright \n+##       notice, this list of conditions and the following disclaimer.\n+## \n+##    2. Redistributions in binary form must reproduce the above copyright \n+##       notice, this list of conditions and the following disclaimer in the\n+##       documentation and/or other materials provided with the distribution.\n+## \n+## THIS SOFTWARE IS PROVIDED BY SCOTT DUNLOP 'AS IS' AND ANY EXPRESS OR \n+## IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+## OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n+## IN NO EVENT SHALL SCOTT DUNLOP OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n+## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \n+## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, \n+## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n+## POSSIBILITY OF SUCH DAMAGE.\n+\n+import subprocess, threading, os, os.path\n+from cStringIO import StringIO\n+\n+class ShellException( Exception ):\n+    def __init__( self, command, output, status ):\n+        self.command = command\n+        self.output = output\n+        self.status = status\n+\n+def printout( prefix, data ):\n+    data = data.rstrip()\n+    if not data: return ''\n+    print prefix + data.replace( '\\n', '\\n' + prefix )\n+\n+def sh( command, no_echo=True, no_fail=False, no_wait=False ):\n+    if not no_echo: \n+        printout( '>>> ', repr( command ) )\n+\n+    process = subprocess.Popen( \n+        command,\n+        stdout = subprocess.PIPE,\n+        stderr = subprocess.STDOUT,\n+        stdin = None,\n+        shell = True if isinstance( command, str ) else False\n+    )\n+    \n+    if no_wait: return process\n+\n+    output, _ = process.communicate( )\n+    status = process.returncode\n+\n+    if status: \n+        if not no_echo: printout( '!!! ', output )\n+        if not no_fail: raise ShellException( command, output, status )\n+    else:\n+        if not no_echo: printout( '::: ', output )\n+\n+    return output\n+\n+def which( utility ):\n+    for path in os.environ['PATH'].split( os.pathsep ):\n+        path = os.path.expanduser( os.path.join( path, utility ) )\n+        if os.path.exists( path ):\n+            return path\n+\n+def test( command, no_echo=False ):\n+    process = subprocess.Popen( \n+        command,\n+        stdout = subprocess.PIPE,\n+        stderr = subprocess.STDOUT,\n+        stdin = None,\n+        shell = True if isinstance( command, str ) else False\n+    )\n+    \n+    output, _ = process.communicate( )\n+    return process.returncode\n+\n+def cat(*seqs):\n+    for seq in seqs:\n+        for item in seq:\n+            yield item\n+\ndiff --git a/setup.py b/setup.py\nindex 45bf039..ec39d9c 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -63,5 +63,6 @@ setup(\n \tpackages = ['andbug'],\n \text_modules = [jdwp],\n \tcmdclass = { 'test' : TestCommand, \n-\t\t\t\t 'clean' : CleanCommand }\n+\t\t\t\t 'clean' : CleanCommand },\n+    scripts = ['andbug']\n )\n"}
{"repo": "AndBug", "commit": "c7f8e8af84751dbcc4fc2ec89f62322997625cf5", "diff": "diff --git a/andbug/__init__.py b/lib/andbug/__init__.py\nsimilarity index 100%\nrename from andbug/__init__.py\nrename to lib/andbug/__init__.py\ndiff --git a/andbug/data.py b/lib/andbug/data.py\nsimilarity index 100%\nrename from andbug/data.py\nrename to lib/andbug/data.py\ndiff --git a/andbug/log.py b/lib/andbug/log.py\nsimilarity index 100%\nrename from andbug/log.py\nrename to lib/andbug/log.py\ndiff --git a/andbug/options.py b/lib/andbug/options.py\nsimilarity index 100%\nrename from andbug/options.py\nrename to lib/andbug/options.py\ndiff --git a/andbug/process.py b/lib/andbug/process.py\nsimilarity index 100%\nrename from andbug/process.py\nrename to lib/andbug/process.py\ndiff --git a/andbug/proto.py b/lib/andbug/proto.py\nsimilarity index 100%\nrename from andbug/proto.py\nrename to lib/andbug/proto.py\n"}
{"repo": "AndBug", "commit": "ff1c79823e238bcc1d1c12b7a1d3192ca0da47f2", "diff": "diff --git a/andbug/process.py b/andbug/process.py\nindex 281094c..6831e6e 100644\n--- a/andbug/process.py\n+++ b/andbug/process.py\n@@ -37,7 +37,8 @@ class Frame(object):\n \t\tself.proc = proc\n \t\tself.fid = fid\n \t\tself.loc = None\n-\t\n+\t\tself.tid = None\n+\t\t\t\n \tdef __repr__(self):\n \t\treturn '<%s>' % self\n \n@@ -45,6 +46,7 @@ class Frame(object):\n \t\treturn 'frame %s, at %s' % (\n \t\t\tself.fid, self.loc\n \t\t) \t\n+\n \t@classmethod \n \tdef unpackFrom(impl, proc, buf):\n \t\treturn proc.pool(impl, proc, buf.unpackFrameId())\n@@ -52,6 +54,7 @@ class Frame(object):\n \tdef packTo(self, buf):\n \t\tbuf.packFrameId(self.fid)\n \n+\t\n class Thread(object):\n \tdef __init__(self, proc, tid):\n \t\tself.proc = proc\n@@ -74,7 +77,7 @@ class Thread(object):\n \tdef resume(self):\n \t\tconn = self.proc.conn\n \t\tbuf = conn.buffer()\n-\t\tbuf.pack('t', self.tid)\n+\t\tbuf.pack('o', self.tid)\n \t\tcode, buf = conn.request(0x0B03, buf.data())\n \t\tif code != 0:\n \t\t\traise Failure(code)\n@@ -89,6 +92,7 @@ class Thread(object):\n \n \t@property\n \tdef frames(self):\n+\t\ttid = self.tid\n \t\tproc = self.proc\n \t\tconn = proc.conn\n \t\tbuf = conn.buffer()\n@@ -101,6 +105,7 @@ class Thread(object):\n \t\tdef load_frame():\n \t\t\tf = Frame.unpackFrom(proc, buf)\n \t\t\tf.loc = Location.unpackFrom(proc, buf)\n+\t\t\tf.tid = tid\n \t\t\treturn f\n \n \t\treturn andbug.data.view(load_frame() for i in range(0,ct))\n@@ -185,13 +190,13 @@ class Method(object):\n \tdef __repr__(self):\n \t\treturn '<method %s>' % self\n \n-\tdef load_table(self):\n+\tdef load_line_table(self):\n \t\tproc = self.proc\n \t\tconn = proc.conn\n \t\tpool = proc.pool\n \t\tcid = self.cid\n \t\tmid = self.mid\n-\t\tdata = conn.buffer().pack('tm', cid, mid)\n+\t\tdata = conn.buffer().pack('om', cid, mid)\n \t\tcode, buf = conn.request(0x0601, data)\n \t\tif code != 0: raise Failure(code)\n \t\t\n@@ -216,9 +221,9 @@ class Method(object):\n \t\tfor i in range(0,ct):\n \t\t\tline_loc()\n \t\n-\tfirstLoc = defer(load_table, 'firstLoc')\n-\tlastLoc = defer(load_table, 'lastLoc')\n-\tlineTable = defer(load_table, 'lineTable')\n+\tfirstLoc = defer(load_line_table, 'firstLoc')\n+\tlastLoc = defer(load_line_table, 'lastLoc')\n+\tlineTable = defer(load_line_table, 'lineTable')\n \n \tdef load_method(self):\n \t\tself.klass.load_methods()\n@@ -229,6 +234,7 @@ class Method(object):\n \tgen = defer(load_method, 'gen')\n \tflags = defer(load_method, 'flags' )\n \n+\t\t\t\t\n class Class(object): \n \tdef __init__(self, proc, cid):\n \t\tself.proc = proc\n@@ -451,3 +457,4 @@ class Process(object):\n \t\tcode, buf = conn.request(0x0108, '')\n \t\tif code != 0:\n \t\t\traise Failure(code)\n+\ndiff --git a/sample/threads.py b/sample/threads.py\nindex d4cba28..6935595 100644\n--- a/sample/threads.py\n+++ b/sample/threads.py\n@@ -45,6 +45,7 @@ def main(args):\n \t\t\tprint str(t)\n \t\t\tfor f in t.frames:\n \t\t\t\tprint \"    \", f.loc\n+\t\t\t\t\n \tfinally:\n \t\tp.resume()\n \n"}
{"repo": "AndBug", "commit": "0f8df9f0cadc711633e23e2bace29ab62935e060", "diff": "diff --git a/andbug/data.py b/andbug/data.py\nindex ec68f12..ad44929 100644\n--- a/andbug/data.py\n+++ b/andbug/data.py\n@@ -23,6 +23,19 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n \n+class multidict(dict):\n+\t'''\n+\tboring old multidicts..\n+\t'''\n+\tdef get(self, key, alt=[]):\n+\t\treturn dict.get(self, key, alt)\n+\t\n+\tdef put(self, key, val):\n+\t\ttry:\n+\t\t\tdict.__getitem__(self, key).append(val)\n+\t\texcept KeyError:\n+\t\t\tdict.__setitem__(self, key, [val])\n+\n class pool(object):\n \t'''\n \ta pool of singleton objects such that, for any combination of constructor \n@@ -42,18 +55,10 @@ class pool(object):\n \tdef __call__(self, *ident):\n \t\tpool = self.pools.get(ident)\n \t\tif pool is None:\n-\t\t\tpool = ident[0](self, *ident[1:])\n+\t\t\tpool = ident[0](*ident[1:])\n \t\t\tself.pools[ident] = pool\n \t\treturn pool\n \n-class item(object):\n-\t'''\n-\tan item which supports the defer property defined below\n-\t'''\n-\tdef __init__(self, pool):\n-\t\tself.pool = pool\n-\t\tself.props = {}\n-\n class view(object):\n \t'''\n \ta homogenous collection of objects that may be acted upon in unison, such\n@@ -83,7 +88,8 @@ class view(object):\n \t\tfor item in self.items:\n \t\t\tsetattr(item, key, val)\n \n-class defer(object):\n+\n+def defer(func, name):\n \t'''\n \ta property decorator that, when applied, specifies a property that relies\n \ton the execution of a costly function for its resolution; this permits the\n@@ -92,37 +98,44 @@ class defer(object):\n \tunlike other deferral implementation, this one accepts the reality that the\n \tproduct of a single calculation may be multiple properties\n \t'''\n-\tdef __init__(self, func, name):\n-\t\tself.func = func\n-\t\tself.name = name\n-\tdef __get__(self, obj, type=None):\n+\tdef fget(obj, type=None):\n \t\ttry:\n-\t\t\tval = obj.props[self.name]\n+\t\t\treturn obj.props[name]\n \t\texcept KeyError:\n-\t\t\tf = self.func\n-\t\t\tf(obj)\n-\t\t\tval = obj.props[self.name]\n+\t\t\tval = func(obj)\n+\t\t\tobj.props[name] = val\n+\t\texcept AttributeError:\n+\t\t\tval = func(obj)\n+\t\t\tobj.props = {name : val}\n \t\treturn val\n-\tdef __set__(self, obj, value):\n-\t\tobj.props[self.name] = value\n \t\n+\tdef fset(obj, value):\n+\t\ttry:\n+\t\t\tobj.props[self.name] = value\n+\t\texcept AttributeError:\n+\t\t\tobj.props = {name : val}\n+\n+\tfget.func_name = 'get_' + name\n+\tfset.func_name = 'set_' + name\n+\treturn property(fget, fset)\n+\n if __name__ == '__main__':\n-\tclass classitem(item):\n-\t\tdef __init__(self, pool, cid):\n-\t\t\titem.__init__(self, pool)\n+\tpool = pool()\n+\n+\tclass classitem:\n+\t\tdef __init__(self, cid):\n \t\t\tself.cid = cid\n \t\tdef __repr__(self):\n \t\t\treturn '<class %s>' % self.cid\n \n-\tclass methoditem(item):\n-\t\tdef __init__(self, pool, cid, mid):\n-\t\t\titem.__init__(self, pool)\n+\tclass methoditem:\n+\t\tdef __init__(self, cid, mid):\n \t\t\tself.cid = cid\n \t\t\tself.mid = mid\n \t\tdef __repr__(self):\n \t\t\treturn '<method %s:%s>' % (self.cid, self.mid)\n \t\tdef classitem(self):\n-\t\t\treturn self.pool(classitem, self.cid)\n+\t\t\treturn pool(classitem, self.cid)\n \t\tdef load_line_table(self):\n \t\t\tprint \"LOAD-LINE-TABLE\", self.cid, self.mid\n \t\t\tself.first = 1\n@@ -135,8 +148,6 @@ if __name__ == '__main__':\n \t\tlast =  defer(load_line_table, 'last')\n \t\tlines = defer(load_line_table, 'lines')\n \n-\n-\tpool = pool()\n \tm1 = pool(methoditem, 'c1', 'm1')\n \tm2 = pool(methoditem, 'c1', 'm2')\n \tm3 = pool(methoditem, 'c2', 'm3')\n@@ -148,4 +159,3 @@ if __name__ == '__main__':\n \tprint (v.get('last'))\n \tprint v.classitem()\n \tprint list(m for m in v)\n-\n"}
{"repo": "AndBug", "commit": "35f546e51e4843c7e6dc3adfd782b9837cc0db45", "diff": "diff --git a/andbug/process.py b/andbug/process.py\nindex 58c2e09..55026bc 100644\n--- a/andbug/process.py\n+++ b/andbug/process.py\n@@ -67,7 +67,14 @@ class Process(object):\n \t\tself.db = sqlite3.connect(dbpath)\n \t\tself.db.text_factory = str\n \t\tself.db.executescript(DB_SCHEMA)\n+\t\tself.cache = {}\n \n+\tdef is_cached(self, key):\n+\t\treturn self.cache.get(key)\n+\t\n+\tdef set_cached(self, key):\n+\t\tself.cache[key] = True\n+\t\n \tdef connect(self, portno = None):\n \t\tif portno: \n \t\t\tself.portno = portno\n@@ -76,6 +83,9 @@ class Process(object):\n \t\treturn self.conn\n \n \tdef load_classes(self):\n+\t\tif self.is_cached('c'):\n+\t\t\treturn \n+\n \t\tcode, buf = self.connect().request(0x0114)\n \t\tif code != 0:\n \t\t\traise Failure(code)\n@@ -92,7 +102,12 @@ class Process(object):\n \t\t\tunpack_entries()\n \t\t)\n \t\n+\t\tself.set_cached('c')\n+\n \tdef load_methods(self, cid):\n+\t\tif self.is_cached('m:' + str(cid)):\n+\t\t\treturn \n+\n \t\tconn = self.connect()\n \t\tbuf = conn.buffer()\n \t\tbuf.pack(\"t\", cid)\n@@ -113,6 +128,7 @@ class Process(object):\n \t\t\t'insert into methods values(?, ?, ?, ?, ?, ?);',\n \t\t\tunpack_entries()\n \t\t)\n+\t\tself.set_cached('m:' + str(cid))\n \n \tdef classes(self, jni=None):\n \t\tself.load_classes()\n"}
{"repo": "AndBug", "commit": "6aec3605c19ea2752c3f3bc91b6679a7ea657df3", "diff": "diff --git a/andbug/proto.py b/andbug/proto.py\nindex e2e67a1..990e54f 100644\n--- a/andbug/proto.py\n+++ b/andbug/proto.py\n@@ -225,8 +225,10 @@ class Connection(Thread):\n \n \tdef buffer(self):\n \t\t'returns a JdwpBuffer configured for this connection'\n-\t\treturn JdwpBuffer.config(*self.size)\n-\t\n+\t\tbuf = JdwpBuffer()\n+\t\tbuf.config(*self.sizes)\n+\t\treturn buf\n+\t\t\n \t################################################################# THREAD API\n \t\n \tdef start(self):\n"}
{"repo": "AndBug", "commit": "eca9ed1f8405d2fd29bf56dd697d5a9f58502b2f", "diff": "diff --git a/andbug/__init__.py b/andbug/__init__.py\nindex e52e366..fd1b17b 100644\n--- a/andbug/__init__.py\n+++ b/andbug/__init__.py\n@@ -1,3 +1,3 @@\n-import jdwp, proto\n+import jdwp, proto, log\n connect = proto.connect\n \ndiff --git a/andbug/log.py b/andbug/log.py\nindex 37fe940..d34cba7 100644\n--- a/andbug/log.py\n+++ b/andbug/log.py\n@@ -23,7 +23,7 @@\n ## ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n ## POSSIBILITY OF SUCH DAMAGE.\n    \n-import os, sys\n+import os, sys, time\n from cStringIO import StringIO\n \n def blocks(seq, sz):\n@@ -145,10 +145,12 @@ stderr = LogWriter(sys.stderr)\n stdout = LogWriter(sys.stdout)\n \n def error(tag, meta, data = None):\n-\tstderr.writeEvent(LogEvent(now, meta, data))\n+\tnow = int(time.time())\n+\tstderr.writeEvent(LogEvent(now, tag, meta, data))\n \n def info(tag, meta, data = None):\n-\tstdout.writeEvent(LogEvent(now, meta, data))\n+\tnow = int(time.time())\n+\tstdout.writeEvent(LogEvent(now, tag, meta, data))\n \n def read_log(path=None, file=None):\n \tif path is None:\n"}
{"repo": "traceback_with_variables", "commit": "e97f94f275033e1e13f50daa3e36586196fd7735", "diff": "diff --git a/tests/utils.py b/tests/utils.py\nindex bbe3cb1..5c6210b 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -39,7 +39,7 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n         value = re.sub(r'(File \").*(/{}/)'.format(dir_), r'\\1...omitted for tests only...\\2', value)\n     value = re.sub(r'(File \")((?!\\.\\.\\.).)*\"'.format(dir_), r'\\1...omitted for tests only...\"', value)\n     value = re.sub(r\"'/.*\\.py'\", \"'/...omitted for tests only...py'\", value)\n-    value = re.sub(r\"(__file__ = )'.*'\", r\"\\1'...omitted for tests only...'\", value)\n+    value = re.sub(r\"(__file__ = )[^\\n]*\\n\", r\"\\1'...omitted for tests only...'\", value)\n     value = re.sub(r'( at 0x)\\w+', r'\\1...omitted for tests only...', value)\n     value = re.sub(r'(__builtins__[^{]*{)[^\\n]*', r'\\1...omitted for tests only...}', value)\n \n"}
{"repo": "traceback_with_variables", "commit": "9091096e8096c250212ec2f41a207925e66ef6b4", "diff": "diff --git a/tests/utils.py b/tests/utils.py\nindex 2a9a8e1..bbe3cb1 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -39,6 +39,7 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n         value = re.sub(r'(File \").*(/{}/)'.format(dir_), r'\\1...omitted for tests only...\\2', value)\n     value = re.sub(r'(File \")((?!\\.\\.\\.).)*\"'.format(dir_), r'\\1...omitted for tests only...\"', value)\n     value = re.sub(r\"'/.*\\.py'\", \"'/...omitted for tests only...py'\", value)\n+    value = re.sub(r\"(__file__ = )'.*'\", r\"\\1'...omitted for tests only...'\", value)\n     value = re.sub(r'( at 0x)\\w+', r'\\1...omitted for tests only...', value)\n     value = re.sub(r'(__builtins__[^{]*{)[^\\n]*', r'\\1...omitted for tests only...}', value)\n \ndiff --git a/traceback_with_variables/__init__.py b/traceback_with_variables/__init__.py\nindex 31e91b6..a6e6822 100644\n--- a/traceback_with_variables/__init__.py\n+++ b/traceback_with_variables/__init__.py\n@@ -10,4 +10,4 @@ from .print import print_exc, print_cur_tb, printing_exc, prints_exc, LoggerAsFi\n from .global_hooks import global_print_exc, global_print_exc_in_ipython, is_ipython_global  # noqa\n \n \n-__version__ = '2.0.2'\n+__version__ = '2.0.3'\ndiff --git a/traceback_with_variables/core.py b/traceback_with_variables/core.py\nindex 3f89700..9c184a8 100644\n--- a/traceback_with_variables/core.py\n+++ b/traceback_with_variables/core.py\n@@ -15,7 +15,7 @@ VarFilterItem = Union[str, Type, ShouldPrint]\n VarFilter = Union[VarFilterItem, List[VarFilterItem]]\n \n \n-class Format:\n+class Format:  # no dataclass for compatibility\n     def __init__(\n         self,\n         max_value_str_len: int = 1000,\n@@ -106,7 +106,6 @@ def iter_exc_lines(\n \n def format_cur_tb(\n     num_skipped_frames: int = 0,\n-\n     fmt: Optional[Format] = None,\n     for_file: Optional[TextIO] = None,\n ) -> str:\ndiff --git a/traceback_with_variables/main.py b/traceback_with_variables/main.py\nindex 00c9d54..816fa81 100644\n--- a/traceback_with_variables/main.py\n+++ b/traceback_with_variables/main.py\n@@ -23,7 +23,6 @@ def run_script(\n         '__cached__', '__package__', '__annotations__', '__spec__',\n     }})\n     globals_.update({\n-        'sys': sys,\n         '__name__': '__main__',\n         '__file__': str(path),\n     })\n"}
{"repo": "traceback_with_variables", "commit": "a5541444fd04b8e9334da116cd0d6e6b089f1c4b", "diff": "diff --git a/traceback_with_variables/main.py b/traceback_with_variables/main.py\nindex 1ea3590..00c9d54 100644\n--- a/traceback_with_variables/main.py\n+++ b/traceback_with_variables/main.py\n@@ -16,18 +16,24 @@ def run_script(\n ) -> int:\n     sys.path[0] = str(path.parent)\n     sys.argv = [str(path)] + argv\n-    globals_ = {\n+    globals_ = {k: v for k, v in globals().items() if k in {\n+        '__builtins__', '__loader__',\n+    }}\n+    globals_.update({k: None for k in globals().keys() if k in {\n+        '__cached__', '__package__', '__annotations__', '__spec__',\n+    }})\n+    globals_.update({\n         'sys': sys,\n-        'argparse': argparse,\n         '__name__': '__main__',\n-    }\n+        '__file__': str(path),\n+    })\n \n     with printing_exc(\n         reraise=False,\n         skip_cur_frame=True,\n         fmt=fmt,\n     ):\n-        exec(compile(path.read_text(), str(path), \"exec\"), globals_, globals_)\n+        exec(compile(path.read_text(), str(path), 'exec'), globals_, globals_)\n \n         return 0\n \n"}
{"repo": "traceback_with_variables", "commit": "8745c0715a1af154ea06904c099c99766d939b0c", "diff": "diff --git a/traceback_with_variables/__init__.py b/traceback_with_variables/__init__.py\nindex 0a7b089..2d11d55 100644\n--- a/traceback_with_variables/__init__.py\n+++ b/traceback_with_variables/__init__.py\n@@ -10,4 +10,4 @@ from .print import print_exc, print_cur_tb, printing_exc, prints_exc, LoggerAsFi\n from .global_hooks import global_print_exc, global_print_exc_in_ipython, is_ipython_global  # noqa\n \n \n-__version__ = '2.0.0'\n+__version__ = '2.0.1'\ndiff --git a/traceback_with_variables/core.py b/traceback_with_variables/core.py\nindex a085be8..3f89700 100644\n--- a/traceback_with_variables/core.py\n+++ b/traceback_with_variables/core.py\n@@ -34,8 +34,8 @@ class Format:\n         self.before = before\n         self.after = after\n         self.color_scheme = color_scheme\n-        self.skip_files_except: List[re.Pattern] = _to_patterns(skip_files_except)\n-        self.brief_files_except: List[re.Pattern] = _to_patterns(brief_files_except)\n+        self.skip_files_except: List['re.Pattern'] = _to_patterns(skip_files_except)\n+        self.brief_files_except: List['re.Pattern'] = _to_patterns(brief_files_except)\n         self.custom_var_printers: List[Tuple[ShouldPrint, Print]] = [\n             (_var_filter_to_should_print(f), p) for f, p in custom_var_printers or []\n         ]\n@@ -222,7 +222,7 @@ def _to_cropped_str(\n     return _crop(raw, max_value_str_len, ellipsis_) if raw is not None else None\n \n \n-def _to_patterns(patterns: Patterns) -> List[re.Pattern]:\n+def _to_patterns(patterns: Patterns) -> List['re.Pattern']:\n     p_strs: List[str] = [patterns] if isinstance(patterns, str) else (patterns or [])\n \n     return [re.compile(p) for p in p_strs]\n"}
{"repo": "traceback_with_variables", "commit": "6ae777bc1d930406d7cbad07c441b1b2a8db4044", "diff": "diff --git a/tests/test_print.py b/tests/test_print.py\nindex d80dd32..bae8dbc 100644\n--- a/tests/test_print.py\n+++ b/tests/test_print.py\n@@ -1,4 +1,5 @@\n import logging\n+import sys\n from io import StringIO\n \n import pytest\n@@ -17,6 +18,9 @@ def test_printing_tb():\n \n \n def test_printing_tb_to_tty():\n+    if sys.platform == 'win32':\n+        return\n+\n     out = StringIO()\n     out.isatty = lambda: True\n     with printing_tb(reraise=False, file_=out, flush=True):\n"}
{"repo": "traceback_with_variables", "commit": "53df8d8534fd83838868d72aa75446f2279ace57", "diff": "diff --git a/traceback_with_variables/main.py b/traceback_with_variables/main.py\nindex 0139551..4312aab 100644\n--- a/traceback_with_variables/main.py\n+++ b/traceback_with_variables/main.py\n@@ -115,7 +115,7 @@ def parse_args() -> Tuple[argparse.Namespace, Path, List[str]]:\n     parser.add_argument(\"--max-exc-str-len\", type=int, default=10000)\n     parser.add_argument(\"--ellipsis\", default=\"...\")\n     parser.add_argument(\"--num-context-lines\", type=int, default=1)\n-    parser.add_argument(\"--color-scheme\", default='default' if sys.stdout.isatty() else 'none',\n+    parser.add_argument(\"--color-scheme\", default='common' if sys.stderr.isatty() else 'none',\n                         choices=[a for a in dir(ColorSchemes) if not a.startswith('_')])\n \n     return parse_args_and_script_cmd(parser)\n"}
{"repo": "traceback_with_variables", "commit": "140fc81f608d88f6c8ff4c17e5ec8be3216bd6dd", "diff": "diff --git a/tests/utils.py b/tests/utils.py\nindex da1e922..21018b0 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -33,7 +33,7 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n     value = re.sub(r'(File \")((?!\\.\\.\\.).)*\"'.format(dir_), r'\\1...omitted for tests only...\"', value)\n     value = re.sub(r\"'/.*\\.py'\", \"'/...omitted for tests only...py'\", value)\n     value = re.sub(r'( at 0x)\\w+', r'\\1...omitted for tests only...', value)\n-    value = re.sub(r'(      __builtins__ = )[^\\n]*', r'\\1{...omitted for tests only...}', value)\n+    value = re.sub(r'(__builtins__[^{]*{)[^\\n]*', r'\\1...omitted for tests only...}', value)\n \n     assert_equals_ref(name, value)\n \ndiff --git a/traceback_with_variables/core.py b/traceback_with_variables/core.py\nindex 0221a4d..0c96257 100644\n--- a/traceback_with_variables/core.py\n+++ b/traceback_with_variables/core.py\n@@ -34,8 +34,10 @@ def iter_tb_lines(\n             try:\n                 for var_name, var in frame.f_locals.items():\n                     var_str = _to_cropped_str(var, max_value_str_len, max_exc_str_len, ellipsis_)\n-                    for line in f'{c.n}{var_name}{c.c_} = {c.v_}{var_str}{c.e}'.split('\\n'):\n-                        yield f'{c.c}      {c.e}{line}'\n+                    var_lines = var_str.split('\\n')\n+                    yield f'{c.c}      {c.n_}{var_name}{c.c_} = {c.v_}{var_lines[0] if var_lines else var_str}{c.e}'\n+                    for line in var_lines[1:]:\n+                        yield f'{c.c}      {c.v_}{line}{c.e}'\n \n                 if __force_bug_mode == 1:\n                     raise ValueError('force_bug_mode')\n"}
{"repo": "traceback_with_variables", "commit": "bc8cc92f0a9880ca5105c5de1232805473c5cc11", "diff": "diff --git a/tests/test_core.py b/tests/test_core.py\nindex 781f7b8..51e07a1 100644\n--- a/tests/test_core.py\n+++ b/tests/test_core.py\n@@ -36,19 +36,11 @@ def test_color_scheme_synthwave():\n \n \n def test_force_bug_mode_1():\n-    try:\n-        core.__force_bug_mode = 1\n-        check('force_bug_mode_1', 10000)\n-    finally:\n-        core.__force_bug_mode = 0\n+    check('force_bug_mode_1', 10000, __force_bug_mode=1)\n \n \n def test_force_bug_mode_2():\n-    try:\n-        core.__force_bug_mode = 2\n-        check('force_bug_mode_2', 10000)\n-    finally:\n-        core.__force_bug_mode = 0\n+    check('force_bug_mode_2', 10000, __force_bug_mode=2)\n \n \n def check(name, arg, **kwargs):\ndiff --git a/traceback_with_variables/core.py b/traceback_with_variables/core.py\nindex d63e8ea..0221a4d 100644\n--- a/traceback_with_variables/core.py\n+++ b/traceback_with_variables/core.py\n@@ -14,7 +14,8 @@ def iter_tb_lines(\n     max_exc_str_len: int = 10000,\n     ellipsis_: str = '...',\n     num_context_lines: int = 1,\n-    color_scheme: ColorScheme = ColorSchemes.none\n+    color_scheme: ColorScheme = ColorSchemes.none,\n+    __force_bug_mode: int = 0,  # for tests only\n ) -> Iterator[str]:\n     c = color_scheme\n \n@@ -70,6 +71,3 @@ def _to_cropped_str(obj: Any, max_value_str_len: int, max_exc_str_len: int, elli\n             max_exc_str_len,\n             ellipsis_,\n         )\n-\n-\n-__force_bug_mode = 0\n"}
{"repo": "traceback_with_variables", "commit": "099307fe3d98f1dc2ea5993f5b1ae3f7cd422f31", "diff": "diff --git a/tests/utils.py b/tests/utils.py\nindex e03850c..da1e922 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -33,6 +33,7 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n     value = re.sub(r'(File \")((?!\\.\\.\\.).)*\"'.format(dir_), r'\\1...omitted for tests only...\"', value)\n     value = re.sub(r\"'/.*\\.py'\", \"'/...omitted for tests only...py'\", value)\n     value = re.sub(r'( at 0x)\\w+', r'\\1...omitted for tests only...', value)\n+    value = re.sub(r'(      __builtins__ = )[^\\n]*', r'\\1{...omitted for tests only...}', value)\n \n     assert_equals_ref(name, value)\n \n"}
{"repo": "traceback_with_variables", "commit": "ca0c7231ccdc906eed6f8b109510e26e6331b1b7", "diff": "diff --git a/tests/test_main.py b/tests/test_main.py\nindex 35a16bc..32b26b4 100644\n--- a/tests/test_main.py\n+++ b/tests/test_main.py\n@@ -81,7 +81,7 @@ def _test_code(name: str, tmp_path, main_argv: List[str], code: str, code_argv:\n             code=code,\n             code_argv=code_argv,\n             raises=raises\n-        )\n+        ).replace('[script-arg [script-arg ...]]', '[script-arg ...]')  # python 3.9+\n     )\n \n \n@@ -92,5 +92,5 @@ def _test_cmd(name: str, tmp_path, argv: List[str], raises: bool):\n             tmp_path=tmp_path,\n             argv=['-m', 'traceback_with_variables.main'] + argv,\n             raises=raises\n-        )\n+        ).replace('[script-arg [script-arg ...]]', '[script-arg ...]')  # python 3.9+\n     )\n"}
{"repo": "traceback_with_variables", "commit": "107ec6f29071ab88492fcf26930521a2ecc074b0", "diff": "diff --git a/tests/test_main.py b/tests/test_main.py\nindex dbdfa4e..35a16bc 100644\n--- a/tests/test_main.py\n+++ b/tests/test_main.py\n@@ -1,6 +1,6 @@\n from typing import List\n \n-from tests.utils import assert_smart_equals_ref, run_code\n+from tests.utils import assert_smart_equals_ref, run_code, run_py\n \n \n simple_code = '''def f(n):\n@@ -9,26 +9,70 @@ simple_code = '''def f(n):\n a = 3\n f(a - 2)'''\n \n-simple_status0_code = '''def f(n):\n+status0_code = '''def f(n):\n     return n + 1\n print(f(10))'''\n \n-code_with_argparse = '''import argparse\n+argparse_code = '''import argparse\n def f(n):\n     m = n - 1\n     return 1 / m\n p = argparse.ArgumentParser()\n-p.add_argument('--a', required=True)\n+p.add_argument('--a', required=True, type=int)\n args = p.parse_args()\n a = args.a\n f(a - 2)'''\n \n \n def test_simple_code_no_args(tmp_path):\n-    _test('simple_code_no_args', tmp_path, [], simple_code, [], True)\n+    _test_code('simple_code_no_args', tmp_path, [], simple_code, [], True)\n \n \n-def _test(name: str, tmp_path, main_argv: List[str], code: str, code_argv: List[str], raises: bool):\n+def test_simple_code_excess_script_args(tmp_path):\n+    _test_code('simple_code_excess_script_args', tmp_path, [], simple_code, ['--b', '2'], True)\n+\n+\n+def test_simple_code_tool_args(tmp_path):\n+    _test_code('simple_code_tool_args', tmp_path, ['--max-value-str-len', '10'], simple_code, [], True)\n+\n+\n+def test_simple_code_excess_tool_args(tmp_path):\n+    _test_code('simple_code_excess_tool_args', tmp_path, ['--b', '2'], simple_code, ['pos_arg', '--c', '3'], True)\n+\n+\n+def test_simple_code_incomplete_tool_args(tmp_path):\n+    _test_code('simple_code_incomplete_tool_args', tmp_path, ['--max-value-str-len'], simple_code, [], True)\n+\n+\n+def test_simple_code_tool_help(tmp_path):\n+    _test_code('simple_code_tool_help', tmp_path, ['--max-value-str-len', '10', '--help'], simple_code, [], False)\n+\n+\n+def test_argparse_code(tmp_path):\n+    _test_code('argparse_code', tmp_path, [], argparse_code, ['--a', '3'], True)\n+\n+\n+def test_argparse_code_script_help(tmp_path):\n+    _test_code('argparse_code_script_help', tmp_path, [], argparse_code, ['--help'], False)\n+\n+\n+def test_status0_code(tmp_path):\n+    _test_code('status0_code', tmp_path, [], status0_code, [], False)\n+\n+\n+def test_module(tmp_path):\n+    _test_cmd('module', tmp_path, ['http.server', '--help'], False)\n+\n+\n+def test_nonexistent(tmp_path):\n+    _test_cmd('nonexistent', tmp_path, ['nonexistent', '--help'], True)\n+\n+\n+def test_no_cmd(tmp_path):\n+    _test_cmd('no_cmd', tmp_path, [], True)\n+\n+\n+def _test_code(name: str, tmp_path, main_argv: List[str], code: str, code_argv: List[str], raises: bool):\n     assert_smart_equals_ref(\n         f'test_main.{name}',\n         run_code(\n@@ -40,4 +84,13 @@ def _test(name: str, tmp_path, main_argv: List[str], code: str, code_argv: List[\n         )\n     )\n \n-# test module, command, script\n+\n+def _test_cmd(name: str, tmp_path, argv: List[str], raises: bool):\n+    assert_smart_equals_ref(\n+        f'test_main.{name}',\n+        run_py(\n+            tmp_path=tmp_path,\n+            argv=['-m', 'traceback_with_variables.main'] + argv,\n+            raises=raises\n+        )\n+    )\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 05ef33b..e03850c 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -38,14 +38,19 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n \n \n def run_code(tmp_path, python_argv: List[str], code: str, code_argv: List[str], raises: bool = False) -> str:\n-    (tmp_path / 'traceback_with_variables').symlink_to(Path(traceback_with_variables.__file__).parent)\n     code_path = tmp_path / 'code.py'\n     code_path.write_text(code)\n \n-    return run_cmd(argv=['python3'] + python_argv + [code_path] + code_argv, raises=raises)\n+    return run_py(tmp_path=tmp_path, argv=python_argv + [str(code_path)] + code_argv, raises=raises)\n+\n+\n+def run_py(tmp_path, argv: List[str], raises: bool = False) -> str:\n+    (tmp_path / 'traceback_with_variables').symlink_to(Path(traceback_with_variables.__file__).parent)\n+\n+    return run_cmd(argv=['python3'] + argv, raises=raises)\n \n \n-def run_cmd(argv: List[str], raises: bool = False):\n+def run_cmd(argv: List[str], raises: bool = False) -> str:\n     if raises:\n         with pytest.raises(CalledProcessError) as e:\n             check_output(argv, stderr=STDOUT)\ndiff --git a/traceback_with_variables/main.py b/traceback_with_variables/main.py\nindex 96186d6..d3a3517 100644\n--- a/traceback_with_variables/main.py\n+++ b/traceback_with_variables/main.py\n@@ -1,6 +1,7 @@\n import argparse\n import sys\n from distutils.spawn import find_executable\n+from importlib.util import find_spec\n from pathlib import Path\n from typing import List, Optional, NoReturn, Tuple\n \n@@ -17,6 +18,11 @@ def run_script(\n ) -> int:\n     sys.path[0] = str(path.parent)\n     sys.argv = [str(path)] + argv\n+    globals_ = {\n+        'sys': sys,\n+        'argparse': argparse,\n+        '__name__': '__main__',\n+    }\n \n     with printing_tb(\n         reraise=False,\n@@ -26,11 +32,7 @@ def run_script(\n         ellipsis_=ellipsis_,\n         num_context_lines=num_context_lines,\n     ):\n-        exec(\n-            compile(path.read_text(), str(path), \"exec\"),\n-            {\"__name__\": \"__main__\"},\n-            {\"__name__\": \"__main__\"},\n-        )\n+        exec(compile(path.read_text(), str(path), \"exec\"), globals_, globals_)\n \n         return 0\n \n@@ -68,7 +70,7 @@ def split_argv_to_own_and_sub(\n def parse_args_and_script_cmd(\n     raising_nohelp_noabbrev_parser: argparse.ArgumentParser,  # with raising .error, no help, no abbrev\n ) -> Tuple[argparse.Namespace, Path, List[str]]:\n-    public_parser = argparse.ArgumentParser(parents=[raising_nohelp_noabbrev_parser])\n+    public_parser = argparse.ArgumentParser(parents=[raising_nohelp_noabbrev_parser])  # only complains\n     public_parser.add_argument(\"script\")\n     public_parser.add_argument(\"script-arg\", nargs=\"*\")\n \n@@ -76,27 +78,27 @@ def parse_args_and_script_cmd(\n         raising_nohelp_noabbrev_parser, sys.argv\n     )\n \n+    args = argparse.Namespace()  # make linter happy\n     try:\n         args = raising_nohelp_noabbrev_parser.parse_args(own_argv)\n     except ParseError:\n         public_parser.parse_args(own_argv)\n-        args = argparse.Namespace()  # not gonna happen anyway, public_parser exits\n \n     if not sub_argv:\n         public_parser.parse_args(own_argv)\n \n-    if sub_argv[0] == \"--help\":\n-        public_parser.parse_args([\"--help\"])\n+    if sub_argv[0].startswith('-'):\n+        public_parser.parse_args(own_argv + sub_argv[:1] + ['some_cmd'])\n \n     script_path_str = find_executable(sub_argv[0])\n \n     if not script_path_str:\n-        module = sys.modules.get(script_path_str)\n+        module_spec = find_spec(sub_argv[0])\n \n-        if not module:\n-            raise ValueError(f\"No such file or command or module: {sub_argv[0]}\")\n+        if not module_spec:\n+            public_parser.error(f\"No such file or command or module: {sub_argv[0]}\")\n \n-        script_path_str = module.__file__\n+        script_path_str = module_spec.origin\n \n     return args, Path(script_path_str), sub_argv[1:]\n \n"}
{"repo": "traceback_with_variables", "commit": "f3d9de7bb053ab5fe496008e2740e8ebc42a3d80", "diff": "diff --git a/tests/test_main.py b/tests/test_main.py\nindex 6401ab9..dbdfa4e 100644\n--- a/tests/test_main.py\n+++ b/tests/test_main.py\n@@ -33,7 +33,7 @@ def _test(name: str, tmp_path, main_argv: List[str], code: str, code_argv: List[\n         f'test_main.{name}',\n         run_code(\n             tmp_path=tmp_path,\n-            python_argv=['traceback_with_variables/main.py'] + main_argv,\n+            python_argv=['-m', 'traceback_with_variables.main'] + main_argv,\n             code=code,\n             code_argv=code_argv,\n             raises=raises\n"}
{"repo": "traceback_with_variables", "commit": "a5d54fba2013e1ca786c2e60ef252084a8e8693f", "diff": "diff --git a/tests/test_main.py b/tests/test_main.py\nindex 8265e1c..6401ab9 100644\n--- a/tests/test_main.py\n+++ b/tests/test_main.py\n@@ -1,6 +1,6 @@\n from typing import List\n \n-from tests.utils import assert_smart_equals_ref, run_cmd\n+from tests.utils import assert_smart_equals_ref, run_code\n \n \n simple_code = '''def f(n):\n@@ -25,16 +25,19 @@ f(a - 2)'''\n \n \n def test_simple_code_no_args(tmp_path):\n-    run_code(tmp_path, 'simple_code_no_args', simple_code, [], True)\n+    _test('simple_code_no_args', tmp_path, [], simple_code, [], True)\n \n \n-def run_code(tmp_path, name: str, code: str, argv: List[str], raises: bool):\n-    code_path = tmp_path / 'code.py'\n-    code_path.write_text(simple_code)\n-\n+def _test(name: str, tmp_path, main_argv: List[str], code: str, code_argv: List[str], raises: bool):\n     assert_smart_equals_ref(\n         f'test_main.{name}',\n-        run_cmd(['python3', 'traceback_with_variables/main.py', str(code_path)] + argv, raises=True)\n+        run_code(\n+            tmp_path=tmp_path,\n+            python_argv=['traceback_with_variables/main.py'] + main_argv,\n+            code=code,\n+            code_argv=code_argv,\n+            raises=raises\n+        )\n     )\n \n # test module, command, script\ndiff --git a/tests/test_override.py b/tests/test_override.py\nindex d2f294e..947492e 100644\n--- a/tests/test_override.py\n+++ b/tests/test_override.py\n@@ -7,7 +7,7 @@ def f(n):\n     return n / 0\n f(10)'''\n \n-    assert_smart_equals_ref('test_override.activate_by_import', run_code(tmp_path=tmp_path, code=code, raises=True))\n+    assert_smart_equals_ref('test_override.activate_by_import', run_code(tmp_path, [], code, [], True))\n \n \n def test_deactivate_by_env_var(tmp_path):\n@@ -17,4 +17,4 @@ def f(n):\n override_print_tb(activate_by_env_var='NONEXISTENT')\n f(10)'''\n \n-    assert_smart_equals_ref('test_override.deactivate_by_env_var', run_code(tmp_path=tmp_path, code=code, raises=True))\n+    assert_smart_equals_ref('test_override.deactivate_by_env_var', run_code(tmp_path, [], code, [], True))\ndiff --git a/tests/test_print.py b/tests/test_print.py\nindex 66714f9..67497d6 100644\n--- a/tests/test_print.py\n+++ b/tests/test_print.py\n@@ -30,7 +30,7 @@ def main():\n          \n main()'''\n \n-    assert_smart_equals_ref('test_print.printing_tb_stderr', run_code(tmp_path=tmp_path, code=code, raises=False))\n+    assert_smart_equals_ref('test_print.printing_tb_stderr', run_code(tmp_path, [], code, [], False))\n \n \n def test_printing_tb_reraise():\n@@ -66,7 +66,7 @@ try:\n except:\n     pass'''\n \n-    assert_smart_equals_ref('test_print.prints_tb_noncall', run_code(tmp_path=tmp_path, code=code, raises=False))\n+    assert_smart_equals_ref('test_print.prints_tb_noncall', run_code(tmp_path, [], code, [], False))\n \n \n def test_logger_as_file(caplog):\ndiff --git a/tests/utils.py b/tests/utils.py\nindex 738f417..05ef33b 100644\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -37,12 +37,12 @@ def assert_smart_equals_ref(name: str, value: str) -> None:\n     assert_equals_ref(name, value)\n \n \n-def run_code(tmp_path, code: str, raises: bool = False) -> str:\n+def run_code(tmp_path, python_argv: List[str], code: str, code_argv: List[str], raises: bool = False) -> str:\n     (tmp_path / 'traceback_with_variables').symlink_to(Path(traceback_with_variables.__file__).parent)\n     code_path = tmp_path / 'code.py'\n     code_path.write_text(code)\n \n-    return run_cmd(argv=['python3', code_path], raises=raises)\n+    return run_cmd(argv=['python3'] + python_argv + [code_path] + code_argv, raises=raises)\n \n \n def run_cmd(argv: List[str], raises: bool = False):\n"}
{"repo": "traceback_with_variables", "commit": "00a62bcaff7c267079d7d3af017afe7b1cdd8cc3", "diff": "diff --git a/traceback_with_variables/main.py b/traceback_with_variables/main.py\nindex 33e3a47..96186d6 100644\n--- a/traceback_with_variables/main.py\n+++ b/traceback_with_variables/main.py\n@@ -60,7 +60,7 @@ def split_argv_to_own_and_sub(\n \n         except ParseError as e:\n             if e.args[0].startswith(\"unrecognized arguments\"):\n-                return _argv[: num_args - 1], _argv[num_args - 1 :]\n+                return _argv[: num_args - 1], _argv[num_args - 1:]\n \n     return _argv, []\n \n"}
{"repo": "python-tblib", "commit": "12c87705a19f454c0c25f32345fb77e1de628f8f", "diff": "diff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex dc52405..ebe93ee 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -1,3 +1,4 @@\n+import os\n from traceback import format_exception\n \n try:\n@@ -345,3 +346,20 @@ def test_oserror_simple():\n     assert exc.errno == 13\n     assert exc.strerror == 'Permission denied'\n     assert exc.__traceback__ is not None\n+\n+\n+def test_real_oserror():\n+    try:\n+        os.open('non-existing-file', os.O_RDONLY)\n+    except Exception as e:\n+        exc = e\n+    else:\n+        pytest.fail('os.open should have raised an OSError')\n+\n+    str_output = str(exc)\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, OSError)\n+    assert exc.errno == 2\n+    assert str_output == str(exc)\n"}
{"repo": "python-tblib", "commit": "97a6aef884a3bfc3acf3e1662287f6325e0fe0ee", "diff": "diff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 014fc1c..dc52405 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -1,4 +1,3 @@\n-import traceback\n from traceback import format_exception\n \n try:\n"}
{"repo": "python-tblib", "commit": "615cdb38daafc77ae9a04b7f39b6d8bb2a2396a2", "diff": "diff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 0e1f35e..014fc1c 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -250,7 +250,7 @@ def test_permissionerror():\n \n     tblib.pickling_support.install(exc)\n     exc = pickle.loads(pickle.dumps(exc))\n-    print(''.join(traceback.format_exception(exc)))\n+\n     assert isinstance(exc, OpenError)\n     assert exc.__traceback__ is not None\n     assert repr(exc) == \"OpenError(PermissionError(13, 'Booboo'))\"\n"}
{"repo": "python-tblib", "commit": "13802fdec8353ead4a7ebfddddf854a856880bbc", "diff": "diff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex a561aa4..d0bdae8 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -65,13 +65,13 @@ def pickle_exception(\n             'args': obj.args,\n         }\n         if isinstance(obj, OSError):\n-            attrs.update(\n-                errno=obj.errno,\n-                strerror=obj.strerror,\n-                winerror=getattr(obj, 'winerror', None),\n-                filename=obj.filename,\n-                filename2=obj.filename2,\n-            )\n+            attrs.update(errno=obj.errno, strerror=obj.strerror)\n+            if (winerror := getattr(obj, 'winerror', None)) is not None:\n+                attrs['winerror'] = winerror\n+            if obj.filename is not None:\n+                attrs['filename'] = obj.filename\n+            if obj.filename2 is not None:\n+                attrs['filename2'] = obj.filename2\n \n         return (\n             unpickle_exception_with_attrs,\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 476a47d..0e1f35e 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -1,3 +1,4 @@\n+import traceback\n from traceback import format_exception\n \n try:\n@@ -230,6 +231,35 @@ def test_oserror():\n     assert exc.__traceback__ is not None\n \n \n+class OpenError(Exception):\n+    pass\n+\n+\n+def bad_open():\n+    try:\n+        raise PermissionError(13, 'Booboo', 'filename', None, None)\n+    except Exception as e:\n+        raise OpenError(e) from e\n+\n+\n+def test_permissionerror():\n+    try:\n+        bad_open()\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+    print(''.join(traceback.format_exception(exc)))\n+    assert isinstance(exc, OpenError)\n+    assert exc.__traceback__ is not None\n+    assert repr(exc) == \"OpenError(PermissionError(13, 'Booboo'))\"\n+    assert str(exc) == \"[Errno 13] Booboo: 'filename'\"\n+    assert exc.args[0].errno == 13\n+    assert exc.args[0].strerror == 'Booboo'\n+    assert exc.args[0].filename == 'filename'\n+\n+\n class BadError(Exception):\n     def __init__(self):\n         super().__init__('Bad Bad Bad!')\n"}
{"repo": "python-tblib", "commit": "0b67609280c349546336fa177cb5f1049a434e45", "diff": "diff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex b035582..a561aa4 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -22,10 +22,10 @@ def pickle_traceback(tb, *, get_locals=None):\n     )\n \n \n-def unpickle_exception_with_new(func, args, cause, tb, context, suppress_context, notes):\n+def unpickle_exception_with_attrs(func, attrs, cause, tb, context, suppress_context, notes):\n     inst = func.__new__(func)\n-    if args is not None:\n-        inst.args = args\n+    for key, value in attrs.items():\n+        setattr(inst, key, value)\n     inst.__cause__ = cause\n     inst.__traceback__ = tb\n     inst.__context__ = context\n@@ -48,43 +48,62 @@ def unpickle_exception(func, args, cause, tb, context=None, suppress_context=Fal\n     return inst\n \n \n-def pickle_exception(obj):\n-    # All exceptions, unlike generic Python objects, define __reduce_ex__\n-    # __reduce_ex__(4) should be no different from __reduce_ex__(3).\n-    # __reduce_ex__(5) could bring benefits in the unlikely case the exception\n-    # directly contains buffers, but PickleBuffer objects will cause a crash when\n-    # running on protocol=4, and there's no clean way to figure out the current\n-    # protocol from here. Note that any object returned by __reduce_ex__(3) will\n-    # still be pickled with protocol 5 if pickle.dump() is running with it.\n-    rv = obj.__reduce_ex__(3)\n-    if isinstance(rv, str):\n-        raise TypeError('str __reduce__ output is not supported')\n-    assert isinstance(rv, tuple)\n-    assert len(rv) >= 2\n-\n-    # Use __new__ whenever there is no customization by __reduce__ and\n-    # __reduce_ex__. Note that OSError and descendants are known to require\n-    # using a constructor, otherwise they do not set the errno, strerror and other\n-    # attributes.\n-    use_new = (\n-        obj.__class__.__reduce__ is BaseException.__reduce__\n-        and obj.__class__.__reduce_ex__ is BaseException.__reduce_ex__\n-        and not isinstance(obj, OSError)\n-    )\n-\n-    return (\n-        unpickle_exception_with_new if use_new else unpickle_exception,\n-        (\n-            *rv[:2],\n-            obj.__cause__,\n-            obj.__traceback__,\n-            obj.__context__,\n-            obj.__suppress_context__,\n-            # __notes__ doesn't exist prior to Python 3.11; and even on Python 3.11 it may be absent\n-            getattr(obj, '__notes__', None),\n-        ),\n-        *rv[2:],\n-    )\n+def pickle_exception(\n+    obj, builtin_reducers=(OSError.__reduce__, BaseException.__reduce__), builtin_inits=(OSError.__init__, BaseException.__init__)\n+):\n+    reduced_value = obj.__reduce__()\n+    if isinstance(reduced_value, str):\n+        raise TypeError('Did not expect {repr(obj)}.__reduce__() to return a string!')\n+\n+    func = type(obj)\n+    # Detect busted objects: they have a custom __init__ but no __reduce__.\n+    # This also means the resulting exceptions may be a bit \"dulled\" down - the args from __reduce__ are discarded.\n+    if func.__reduce__ in builtin_reducers and func.__init__ not in builtin_inits:\n+        _, args, *optionals = reduced_value\n+        attrs = {\n+            '__dict__': obj.__dict__,\n+            'args': obj.args,\n+        }\n+        if isinstance(obj, OSError):\n+            attrs.update(\n+                errno=obj.errno,\n+                strerror=obj.strerror,\n+                winerror=getattr(obj, 'winerror', None),\n+                filename=obj.filename,\n+                filename2=obj.filename2,\n+            )\n+\n+        return (\n+            unpickle_exception_with_attrs,\n+            (\n+                func,\n+                attrs,\n+                obj.__cause__,\n+                obj.__traceback__,\n+                obj.__context__,\n+                obj.__suppress_context__,\n+                # __notes__ doesn't exist prior to Python 3.11; and even on Python 3.11 it may be absent\n+                getattr(obj, '__notes__', None),\n+            ),\n+            *optionals,\n+        )\n+    else:\n+        func, args, *optionals = reduced_value\n+\n+        return (\n+            unpickle_exception,\n+            (\n+                func,\n+                args,\n+                obj.__cause__,\n+                obj.__traceback__,\n+                obj.__context__,\n+                obj.__suppress_context__,\n+                # __notes__ doesn't exist prior to Python 3.11; and even on Python 3.11 it may be absent\n+                getattr(obj, '__notes__', None),\n+            ),\n+            *optionals,\n+        )\n \n \n def _get_subclasses(cls):\ndiff --git a/tests/test_issue30.py b/tests/test_issue30.py\nindex 09d3069..a446914 100644\n--- a/tests/test_issue30.py\n+++ b/tests/test_issue30.py\n@@ -20,7 +20,7 @@ def test_30():\n \n     f = None\n     try:\n-        _etype, evalue, etb = pickle.loads(s)  # noqa: S301\n+        _etype, evalue, etb = pickle.loads(s)\n         raise evalue.with_traceback(etb)\n     except ValueError:\n         f = Failure()\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex c401622..476a47d 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -72,7 +72,7 @@ def test_install(clear_dispatch_table, how, protocol):\n     if how == 'instance':\n         tblib.pickling_support.install(exc)\n     if protocol:\n-        exc = pickle.loads(pickle.dumps(exc, protocol=protocol))  # noqa: S301\n+        exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n \n     assert isinstance(exc, CustomError)\n     assert exc.args == ('foo',)\n@@ -105,7 +105,7 @@ def test_install_decorator():\n         raise RegisteredError('foo')\n     exc = ewrap.value\n     exc.x = 1\n-    exc = pickle.loads(pickle.dumps(exc))  # noqa: S301\n+    exc = pickle.loads(pickle.dumps(exc))\n \n     assert isinstance(exc, RegisteredError)\n     assert exc.args == ('foo',)\n@@ -162,7 +162,7 @@ def test_get_locals(clear_dispatch_table, how, protocol):\n     if how == 'instance':\n         tblib.pickling_support.install(exc, get_locals=get_locals)\n \n-    exc = pickle.loads(pickle.dumps(exc, protocol=protocol))  # noqa: S301\n+    exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n     assert exc.__traceback__.tb_next.tb_frame.f_locals == {'my_variable': 1}\n \n \n@@ -189,6 +189,66 @@ def test_custom_with_attributes():\n     assert exc.__traceback__ is not None\n \n \n+class CustomOSError(OSError):\n+    def __init__(self, message, errno, strerror: str, filename, none: None, filename2):\n+        super().__init__(errno, strerror, filename, none, filename2)\n+        self.message = message\n+\n+\n+def test_custom_oserror():\n+    try:\n+        raise CustomOSError('bar', 2, 'err', 3, None, 5)\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, CustomOSError)\n+    assert exc.message == 'bar'\n+    assert exc.errno == 2\n+    assert exc.strerror == 'err'\n+    assert exc.filename == 3\n+    assert exc.filename2 == 5\n+    assert exc.__traceback__ is not None\n+\n+\n+def test_oserror():\n+    try:\n+        raise OSError(2, 'err', 3, None, 5)\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, OSError)\n+    assert exc.errno == 2\n+    assert exc.strerror == 'err'\n+    assert exc.filename == 3\n+    assert exc.filename2 == 5\n+    assert exc.__traceback__ is not None\n+\n+\n+class BadError(Exception):\n+    def __init__(self):\n+        super().__init__('Bad Bad Bad!')\n+\n+\n+def test_baderror():\n+    try:\n+        raise BadError\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, BadError)\n+    assert exc.args == ('Bad Bad Bad!',)\n+    assert exc.__traceback__ is not None\n+\n+\n class CustomReduceException(Exception):\n     def __init__(self, message, arg1, arg2, arg3):\n         super().__init__(message)\n@@ -242,7 +302,7 @@ def test_custom_reduce_ex(protocol):\n     assert exc.__traceback__ is not None\n \n \n-def test_oserror():\n+def test_oserror_simple():\n     try:\n         raise OSError(13, 'Permission denied')\n     except Exception as e:\ndiff --git a/tests/test_tblib.py b/tests/test_tblib.py\nindex bac06e1..6d01ebe 100644\n--- a/tests/test_tblib.py\n+++ b/tests/test_tblib.py\n@@ -107,7 +107,7 @@ KeyboardInterrupt\"\"\"\n         },\n     }\n     tb3 = Traceback.from_dict(expected_dict)\n-    tb4 = pickle.loads(pickle.dumps(tb3))  # noqa: S301\n+    tb4 = pickle.loads(pickle.dumps(tb3))\n     assert tb4.as_dict() == tb3.as_dict() == tb2.as_dict() == tb1.as_dict() == expected_dict\n \n \n"}
{"repo": "python-tblib", "commit": "d66df68760d6c0c31fe5f2bf6b943fc315c19c18", "diff": "diff --git a/tests/test_issue65.py b/tests/test_issue65.py\nnew file mode 100644\nindex 0000000..9da4a9f\n--- /dev/null\n+++ b/tests/test_issue65.py\n@@ -0,0 +1,27 @@\n+import pickle\n+\n+from tblib import pickling_support\n+\n+\n+class HTTPrettyError(Exception):\n+    pass\n+\n+\n+class UnmockedError(HTTPrettyError):\n+    def __init__(self):\n+        super().__init__('No mocking was registered, and real connections are not allowed (httpretty.allow_net_connect = False).')\n+\n+\n+def test_65():\n+    pickling_support.install()\n+\n+    try:\n+        raise UnmockedError\n+    except Exception as e:\n+        exc = e\n+\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, UnmockedError)\n+    assert exc.args == ('No mocking was registered, and real connections are not allowed (httpretty.allow_net_connect = False).',)\n+    assert exc.__traceback__ is not None\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex a16c3a1..c401622 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -164,3 +164,95 @@ def test_get_locals(clear_dispatch_table, how, protocol):\n \n     exc = pickle.loads(pickle.dumps(exc, protocol=protocol))  # noqa: S301\n     assert exc.__traceback__.tb_next.tb_frame.f_locals == {'my_variable': 1}\n+\n+\n+class CustomWithAttributesException(Exception):\n+    def __init__(self, message, arg1, arg2, arg3):\n+        super().__init__(message)\n+        self.values12 = (arg1, arg2)\n+        self.value3 = arg3\n+\n+\n+def test_custom_with_attributes():\n+    try:\n+        raise CustomWithAttributesException('bar', 1, 2, 3)\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, CustomWithAttributesException)\n+    assert exc.args == ('bar',)\n+    assert exc.values12 == (1, 2)\n+    assert exc.value3 == 3\n+    assert exc.__traceback__ is not None\n+\n+\n+class CustomReduceException(Exception):\n+    def __init__(self, message, arg1, arg2, arg3):\n+        super().__init__(message)\n+        self.values12 = (arg1, arg2)\n+        self.value3 = arg3\n+\n+    def __reduce__(self):\n+        return self.__class__, self.args + self.values12 + (self.value3,)\n+\n+\n+def test_custom_reduce():\n+    try:\n+        raise CustomReduceException('foo', 1, 2, 3)\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, CustomReduceException)\n+    assert exc.args == ('foo',)\n+    assert exc.values12 == (1, 2)\n+    assert exc.value3 == 3\n+    assert exc.__traceback__ is not None\n+\n+\n+class CustomReduceExException(Exception):\n+    def __init__(self, message, arg1, arg2, protocol):\n+        super().__init__(message)\n+        self.values12 = (arg1, arg2)\n+        self.value3 = protocol\n+\n+    def __reduce_ex__(self, protocol):\n+        return self.__class__, self.args + self.values12 + (self.value3,)\n+\n+\n+@pytest.mark.parametrize('protocol', [None, *list(range(1, pickle.HIGHEST_PROTOCOL + 1))])\n+def test_custom_reduce_ex(protocol):\n+    try:\n+        raise CustomReduceExException('foo', 1, 2, 3)\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n+\n+    assert isinstance(exc, CustomReduceExException)\n+    assert exc.args == ('foo',)\n+    assert exc.values12 == (1, 2)\n+    assert exc.value3 == 3\n+    assert exc.__traceback__ is not None\n+\n+\n+def test_oserror():\n+    try:\n+        raise OSError(13, 'Permission denied')\n+    except Exception as e:\n+        exc = e\n+\n+    tblib.pickling_support.install(exc)\n+    exc = pickle.loads(pickle.dumps(exc))\n+\n+    assert isinstance(exc, OSError)\n+    assert exc.args == (13, 'Permission denied')\n+    assert exc.errno == 13\n+    assert exc.strerror == 'Permission denied'\n+    assert exc.__traceback__ is not None\n"}
{"repo": "python-tblib", "commit": "1da47d4e15302eab76a7948f47aceab450db780b", "diff": "diff --git a/ci/bootstrap.py b/ci/bootstrap.py\nindex f3c9a7e..d069fb5 100755\n--- a/ci/bootstrap.py\n+++ b/ci/bootstrap.py\n@@ -20,8 +20,6 @@ def exec_in_env():\n     else:\n         bin_path = env_path / 'bin'\n     if not env_path.exists():\n-        import subprocess\n-\n         print(f'Making bootstrap env in: {env_path} ...')\n         try:\n             check_call([sys.executable, '-m', 'venv', env_path])\n@@ -42,7 +40,7 @@ def exec_in_env():\n \n \n def main():\n-    import jinja2\n+    import jinja2  # noqa: PLC0415\n \n     print(f'Project path: {base_path}')\n \ndiff --git a/docs/conf.py b/docs/conf.py\nindex 34a8cf7..ff25663 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -12,7 +12,7 @@ extensions = [\n source_suffix = '.rst'\n master_doc = 'index'\n project = 'tblib'\n-year = '2013-2023'\n+year = '2013-2025'\n author = 'Ionel Cristian M\u00c4\u0192rie\u00c8\u2122'\n copyright = f'{year}, {author}'\n version = release = '3.1.0'\n@@ -26,7 +26,15 @@ extlinks = {\n \n html_theme = 'furo'\n html_theme_options = {\n-    'githuburl': 'https://github.com/ionelmc/python-tblib/',\n+    'source_repository': 'https://github.com/ionelmc/python-tblib/',\n+    'source_branch': 'master',\n+    'source_directory': 'docs/',\n+    'footer_icons': [\n+        {\n+            'url': 'https://github.com/ionelmc/python-tblib/',\n+            'html': 'github.com/ionelmc/python-tblib',\n+        },\n+    ],\n }\n \n html_use_smartypants = True\ndiff --git a/setup.py b/setup.py\nindex 14c6267..4472314 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -12,62 +12,14 @@ def read(*names, **kwargs):\n \n \n setup(\n-    name='tblib',\n-    version='3.1.0',\n-    license='BSD-2-Clause',\n-    description='Traceback serialization library.',\n     long_description='{}\\n{}'.format(\n         re.compile('^.. start-badges.*^.. end-badges', re.M | re.S).sub('', read('README.rst')),\n         re.sub(':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst')),\n     ),\n-    author='Ionel Cristian M\u00c4\u0192rie\u00c8\u2122',\n-    author_email='contact@ionelmc.ro',\n-    url='https://github.com/ionelmc/python-tblib',\n+    long_description_content_type='text/x-rst',\n     packages=find_namespace_packages('src'),\n     package_dir={'': 'src'},\n     py_modules=[path.stem for path in Path('src').glob('*.py')],\n     include_package_data=True,\n     zip_safe=False,\n-    classifiers=[\n-        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n-        'Development Status :: 5 - Production/Stable',\n-        'Intended Audience :: Developers',\n-        'Operating System :: Unix',\n-        'Operating System :: POSIX',\n-        'Operating System :: Microsoft :: Windows',\n-        'Programming Language :: Python',\n-        'Programming Language :: Python :: 3',\n-        'Programming Language :: Python :: 3 :: Only',\n-        'Programming Language :: Python :: 3.9',\n-        'Programming Language :: Python :: 3.10',\n-        'Programming Language :: Python :: 3.11',\n-        'Programming Language :: Python :: 3.12',\n-        'Programming Language :: Python :: 3.13',\n-        'Programming Language :: Python :: Implementation :: CPython',\n-        'Programming Language :: Python :: Implementation :: PyPy',\n-        # uncomment if you test on these interpreters:\n-        # \"Programming Language :: Python :: Implementation :: IronPython\",\n-        # \"Programming Language :: Python :: Implementation :: Jython\",\n-        # \"Programming Language :: Python :: Implementation :: Stackless\",\n-        'Topic :: Utilities',\n-    ],\n-    project_urls={\n-        'Documentation': 'https://python-tblib.readthedocs.io/',\n-        'Changelog': 'https://python-tblib.readthedocs.io/en/latest/changelog.html',\n-        'Issue Tracker': 'https://github.com/ionelmc/python-tblib/issues',\n-    },\n-    keywords=[\n-        'traceback',\n-        'debugging',\n-        'exceptions',\n-    ],\n-    python_requires='>=3.9',\n-    install_requires=[\n-        # eg: \"aspectlib==1.1.1\",\n-    ],\n-    extras_require={\n-        # eg:\n-        #   \"rst\": [\"docutils>=0.11\"],\n-        #   \":python_version==\"2.6\"\": [\"argparse\"],\n-    },\n )\ndiff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex 6fdd30f..48670ba 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -51,8 +51,8 @@ def pickle_exception(obj):\n \n     return (\n         unpickle_exception,\n-        rv[:2]\n-        + (\n+        (\n+            *rv[:2],\n             obj.__cause__,\n             obj.__traceback__,\n             obj.__context__,\n@@ -60,7 +60,8 @@ def pickle_exception(obj):\n             # __notes__ doesn't exist prior to Python 3.11; and even on Python 3.11 it may be absent\n             getattr(obj, '__notes__', None),\n         ),\n-    ) + rv[2:]\n+        *rv[2:],\n+    )\n \n \n def _get_subclasses(cls):\ndiff --git a/tests/examples.py b/tests/examples.py\nindex bb61d8c..dfff3e9 100644\n--- a/tests/examples.py\n+++ b/tests/examples.py\n@@ -15,12 +15,12 @@ def func_d():\n \n \n def bad_syntax():\n-    import badsyntax\n+    import badsyntax  # noqa: PLC0415\n \n     badsyntax()\n \n \n def bad_module():\n-    import badmodule\n+    import badmodule  # noqa: PLC0415\n \n     badmodule()\ndiff --git a/tests/test_issue30.py b/tests/test_issue30.py\nindex cb66bd0..09d3069 100644\n--- a/tests/test_issue30.py\n+++ b/tests/test_issue30.py\n@@ -9,7 +9,7 @@ pytest.importorskip('twisted')\n \n \n def test_30():\n-    from twisted.python.failure import Failure\n+    from twisted.python.failure import Failure  # noqa: PLC0415\n \n     pickling_support.install()\n \n@@ -20,7 +20,7 @@ def test_30():\n \n     f = None\n     try:\n-        etype, evalue, etb = pickle.loads(s)  # noqa: S301\n+        _etype, evalue, etb = pickle.loads(s)  # noqa: S301\n         raise evalue.with_traceback(etb)\n     except ValueError:\n         f = Failure()\n"}
{"repo": "python-tblib", "commit": "be707e9b08e7e1824be2d5882ae26996c5bf360f", "diff": "diff --git a/docs/conf.py b/docs/conf.py\nindex 9508050..56436f0 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -24,7 +24,7 @@ extlinks = {\n     'pr': ('https://github.com/ionelmc/python-tblib/pull/%s', 'PR #%s'),\n }\n \n-html_theme = 'sphinx_py3doc_enhanced_theme'\n+html_theme = 'furo'\n html_theme_options = {\n     'githuburl': 'https://github.com/ionelmc/python-tblib/',\n }\n"}
{"repo": "python-tblib", "commit": "7d4370889f037387c23fb8378a665605b35b4183", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex a9b1084..6e2e1ea 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -51,8 +51,8 @@ class Frame:\n     Class that replicates just enough of the builtin Frame object to enable serialization and traceback rendering.\n     \"\"\"\n \n-    def __init__(self, frame):\n-        self.f_locals = {}\n+    def __init__(self, frame, *, get_locals=None):\n+        self.f_locals = {} if get_locals is None else get_locals(frame)\n         self.f_globals = {k: v for k, v in frame.f_globals.items() if k in ('__file__', '__name__')}\n         self.f_code = Code(frame.f_code)\n         self.f_lineno = frame.f_lineno\n@@ -73,9 +73,8 @@ class Traceback:\n \n     tb_next = None\n \n-    def __init__(self, tb):\n-        self.tb_frame = Frame(tb.tb_frame)\n-        # noinspection SpellCheckingInspection\n+    def __init__(self, tb, *, get_locals=None):\n+        self.tb_frame = Frame(tb.tb_frame, get_locals=get_locals)\n         self.tb_lineno = int(tb.tb_lineno)\n \n         # Build in place to avoid exceeding the recursion limit\n@@ -84,7 +83,7 @@ class Traceback:\n         cls = type(self)\n         while tb is not None:\n             traceback = object.__new__(cls)\n-            traceback.tb_frame = Frame(tb.tb_frame)\n+            traceback.tb_frame = Frame(tb.tb_frame, get_locals=get_locals)\n             traceback.tb_lineno = int(tb.tb_lineno)\n             prev_traceback.tb_next = traceback\n             prev_traceback = traceback\n@@ -124,7 +123,7 @@ class Traceback:\n \n             # noinspection PyBroadException\n             try:\n-                exec(code, dict(current.tb_frame.f_globals), {})  # noqa: S102\n+                exec(code, dict(current.tb_frame.f_globals), dict(current.tb_frame.f_locals))  # noqa: S102\n             except Exception:\n                 next_tb = sys.exc_info()[2].tb_next\n                 if top_tb is None:\n@@ -151,7 +150,7 @@ class Traceback:\n         if self.tb_next is None:\n             tb_next = None\n         else:\n-            tb_next = self.tb_next.to_dict()\n+            tb_next = self.tb_next.as_dict()\n \n         code = {\n             'co_filename': self.tb_frame.f_code.co_filename,\n@@ -159,6 +158,7 @@ class Traceback:\n         }\n         frame = {\n             'f_globals': self.tb_frame.f_globals,\n+            'f_locals': self.tb_frame.f_locals,\n             'f_code': code,\n             'f_lineno': self.tb_frame.f_lineno,\n         }\n@@ -186,6 +186,7 @@ class Traceback:\n         )\n         frame = _AttrDict(\n             f_globals=dct['tb_frame']['f_globals'],\n+            f_locals=dct['tb_frame'].get('f_locals', {}),\n             f_code=code,\n             f_lineno=dct['tb_frame']['f_lineno'],\n         )\n@@ -194,7 +195,7 @@ class Traceback:\n             tb_lineno=dct['tb_lineno'],\n             tb_next=tb_next,\n         )\n-        return cls(tb)\n+        return cls(tb, get_locals=get_all_locals)\n \n     @classmethod\n     def from_string(cls, string, strict=True):\n@@ -230,6 +231,7 @@ class Traceback:\n                             __file__=frame['co_filename'],\n                             __name__='?',\n                         ),\n+                        f_locals={},\n                         f_code=_AttrDict(frame),\n                         f_lineno=int(frame['tb_lineno']),\n                     ),\n@@ -238,3 +240,7 @@ class Traceback:\n             return cls(previous)\n         else:\n             raise TracebackParseError('Could not find any frames in %r.' % string)\n+\n+\n+def get_all_locals(frame):\n+    return dict(frame.f_locals)\ndiff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex ecfdbac..bb67e76 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -1,14 +1,10 @@\n-import sys\n+import copyreg\n+from functools import partial\n from types import TracebackType\n \n from . import Frame\n from . import Traceback\n \n-if sys.version_info.major >= 3:\n-    import copyreg\n-else:\n-    import copy_reg as copyreg\n-\n \n def unpickle_traceback(tb_frame, tb_lineno, tb_next):\n     ret = object.__new__(Traceback)\n@@ -18,8 +14,12 @@ def unpickle_traceback(tb_frame, tb_lineno, tb_next):\n     return ret.as_traceback()\n \n \n-def pickle_traceback(tb):\n-    return unpickle_traceback, (Frame(tb.tb_frame), tb.tb_lineno, tb.tb_next and Traceback(tb.tb_next))\n+def pickle_traceback(tb, *, get_locals=None):\n+    return unpickle_traceback, (\n+        Frame(tb.tb_frame, get_locals=get_locals),\n+        tb.tb_lineno,\n+        tb.tb_next and Traceback(tb.tb_next, get_locals=get_locals),\n+    )\n \n \n # Note: Older versions of tblib will generate pickle archives that call unpickle_exception() with\n@@ -72,16 +72,8 @@ def _get_subclasses(cls):\n         to_visit += list(this.__subclasses__())\n \n \n-def install(*exc_classes_or_instances):\n-    copyreg.pickle(TracebackType, pickle_traceback)\n-\n-    if sys.version_info.major < 3:\n-        # Dummy decorator?\n-        if len(exc_classes_or_instances) == 1:\n-            exc = exc_classes_or_instances[0]\n-            if isinstance(exc, type) and issubclass(exc, BaseException):\n-                return exc\n-        return\n+def install(*exc_classes_or_instances, get_locals=None):\n+    copyreg.pickle(TracebackType, partial(pickle_traceback, get_locals=get_locals))\n \n     if not exc_classes_or_instances:\n         for exception_cls in _get_subclasses(BaseException):\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex f0d8ba6..5ff4679 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -13,7 +13,6 @@ import pytest\n \n import tblib.pickling_support\n \n-has_python3 = sys.version_info.major >= 3\n has_python311 = sys.version_info >= (3, 11)\n \n \n@@ -49,11 +48,10 @@ def test_install(clear_dispatch_table, how, protocol):\n             # Python 3 only syntax\n             # raise CustomError(\"foo\") from e\n             new_e = CustomError('foo')\n-            if has_python3:\n-                new_e.__cause__ = e\n-                if has_python311:\n-                    new_e.add_note('note 1')\n-                    new_e.add_note('note 2')\n+            new_e.__cause__ = e\n+            if has_python311:\n+                new_e.add_note('note 1')\n+                new_e.add_note('note 2')\n             raise new_e from e\n     except Exception as e:\n         exc = e\n@@ -64,9 +62,8 @@ def test_install(clear_dispatch_table, how, protocol):\n     print(expected_format_exception)\n     # Populate Exception.__dict__, which is used in some cases\n     exc.x = 1\n-    if has_python3:\n-        exc.__cause__.x = 2\n-        exc.__cause__.__context__.x = 3\n+    exc.__cause__.x = 2\n+    exc.__cause__.__context__.x = 3\n \n     if how == 'instance':\n         tblib.pickling_support.install(exc)\n@@ -76,21 +73,20 @@ def test_install(clear_dispatch_table, how, protocol):\n     assert isinstance(exc, CustomError)\n     assert exc.args == ('foo',)\n     assert exc.x == 1\n-    if has_python3:\n-        assert exc.__traceback__ is not None\n+    assert exc.__traceback__ is not None\n \n-        assert isinstance(exc.__cause__, ValueError)\n-        assert exc.__cause__.__traceback__ is not None\n-        assert exc.__cause__.x == 2\n-        assert exc.__cause__.__cause__ is None\n+    assert isinstance(exc.__cause__, ValueError)\n+    assert exc.__cause__.__traceback__ is not None\n+    assert exc.__cause__.x == 2\n+    assert exc.__cause__.__cause__ is None\n \n-        assert isinstance(exc.__cause__.__context__, ZeroDivisionError)\n-        assert exc.__cause__.__context__.x == 3\n-        assert exc.__cause__.__context__.__cause__ is None\n-        assert exc.__cause__.__context__.__context__ is None\n+    assert isinstance(exc.__cause__.__context__, ZeroDivisionError)\n+    assert exc.__cause__.__context__.x == 3\n+    assert exc.__cause__.__context__.__cause__ is None\n+    assert exc.__cause__.__context__.__context__ is None\n \n-        if has_python311:\n-            assert exc.__notes__ == ['note 1', 'note 2']\n+    if has_python311:\n+        assert exc.__notes__ == ['note 1', 'note 2']\n \n     assert expected_format_exception == ''.join(format_exception(type(exc), exc, exc.__traceback__))\n \n@@ -110,8 +106,7 @@ def test_install_decorator():\n     assert isinstance(exc, RegisteredError)\n     assert exc.args == ('foo',)\n     assert exc.x == 1\n-    if has_python3:\n-        assert exc.__traceback__ is not None\n+    assert exc.__traceback__ is not None\n \n \n @pytest.mark.skipif(not has_python311, reason='no BaseExceptionGroup before Python 3.11')\n@@ -126,7 +121,42 @@ def test_install_instance_recursively(clear_dispatch_table):\n     assert installed == {ExceptionGroup, ValueError, CustomError, ZeroDivisionError, AttributeError}\n \n \n-@pytest.mark.skipif(sys.version_info[0] < 3, reason='No checks done in Python 2')\n def test_install_typeerror():\n     with pytest.raises(TypeError):\n         tblib.pickling_support.install('foo')\n+\n+\n+@pytest.mark.parametrize('protocol', [None, *list(range(1, pickle.HIGHEST_PROTOCOL + 1))])\n+@pytest.mark.parametrize('how', ['global', 'instance', 'class'])\n+def test_get_locals(clear_dispatch_table, how, protocol):\n+    def get_locals(frame):\n+        if 'my_variable' in frame.f_locals:\n+            return {'my_variable': int(frame.f_locals['my_variable'])}\n+        else:\n+            return {}\n+\n+    if how == 'global':\n+        tblib.pickling_support.install(get_locals=get_locals)\n+    elif how == 'class':\n+        tblib.pickling_support.install(CustomError, ValueError, ZeroDivisionError, get_locals=get_locals)\n+\n+    def func(my_arg='2'):\n+        my_variable = '1'\n+        raise ValueError(my_variable)\n+\n+    try:\n+        func()\n+    except Exception as e:\n+        exc = e\n+    else:\n+        raise AssertionError\n+\n+    f_locals = exc.__traceback__.tb_next.tb_frame.f_locals\n+    assert 'my_variable' in f_locals\n+    assert f_locals['my_variable'] == '1'\n+\n+    if how == 'instance':\n+        tblib.pickling_support.install(exc, get_locals=get_locals)\n+\n+    exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n+    assert exc.__traceback__.tb_next.tb_frame.f_locals == {'my_variable': 1}\ndiff --git a/tests/test_tblib.py b/tests/test_tblib.py\nindex d05160b..2f04cd9 100644\n--- a/tests/test_tblib.py\n+++ b/tests/test_tblib.py\n@@ -9,6 +9,54 @@ pickling_support.install()\n pytest_plugins = ('pytester',)\n \n \n+def test_get_locals():\n+    def get_locals(frame):\n+        print(frame, frame.f_locals)\n+        if 'my_variable' in frame.f_locals:\n+            return {'my_variable': int(frame.f_locals['my_variable'])}\n+        else:\n+            return {}\n+\n+    def func(my_arg='2'):\n+        my_variable = '1'\n+        raise ValueError(my_variable)\n+\n+    try:\n+        func()\n+    except Exception as e:\n+        exc = e\n+    else:\n+        raise AssertionError\n+\n+    f_locals = exc.__traceback__.tb_next.tb_frame.f_locals\n+    assert 'my_variable' in f_locals\n+    assert f_locals['my_variable'] == '1'\n+\n+    value = Traceback(exc.__traceback__, get_locals=get_locals).as_dict()\n+    lineno = exc.__traceback__.tb_lineno\n+    assert value == {\n+        'tb_frame': {\n+            'f_globals': {'__name__': 'test_tblib', '__file__': __file__},\n+            'f_locals': {},\n+            'f_code': {'co_filename': __file__, 'co_name': 'test_get_locals'},\n+            'f_lineno': lineno + 10,\n+        },\n+        'tb_lineno': lineno,\n+        'tb_next': {\n+            'tb_frame': {\n+                'f_globals': {'__name__': 'test_tblib', '__file__': __file__},\n+                'f_locals': {'my_variable': 1},\n+                'f_code': {'co_filename': __file__, 'co_name': 'func'},\n+                'f_lineno': lineno - 3,\n+            },\n+            'tb_lineno': lineno - 3,\n+            'tb_next': None,\n+        },\n+    }\n+\n+    assert Traceback.from_dict(value).tb_next.tb_frame.f_locals == {'my_variable': 1}\n+\n+\n def test_parse_traceback():\n     tb1 = Traceback.from_string(\n         \"\"\"\n@@ -34,6 +82,7 @@ KeyboardInterrupt\"\"\"\n         'tb_frame': {\n             'f_code': {'co_filename': 'file1', 'co_name': '<module>'},\n             'f_globals': {'__file__': 'file1', '__name__': '?'},\n+            'f_locals': {},\n             'f_lineno': 123,\n         },\n         'tb_lineno': 123,\n@@ -41,6 +90,7 @@ KeyboardInterrupt\"\"\"\n             'tb_frame': {\n                 'f_code': {'co_filename': 'file2', 'co_name': '???'},\n                 'f_globals': {'__file__': 'file2', '__name__': '?'},\n+                'f_locals': {},\n                 'f_lineno': 234,\n             },\n             'tb_lineno': 234,\n@@ -48,6 +98,7 @@ KeyboardInterrupt\"\"\"\n                 'tb_frame': {\n                     'f_code': {'co_filename': 'file3', 'co_name': 'function3'},\n                     'f_globals': {'__file__': 'file3', '__name__': '?'},\n+                    'f_locals': {},\n                     'f_lineno': 345,\n                 },\n                 'tb_lineno': 345,\n"}
{"repo": "python-tblib", "commit": "dcb16f003c454e9e0eeb7cc8260cf4c33e914dab", "diff": "diff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 12952fb..d28fb14 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -44,7 +44,6 @@ def test_install(clear_dispatch_table, how, protocol):\n                 # The ValueError's __context__ will be the ZeroDivisionError\n                 raise ValueError('blah')\n         except Exception as e:\n-            assert isinstance(e.__context__, ZeroDivisionError)\n             # Python 3 only syntax\n             # raise CustomError(\"foo\") from e\n             new_e = CustomError('foo')\n"}
{"repo": "python-tblib", "commit": "c808f05456b6522c0b52ec65ccbbd1f64cb4c083", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 094d9ca..f41bf30 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -15,7 +15,7 @@ class _AttrDict(dict):\n         try:\n             return self[name]\n         except KeyError:\n-            raise AttributeError(name)\n+            raise AttributeError(name) from None\n \n \n # noinspection PyPep8Naming\n@@ -124,7 +124,7 @@ class Traceback:\n \n             # noinspection PyBroadException\n             try:\n-                exec(code, dict(current.tb_frame.f_globals), {})\n+                exec(code, dict(current.tb_frame.f_globals), {})  # noqa: S102\n             except Exception:\n                 next_tb = sys.exc_info()[2].tb_next\n                 if top_tb is None:\ndiff --git a/tests/examples.py b/tests/examples.py\nindex 756bf81..bb61d8c 100644\n--- a/tests/examples.py\n+++ b/tests/examples.py\n@@ -17,10 +17,10 @@ def func_d():\n def bad_syntax():\n     import badsyntax\n \n-    badsyntax\n+    badsyntax()\n \n \n def bad_module():\n     import badmodule\n \n-    badmodule\n+    badmodule()\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 3cd32bd..aa10762 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -18,7 +18,7 @@ has_python3 = sys.version_info.major >= 3\n def clear_dispatch_table():\n     bak = copyreg.dispatch_table.copy()\n     copyreg.dispatch_table.clear()\n-    yield\n+    yield None\n     copyreg.dispatch_table.clear()\n     copyreg.dispatch_table.update(bak)\n \n@@ -37,7 +37,7 @@ def test_install(clear_dispatch_table, how, protocol):\n \n     try:\n         try:\n-            1 / 0\n+            1 / 0  # noqa: B018\n         except Exception as e:\n             # Python 3 only syntax\n             # raise CustomError(\"foo\") from e\n"}
{"repo": "python-tblib", "commit": "dd926c1e5dc5bbe5e1fc494443bbac8970c7d3ee", "diff": "diff --git a/ci/appveyor-download.py b/ci/appveyor-download.py\ndeleted file mode 100755\nindex 8373863..0000000\n--- a/ci/appveyor-download.py\n+++ /dev/null\n@@ -1,109 +0,0 @@\n-#!/usr/bin/env python\n-\"\"\"\n-Use the AppVeyor API to download Windows artifacts.\n-\n-Taken from: https://bitbucket.org/ned/coveragepy/src/tip/ci/download_appveyor.py\n-# Licensed under the Apache License: https://www.apache.org/licenses/LICENSE-2.0\n-# For details: https://bitbucket.org/ned/coveragepy/src/default/NOTICE.txt\n-\"\"\"\n-from __future__ import unicode_literals\n-\n-import argparse\n-import os\n-import zipfile\n-\n-import requests\n-\n-\n-def make_auth_headers():\n-    \"\"\"Make the authentication headers needed to use the Appveyor API.\"\"\"\n-    path = os.path.expanduser(\"~/.appveyor.token\")\n-    if not os.path.exists(path):\n-        raise RuntimeError(\n-            \"Please create a file named `.appveyor.token` in your home directory. \"\n-            \"You can get the token from https://ci.appveyor.com/api-token\"\n-        )\n-    with open(path) as f:\n-        token = f.read().strip()\n-\n-    headers = {\n-        'Authorization': 'Bearer {}'.format(token),\n-    }\n-    return headers\n-\n-\n-def download_latest_artifacts(account_project, build_id):\n-    \"\"\"Download all the artifacts from the latest build.\"\"\"\n-    if build_id is None:\n-        url = \"https://ci.appveyor.com/api/projects/{}\".format(account_project)\n-    else:\n-        url = \"https://ci.appveyor.com/api/projects/{}/build/{}\".format(account_project, build_id)\n-    build = requests.get(url, headers=make_auth_headers()).json()\n-    jobs = build['build']['jobs']\n-    print(u\"Build {0[build][version]}, {1} jobs: {0[build][message]}\".format(build, len(jobs)))\n-\n-    for job in jobs:\n-        name = job['name']\n-        print(u\"  {0}: {1[status]}, {1[artifactsCount]} artifacts\".format(name, job))\n-\n-        url = \"https://ci.appveyor.com/api/buildjobs/{}/artifacts\".format(job['jobId'])\n-        response = requests.get(url, headers=make_auth_headers())\n-        artifacts = response.json()\n-\n-        for artifact in artifacts:\n-            is_zip = artifact['type'] == \"Zip\"\n-            filename = artifact['fileName']\n-            print(u\"    {0}, {1} bytes\".format(filename, artifact['size']))\n-\n-            url = \"https://ci.appveyor.com/api/buildjobs/{}/artifacts/{}\".format(job['jobId'], filename)\n-            download_url(url, filename, make_auth_headers())\n-\n-            if is_zip:\n-                unpack_zipfile(filename)\n-                os.remove(filename)\n-\n-\n-def ensure_dirs(filename):\n-    \"\"\"Make sure the directories exist for `filename`.\"\"\"\n-    dirname = os.path.dirname(filename)\n-    if dirname and not os.path.exists(dirname):\n-        os.makedirs(dirname)\n-\n-\n-def download_url(url, filename, headers):\n-    \"\"\"Download a file from `url` to `filename`.\"\"\"\n-    ensure_dirs(filename)\n-    response = requests.get(url, headers=headers, stream=True)\n-    if response.status_code == 200:\n-        with open(filename, 'wb') as f:\n-            for chunk in response.iter_content(16 * 1024):\n-                f.write(chunk)\n-    else:\n-        print(u\"    Error downloading {}: {}\".format(url, response))\n-\n-\n-def unpack_zipfile(filename):\n-    \"\"\"Unpack a zipfile, using the names in the zip.\"\"\"\n-    with open(filename, 'rb') as fzip:\n-        z = zipfile.ZipFile(fzip)\n-        for name in z.namelist():\n-            print(u\"      extracting {}\".format(name))\n-            ensure_dirs(name)\n-            z.extract(name)\n-\n-\n-parser = argparse.ArgumentParser(description='Download artifacts from AppVeyor.')\n-parser.add_argument('--id',\n-                    metavar='PROJECT_ID',\n-                    default='ionelmc/python-tblib',\n-                    help='Project ID in AppVeyor.')\n-parser.add_argument('build',\n-                    nargs='?',\n-                    metavar='BUILD_ID',\n-                    help='Build ID in AppVeyor. Eg: master-123')\n-\n-if __name__ == \"__main__\":\n-    # import logging\n-    # logging.basicConfig(level=\"DEBUG\")\n-    args = parser.parse_args()\n-    download_latest_artifacts(args.id, args.build)\ndiff --git a/setup.py b/setup.py\nindex 86a732b..58f3cd8 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -64,7 +64,9 @@ setup(\n         'Issue Tracker': 'https://github.com/ionelmc/python-tblib/issues',\n     },\n     keywords=[\n-        'traceback', 'debugging', 'exceptions',\n+        'traceback',\n+        'debugging',\n+        'exceptions',\n     ],\n     python_requires='>=3.7',\n     install_requires=[\ndiff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 1e88a0f..c319184 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -1,8 +1,6 @@\n import re\n import sys\n from types import CodeType\n-from types import FrameType\n-from types import TracebackType\n \n __version__ = '1.7.0'\n __all__ = 'Traceback', 'TracebackParseError', 'Frame', 'Code'\n@@ -33,6 +31,7 @@ class Code(object):\n     \"\"\"\n     Class that replicates just enough of the builtin Code object to enable serialization and traceback rendering.\n     \"\"\"\n+\n     co_code = None\n \n     def __init__(self, code):\n@@ -51,13 +50,10 @@ class Frame(object):\n     \"\"\"\n     Class that replicates just enough of the builtin Frame object to enable serialization and traceback rendering.\n     \"\"\"\n+\n     def __init__(self, frame):\n         self.f_locals = {}\n-        self.f_globals = {\n-            k: v\n-            for k, v in frame.f_globals.items()\n-            if k in (\"__file__\", \"__name__\")\n-        }\n+        self.f_globals = {k: v for k, v in frame.f_globals.items() if k in (\"__file__\", \"__name__\")}\n         self.f_code = Code(frame.f_code)\n         self.f_lineno = frame.f_lineno\n \n@@ -74,6 +70,7 @@ class Traceback(object):\n     \"\"\"\n     Class that wraps builtin Traceback objects.\n     \"\"\"\n+\n     tb_next = None\n \n     def __init__(self, tb):\n@@ -105,16 +102,24 @@ class Traceback(object):\n             code = compile('\\n' * (current.tb_lineno - 1) + 'raise __traceback_maker', current.tb_frame.f_code.co_filename, 'exec')\n             if hasattr(code, \"replace\"):\n                 # Python 3.8 and newer\n-                code = code.replace(co_argcount=0,\n-                                    co_filename=f_code.co_filename, co_name=f_code.co_name,\n-                                    co_freevars=(), co_cellvars=())\n+                code = code.replace(co_argcount=0, co_filename=f_code.co_filename, co_name=f_code.co_name, co_freevars=(), co_cellvars=())\n             else:\n                 code = CodeType(\n-                    0, code.co_kwonlyargcount,\n-                    code.co_nlocals, code.co_stacksize, code.co_flags,\n-                    code.co_code, code.co_consts, code.co_names, code.co_varnames,\n-                    f_code.co_filename, f_code.co_name,\n-                    code.co_firstlineno, code.co_lnotab, (), ()\n+                    0,\n+                    code.co_kwonlyargcount,\n+                    code.co_nlocals,\n+                    code.co_stacksize,\n+                    code.co_flags,\n+                    code.co_code,\n+                    code.co_consts,\n+                    code.co_names,\n+                    code.co_varnames,\n+                    f_code.co_filename,\n+                    f_code.co_name,\n+                    code.co_firstlineno,\n+                    code.co_lnotab,\n+                    (),\n+                    (),\n                 )\n \n             # noinspection PyBroadException\n@@ -135,6 +140,7 @@ class Traceback(object):\n         finally:\n             del top_tb\n             del tb\n+\n     to_traceback = as_traceback\n \n     def as_dict(self):\n@@ -161,6 +167,7 @@ class Traceback(object):\n             'tb_lineno': self.tb_lineno,\n             'tb_next': tb_next,\n         }\n+\n     to_dict = as_dict\n \n     @classmethod\ndiff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex cf6e390..5ec6e36 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -81,7 +81,4 @@ def install(*exc_classes_or_instances):\n             if len(exc_classes_or_instances) == 1:\n                 return exc\n         else:\n-            raise TypeError(\n-                \"Expected subclasses or instances of BaseException, got %s\"\n-                % (type(exc))\n-            )\n+            raise TypeError(\"Expected subclasses or instances of BaseException, got %s\" % (type(exc)))\ndiff --git a/tests/examples.py b/tests/examples.py\nindex d4e64ab..441491b 100644\n--- a/tests/examples.py\n+++ b/tests/examples.py\n@@ -16,9 +16,11 @@ def func_d():\n \n def bad_syntax():\n     import badsyntax\n+\n     badsyntax\n \n \n def bad_module():\n     import badmodule\n+\n     badmodule\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 18a018c..c5cd6c8 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -27,9 +27,7 @@ class CustomError(Exception):\n     pass\n \n \n-@pytest.mark.parametrize(\n-    \"protocol\", [None] + list(range(1, pickle.HIGHEST_PROTOCOL + 1))\n-)\n+@pytest.mark.parametrize(\"protocol\", [None] + list(range(1, pickle.HIGHEST_PROTOCOL + 1)))\n @pytest.mark.parametrize(\"how\", [\"global\", \"instance\", \"class\"])\n def test_install(clear_dispatch_table, how, protocol):\n     if how == \"global\":\ndiff --git a/tests/test_tblib.py b/tests/test_tblib.py\nindex bade6d4..058d53a 100644\n--- a/tests/test_tblib.py\n+++ b/tests/test_tblib.py\n@@ -6,7 +6,7 @@ from tblib import pickling_support\n \n pickling_support.install()\n \n-pytest_plugins = 'pytester',\n+pytest_plugins = ('pytester',)\n \n \n def test_parse_traceback():\n@@ -61,7 +61,8 @@ KeyboardInterrupt\"\"\"\n \n \n def test_pytest_integration(testdir):\n-    test = testdir.makepyfile(\"\"\"\n+    test = testdir.makepyfile(\n+        \"\"\"\n import six\n \n from tblib import Traceback\n@@ -78,67 +79,75 @@ Traceback (most recent call last):\n ''')\n     pytb = tb1.as_traceback()\n     six.reraise(RuntimeError, RuntimeError(), pytb)\n-\"\"\")\n+\"\"\"\n+    )\n \n     # mode(auto / long / short / line / native / no).\n \n     result = testdir.runpytest_subprocess('--tb=long', '-vv', test)\n-    result.stdout.fnmatch_lines([\n-        \"_ _ _ _ _ _ _ _ *\",\n-        \"\",\n-        \">   [?][?][?]\",\n-        \"\",\n-        \"file1:123:*\",\n-        \"_ _ _ _ _ _ _ _ *\",\n-        \"\",\n-        \">   [?][?][?]\",\n-        \"\",\n-        \"file2:234:*\",\n-        \"_ _ _ _ _ _ _ _ *\",\n-        \"\",\n-        \">   [?][?][?]\",\n-        \"\",\n-        \"file3:345:*\",\n-        \"_ _ _ _ _ _ _ _ *\",\n-        \"\",\n-        \">   [?][?][?]\",\n-        \"E   RuntimeError\",\n-        \"\",\n-        \"file4:456: RuntimeError\",\n-        \"===*=== 1 failed in * ===*===\",\n-    ])\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"_ _ _ _ _ _ _ _ *\",\n+            \"\",\n+            \">   [?][?][?]\",\n+            \"\",\n+            \"file1:123:*\",\n+            \"_ _ _ _ _ _ _ _ *\",\n+            \"\",\n+            \">   [?][?][?]\",\n+            \"\",\n+            \"file2:234:*\",\n+            \"_ _ _ _ _ _ _ _ *\",\n+            \"\",\n+            \">   [?][?][?]\",\n+            \"\",\n+            \"file3:345:*\",\n+            \"_ _ _ _ _ _ _ _ *\",\n+            \"\",\n+            \">   [?][?][?]\",\n+            \"E   RuntimeError\",\n+            \"\",\n+            \"file4:456: RuntimeError\",\n+            \"===*=== 1 failed in * ===*===\",\n+        ]\n+    )\n \n     result = testdir.runpytest_subprocess('--tb=short', '-vv', test)\n-    result.stdout.fnmatch_lines([\n-        'test_pytest_integration.py:*: in test_raise',\n-        '    six.reraise(RuntimeError, RuntimeError(), pytb)',\n-        'file1:123: in <module>',\n-        '    ???',\n-        'file2:234: in ???',\n-        '    ???',\n-        'file3:345: in function3',\n-        '    ???',\n-        'file4:456: in \"\"',\n-        '    ???',\n-        'E   RuntimeError',\n-    ])\n+    result.stdout.fnmatch_lines(\n+        [\n+            'test_pytest_integration.py:*: in test_raise',\n+            '    six.reraise(RuntimeError, RuntimeError(), pytb)',\n+            'file1:123: in <module>',\n+            '    ???',\n+            'file2:234: in ???',\n+            '    ???',\n+            'file3:345: in function3',\n+            '    ???',\n+            'file4:456: in \"\"',\n+            '    ???',\n+            'E   RuntimeError',\n+        ]\n+    )\n \n     result = testdir.runpytest_subprocess('--tb=line', '-vv', test)\n-    result.stdout.fnmatch_lines([\n-        \"===*=== FAILURES ===*===\",\n-        \"file4:456: RuntimeError\",\n-        \"===*=== 1 failed in * ===*===\",\n-    ])\n+    result.stdout.fnmatch_lines(\n+        [\n+            \"===*=== FAILURES ===*===\",\n+            \"file4:456: RuntimeError\",\n+            \"===*=== 1 failed in * ===*===\",\n+        ]\n+    )\n \n     result = testdir.runpytest_subprocess('--tb=native', '-vv', test)\n-    result.stdout.fnmatch_lines([\n-        'Traceback (most recent call last):',\n-        '  File \"*test_pytest_integration.py\", line *, in test_raise',\n-        '    six.reraise(RuntimeError, RuntimeError(), pytb)',\n-        '  File \"file1\", line 123, in <module>',\n-        '  File \"file2\", line 234, in ???',\n-        '  File \"file3\", line 345, in function3',\n-        '  File \"file4\", line 456, in \"\"',\n-        'RuntimeError',\n-\n-    ])\n+    result.stdout.fnmatch_lines(\n+        [\n+            'Traceback (most recent call last):',\n+            '  File \"*test_pytest_integration.py\", line *, in test_raise',\n+            '    six.reraise(RuntimeError, RuntimeError(), pytb)',\n+            '  File \"file1\", line 123, in <module>',\n+            '  File \"file2\", line 234, in ???',\n+            '  File \"file3\", line 345, in function3',\n+            '  File \"file4\", line 456, in \"\"',\n+            'RuntimeError',\n+        ]\n+    )\n"}
{"repo": "python-tblib", "commit": "14e388388b380f7ab448eb8de67a7f3e7e8e79a0", "diff": "diff --git a/docs/conf.py b/docs/conf.py\nindex f6a4e14..df84309 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -4,8 +4,7 @@ from __future__ import unicode_literals\n import os\n \n extensions = [\n-    'sphinx.ext.autodoc',\n-    'sphinx.ext.autosummary',\n+    'autoapi.extension',\n     'sphinx.ext.coverage',\n     'sphinx.ext.doctest',\n     'sphinx.ext.extlinks',\n@@ -14,10 +13,13 @@ extensions = [\n     'sphinx.ext.todo',\n     'sphinx.ext.viewcode',\n ]\n+autoapi_type = 'python'\n+autoapi_dirs = ['../src']\n+\n source_suffix = '.rst'\n master_doc = 'index'\n project = 'tblib'\n-year = '2013-2019'\n+year = '2013-2020'\n author = 'Ionel Cristian M\u00c4\u0192rie\u00c8\u2122'\n copyright = '{0}, {1}'.format(year, author)\n version = release = '1.6.0'\ndiff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 7c69500..7996361 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -17,7 +17,7 @@ if not tb_set_next and not tproxy:\n     raise ImportError(\"Cannot use tblib. Runtime not supported.\")\n \n __version__ = '1.6.0'\n-__all__ = 'Traceback',\n+__all__ = 'Traceback', 'TracebackParseError', 'Frame', 'Code'\n \n PY3 = sys.version_info[0] == 3\n FRAME_RE = re.compile(r'^\\s*File \"(?P<co_filename>.+)\", line (?P<tb_lineno>\\d+)(, in (?P<co_name>.+))?$')\n@@ -43,6 +43,9 @@ class TracebackParseError(Exception):\n \n \n class Code(object):\n+    \"\"\"\n+    Class that replicates just enough of the builtin Code object to enable serialization and traceback rendering.\n+    \"\"\"\n     co_code = None\n \n     def __init__(self, code):\n@@ -61,6 +64,9 @@ class Code(object):\n \n     # noinspection SpellCheckingInspection\n     def __tproxy__(self, operation, *args, **kwargs):\n+        \"\"\"\n+        Necessary for PyPy's tproxy.\n+        \"\"\"\n         if operation in ('__getattribute__', '__getattr__'):\n             return getattr(self, args[0])\n         else:\n@@ -68,6 +74,9 @@ class Code(object):\n \n \n class Frame(object):\n+    \"\"\"\n+    Class that replicates just enough of the builtin Frame object to enable serialization and traceback rendering.\n+    \"\"\"\n     def __init__(self, frame):\n         self.f_locals = {}\n         self.f_globals = {\n@@ -79,14 +88,18 @@ class Frame(object):\n         self.f_lineno = frame.f_lineno\n \n     def clear(self):\n-        # For compatibility with PyPy 3.5;\n-        # clear() was added to frame in Python 3.4\n-        # and is called by traceback.clear_frames(), which\n-        # in turn is called by unittest.TestCase.assertRaises\n-        pass\n+        \"\"\"\n+        For compatibility with PyPy 3.5;\n+        clear() was added to frame in Python 3.4\n+        and is called by traceback.clear_frames(), which\n+        in turn is called by unittest.TestCase.assertRaises\n+        \"\"\"\n \n     # noinspection SpellCheckingInspection\n     def __tproxy__(self, operation, *args, **kwargs):\n+        \"\"\"\n+        Necessary for PyPy's tproxy.\n+        \"\"\"\n         if operation in ('__getattribute__', '__getattr__'):\n             if args[0] == 'f_code':\n                 return tproxy(CodeType, self.f_code.__tproxy__)\n@@ -97,6 +110,9 @@ class Frame(object):\n \n \n class Traceback(object):\n+    \"\"\"\n+    Class that wraps builtin Traceback objects.\n+    \"\"\"\n     tb_next = None\n \n     def __init__(self, tb):\n@@ -117,6 +133,9 @@ class Traceback(object):\n             tb = tb.tb_next\n \n     def as_traceback(self):\n+        \"\"\"\n+        Convert to a builtin Traceback object that is usable for raising or rendering a stacktrace.\n+        \"\"\"\n         if tproxy:\n             return tproxy(TracebackType, self.__tproxy__)\n         if not tb_set_next:\n@@ -172,6 +191,9 @@ class Traceback(object):\n \n     # noinspection SpellCheckingInspection\n     def __tproxy__(self, operation, *args, **kwargs):\n+        \"\"\"\n+        Necessary for PyPy's tproxy.\n+        \"\"\"\n         if operation in ('__getattribute__', '__getattr__'):\n             if args[0] == 'tb_next':\n                 return self.tb_next and self.tb_next.as_traceback()\n@@ -183,7 +205,10 @@ class Traceback(object):\n             return getattr(self, operation)(*args, **kwargs)\n \n     def as_dict(self):\n-        \"\"\"Convert a Traceback into a dictionary representation\"\"\"\n+        \"\"\"\n+        Converts to a dictionary representation. You can serialize the result to JSON as it only has\n+        builtin objects like dicts, lists, ints or strings.\n+        \"\"\"\n         if self.tb_next is None:\n             tb_next = None\n         else:\n@@ -207,6 +232,9 @@ class Traceback(object):\n \n     @classmethod\n     def from_dict(cls, dct):\n+        \"\"\"\n+        Creates an instance from a dictionary with the same structure as ``.as_dict()`` returns.\n+        \"\"\"\n         if dct['tb_next']:\n             tb_next = cls.from_dict(dct['tb_next'])\n         else:\n@@ -230,6 +258,10 @@ class Traceback(object):\n \n     @classmethod\n     def from_string(cls, string, strict=True):\n+        \"\"\"\n+        Creates an instance by parsing a stacktrace. Strict means that parsing stops when lines are not indented by at least two spaces\n+        anymore.\n+        \"\"\"\n         frames = []\n         header = strict\n \n"}
{"repo": "python-tblib", "commit": "f9c2a0df17656d9b891041d8eebd708f35a7e944", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 318c7a9..c568ef5 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -119,7 +119,7 @@ class Traceback(object):\n \n             # noinspection PyBroadException\n             try:\n-                exec(code, current.tb_frame.f_globals, {})\n+                exec(code, dict(current.tb_frame.f_globals), {})\n             except Exception:\n                 next_tb = sys.exc_info()[2].tb_next\n                 if top_tb is None:\ndiff --git a/tests/test_tblib.py b/tests/test_tblib.py\nnew file mode 100644\nindex 0000000..a2e7000\n--- /dev/null\n+++ b/tests/test_tblib.py\n@@ -0,0 +1,52 @@\n+import traceback\n+\n+from tblib import pickling_support, Traceback\n+\n+pickling_support.install()\n+\n+\n+def test_parse_traceback():\n+    tb1 = Traceback.from_string(\n+        \"\"\"\n+Traceback (most recent call last):\n+  File \"file1\", line 123, in <module>\n+    code1\n+  File \"file2\", line 234, in ???\n+    code2\n+  File \"file3\", line 345, in function3\n+  File \"file4\", line 456, in\n+    code4\n+KeyboardInterrupt\"\"\"\n+    )\n+    pytb = tb1.as_traceback()\n+    assert traceback.format_tb(pytb) == [\n+        '  File \"file1\", line 123, in <module>\\n',\n+        '  File \"file2\", line 234, in ???\\n',\n+        '  File \"file3\", line 345, in function3\\n',\n+    ]\n+    tb2 = Traceback(pytb)\n+\n+    expected_dict = {\n+        \"tb_frame\": {\n+            \"f_code\": {\"co_filename\": \"file1\", \"co_name\": \"<module>\"},\n+            \"f_globals\": {\"__file__\": \"file1\", \"__name__\": \"?\"},\n+        },\n+        \"tb_lineno\": 123,\n+        \"tb_next\": {\n+            \"tb_frame\": {\n+                \"f_code\": {\"co_filename\": \"file2\", \"co_name\": \"???\"},\n+                \"f_globals\": {\"__file__\": \"file2\", \"__name__\": \"?\"},\n+            },\n+            \"tb_lineno\": 234,\n+            \"tb_next\": {\n+                \"tb_frame\": {\n+                    \"f_code\": {\"co_filename\": \"file3\", \"co_name\": \"function3\"},\n+                    \"f_globals\": {\"__file__\": \"file3\", \"__name__\": \"?\"},\n+                },\n+                \"tb_lineno\": 345,\n+                \"tb_next\": None,\n+            },\n+        },\n+    }\n+    tb3 = Traceback.from_dict(expected_dict)\n+    assert tb3.as_dict() == tb2.as_dict() == tb1.as_dict() == expected_dict\n"}
{"repo": "python-tblib", "commit": "63652fd2569482cba0c4596e284f130d39f4d34f", "diff": "diff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex 02797df..cf6e390 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -58,6 +58,11 @@ def install(*exc_classes_or_instances):\n     copyreg.pickle(TracebackType, pickle_traceback)\n \n     if sys.version_info.major < 3:\n+        # Dummy decorator?\n+        if len(exc_classes_or_instances) == 1:\n+            exc = exc_classes_or_instances[0]\n+            if isinstance(exc, type) and issubclass(exc, BaseException):\n+                return exc\n         return\n \n     if not exc_classes_or_instances:\n@@ -70,7 +75,7 @@ def install(*exc_classes_or_instances):\n             while exc is not None:\n                 copyreg.pickle(type(exc), pickle_exception)\n                 exc = exc.__cause__\n-        elif issubclass(exc, BaseException):\n+        elif isinstance(exc, type) and issubclass(exc, BaseException):\n             copyreg.pickle(exc, pickle_exception)\n             # Allow using @install as a decorator for Exception classes\n             if len(exc_classes_or_instances) == 1:\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 391c656..5fb9b36 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -93,6 +93,7 @@ def test_install_decorator():\n         assert exc.__traceback__ is not None\n \n \n+@pytest.mark.skipif(sys.version_info[0] < 3, reason=\"No checks done in Python 2\")\n def test_install_typeerror():\n     with pytest.raises(TypeError):\n         tblib.pickling_support.install(\"foo\")\n"}
{"repo": "python-tblib", "commit": "587a73b09baa1177bcf4e54445af15d3be28f753", "diff": "diff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex a64bf6e..fc9aba8 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -32,24 +32,14 @@ def unpickle_exception(func, args, cause, tb):\n \n \n def pickle_exception(obj):\n-    # Check for a __reduce_ex__ method, fall back to __reduce__\n-    reduce = getattr(obj, \"__reduce_ex__\", None)\n-    if reduce is not None:\n-        # __reduce_ex__(4) should be no different from __reduce_ex__(3).\n-        # __reduce_ex__(5) could bring benefits in the unlikely case the exception\n-        # directly contains buffers, but PickleBuffer objects will cause a crash when\n-        # running on protocol=4, and there's no clean way to figure out the current\n-        # protocol from here. Note that any object returned by __reduce_ex__(3) will\n-        # still be pickled with protocol 5 if pickle.dump() is running with it.\n-        rv = reduce(3)\n-    else:\n-        reduce = getattr(obj, \"__reduce__\", None)\n-        if reduce is not None:\n-            rv = reduce()\n-        else:\n-            raise pickle.PicklingError(\n-                \"Can't pickle %r object: %r\" % (obj.__class__.__name__, obj)\n-            )\n+    # All exceptions, unlike generic Python objects, define __reduce_ex__\n+    # __reduce_ex__(4) should be no different from __reduce_ex__(3).\n+    # __reduce_ex__(5) could bring benefits in the unlikely case the exception\n+    # directly contains buffers, but PickleBuffer objects will cause a crash when\n+    # running on protocol=4, and there's no clean way to figure out the current\n+    # protocol from here. Note that any object returned by __reduce_ex__(3) will\n+    # still be pickled with protocol 5 if pickle.dump() is running with it.\n+    rv = obj.__reduce_ex__(3)\n     if isinstance(rv, str):\n         raise TypeError(\"str __reduce__ output is not supported\")\n     assert isinstance(rv, tuple) and len(rv) >= 2\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nindex 14b87d9..04ffc7b 100644\n--- a/tests/test_pickle_exception.py\n+++ b/tests/test_pickle_exception.py\n@@ -27,21 +27,11 @@ class CustomError(Exception):\n     pass\n \n \n-class CustomErrorEx(Exception):\n-    # Test that __reduce_ex__ is preferred to __reduce__ when available\n-    def __reduce__(self):\n-        assert False\n-\n-    def __reduce_ex__(self, proto):\n-        return CustomErrorEx, self.args, self.__dict__\n-\n-\n @pytest.mark.parametrize(\n     \"protocol\", [None] + list(range(1, pickle.HIGHEST_PROTOCOL + 1))\n )\n-@pytest.mark.parametrize(\"exc_cls\", [CustomError, CustomErrorEx])\n @pytest.mark.parametrize(\"global_install\", [False, True])\n-def test_pickle_exceptions(global_install, exc_cls, protocol):\n+def test_pickle_exceptions(global_install, protocol):\n     if global_install:\n         tblib.pickling_support.install()\n \n@@ -51,7 +41,7 @@ def test_pickle_exceptions(global_install, exc_cls, protocol):\n         except Exception as e:\n             # Python 3 only syntax\n             # raise CustomError(\"foo\") from e\n-            new_e = exc_cls(\"foo\")\n+            new_e = CustomError(\"foo\")\n             if has_python3:\n                 new_e.__cause__ = e\n             raise new_e\n@@ -70,7 +60,7 @@ def test_pickle_exceptions(global_install, exc_cls, protocol):\n     if protocol:\n         exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n \n-    assert isinstance(exc, exc_cls)\n+    assert isinstance(exc, CustomError)\n     assert exc.args == (\"foo\",)\n     assert exc.x == 1\n     if has_python3:\n"}
{"repo": "python-tblib", "commit": "c6d1796914a52d0f6f053a64cc5d61504443e184", "diff": "diff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex 28c4d11..3b19123 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -1,7 +1,11 @@\n-try:\n-    import copy_reg\n-except ImportError:\n-    import copyreg as copy_reg\n+import sys\n+if sys.version_info.major >= 3:\n+    import copyreg\n+    import pickle\n+else:\n+    import copy_reg as copyreg\n+    import cPickle as pickle\n+\n from types import TracebackType\n \n from . import Frame\n@@ -20,5 +24,60 @@ def pickle_traceback(tb):\n     return unpickle_traceback, (Frame(tb.tb_frame), tb.tb_lineno, tb.tb_next and Traceback(tb.tb_next))\n \n \n-def install():\n-    copy_reg.pickle(TracebackType, pickle_traceback)\n+def unpickle_exception(func, args, cause, tb):\n+    inst = func(*args)\n+    inst.__cause__ = cause\n+    inst.__traceback__ = tb\n+    return inst\n+\n+\n+def pickle_exception(obj):\n+    # Check for a __reduce_ex__ method, fall back to __reduce__\n+    reduce = getattr(obj, \"__reduce_ex__\", None)\n+    if reduce is not None:\n+        # __reduce_ex__(4) should be no different from __reduce_ex__(3).\n+        # __reduce_ex__(5) could bring benefits in the unlikely case the exception\n+        # directly contains buffers, but PickleBuffer objects will cause a crash when\n+        # running on protocol=4, and there's no clean way to figure out the current\n+        # protocol from here. Note that any object returned by __reduce_ex__(3) will\n+        # still be pickled with protocol 5 if pickle.dump() is running with it.\n+        rv = reduce(3)\n+    else:\n+        reduce = getattr(obj, \"__reduce__\", None)\n+        if reduce is not None:\n+            rv = reduce()\n+        else:\n+            raise pickle.PicklingError(\n+                \"Can't pickle %r object: %r\" % (obj.__class__.__name__, obj)\n+            )\n+    if isinstance(rv, str):\n+        raise TypeError(\"str __reduce__ output is not supported\")\n+    assert isinstance(rv, tuple) and len(rv) >= 2\n+\n+    return (unpickle_exception, rv[:2] + (obj.__cause__, obj.__traceback__)) + rv[2:]\n+\n+\n+def _get_subclasses(cls):\n+    # Depth-first traversal of all direct and indirect subclasses of cls\n+    to_visit = [cls]\n+    while to_visit:\n+        this = to_visit.pop()\n+        yield this\n+        to_visit += list(this.__subclasses__())\n+\n+\n+def install(*exception_instances):\n+    copyreg.pickle(TracebackType, pickle_traceback)\n+\n+    if sys.version_info.major < 3:\n+        return\n+\n+    if exception_instances:\n+        for exc in exception_instances:\n+            while exc is not None:\n+                copyreg.pickle(type(exc), pickle_exception)\n+                exc = exc.__cause__\n+\n+    else:\n+        for exception_cls in _get_subclasses(BaseException):\n+            copyreg.pickle(exception_cls, pickle_exception)\ndiff --git a/tests/test_pickle_exception.py b/tests/test_pickle_exception.py\nnew file mode 100644\nindex 0000000..eb59ae5\n--- /dev/null\n+++ b/tests/test_pickle_exception.py\n@@ -0,0 +1,83 @@\n+try:\n+    import copyreg\n+except ImportError:\n+    # Python 2\n+    import copy_reg as copyreg\n+\n+import pickle\n+import sys\n+\n+import pytest\n+\n+import tblib.pickling_support\n+\n+\n+has_python3 = sys.version_info.major >= 3\n+protocol = pytest.mark.parametrize(\n+    \"protocol\",\n+    [None] + list(range(1, pickle.HIGHEST_PROTOCOL + 1))\n+)\n+\n+\n+def setup_function():\n+    copyreg.dispatch_table.clear()\n+\n+\n+def teardown_function():\n+    copyreg.dispatch_table.clear()\n+\n+\n+class CustomError(Exception):\n+    pass\n+\n+\n+class CustomErrorEx(Exception):\n+    # Test that __reduce_ex__ is preferred to __reduce__ when available\n+    def __reduce__(self):\n+        assert False\n+\n+    def __reduce_ex__(self, proto):\n+        return CustomErrorEx, self.args, self.__dict__\n+\n+\n+@protocol\n+@pytest.mark.parametrize(\"exc_cls\", [CustomError, CustomErrorEx])\n+@pytest.mark.parametrize(\"global_install\", [False, True])\n+def test_pickle_exceptions(global_install, exc_cls, protocol):\n+    if global_install:\n+        tblib.pickling_support.install()\n+\n+    try:\n+        try:\n+            1 / 0\n+        except Exception as e:\n+            # Python 3 only syntax\n+            # raise CustomError(\"foo\") from e\n+            new_e = exc_cls(\"foo\")\n+            if has_python3:\n+                new_e.__cause__ = e\n+            raise new_e\n+    except Exception as e:\n+        exc = e\n+    else:\n+        assert False\n+\n+    # Populate Exception.__dict__, which is used in some cases\n+    exc.x = 1\n+    if has_python3:\n+        exc.__cause__.x = 2\n+\n+    if not global_install:\n+        tblib.pickling_support.install(exc)\n+    if protocol:\n+        exc = pickle.loads(pickle.dumps(exc, protocol=protocol))\n+\n+    assert isinstance(exc, exc_cls)\n+    assert exc.args == (\"foo\",)\n+    assert exc.x == 1\n+    if has_python3:\n+        assert exc.__traceback__ is not None\n+        assert isinstance(exc.__cause__, ZeroDivisionError)\n+        assert exc.__cause__.__traceback__ is not None\n+        assert exc.__cause__.x == 2\n+        assert exc.__cause__.__cause__ is None\n"}
{"repo": "python-tblib", "commit": "e9283924858ab450258c1a257a8353ab623abf98", "diff": "diff --git a/tests/test_issue30.py b/tests/test_issue30.py\nindex 6ced60d..270f146 100644\n--- a/tests/test_issue30.py\n+++ b/tests/test_issue30.py\n@@ -1,15 +1,17 @@\n import pickle\n import sys\n \n-import six\n import pytest\n-pytest.importorskip('twisted')\n-from twisted.python.failure import Failure\n+import six\n \n-from tblib import pickling_support\n+from tblib import pickling_support  # noqa: E402\n+\n+pytest.importorskip('twisted')\n \n \n def test_30():\n+    from twisted.python.failure import Failure\n+\n     pickling_support.install()\n \n     try:\n"}
{"repo": "python-tblib", "commit": "a96352760d20bedb881dd592fd342a732a36ec4b", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 3ac6d4f..33e0ae8 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -98,6 +98,7 @@ class Traceback(object):\n             if hasattr(code, \"replace\"):\n                 # Python 3.8 and newer\n                 code = code.replace(co_argcount=0,\n+                                    co_filename=f_code.co_filename, co_name=f_code.co_name,\n                                     co_freevars=(), co_cellvars=())\n             elif PY3:\n                 code = CodeType(\ndiff --git a/tests/test_issue30.py b/tests/test_issue30.py\nindex 6974ff1..6ced60d 100644\n--- a/tests/test_issue30.py\n+++ b/tests/test_issue30.py\n@@ -2,6 +2,8 @@ import pickle\n import sys\n \n import six\n+import pytest\n+pytest.importorskip('twisted')\n from twisted.python.failure import Failure\n \n from tblib import pickling_support\n"}
{"repo": "python-tblib", "commit": "5f04fa62b28d305aa74a9cb70ce6accdcbaaebde", "diff": "diff --git a/tests/badsyntax.py b/tests/badsyntax.py\nindex 7acf0d0..124ce11 100644\n--- a/tests/badsyntax.py\n+++ b/tests/badsyntax.py\n@@ -1,3 +1,4 @@\n+# flake8: noqa\n \"\"\"\n bad\n bad bad\ndiff --git a/tests/test_issue30.py b/tests/test_issue30.py\nindex e480031..6974ff1 100644\n--- a/tests/test_issue30.py\n+++ b/tests/test_issue30.py\n@@ -1,10 +1,15 @@\n+import pickle\n+import sys\n+\n+import six\n+from twisted.python.failure import Failure\n+\n+from tblib import pickling_support\n+\n+\n def test_30():\n-    from tblib import pickling_support\n     pickling_support.install()\n \n-    import six, pickle, sys\n-    from twisted.python.failure import Failure\n-\n     try:\n         raise ValueError\n     except ValueError:\n"}
{"repo": "python-tblib", "commit": "7cd288e616cf18aec4cab1f6d5b398bdc7b47e88", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 1a6545f..6726fb5 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -112,7 +112,7 @@ class Traceback(object):\n             # noinspection PyBroadException\n             try:\n                 exec(code, current.tb_frame.f_globals, {})\n-            except:\n+            except Exception:\n                 next_tb = sys.exc_info()[2].tb_next\n                 if top_tb is None:\n                     top_tb = next_tb\n"}
{"repo": "python-tblib", "commit": "d5623cf034e878cb45ba0bc5f1d8624dbe28ffe4", "diff": "diff --git a/setup.py b/setup.py\nindex f3547e8..23a3d8c 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,11 +15,9 @@ from setuptools import find_packages\n from setuptools import setup\n \n \n-def read(*names, **kwargs):\n-    return io.open(\n-        join(dirname(__file__), *names),\n-        encoding=kwargs.get('encoding', 'utf8')\n-    ).read()\n+def read(*names):\n+    with io.open(join(dirname(__file__), *names), encoding='utf-8') as fp:\n+        return fp.read()\n \n \n setup(\n"}
{"repo": "python-tblib", "commit": "20bcfb3cba45a6054e43706dc75c7bb392239eb6", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 4d0c7cf..b68cccf 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -77,7 +77,7 @@ class Traceback(object):\n         if tproxy:\n             return tproxy(TracebackType, self.__tproxy_handler)\n         if not tb_set_next:\n-            raise RuntimeError(\"Cannot re-create traceback !\")\n+            raise RuntimeError(\"Unsupported Python interpreter!\")\n \n         current = self\n         top_tb = None\n"}
{"repo": "python-tblib", "commit": "b3cc5a5d0e1290745c2341e3ed58b88defb34047", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 3a6abf6..4d0c7cf 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -53,21 +53,38 @@ class Frame(object):\n \n \n class Traceback(object):\n+\n+    tb_next = None\n+\n     def __init__(self, tb):\n         self.tb_frame = Frame(tb.tb_frame)\n         # noinspection SpellCheckingInspection\n         self.tb_lineno = int(tb.tb_lineno)\n-        if tb.tb_next is None:\n-            self.tb_next = None\n-        else:\n-            self.tb_next = Traceback(tb.tb_next)\n+\n+        # Build in place to avoid exceeding the recursion limit\n+        tb = tb.tb_next\n+        prev_traceback = self\n+        cls = type(self)\n+        while tb is not None:\n+            traceback = object.__new__(cls)\n+            traceback.tb_frame = Frame(tb.tb_frame)\n+            traceback.tb_lineno = int(tb.tb_lineno)\n+            prev_traceback.tb_next = traceback\n+            prev_traceback = traceback\n+            tb = tb.tb_next\n \n     def as_traceback(self):\n         if tproxy:\n             return tproxy(TracebackType, self.__tproxy_handler)\n-        elif tb_set_next:\n-            f_code = self.tb_frame.f_code\n-            code = compile('\\n' * (self.tb_lineno - 1) + 'raise __traceback_maker', self.tb_frame.f_code.co_filename, 'exec')\n+        if not tb_set_next:\n+            raise RuntimeError(\"Cannot re-create traceback !\")\n+\n+        current = self\n+        top_tb = None\n+        tb = None\n+        while current:\n+            f_code = current.tb_frame.f_code\n+            code = compile('\\n' * (current.tb_lineno - 1) + 'raise __traceback_maker', current.tb_frame.f_code.co_filename, 'exec')\n             if PY3:\n                 code = CodeType(\n                     0, code.co_kwonlyargcount,\n@@ -87,13 +104,22 @@ class Traceback(object):\n \n             # noinspection PyBroadException\n             try:\n-                exec(code, self.tb_frame.f_globals, {})\n+                exec(code, current.tb_frame.f_globals, {})\n             except:\n-                tb = sys.exc_info()[2].tb_next\n-                tb_set_next(tb, self.tb_next and self.tb_next.as_traceback())\n-                return tb\n-        else:\n-            raise RuntimeError(\"Cannot re-create traceback !\")\n+                next_tb = sys.exc_info()[2].tb_next\n+                if top_tb is None:\n+                    top_tb = next_tb\n+                if tb is not None:\n+                    tb_set_next(tb, next_tb)\n+                tb = next_tb\n+                del next_tb\n+\n+            current = current.tb_next\n+        try:\n+            return top_tb\n+        finally:\n+            del top_tb\n+            del tb\n \n     # noinspection SpellCheckingInspection\n     def __tproxy_handler(self, operation, *args, **kwargs):\n"}
{"repo": "python-tblib", "commit": "3e6372e1e077abdc8d3649713875b464eb8f0a17", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 4268e82..0f59924 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -1,3 +1,8 @@\n+import sys\n+\n+from types import CodeType\n+from types import TracebackType\n+\n try:\n     from __pypy__ import tproxy\n except ImportError:\n@@ -10,11 +15,6 @@ except ImportError:\n if not tb_set_next and not tproxy:\n     raise ImportError(\"Cannot use tblib. Runtime not supported.\")\n \n-import sys\n-\n-from types import CodeType\n-from types import TracebackType\n-\n __version__ = '1.2.0'\n \n PY3 = sys.version_info[0] == 3\ndiff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex 1bafb4c..28c4d11 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -4,7 +4,8 @@ except ImportError:\n     import copyreg as copy_reg\n from types import TracebackType\n \n-from . import Frame, Traceback\n+from . import Frame\n+from . import Traceback\n \n \n def unpickle_traceback(tb_frame, tb_lineno, tb_next):\n"}
{"repo": "python-tblib", "commit": "df1dff9749ef0562fc5bc57ed5aec79b517dba8a", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 021928d..aa3b414 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -138,5 +138,3 @@ class Traceback(object):\n             ('tb_next', tb_next)\n         ))\n         return cls(tb)\n-\n-\ndiff --git a/src/tblib/cpython.py b/src/tblib/cpython.py\nindex 79c71d2..5c4bf20 100644\n--- a/src/tblib/cpython.py\n+++ b/src/tblib/cpython.py\n@@ -6,6 +6,7 @@ https://github.com/mitsuhiko/jinja2/blob/master/jinja2/debug.py#L267\n import platform\n import sys\n \n+\n def _init_ugly_crap():\n     \"\"\"This function implements a few ugly things so that we can patch the\n     traceback objects.  The function returned allows resetting `tb_next` on\n@@ -24,6 +25,7 @@ def _init_ugly_crap():\n     # regular python\n     class _PyObject(ctypes.Structure):\n         pass\n+\n     _PyObject._fields_ = [\n         ('ob_refcnt', _Py_ssize_t),\n         ('ob_type', ctypes.POINTER(_PyObject))\n@@ -33,6 +35,7 @@ def _init_ugly_crap():\n     if hasattr(sys, 'getobjects'):\n         class _PyObject(ctypes.Structure):\n             pass\n+\n         _PyObject._fields_ = [\n             ('_ob_next', ctypes.POINTER(_PyObject)),\n             ('_ob_prev', ctypes.POINTER(_PyObject)),\n@@ -42,6 +45,7 @@ def _init_ugly_crap():\n \n     class _Traceback(_PyObject):\n         pass\n+\n     _Traceback._fields_ = [\n         ('tb_next', ctypes.POINTER(_Traceback)),\n         ('tb_frame', ctypes.POINTER(_PyObject)),\n@@ -51,8 +55,7 @@ def _init_ugly_crap():\n \n     def tb_set_next(tb, next):\n         \"\"\"Set the tb_next attribute of a traceback object.\"\"\"\n-        if not (isinstance(tb, TracebackType) and\n-                (next is None or isinstance(next, TracebackType))):\n+        if not (isinstance(tb, TracebackType) and (next is None or isinstance(next, TracebackType))):\n             raise TypeError('tb_set_next arguments must be traceback objects')\n         obj = _Traceback.from_address(id(tb))\n         if tb.tb_next is not None:\n@@ -67,6 +70,7 @@ def _init_ugly_crap():\n \n     return tb_set_next\n \n+\n tb_set_next = None\n try:\n     if platform.python_implementation() == 'CPython':\ndiff --git a/src/tblib/decorators.py b/src/tblib/decorators.py\nindex d2d55ab..29fdef2 100644\n--- a/src/tblib/decorators.py\n+++ b/src/tblib/decorators.py\n@@ -5,6 +5,7 @@ from six import reraise\n \n from . import Traceback\n \n+\n class Error(object):\n     def __init__(self, exc_type, exc_value, traceback):\n         self.exc_type = exc_type\n@@ -18,16 +19,20 @@ class Error(object):\n     def reraise(self):\n         reraise(self.exc_type, self.exc_value, self.traceback)\n \n+\n def return_error(func, exc_type=Exception):\n     @wraps(func)\n     def return_exceptions_wrapper(*args, **kwargs):\n         try:\n             return func(*args, **kwargs)\n-        except exc_type as exc:\n+        except exc_type:\n             return Error(*sys.exc_info())\n+\n     return return_exceptions_wrapper\n \n-returns_error = return_errors = returns_errors = return_error # cause I make too many typos\n+\n+returns_error = return_errors = returns_errors = return_error  # cause I make too many typos\n+\n \n @return_error\n def apply_with_return_error(args):\ndiff --git a/src/tblib/pickling_support.py b/src/tblib/pickling_support.py\nindex ea93243..1bafb4c 100644\n--- a/src/tblib/pickling_support.py\n+++ b/src/tblib/pickling_support.py\n@@ -1,4 +1,3 @@\n-import pickle\n try:\n     import copy_reg\n except ImportError:\n@@ -7,6 +6,7 @@ from types import TracebackType\n \n from . import Frame, Traceback\n \n+\n def unpickle_traceback(tb_frame, tb_lineno, tb_next):\n     ret = object.__new__(Traceback)\n     ret.tb_frame = tb_frame\n@@ -14,8 +14,10 @@ def unpickle_traceback(tb_frame, tb_lineno, tb_next):\n     ret.tb_next = tb_next\n     return ret.as_traceback()\n \n+\n def pickle_traceback(tb):\n     return unpickle_traceback, (Frame(tb.tb_frame), tb.tb_lineno, tb.tb_next and Traceback(tb.tb_next))\n \n+\n def install():\n     copy_reg.pickle(TracebackType, pickle_traceback)\n"}
{"repo": "python-tblib", "commit": "b44174d29088cb5a8ec18b5b0b48145449e5d6b7", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 31c3958..021928d 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -106,11 +106,11 @@ class Traceback(object):\n         else:\n             tb_next = self.tb_next.to_dict()\n \n-        code = {\n-            k: v\n+        code = dict([\n+            (k, v)\n             for k, v in self.tb_frame.f_code.__dict__.items()\n             if k.startswith('co_')\n-        }\n+        ])\n         frame = {\n             'f_globals': self.tb_frame.f_globals,\n             'f_code': code\n"}
{"repo": "python-tblib", "commit": "d80ece7f84a8b168862bbf646fd2910275cb4d63", "diff": "diff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex e11c490..9f9df6d 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -26,6 +26,7 @@ class _AttrDict(dict):\n class __traceback_maker(Exception):\n     pass\n \n+\n class Code(object):\n     def __init__(self, code):\n         self.co_filename = code.co_filename\n@@ -34,7 +35,7 @@ class Code(object):\n         self.co_stacksize = code.co_stacksize\n         self.co_flags = code.co_flags\n         self.co_firstlineno = code.co_firstlineno\n-        self.co_lnotab = \"\"\n+\n \n class Frame(object):\n     def __init__(self, frame):\n@@ -43,6 +44,7 @@ class Frame(object):\n         }\n         self.f_code = Code(frame.f_code)\n \n+\n class Traceback(object):\n     def __init__(self, tb):\n         self.tb_frame = Frame(tb.tb_frame)\n@@ -72,7 +74,7 @@ class Traceback(object):\n                     0,\n                     f_code.co_nlocals, f_code.co_stacksize, f_code.co_flags,\n                     code.co_code, code.co_consts, code.co_names, code.co_varnames,\n-                    f_code.co_filename, f_code.co_name,\n+                    f_code.co_filename.encode(), f_code.co_name.encode(),\n                     code.co_firstlineno, b\"\",\n                     (), ()\n                 )\n"}
{"repo": "python-tblib", "commit": "49a4190d3c92b50fbb92eda1884d54ae42964d11", "diff": "diff --git a/tests/test_tblib.py b/tests/test_tblib.py\nindex aee5b7f..267a164 100644\n--- a/tests/test_tblib.py\n+++ b/tests/test_tblib.py\n@@ -6,8 +6,8 @@ import doctest\n #    pth.PathMustBeFile.__name__      = 'pth.' + pth.PathMustBeFile.__name__\n #    pth.PathMustBeDirectory.__name__ = 'pth.' + pth.PathMustBeDirectory.__name__\n #    pth.PathDoesNotExist.__name__    = 'pth.' + pth.PathDoesNotExist.__name__\n-\n-results = doctest.testfile('../README.rst', optionflags=doctest.ELLIPSIS)\n-print(results)\n-if results.failed:\n-    sys.exit(1)\n+if __name__ == '__main__':\n+    results = doctest.testfile('../README.rst', optionflags=doctest.ELLIPSIS)\n+    print(results)\n+    if results.failed:\n+        sys.exit(1)\n"}
{"repo": "python-tblib", "commit": "a2bd19dcbc197124ef8a213501c5eb2aa1cbf231", "diff": "diff --git a/src/tblib/decorators.py b/src/tblib/decorators.py\nindex c18216e..d2d55ab 100644\n--- a/src/tblib/decorators.py\n+++ b/src/tblib/decorators.py\n@@ -39,5 +39,4 @@ def apply_with_return_error(args):\n         apply_with_return_error((func, 1, 2, 3)) - this will call func(1, 2, 3)\n \n     \"\"\"\n-    print args[0]\n     return args[0](*args[1:])\n"}
{"repo": "python-tblib", "commit": "32e531713370b4b6d688afe5272c753a2fe24173", "diff": "diff --git a/setup.py b/setup.py\nindex 64cb967..505ccd4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -13,8 +13,8 @@ setup(\n     long_description = open(os.path.join(os.path.dirname(__file__), 'README.rst')).read(),\n     author = 'Ionel Cristian M\u00c4\u0192rie\u00c8\u2122',\n     author_email = 'contact@ionelmc.ro',\n+    packages = find_packages('src'),\n     package_dir = {'':'src'},\n-    py_modules = ['pth'],\n     include_package_data = True,\n     zip_safe = False,\n     classifiers = [\ndiff --git a/src/tblib/__init__.py b/src/tblib/__init__.py\nindex 5686123..2193164 100644\n--- a/src/tblib/__init__.py\n+++ b/src/tblib/__init__.py\n@@ -15,6 +15,8 @@ import sys\n from types import CodeType\n from types import TracebackType\n \n+PY3 = sys.version_info[0] == 3\n+\n class __traceback_maker(Exception):\n     pass\n \n@@ -31,8 +33,7 @@ class Code(object):\n class Frame(object):\n     def __init__(self, frame):\n         self.f_globals = {\n-            \"__file__\": frame.f_globals[\"__file__\"],\n-            \"__name__\": frame.f_globals[\"__name__\"],\n+            k: v for k, v in frame.f_globals.items() if k in (\"__file__\", \"__name__\")\n         }\n         self.f_code = Code(frame.f_code)\n \n@@ -46,41 +47,43 @@ class Traceback(object):\n             self.tb_next = Traceback(tb.tb_next)\n \n     def as_traceback(self):\n-        f_code = self.tb_frame.f_code\n-        print self.tb_lineno\n-        code = compile('\\n' * (self.tb_lineno - 1) + 'raise __traceback_maker', self.tb_frame.f_code.co_filename, 'exec')\n-        code = CodeType(\n-            0,\n-            f_code.co_nlocals,\n-            f_code.co_stacksize,\n-            f_code.co_flags,\n-            code.co_code,\n-            code.co_consts,\n-            code.co_names,\n-            code.co_varnames,\n-            f_code.co_filename,\n-            f_code.co_name,\n-            code.co_firstlineno,\n-            code.co_lnotab,\n-            (),\n-            ()\n-        )\n-        try:\n-            exec(code, self.tb_frame.f_globals, {})\n-        except:\n-            tb = sys.exc_info()[2].tb_next\n-            if tb_set_next:\n-                tb_set_next(tb, self.tb_next and self.tb_next.as_traceback())\n-            elif tproxy:\n-                tb = tproxy(TracebackType, self.__tproxy_handler)\n+        if tproxy:\n+            return tproxy(TracebackType, self.__tproxy_handler)\n+        elif tb_set_next:\n+            f_code = self.tb_frame.f_code\n+            code = compile('\\n' * (self.tb_lineno - 1) + 'raise __traceback_maker', self.tb_frame.f_code.co_filename, 'exec')\n+            if PY3:\n+                code = CodeType(\n+                    0, 0,\n+                    f_code.co_nlocals, f_code.co_stacksize, f_code.co_flags,\n+                    code.co_code, code.co_consts, code.co_names, code.co_varnames,\n+                    f_code.co_filename, f_code.co_name,\n+                    code.co_firstlineno, code.co_lnotab,\n+                    (), ()\n+                )\n             else:\n-                raise RuntimeError(\"Cannot re-create traceback !\")\n-            return tb\n+                code = CodeType(\n+                    0,\n+                    f_code.co_nlocals, f_code.co_stacksize, f_code.co_flags,\n+                    code.co_code, code.co_consts, code.co_names, code.co_varnames,\n+                    f_code.co_filename, f_code.co_name,\n+                    code.co_firstlineno, code.co_lnotab,\n+                    (), ()\n+                )\n+\n+            try:\n+                exec(code, self.tb_frame.f_globals, {})\n+            except:\n+                tb = sys.exc_info()[2].tb_next\n+                tb_set_next(tb, self.tb_next and self.tb_next.as_traceback())\n+                return tb\n+        else:\n+            raise RuntimeError(\"Cannot re-create traceback !\")\n \n     def __tproxy_handler(self, operation, *args, **kwargs):\n         if operation in ('__getattribute__', '__getattr__'):\n             if args[0] == 'tb_next':\n-                return self.tb_next and self.tb_next.as_traceback\n+                return self.tb_next and self.tb_next.as_traceback()\n             else:\n                 return getattr(self, args[0])\n         else:\ndiff --git a/src/tblib/cpython.py b/src/tblib/cpython.py\nindex 34a9b71..0754d02 100644\n--- a/src/tblib/cpython.py\n+++ b/src/tblib/cpython.py\n@@ -3,6 +3,7 @@ Taken verbatim from Jinja2.\n \n https://github.com/mitsuhiko/jinja2/blob/master/jinja2/debug.py#L267\n \"\"\"\n+import sys\n \n def _init_ugly_crap():\n     \"\"\"This function implements a few ugly things so that we can patch the\n@@ -69,5 +70,6 @@ tb_set_next = None\n try:\n     tb_set_next = _init_ugly_crap()\n except:\n-    pass\n+    import traceback\n+    traceback.print_exc()\n del _init_ugly_crap\ndiff --git a/src/tblib/decorators.py b/src/tblib/decorators.py\nindex d79f864..c18216e 100644\n--- a/src/tblib/decorators.py\n+++ b/src/tblib/decorators.py\n@@ -18,7 +18,7 @@ class Error(object):\n     def reraise(self):\n         reraise(self.exc_type, self.exc_value, self.traceback)\n \n-def return_errors(func, exc_type=Exception):\n+def return_error(func, exc_type=Exception):\n     @wraps(func)\n     def return_exceptions_wrapper(*args, **kwargs):\n         try:\n@@ -26,3 +26,18 @@ def return_errors(func, exc_type=Exception):\n         except exc_type as exc:\n             return Error(*sys.exc_info())\n     return return_exceptions_wrapper\n+\n+returns_error = return_errors = returns_errors = return_error # cause I make too many typos\n+\n+@return_error\n+def apply_with_return_error(args):\n+    \"\"\"\n+    args is a tuple where the first argument is a callable.\n+\n+    eg::\n+\n+        apply_with_return_error((func, 1, 2, 3)) - this will call func(1, 2, 3)\n+\n+    \"\"\"\n+    print args[0]\n+    return args[0](*args[1:])\ndiff --git a/src/tblib/unpickler.py b/src/tblib/pickling_support.py\nsimilarity index 86%\nrename from src/tblib/unpickler.py\nrename to src/tblib/pickling_support.py\nindex fc0d058..ea93243 100644\n--- a/src/tblib/unpickler.py\n+++ b/src/tblib/pickling_support.py\n@@ -1,5 +1,8 @@\n import pickle\n-import copy_reg\n+try:\n+    import copy_reg\n+except ImportError:\n+    import copyreg as copy_reg\n from types import TracebackType\n \n from . import Frame, Traceback\ndiff --git a/tests/examples.py b/tests/examples.py\nnew file mode 100644\nindex 0000000..d7d5ee3\n--- /dev/null\n+++ b/tests/examples.py\n@@ -0,0 +1,12 @@\n+def func_a(_):\n+    func_b()\n+\n+def func_b():\n+    func_c()\n+\n+def func_c():\n+    func_d()\n+\n+def func_d():\n+    raise Exception(\"Guessing time !\")\n+\ndiff --git a/tests/test_tblib.py b/tests/test_tblib.py\nnew file mode 100644\nindex 0000000..aee5b7f\n--- /dev/null\n+++ b/tests/test_tblib.py\n@@ -0,0 +1,13 @@\n+import sys\n+import doctest\n+#if sys.version_info[0] == 2 and sys.version_info[1] == 6:\n+#    import pth\n+#    pth.PathError.__name__           = 'pth.' + pth.PathError.__name__\n+#    pth.PathMustBeFile.__name__      = 'pth.' + pth.PathMustBeFile.__name__\n+#    pth.PathMustBeDirectory.__name__ = 'pth.' + pth.PathMustBeDirectory.__name__\n+#    pth.PathDoesNotExist.__name__    = 'pth.' + pth.PathDoesNotExist.__name__\n+\n+results = doctest.testfile('../README.rst', optionflags=doctest.ELLIPSIS)\n+print(results)\n+if results.failed:\n+    sys.exit(1)\n"}
{"repo": "catcher", "commit": "52313b37c3e77c09b24f3520ee0a470290379923", "diff": "diff --git a/catcher/formatters/text.py b/catcher/formatters/text.py\nindex a4ed17c..6398d2a 100644\n--- a/catcher/formatters/text.py\n+++ b/catcher/formatters/text.py\n@@ -10,21 +10,27 @@ class TextFormatter:\n \n     @staticmethod\n     def isValidToRepresent(varname: str, object):\n-        if not (varname in ('self', 'e') or\n-                varname.startswith('__') or\n-                'method' in varname):\n+        if not (varname  in ('self', 'e')     or\n+                varname.startswith('__')      or\n+                'method' in varname           or\n+                'function' in varname         or\n+                'module' in str(type(object)) or\n+                'Report' in str(type(object))):\n             return True\n \n \n     @staticmethod\n     def extractAttrs(object):\n-        r = {}\n+        result = {}\n         for k in dir(object):\n-            if not k.startswith('__') and not (k in ('self', 'e')) and hasattr(object, k):\n-                v = getattr(object, k)\n-                if not type(v).__name__.endswith('method'):\n-                    r[k] = v\n-        return r\n+            if (hasattr(object, k)\n+                and not k.startswith('__')\n+                and not k.endswith('__')\n+                and not hasattr(k, 'hidden')\n+                and not type(getattr(object, k)).__name__.endswith('method')):\n+                    result[k] = getattr(object, k)\n+\n+        return result\n \n \n     def formatTracebackFrame(self, frame):\n"}
{"repo": "catcher", "commit": "8dc05d48f5cdbc3bbe151c62ae6cf6a6cb3ad48c", "diff": "diff --git a/catcher/formatters/html.py b/catcher/formatters/html.py\nindex f3ae756..ba9f721 100644\n--- a/catcher/formatters/html.py\n+++ b/catcher/formatters/html.py\n@@ -66,7 +66,7 @@ _template = Template(\"\"\"<!doctype html>\n             <% return \"[too deep]\" %>\n         % endif\n         <% objid = id() %>\n-        % if type(x) in [str, int, long, float, set] or x in [None]:\n+        % if type(x) in [str, int, long, float, set] or x is None:\n             <code>${repr(x) | h}</code>\n         % elif type(x) == dict:\n             <table class=\"table\">\n@@ -127,7 +127,7 @@ _template = Template(\"\"\"<!doctype html>\n                                         <span class=\"lineno\">\n                                             ${ frame.code[1] + index }\n                                         </span>\n-                                        <span class=\"code\">${ line }</span>\n+                                        <span class=\"code\">${ line | h}</span>\n                                     </div>\n                                 % endfor\n                             </div>\n"}
{"repo": "catcher", "commit": "492afb5932ddb85ff481c14b50cdc44c74c96139", "diff": "diff --git a/catcher/_version.py b/catcher/_version.py\nindex 66a87bb..2fb2513 100644\n--- a/catcher/_version.py\n+++ b/catcher/_version.py\n@@ -1 +1 @@\n-__version__ = '0.1.5'\n+__version__ = '0.1.6'\ndiff --git a/setup.py b/setup.py\nindex aa3a376..be439d9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,7 +3,7 @@\n from distutils.core import setup\n from setuptools import find_packages\n \n-from catcher._version import __version__\n+execfile('catcher/_version.py')\n \n setup(\n     name='python-catcher',\n"}
{"repo": "catcher", "commit": "6c1e1b1d9629381d31f13d79a8ce25195885a769", "diff": "diff --git a/catcher/formatters/html.py b/catcher/formatters/html.py\nindex 0e3536e..10d535f 100644\n--- a/catcher/formatters/html.py\n+++ b/catcher/formatters/html.py\n@@ -5,12 +5,13 @@ from datetime import datetime\n _template = Template(\"\"\"<!doctype html>\n <html>\n     <head>\n+        <meta charset=\"utf-8\">\n         <title>Error report</title>\n \n         <script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"></script>\n-        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0-rc1/js/bootstrap.min.js\"></script>\n+        <script src=\"http://netdna.bootstrapcdn.com/bootstrap/3.0.0-rc1/js/bootstrap.min.js\"></script>\n \n-        <link href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0-rc1/css/bootstrap.min.css\" rel=\"stylesheet\">\n+        <link href=\"http://netdna.bootstrapcdn.com/bootstrap/3.0.0-rc1/css/bootstrap.min.css\" rel=\"stylesheet\">\n         <link href=\"http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css\" rel=\"stylesheet\">\n         <style>\n             a {\n"}
{"repo": "tbvaccine", "commit": "2af4aa3b57c33e8704a1ad15ff6e48ad6e8e0454", "diff": "diff --git a/setup.py b/setup.py\nindex 4e76f6f..6f9396a 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -37,8 +37,9 @@ classifiers = [\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\n ]\n \n-install_requires = [\"pygments\", \"appdirs\"]\n-tests_require = [\"pep8\", \"pytest\"] + install_requires\n+INSTALL_REQUIRES = [\"pygments\", \"appdirs\"]\n+TESTS_REQUIRE = [\"pep8\", \"pytest\"] + INSTALL_REQUIRES\n+EXTRAS_REQUIRE = {\":sys_platform == 'win32'\": [\"colorama>=0.2.5\"]}\n \n setup(\n     name=\"tbvaccine\",\n@@ -46,13 +47,14 @@ setup(\n     author=\"Stavros Korokithakis\",\n     author_email=\"hi@stavros.io\",\n     url=\"https://github.com/skorokithakis/tbvaccine/\",\n-    description=\"A utility that cures the horrible traceback displays in Python, \" \"making them more readable.\",\n+    description=\"A utility that cures the horrible traceback displays in Python, making them more readable.\",\n     long_description=open(\"README.rst\").read(),\n     license=\"MIT\",\n     classifiers=classifiers,\n     packages=[\"tbvaccine\"],\n-    install_requires=install_requires,\n-    tests_require=tests_require,\n+    install_requires=INSTALL_REQUIRES,\n+    extras_require=EXTRAS_REQUIRE,\n+    tests_require=TESTS_REQUIRE,\n     test_suite=\"tbvaccine.tests\",\n     entry_points={\"console_scripts\": [\"tbvaccine=tbvaccine.cli:main\"]},\n     cmdclass={\"install_lib\": InstallLibWithPTH},\n"}
{"repo": "tbvaccine", "commit": "80e2d7078383492f5a1afa49070a179e89cea3e2", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 321502f..fe11d75 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -60,10 +60,7 @@ class TBVaccine:\n     def _load_config(self):\n         dir_path = user_config_dir(\"tbvaccine\")\n         config_path = os.path.join(dir_path, \"tbvaccine.cfg\")\n-        try:\n-            os.mkdir(dir_path)\n-        except OSError:\n-            pass\n+        os.makedirs(dir_path, exist_ok=True)\n \n         if not os.path.exists(config_path):\n             with open(config_path, \"w\") as configfile:\n"}
{"repo": "tbvaccine", "commit": "d8638411a5c2dc1988113fb56f37ddd51bbb9b01", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex acedd1e..2cd7ece 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -53,7 +53,7 @@ class TBVaccine:\n         self._max_length = max_length\n \n         self._load_config()\n-        \n+\n         self.pygments_lexer = PythonLexer()\n         self.pygments_formatter = TerminalFormatter(style=self._config.get(\"style\", \"color_scheme\"))\n \n@@ -100,8 +100,8 @@ class TBVaccine:\n \n     def _highlight_line(self, line):\n         line = highlight(line, self.pygments_lexer, self.pygments_formatter)\n-        return line.rstrip(\"\\r\\n\")        \n-        \n+        return line.rstrip(\"\\r\\n\")\n+\n     def _file_in_dir(self):\n         \"\"\"\n         Decide whether the file in the traceback is one in our code_dir or not.\ndiff --git a/tbvaccine/version.py b/tbvaccine/version.py\nindex 73e3bb4..f9aa3e1 100644\n--- a/tbvaccine/version.py\n+++ b/tbvaccine/version.py\n@@ -1 +1 @@\n-__version__ = '0.3.2'\n+__version__ = \"0.3.2\"\n"}
{"repo": "tbvaccine", "commit": "567919008c0871fac277590f1051da7e9b00504e", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex e7ff6b0..acedd1e 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -53,6 +53,9 @@ class TBVaccine:\n         self._max_length = max_length\n \n         self._load_config()\n+        \n+        self.pygments_lexer = PythonLexer()\n+        self.pygments_formatter = TerminalFormatter(style=self._config.get(\"style\", \"color_scheme\"))\n \n     def _load_config(self):\n         dir_path = user_config_dir(\"tbvaccine\")\n@@ -95,6 +98,10 @@ class TBVaccine:\n             text = \"\\x1b[%d;%dm%s\\x1b[m\" % (styles[style], colors[fg], text)\n         self._buffer += text\n \n+    def _highlight_line(self, line):\n+        line = highlight(line, self.pygments_lexer, self.pygments_formatter)\n+        return line.rstrip(\"\\r\\n\")        \n+        \n     def _file_in_dir(self):\n         \"\"\"\n         Decide whether the file in the traceback is one in our code_dir or not.\n@@ -109,8 +116,8 @@ class TBVaccine:\n             # Don't print.\n             return False\n         else:\n-            line = highlight(line, PythonLexer(), TerminalFormatter(style=self._config.get(\"style\", \"color_scheme\")))\n-            self._print(line.rstrip(\"\\r\\n\"), max_length=self._max_length)\n+            line = self._highlight_line(line)\n+            self._print(line, max_length=self._max_length)\n         return True\n \n     def _process_code_line(self, line):\n@@ -124,8 +131,8 @@ class TBVaccine:\n             if self._isolate:\n                 line = line[1:]\n                 self._print(\">\", fg=\"red\", style=\"bright\")\n-            line = highlight(line, PythonLexer(), TerminalFormatter(style=\"monokai\"))\n-            self._print(line.rstrip(\"\\r\\n\"))\n+            line = self._highlight_line(line)\n+            self._print(line)\n \n     def _process_file_line(self, line):\n         \"\"\"\n"}
{"repo": "tbvaccine", "commit": "49a5b5e55c8c88678e7ea7e2ac07d4e223da4ebb", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex d9066df..e7ff6b0 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -1,4 +1,8 @@\n-import configparser\n+try:\n+    from configparser import ConfigParser\n+except ImportError:\n+    from ConfigParser import ConfigParser\n+\n import os\n import re\n import sys\n@@ -60,12 +64,12 @@ class TBVaccine:\n \n         if not os.path.exists(config_path):\n             with open(config_path, \"w\") as configfile:\n-                config = configparser.ConfigParser()\n+                config = ConfigParser()\n                 config.add_section(\"style\")\n                 config.set(\"style\", \"color_scheme\", \"monokai\")\n                 config.write(configfile)\n \n-        self._config = configparser.ConfigParser()\n+        self._config = ConfigParser()\n         self._config.read(config_path)\n \n     def _print(self, text, fg=None, style=None, max_length=None):\n"}
{"repo": "tbvaccine", "commit": "6d047a46a4a9c314db9b5e9e4120774c1f02f832", "diff": "diff --git a/tbvaccine/cli.py b/tbvaccine/cli.py\nindex 6f4da20..57cb4ed 100644\n--- a/tbvaccine/cli.py\n+++ b/tbvaccine/cli.py\n@@ -5,7 +5,7 @@ from tbvaccine import TBVaccine, __version__\n \n \n def main():\n-    parser = argparse.ArgumentParser(description=\"Upload a file to Pastery, the \" \" best pastebin in the world.\")\n+    parser = argparse.ArgumentParser(description=\"Pretty-print tracebacks\")\n     parser.add_argument(\n         \"-d\",\n         \"--dir\",\n"}
{"repo": "tbvaccine", "commit": "58477b7854eb139db1a6aff61229732686a6fb37", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 520895c..a0f040c 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -73,7 +73,8 @@ class TBVaccine:\n         \"\"\"\n         Decide whether the file in the traceback is one in our code_dir or not.\n         \"\"\"\n-        return self._file.startswith(self._code_dir) or not self._file.startswith(\"/\")\n+        return (self._file.startswith(self._code_dir) or\n+                (sys.platform != 'win32' and not self._file.startswith(\"/\")))\n \n     def _process_var_line(self, line):\n         \"\"\"\n"}
{"repo": "tbvaccine", "commit": "17bc0c8ca3768b14151ccdc1ee9fa587b3f48e84", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 520895c..a0f040c 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -73,7 +73,8 @@ class TBVaccine:\n         \"\"\"\n         Decide whether the file in the traceback is one in our code_dir or not.\n         \"\"\"\n-        return self._file.startswith(self._code_dir) or not self._file.startswith(\"/\")\n+        return (self._file.startswith(self._code_dir) or\n+                (sys.platform != 'win32' and not self._file.startswith(\"/\")))\n \n     def _process_var_line(self, line):\n         \"\"\"\n"}
{"repo": "tbvaccine", "commit": "04e2da1a0c903c0332f7396ee1c1a27c234a9664", "diff": "diff --git a/setup.py b/setup.py\nindex b684452..47fc646 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -1,10 +1,25 @@\n #!/usr/bin/env python\n-from distutils.sysconfig import get_python_lib\n+import os.path\n import sys\n+from itertools import chain\n+from setuptools import setup  # noqa\n+from setuptools.command.install_lib import install_lib\n \n exec(open('tbvaccine/version.py').read())\n assert sys.version >= '2.6', \"Requires Python v2.6 or above.\"\n-from setuptools import setup  # noqa\n+\n+\n+class InstallLibWithPTH(install_lib):\n+    def run(self):\n+        install_lib.run(self)\n+        path = os.path.join(os.path.dirname(__file__), 'tbvaccine.pth')\n+        dest = os.path.join(self.install_dir, os.path.basename(path))\n+        self.copy_file(path, dest)\n+        self.outputs = [dest]\n+\n+    def get_outputs(self):\n+        return chain(install_lib.get_outputs(self), self.outputs)\n+\n \n classifiers = [\n     \"License :: OSI Approved :: MIT License\",\n@@ -41,5 +56,5 @@ setup(\n     entry_points={\n         'console_scripts': ['tbvaccine=tbvaccine.cli:main'],\n     },\n-    data_files=[(get_python_lib(), ['tbvaccine.pth']), ],\n+    cmdclass={'install_lib': InstallLibWithPTH},\n )\n"}
{"repo": "tbvaccine", "commit": "f48e348cce16cfeafc5dce82ebc1abad039a3a80", "diff": "diff --git a/setup.py b/setup.py\nindex b684452..47fc646 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -1,10 +1,25 @@\n #!/usr/bin/env python\n-from distutils.sysconfig import get_python_lib\n+import os.path\n import sys\n+from itertools import chain\n+from setuptools import setup  # noqa\n+from setuptools.command.install_lib import install_lib\n \n exec(open('tbvaccine/version.py').read())\n assert sys.version >= '2.6', \"Requires Python v2.6 or above.\"\n-from setuptools import setup  # noqa\n+\n+\n+class InstallLibWithPTH(install_lib):\n+    def run(self):\n+        install_lib.run(self)\n+        path = os.path.join(os.path.dirname(__file__), 'tbvaccine.pth')\n+        dest = os.path.join(self.install_dir, os.path.basename(path))\n+        self.copy_file(path, dest)\n+        self.outputs = [dest]\n+\n+    def get_outputs(self):\n+        return chain(install_lib.get_outputs(self), self.outputs)\n+\n \n classifiers = [\n     \"License :: OSI Approved :: MIT License\",\n@@ -41,5 +56,5 @@ setup(\n     entry_points={\n         'console_scripts': ['tbvaccine=tbvaccine.cli:main'],\n     },\n-    data_files=[(get_python_lib(), ['tbvaccine.pth']), ],\n+    cmdclass={'install_lib': InstallLibWithPTH},\n )\n"}
{"repo": "tbvaccine", "commit": "36de786d6c573f938ff8bf3f22ffd662978ed7dc", "diff": "diff --git a/setup.py b/setup.py\nindex d2676f1..b684452 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -1,6 +1,7 @@\n #!/usr/bin/env python\n-\n+from distutils.sysconfig import get_python_lib\n import sys\n+\n exec(open('tbvaccine/version.py').read())\n assert sys.version >= '2.6', \"Requires Python v2.6 or above.\"\n from setuptools import setup  # noqa\n@@ -22,7 +23,6 @@ classifiers = [\n install_requires = [\"pygments\"]\n tests_require = [\"pep8\", \"pytest\"] + install_requires\n \n-\n setup(\n     name=\"tbvaccine\",\n     version=__version__,  # noqa\n@@ -41,4 +41,5 @@ setup(\n     entry_points={\n         'console_scripts': ['tbvaccine=tbvaccine.cli:main'],\n     },\n+    data_files=[(get_python_lib(), ['tbvaccine.pth']), ],\n )\n"}
{"repo": "tbvaccine", "commit": "22ade1023a177f839a7f92830c65de1add2a4117", "diff": "diff --git a/setup.py b/setup.py\nindex d2676f1..b684452 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -1,6 +1,7 @@\n #!/usr/bin/env python\n-\n+from distutils.sysconfig import get_python_lib\n import sys\n+\n exec(open('tbvaccine/version.py').read())\n assert sys.version >= '2.6', \"Requires Python v2.6 or above.\"\n from setuptools import setup  # noqa\n@@ -22,7 +23,6 @@ classifiers = [\n install_requires = [\"pygments\"]\n tests_require = [\"pep8\", \"pytest\"] + install_requires\n \n-\n setup(\n     name=\"tbvaccine\",\n     version=__version__,  # noqa\n@@ -41,4 +41,5 @@ setup(\n     entry_points={\n         'console_scripts': ['tbvaccine=tbvaccine.cli:main'],\n     },\n+    data_files=[(get_python_lib(), ['tbvaccine.pth']), ],\n )\n"}
{"repo": "tbvaccine", "commit": "aa73e0760f2066da1cb5a5abe60d578967006faf", "diff": "diff --git a/tbvaccine/cli.py b/tbvaccine/cli.py\nindex 0c60f69..a23b19e 100644\n--- a/tbvaccine/cli.py\n+++ b/tbvaccine/cli.py\n@@ -26,7 +26,7 @@ def main():\n     )\n \n     for line in iter(sys.stdin.readline, ''):\n-        output = tbv.process_line(line)\n+        output = tbv._process_line(line)\n         sys.stderr.write(output)\n \n \n"}
{"repo": "tbvaccine", "commit": "341d6c134fcee083ca7fc18a6e557b7165df378e", "diff": "diff --git a/tbvaccine/__main__.py b/tbvaccine/__main__.py\nindex f4f7b3c..d0e2e66 100644\n--- a/tbvaccine/__main__.py\n+++ b/tbvaccine/__main__.py\n@@ -21,6 +21,8 @@ del sys.argv[0]\n \n with open(script_path) as script_file:\n     code = compile(script_file.read(), script_path, 'exec')\n-    variables = {}\n+    variables = {\n+        '__name__': '__main__'\n+    }\n     exec(code, variables, variables)\n \n"}
{"repo": "tbvaccine", "commit": "797061448b7876e0f1be646ec9f1459033b7e511", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 7c535bd..c0139fb 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -170,6 +170,10 @@ class TBVaccine:\n             # Frame lines contain newlines, so we need to split on them.\n             lines.extend(line.split(\"\\n\"))\n             var_tuples = sorted(frame.f_locals.items())\n+            if not var_tuples:\n+                # There are no locals, so continue.\n+                continue\n+\n             max_length = max([len(x[0]) for x in var_tuples])\n             for key, val in var_tuples:\n                 try:\n"}
{"repo": "tbvaccine", "commit": "8ad93759ea5f065116e6ca515aec41ada85814be", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 3bb32b9..7c535bd 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -102,7 +102,10 @@ class TBVaccine:\n             self._print(line)\n         else:\n             self._print(\"  File \\\"\")\n-            self._print(match[\"filename\"], \"cyan\")\n+            base, fn = os.path.split(match[\"filename\"])\n+            if base:\n+                self._print(base + os.sep, \"cyan\")\n+            self._print(fn, \"cyan\", style=\"bright\")\n             self._print(\"\\\", line \")\n             self._print(match[\"line\"], \"yellow\")\n             self._print(\", in \")\n"}
{"repo": "tbvaccine", "commit": "6990be9ff2a2f36f0963156f02f99d2b1f14861f", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex eeccc44..3bb32b9 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -68,7 +68,7 @@ class TBVaccine:\n         \"\"\"\n         Process a line of variables in the traceback.\n         \"\"\"\n-        if self._show_vars and self._isolate and not self._file_in_dir():\n+        if self._show_vars is False or (self._isolate and not self._file_in_dir()):\n             # Don't print.\n             return False\n         else:\n@@ -197,10 +197,10 @@ class TBVaccine:\n         return self._format_tb_string_with_locals(*sys.exc_info())\n \n \n-def add_hook():\n+def add_hook(*args, **kwargs):\n     if not getattr(sys.stderr, 'isatty', lambda: False)():\n         sys.stderr.write(\"\\n\\nNot an interactive session, \"\n                          \"TBVaccine won't pretty print exceptions.\\n\\n\")\n         return\n-    tbv = TBVaccine()\n+    tbv = TBVaccine(*args, **kwargs)\n     sys.excepthook = tbv.print_exception\n"}
{"repo": "tbvaccine", "commit": "5e3c55b01050783a3980b1fed69e440d4f563d45", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 784bd76..c780f67 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -15,7 +15,7 @@ class State(Enum):\n \n \n class TBVaccine:\n-    TB_END_RE = re.compile(r'^(?P<exception>\\w+)\\: (?P<description>.*?)$')\n+    TB_END_RE = re.compile(r'^(?P<exception>[\\w\\.]+)\\: (?P<description>.*?)$')\n     TB_FILE_RE = re.compile(r'^  File \"(?P<filename>.*?)\", line (?P<line>\\d+), in (?P<func>.*)$')\n \n     def __init__(self, code_dir=None, isolate=True):\n"}
{"repo": "tbvaccine", "commit": "1286b968b161d079a6cd4e7a6377bf0a926596be", "diff": "diff --git a/tbvaccine/tbv.py b/tbvaccine/tbv.py\nindex 065aac0..784bd76 100644\n--- a/tbvaccine/tbv.py\n+++ b/tbvaccine/tbv.py\n@@ -148,7 +148,8 @@ class TBVaccine:\n \n def add_hook():\n     if not getattr(sys.stderr, 'isatty', lambda: False)():\n-        sys.stderr.write(\"no tty\")\n+        sys.stderr.write(\"\\n\\nNot an interactive session, \"\n+                         \"TBVaccine won't pretty print exceptions.\\n\\n\")\n         return\n     tbv = TBVaccine()\n     sys.excepthook = tbv.print_exception\n"}
{"repo": "tbvaccine", "commit": "cf9aef12d48d4036cfcb853826fde7f6a3c9622b", "diff": "diff --git a/setup.py b/setup.py\nindex 0d60269..ef67506 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -17,7 +17,7 @@ classifiers = [\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\n ]\n \n-install_requires = []\n+install_requires = [\"pygments\"]\n tests_require = [\"pep8\", \"pytest\"] + install_requires\n \n \n"}
{"repo": "tbvaccine", "commit": "0a231ccb7cb1a9405fc9a790ea1db5624dd21983", "diff": "diff --git a/setup.py b/setup.py\nindex 29ba7fd..0d60269 100755\n--- a/setup.py\n+++ b/setup.py\n@@ -3,7 +3,7 @@\n import sys\n exec(open('tbvaccine/version.py').read())\n assert sys.version >= '2.6', \"Requires Python v2.6 or above.\"\n-from setuptools import setup\n+from setuptools import setup  # noqa\n \n classifiers = [\n     \"License :: OSI Approved :: MIT License\",\ndiff --git a/tbvaccine/cli.py b/tbvaccine/cli.py\nindex d7667fb..5cb5016 100644\n--- a/tbvaccine/cli.py\n+++ b/tbvaccine/cli.py\n@@ -1,5 +1,4 @@\n import argparse\n-import os\n import sys\n \n from tbvaccine import __version__\ndiff --git a/tbvaccine/tbvaccine.py b/tbvaccine/tbvaccine.py\nindex 7733c4e..7cb36f9 100755\n--- a/tbvaccine/tbvaccine.py\n+++ b/tbvaccine/tbvaccine.py\n@@ -50,7 +50,7 @@ class TBVaccine:\n                 \"cyan\": 36,\n                 \"gray\": 37,\n             }\n-            text = \"\\x1b[%dm%s\\x1b[m\" % (colors[fg], text)\n+            text = \"\\x1b[%d;%dm%s\\x1b[m\" % (styles[style], colors[fg], text)\n         self._buffer += text\n \n     def _file_in_dir(self):\ndiff --git a/tbvaccine/tests.py b/tbvaccine/tests.py\nindex 49b1eb2..612de13 100644\n--- a/tbvaccine/tests.py\n+++ b/tbvaccine/tests.py\n@@ -5,7 +5,7 @@ import pep8\n \n sys.path.insert(0, os.path.abspath(__file__ + \"/../..\"))\n \n-from tbvaccine import TBVaccine\n+from tbvaccine import TBVaccine  # noqa\n \n \n class BasicTest(unittest.TestCase):\n"}
{"repo": "colored-traceback.py", "commit": "e21165a5e7c4c38a0a1a004f5ce81af7525dd90c", "diff": "diff --git a/colored_traceback/colored_traceback.py b/colored_traceback/colored_traceback.py\nindex 1828033..ebeb173 100644\n--- a/colored_traceback/colored_traceback.py\n+++ b/colored_traceback/colored_traceback.py\n@@ -29,35 +29,34 @@ def _get_term_color_support():\n         curses.setupterm()\n         return curses.tigetnum('colors')\n \n-    def _determine_formatter(self):\n+    def _determine_formatter(style=\"default\", debug=False):\n         colors = _get_term_color_support()\n-        if self.debug:\n+        if debug:\n             sys.stderr.write(\"Detected support for %s colors\\n\" % colors)\n         if colors == 256:\n-            fmt_options = {'style': self.style}\n-        elif self.style in ('light', 'dark'):\n-            fmt_options = {'bg': self.style}\n+            fmt_options = {'style': style}\n+        elif style in ('light', 'dark'):\n+            fmt_options = {'bg': style}\n         else:\n             fmt_options = {'bg': 'dark'}\n         fmt_alias = 'terminal256' if colors == 256 else 'terminal'\n         try:\n             return get_formatter_by_name(fmt_alias, **fmt_options)\n         except ClassNotFound as ex:\n-            if self.debug:\n+            if debug:\n                 sys.stderr.write(str(ex) + \"\\n\")\n             return get_formatter_by_name(fmt_alias)\n \n     LEXER = get_lexer_by_name(\n         \"pytb\" if sys.version_info.major < 3 else \"py3tb\"\n     )\n-    FORMATTER = _determine_formatter()\n \n     class Colorizer(object):\n         def __init__(self, style, debug=False):\n             self.style = style\n             self.debug = debug\n             self.lexer = LEXER\n-            self.formatter = FORMATTER\n+            self.formatter = _determine_formatter(style, debug)\n \n         def colorize_traceback(self, type, value, tb):\n             tb_text = \"\".join(traceback.format_exception(type, value, tb))\n"}
{"repo": "backtrace", "commit": "29db66cf8eca5eada066a6732c68fd42829a54ad", "diff": "diff --git a/backtrace.py b/backtrace.py\nindex 1331586..a45fe5d 100644\n--- a/backtrace.py\n+++ b/backtrace.py\n@@ -166,8 +166,10 @@ def hook(reverse=False,\n \n         tpe = tpe if isinstance(tpe, str) else tpe.__name__\n         tb_message = styles['backtrace'].format('Traceback ({0}):'.format(\n-            'Most recent call ' + ('first' if reverse else 'last'))) + Style.RESET_ALL\n-        err_message = styles['error'].format(tpe + ': ' + str(value)) + Style.RESET_ALL\n+            'Most recent call ' + ('first' if reverse else 'last'))) + \\\n+            Style.RESET_ALL\n+        err_message = styles['error'].format(tpe + ': ' + str(value)) + \\\n+            Style.RESET_ALL\n \n         if reverse:\n             parser.reverse()\n"}
{"repo": "backtrace", "commit": "94ec541e5fca7e9258b4435da5e9fff06d1c384b", "diff": "diff --git a/backtrace.py b/backtrace.py\nindex 6a114cb..e39d8cf 100644\n--- a/backtrace.py\n+++ b/backtrace.py\n@@ -191,26 +191,57 @@ def unhook():\n \n \n def _extract_traceback(text):\n+    \"\"\"Receive a list of strings representing the input from stdin and return\n+    the restructured backtrace.\n+\n+    This iterates over the output and once it identifies a hopefully genuine\n+    identifier, it will start parsing output.\n+    In the case the input includes a reraise (a Python 3 case), the primary\n+    traceback isn't handled, only the reraise.\n+\n+    Each of the traceback lines are then handled two lines at a time for each\n+    stack object.\n+\n+    Note that all parts of each stack object are stripped from newlines and\n+    spaces to keep the output clean.\n+    \"\"\"\n     capture = False\n     entries = []\n     all_else = []\n+    ignore_trace = False\n+\n+    # In python 3, a traceback may includes output from a reraise.\n+    # e.g, an exception is captured and reraised with another exception.\n+    # This marks that we should ignore\n+    if text.count(TRACEBACK_IDENTIFIER) == 2:\n+        ignore_trace = True\n \n     for index, line in enumerate(text):\n         if TRACEBACK_IDENTIFIER in line:\n+            if ignore_trace:\n+                ignore_trace = False\n+                continue\n             capture = True\n+        # We're not capturing and making sure we only read lines\n+        # with spaces since, after the initial identifier, all traceback lines\n+        # contain a prefix spacing.\n         elif capture and line.startswith(' '):\n             if index % 2 == 0:\n+                # Line containing a file, line and module.\n                 line = line.strip().strip('\\n')\n                 next_line = text[index + 1].strip('\\n')\n                 entries.append(line + ', ' + next_line)\n         elif capture:\n+            # Line containing the module call.\n             entries.append(line)\n             break\n         else:\n+            # Add everything else after the traceback.\n             all_else.append(line)\n \n     traceback_entries = []\n \n+    # Build the traceback structure later passed for formatting.\n     for index, line in enumerate(entries[:-2]):\n         # TODO: This should be done in a _parse_entry function\n         element = line.split(',')\n"}
{"repo": "backtrace", "commit": "f116de14ab2abdbe187feb957cd34e0613867bfe", "diff": "diff --git a/tests/test_backtrace.py b/tests/test_backtrace.py\nindex 9a43a2f..6fc5184 100644\n--- a/tests/test_backtrace.py\n+++ b/tests/test_backtrace.py\n@@ -12,24 +12,11 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-import shlex\n-\n import pytest\n-import click.testing as clicktest\n \n import backtrace\n \n \n-def _invoke(command):\n-    cli = clicktest.CliRunner()\n-\n-    lexed_command = command if isinstance(command, list) \\\n-        else shlex.split(command)\n-    func = lexed_command[0]\n-    params = lexed_command[1:]\n-    return cli.invoke(getattr(backtrace, func), params)\n-\n-\n class TestGeneral:\n     def test_base(self):\n         backtrace.hook()\n"}
{"repo": "backtrace", "commit": "2ffecaaa3bb919c8e85335864e899bd2adf74534", "diff": "diff --git a/backtrace.py b/backtrace.py\nindex 3bea5fd..a093a61 100644\n--- a/backtrace.py\n+++ b/backtrace.py\n@@ -61,7 +61,7 @@ class _Hook(object):\n \n         for entry in entries:\n             for index, field in enumerate(entry):\n-                lengths[index] = max(lengths[index], len(str(entry[index])))\n+                lengths[index] = max(lengths[index], len(str(field)))\n         return lengths\n \n \n"}
